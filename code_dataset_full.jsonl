{"file_path": "training_sources\\ltpp-docs\\src\\compare-version\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: License,LICENSE\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\n---\n\n<Share colorful />\n\nMIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n<Bottom />", "file_size": 1218, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\head.js", "language": "javascript", "content": "function errorHandle() {\n  try {\n    var is_dev =\n      window.location.href.indexOf('http://localhost') !== -1 ||\n      window.location.href.indexOf('http://127.0.0.1') !== -1;\n    window.addEventListener('error', function (event) {\n      event.preventDefault();\n      is_dev && console.error(event);\n    });\n    window.addEventListener('unhandledrejection', function (event) {\n      event.preventDefault();\n      is_dev && console.error(event);\n    });\n  } catch (e) {}\n}\n\nfunction printData() {\n  try {\n    console.log(\n      '%c 如有疑问请联系邮箱 %c root@ltpp.vip %c ',\n      'background:#35495e ; padding: 1px; border-radius: 3px 0 0 3px;  color: #fff',\n      'background:#41b883 ; padding: 1px; border-radius: 0 3px 3px 0;  color: #fff',\n      'background:transparent'\n    );\n    console.log(\n      '%c                   _oo0oo_                   \\n                  o8888888o\t\t\t\t     \\n                  88\" . \"88\t\t\t\t     \\n                  (| -_- |)\t\t\t\t     \\n                   O\\\\ = /O\t\t\t\t     \\n' +\n        \"               ____/`---'\\\\____\t\t\t     \\n             .   ' \\\\\\\\| |// `.\t\t\t     \\n\" +\n        '              / \\\\\\\\||| : |||// \\\\\t\t\t\t \\n           / _||||| -卍- |||||- \\\\\t\t     \\n              | | \\\\\\\\\\\\ - /// | |\t\t\t\t \\n' +\n        \"            | \\\\_| ''\\\\---/'' | |\t\t\t\t \\n\" +\n        '             \\\\ .-\\\\__ `-` ___/-. /\t\t\t \\n' +\n        \"          ___`. .' /--.--\\\\ `. . __\t\t     \\n\" +\n        '       .\"\" \"< `.___\\\\_<|>_/___. ` >\" \"\".      \\n      | | : `- \\\\`.;`\\\\ _ /`;.`/ - ` : | |     \\n        \\\\ \\\\ `-. \\\\_ __\\\\ /__ _/ .-` / /        \\n' +\n        \"======`-.____`-.___\\\\_____/___.-`____.-'======\\n                   `=---='                   \\n\" +\n        '.............................................\\n      佛祖镇楼                  BUG辟易       \\n',\n      'background:#35495e ;  color: yellow'\n    );\n  } catch (e) {}\n}\n\nfunction setCookie() {\n  try {\n    document.cookie = 'SameSite=Lax; Secure; Max-Age=3153600000';\n  } catch (e) {}\n}\n\nfunction redirectToLowerCaseUrl() {\n  try {\n    var parsedUrl = new URL(window.location.href);\n    var lowerCaseUrl = (\n      `${parsedUrl.protocol.toLowerCase()}//` +\n      `${parsedUrl.hostname.toLowerCase()}` +\n      (parsedUrl.port ? `:${parsedUrl.port}` : '') +\n      `${parsedUrl.pathname.toLowerCase()}` +\n      `${parsedUrl.search.toLowerCase()}` +\n      `${parsedUrl.hash.toLowerCase()}`\n    ).replace(/_/g, '-');\n    if (window.location.href !== lowerCaseUrl) {\n      window.location.href = lowerCaseUrl;\n    }\n  } catch (e) {}\n}\n\nfunction listenScroll() {\n  try {\n    var hasAdd = false;\n    var progressBar = document.createElement('div');\n    progressBar.style.cssText = `\n                position: fixed;\n                top: 0;\n                left: 0;\n                width: 100vw;\n                height: var(--ltpp-top-scroll-height);\n                background-color: var(--ltpp-top-scroll-color);\n                z-index: 1000000000 !important;\n            `;\n    function updateScroll() {\n      try {\n        if (document.body && document.body.appendChild && !hasAdd) {\n          document.body.appendChild(progressBar);\n          hasAdd = true;\n        }\n        var scrollTop =\n          window.pageYOffset || document.documentElement.scrollTop;\n        var scrollHeight = document.documentElement.scrollHeight;\n        var clientHeight = document.documentElement.clientHeight;\n        var progress = (scrollTop / (scrollHeight - clientHeight)) * 100;\n        progressBar.style.width = `${progress}%`;\n      } catch (e) {}\n    }\n    setInterval(updateScroll, 360);\n    window.addEventListener('scroll', updateScroll);\n  } catch (e) {}\n}\n\nfunction listenWheel() {\n  try {\n    window.addEventListener(\n      'wheel',\n      function (e) {\n        e = e || window.event;\n        if ((e.wheelDelta && event.ctrlKey) || e.detail) {\n          event.preventDefault();\n        }\n      },\n      {\n        capture: false,\n        passive: false,\n      }\n    );\n  } catch (e) {}\n}\n\nfunction listenKeydown() {\n  try {\n    window.addEventListener('keydown', function (e) {\n      if (e.ctrlKey && e.shiftKey) {\n        e.preventDefault();\n        return;\n      }\n      if (e.ctrlKey === true) {\n        if (\n          e.keyCode == 65 ||\n          e.keyCode == 67 ||\n          e.keyCode == 86 ||\n          e.keyCode == 87 ||\n          e.keyCode == 89 ||\n          e.keyCode == 90 ||\n          e.keyCode == 88\n        ) {\n          return;\n        }\n        e.preventDefault();\n      }\n      if (e.keyCode == 116 || e.keyCode == 123) {\n        e.preventDefault();\n      }\n    });\n  } catch (e) {}\n}\n\nfunction listenContextmenu() {\n  try {\n    window.addEventListener('contextmenu', function (e) {\n      e.preventDefault();\n    });\n  } catch (e) {}\n}\n\nfunction listen() {\n  try {\n    listenWheel();\n    listenKeydown();\n    listenContextmenu();\n    listenScroll();\n  } catch (e) {}\n}\n\nfunction disableWarnLog() {\n  console.warn = function () {};\n}\n\nfunction disableClickDom() {\n  var processedElements = new WeakSet();\n\n  function processNoClickElements() {\n    var noClickElements = document.querySelectorAll(\n      '.no-click:not([data-no-click-processed])'\n    );\n    noClickElements.forEach(function (element) {\n      if (!processedElements.has(element)) {\n        element.addEventListener(\n          'click',\n          function (event) {\n            event.preventDefault();\n            event.stopPropagation();\n          },\n          { passive: false }\n        );\n        element.addEventListener(\n          'contextmenu',\n          function (event) {\n            event.preventDefault();\n          },\n          { passive: false }\n        );\n        element.addEventListener(\n          'dragstart',\n          function (event) {\n            event.preventDefault();\n          },\n          { passive: false }\n        );\n\n        // 标记已处理\n        element.setAttribute('data-no-click-processed', 'true');\n        processedElements.add(element);\n      }\n    });\n  }\n\n  // 使用 MutationObserver 监听 DOM 变化\n  if (typeof MutationObserver !== 'undefined') {\n    var observer = new MutationObserver(function (mutations) {\n      var shouldProcess = false;\n      mutations.forEach(function (mutation) {\n        if (mutation.type === 'childList') {\n          mutation.addedNodes.forEach(function (node) {\n            if (node.nodeType === 1) {\n              // Element node\n              if (node.classList && node.classList.contains('no-click')) {\n                shouldProcess = true;\n              } else if (\n                node.querySelector &&\n                node.querySelector('.no-click')\n              ) {\n                shouldProcess = true;\n              }\n            }\n          });\n        } else if (\n          mutation.type === 'attributes' &&\n          mutation.attributeName === 'class' &&\n          mutation.target.classList.contains('no-click')\n        ) {\n          shouldProcess = true;\n        }\n      });\n\n      if (shouldProcess) {\n        processNoClickElements();\n      }\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true,\n      attributes: true,\n      attributeFilter: ['class'],\n    });\n  }\n\n  // 初始处理已存在的元素\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', processNoClickElements);\n  } else {\n    processNoClickElements();\n  }\n\n  // 备用方案：使用更长间隔的定时器作为兜底，仅在必要时运行\n  var backupTimer = setInterval(function () {\n    var unprocessedElements = document.querySelectorAll(\n      '.no-click:not([data-no-click-processed])'\n    );\n    if (unprocessedElements.length > 0) {\n      processNoClickElements();\n    }\n  }, 10000); // 增加到10秒间隔\n\n  // 页面卸载时清理定时器\n  window.addEventListener('beforeunload', function () {\n    if (backupTimer) {\n      clearInterval(backupTimer);\n    }\n    if (observer) {\n      observer.disconnect();\n    }\n  });\n}\n\n(function () {\n  try {\n    disableWarnLog();\n    errorHandle();\n    printData();\n    setCookie();\n    listen();\n    redirectToLowerCaseUrl();\n    disableClickDom();\n  } catch (e) {}\n})();", "file_size": 7976, "extension": ".js"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: License\ntitle: License\nicon: gears\ncategory:\n  - license\norder: 9\n---\n\n<Share colorful />\n\nMIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n<Bottom />", "file_size": 1219, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\catalog.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 文档目录,目录,Eastspire\ntitle: 文档目录\nindex: true\nicon: book\ncategory:\n  - 目录\n  - 文档目录\n  - Eastspire\nsidebar: false\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `Eastspire` 文档目录\n\n<Catalog :level=2 />\n\n<Bottom />", "file_size": 253, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\recoverable-spawn\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\n---\n\n<Share colorful />\n\nMIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n<Bottom />", "file_size": 1202, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\theme.ts", "language": "typescript", "content": "import { hopeTheme } from 'vuepress-theme-hope';\nimport navbar from './navbar.js';\nimport sidebar from './sidebar.js';\n\nexport default hopeTheme({\n  hostname: 'https://docs.ltpp.vip',\n\n  author: {\n    name: 'eastspire',\n    url: 'https://github.com/eastspire',\n  },\n\n  iconAssets: 'fontawesome-with-brands',\n\n  logo: '/img/logo.png',\n\n  repo: 'https://github.com/eastspire',\n\n  docsDir: 'src',\n\n  repoDisplay: true,\n\n  print: true,\n\n  // 导航栏\n  navbar,\n\n  // 侧边栏\n  sidebar,\n\n  displayFooter: true,\n\n  editLink: false,\n\n  copyright:\n    '<a target=\"_blank\" class=\"ltpp-link animate\" href=\"mailto:root@ltpp.vip\">© 2021 - present eastspire 版权所有</a>',\n\n  // 多语言配置\n  metaLocales: {\n    editLink: '在 GitHub 上编辑此页',\n  },\n\n  // 如果想要实时查看任何改变，启用它。注: 这对更新性能有很大负面影响\n  hotReload: true,\n\n  darkmode: 'toggle',\n\n  fullscreen: false,\n\n  // 在这里配置主题提供的插件\n  plugins: {\n    seo: true,\n    copyright: true,\n    activeHeaderLinks: true,\n    components: {\n      components: [\n        'ArtPlayer',\n        'Badge',\n        'CodePen',\n        'PDF',\n        'Share',\n        'SiteInfo',\n        'StackBlitz',\n        'VPBanner',\n        'VPCard',\n        'VidStack',\n        'XiGua',\n      ],\n    },\n    // 搜索框\n    search: {\n      maxSuggestions: 100,\n    },\n    copyCode: {\n      showInMobile: true,\n    },\n    // 此处开启了很多功能用于演示，你应仅保留用到的功能。\n    mdEnhance: {\n      alert: true,\n      align: true,\n      mermaid: true,\n      attrs: true,\n      codetabs: true,\n      component: true,\n      demo: true,\n      figure: true,\n      imgLazyload: true,\n      imgSize: true,\n      include: true,\n      mark: true,\n      stylize: [\n        {\n          matcher: 'Recommended',\n          replacer: ({ tag }) => {\n            if (tag === 'em')\n              return {\n                tag: 'Badge',\n                attrs: { type: 'tip' },\n                content: 'Recommended',\n              };\n          },\n        },\n      ],\n      sub: true,\n      sup: true,\n      tabs: true,\n      tasklist: true,\n      vPre: true,\n      playground: {\n        presets: ['ts', 'vue'],\n      },\n    },\n  },\n});", "file_size": 2055, "extension": ".ts"}
{"file_path": "training_sources\\ltpp-docs\\plugin\\creat-sidebar.js", "language": "javascript", "content": "import fs from 'fs';\nimport path from 'path';\n\nconst current_dir = process.cwd();\n\nconst find_dir_name = 'src';\nconst ignore_dir = ['.vuepress'];\nconst js_head_str = 'import { sidebar } from \"vuepress-theme-hope\";\\n';\nconst js_export_head_str = 'export default sidebar({';\nconst js_export_end_str = '});';\nconst sidebar_mode = 'structure';\nconst sidebar_file_path = path.join(current_dir, 'src/.vuepress/sidebar.js');\nconst directories = [];\n\n(() => {\n  const src_dir = path.join(current_dir, find_dir_name);\n  console.log(`Start read dir list: ${src_dir}`);\n\n  fs.readdir(src_dir, (err, files) => {\n    if (err) {\n      console.error(`Read dir error: ${err.message}`);\n      return;\n    }\n\n    const promises = [];\n\n    files.forEach((file) => {\n      const full_path = path.join(src_dir, file);\n      const promise = new Promise((resolve, reject) => {\n        fs.stat(full_path, (err, stats) => {\n          if (err) {\n            console.error(`Get file error: ${err.message}`);\n            reject(err);\n            return;\n          }\n          if (stats.isDirectory() && !ignore_dir.includes(file)) {\n            directories.push(file);\n          }\n          resolve();\n        });\n      });\n      promises.push(promise);\n    });\n\n    Promise.all(promises)\n      .then(() => {\n        let js_str = '';\n        directories.sort((a, b) => a.localeCompare(b));\n        directories.forEach((tem) => {\n          js_str += `  \"/${tem}\": '${sidebar_mode}',\\n`;\n        });\n        const res_js_str = `${js_head_str}\\n${js_export_head_str}\\n${js_str}${js_export_end_str}`;\n        console.log('Creat sidebar file content\\n', res_js_str);\n        fs.writeFileSync(sidebar_file_path, res_js_str);\n      })\n      .catch((err) => {\n        console.error(`Error processing files: ${err.message}`);\n      });\n  });\n})();", "file_size": 1810, "extension": ".js"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-web-ide\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\n---\n\n<Share colorful />\n\nEnd User License Agreement (EULA)\nCopyright (c) 2024 尤雨东\nVersion: 1.0\nEffective Date: Permanent\n\n1. Definitions\n   Software: Refers to the program developed by the software developer, including all related files, resources, and updates.\n   Licensor: Refers to the copyright owner of the software.\n   User: Refers to any individual who downloads, installs, or uses the software.\n\n2. License Scope\n   The Licensor grants the User a non-exclusive, non-transferable, and non-sublicensable right to use the software for personal, non-commercial purposes only.\n   This license does not include ownership of the software. The Licensor retains all rights, titles, and interests in the software.\n\n3. Restrictions\n   The User must not modify, decompile, reverse engineer, disassemble, or attempt to obtain the source code of the software.\n   The User must not use the software for illegal activities.\n   The User must not distribute, lease, transfer, or sublicense the software unless explicitly permitted by the Licensor in writing.\n   The User must not remove or alter any copyright notices or branding information included in the software.\n\n4. Updates and Support\n   The Licensor may provide updates to the software but is under no obligation to offer maintenance, technical support, or upgrades.\n   Any updates provided will be subject to the terms of this agreement unless otherwise specified.\n\n5. Privacy\n   Use of the software may involve the collection and processing of user data, as governed by the Licensor's privacy policy (if applicable).\n\n6. Disclaimer\n   The software is provided \"as is\" without any express or implied warranties, including but not limited to warranties of merchantability, fitness for a particular purpose, and non-infringement.\n   The Licensor shall not be liable for any direct or indirect damages arising from the use or inability to use the software.\n\n7. Termination\n   The Licensor reserves the right to terminate this agreement immediately if the User breaches any of its terms.\n   Upon termination, the User must delete all copies of the software and cease any further use.\n\n8. Miscellaneous\n   If any provision of this agreement is deemed invalid or unenforceable, the remaining provisions shall remain in full force and effect.\n\nThis agreement constitutes the entire agreement between the User and the Licensor regarding the software and supersedes all prior communications and agreements.\n\n<Bottom />", "file_size": 2564, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\component\\bottom.vue", "language": "vue", "content": "<script>\nimport Appreciate from './appreciate.vue';\nexport default {\n  components: {\n    Appreciate,\n  },\n};\n</script>\n<template>\n  <div>\n    <!-- <Appreciate></Appreciate> -->\n  </div>\n</template>", "file_size": 197, "extension": ".vue"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-rust-web-server\\config.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 配置文件示例\ntitle: 配置文件示例\nindex: true\nicon: fas fa-cogs\ncategory:\n  - 配置文件示例\n---\n\n<Share colorful />\n\n```json\n{\n  \"server\": [\n    {\n      \"listen_ip\": \"0.0.0.0\",\n      \"listen_port\": 80,\n      \"bind_server_name\": {\n        \"127.0.0.1\": {\n          \"root_path\": \"./\",\n          \"buffer\": 10240,\n          \"gzip_level\": 1,\n          \"log_dir_path\": \"./logs\",\n          \"empty_path_try_files_path\": \"./index.html\",\n          \"response_header_list\": [\n            \"Server: RUST-WEB-SERVER\",\n            \"Access-Control-Allow-Credentials: true\",\n            \"Access-Control-Allow-Headers: *\",\n            \"Access-Control-Allow-Methods: *\",\n            \"Access-Control-Allow-Origin: *\",\n            \"Git: https://github.com/crates-dev/RUST-WEB-SERVE.git\",\n            \"Content-Type: text/html\",\n            \"Content-Encoding: gzip\"\n          ],\n          \"proxy\": [],\n          \"proxy_timeout_seconds\": 10,\n          \"hotlink_protection\": []\n        },\n        \"localhost\": {\n          \"root_path\": \"./\",\n          \"buffer\": 10240,\n          \"gzip_level\": 1,\n          \"log_dir_path\": \"./logs\",\n          \"empty_path_try_files_path\": \"./index.html\",\n          \"response_header_list\": [\n            \"Server: RUST-WEB-SERVER\",\n            \"Access-Control-Allow-Credentials: true\",\n            \"Access-Control-Allow-Headers: *\",\n            \"Access-Control-Allow-Methods: *\",\n            \"Access-Control-Allow-Origin: *\",\n            \"Git: https://github.com/crates-dev/RUST-WEB-SERVE.git\",\n            \"Content-Type: application/json\",\n            \"Content-Encoding: gzip\"\n          ],\n          \"proxy\": [\n            \"https://api.ltpp.vip\",\n            \"https://api.ltpp.vip/Version/getVersion\",\n            \"https://api.ltpp.vip/Version/getVersion?origin=proxy1\"\n          ],\n          \"proxy_timeout_seconds\": 10,\n          \"hotlink_protection\": []\n        }\n      }\n    },\n    {\n      \"listen_ip\": \"0.0.0.0\",\n      \"listen_port\": 81,\n      \"bind_server_name\": {\n        \"127.0.0.1\": {\n          \"root_path\": \"./\",\n          \"buffer\": 10240,\n          \"gzip_level\": 1,\n          \"log_dir_path\": \"./logs\",\n          \"empty_path_try_files_path\": \"./index.html\",\n          \"response_header_list\": [\n            \"Access-Control-Allow-Origin: *\",\n            \"Access-Control-Allow-Methods: *\",\n            \"Access-Control-Allow-Headers: *\",\n            \"Access-Control-Allow-Credentials: true\",\n            \"Server: RUST-WEB-SERVER\",\n            \"Git: https://github.com/crates-dev/RUST-WEB-SERVE.git\",\n            \"Content-Type: application/json\",\n            \"Content-Encoding: gzip\"\n          ],\n          \"proxy\": [\"https://api.ltpp.vip/Version/getVersion?origin=proxy1\"],\n          \"proxy_timeout_seconds\": 10,\n          \"hotlink_protection\": [\"origin=1$\"]\n        }\n      }\n    }\n  ]\n}\n```\n\n<Bottom />", "file_size": 2850, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\config.ts", "language": "typescript", "content": "import { defineUserConfig } from 'vuepress';\nimport { resolve } from 'path';\nimport fs from 'fs';\nimport theme from './theme.js';\nconst is_ltpp_pages = process.env.LTPP === 'LTPP';\nconst is_dev = process.env.NODE_ENV === 'development';\nconst base = is_dev ? '/' : is_ltpp_pages ? '/ltpp-docs/' : '/';\n\nconsole.log(`${is_dev ? '开发' : '生产'}环境`);\n\n!is_dev && console.log(`${is_ltpp_pages ? 'LTPP-GIT' : 'GITHUB'}流水线`);\n\nexport default defineUserConfig({\n  base: base,\n  locales: {\n    '/': {\n      lang: 'zh-CN',\n    },\n  },\n  title: 'Eastspire文档',\n  description: 'Eastspire文档',\n  theme,\n  dest: resolve(__dirname, '../../docs-html'),\n  head: [\n    [\n      'meta',\n      {\n        name: 'viewport',\n        content:\n          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no',\n      },\n    ],\n    [\n      'meta',\n      {\n        name: 'viewport',\n        content:\n          'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no',\n      },\n    ],\n    [\n      'meta',\n      {\n        name: 'keywords',\n        content:\n          'LTPP,开发,编程,计算机,学习,资源,Eastspire,Eastspire文档,Rust,博客,文字,文章,精选,OJ,在线开发平台',\n      },\n    ],\n    [\n      'meta',\n      {\n        name: 'description',\n        content: 'Eastspire文档',\n      },\n    ],\n    [\n      'link',\n      {\n        rel: 'icon',\n        href: `${base}img/logo.png`,\n      },\n    ],\n    [\n      'script',\n      {},\n      `\n      ${fs.readFileSync(resolve(__dirname, './head.js'))}\n    `,\n    ],\n  ],\n});", "file_size": 1489, "extension": ".ts"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\client.ts", "language": "typescript", "content": "import { defineClientConfig } from 'vuepress/client';\nimport Bottom from '../../component/bottom.vue';\nimport Appreciate from '../../component/appreciate.vue';\nimport CratesDownloads from '../../component/crates-downloads.vue';\nimport GitHubMetrics from '../../component/github-metrics.vue';\n\nexport default defineClientConfig({\n  enhance: ({ app, router, siteData }) => {\n    app.component('Bottom', Bottom);\n    app.component('Appreciate', Appreciate);\n    app.component('CratesDownloads', CratesDownloads);\n    app.component('GitHubMetrics', GitHubMetrics);\n  },\n});", "file_size": 569, "extension": ".ts"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-gitlab\\use.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: LTPP-GIT仓库常用命令,LTPP-GIT仓库常用命令文档,教程\ntitle: LTPP-GIT仓库常用命令\nindex: true\nicon: fab fa-gitlab\ncategory:\n  - LTPP-GIT仓库常用命令文档\n  - 教程\n---\n\n#### 命令行指引\n\n##### Git 全局设置\n\n```sh\ngit config --global user.name \"你的用户名\"\ngit config --global user.email \"你的邮箱\"\n```\n\n##### 创建一个新仓库\n\n```sh\ngit clone ssh://git@git.ltpp.vip:66/你的仓库.git\ncd ltpp-week-contest-photo\ngit switch --create main\ntouch README.md\ngit add README.md\ngit commit -m \"add README\"\ngit push --set-upstream origin main\n```\n\n##### 推送现有文件夹\n\n```sh\ncd existing_folder\ngit init --initial-branch=main\ngit remote add origin ssh://git@git.ltpp.vip:66/你的仓库.git\ngit add .\ngit commit -m \"提交信息\"\ngit push --set-upstream origin main\n```\n\n##### 推送现有的 Git 仓库\n\n```sh\ncd existing_repo\ngit remote rename origin old-origin\ngit remote add origin ssh://git@git.ltpp.vip:66/你的仓库.git\ngit push --set-upstream origin --all\ngit push --set-upstream origin --tags\n```\n\n<Bottom />", "file_size": 950, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-rust-web-server\\run.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 运行效果\ntitle: 运行效果\nindex: true\nicon: fas fa-cogs\ncategory:\n  - 运行效果\n---\n\n<Share colorful />\n\n[配置文件示例](./config.md)\n\n### 404\n\n![](markdown-images/image-1.png)\n\n### 反向代理\n\n![](markdown-images/image.png)\n\n### 防盗链\n\n![](markdown-images/image-5.png)\n\n<Bottom />", "file_size": 309, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\vercel.json", "language": "json", "content": "{\n  \"outputDirectory\": \"docs-html\"\n}", "file_size": 36, "extension": ".json"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-share\\mysql.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: LTPP公益MYSQL分享,LTPP公益MYSQL文档\ntitle: LTPP公益MYSQL分享\nindex: true\nicon: fas fa-database\ncategory:\n  - LTPP公益MYSQL文档\n---\n\n<Share colorful />\n\n#### LTPP 公用数据库\n\n> [!tip]\n>\n> - [数据库管理面板](http://free-mysql-phpmyadmin.ltpp.vip/phpmyadmin)\n\n#### 地址（地址已于 2025/2/1 关闭）\n\n> linux.ltpp.vip\n\n#### 端口（端口已于 2025/2/1 关闭）\n\n> 60002\n\n#### root 用户密码\n\n> ltpp\n\n## phpmyadmin 登录界面\n\n![](markdown-images/image-1.png)\n\n## phpmyadmin 管理界面\n\n![](markdown-images/image-2.png)\n\n<Bottom />", "file_size": 509, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\sidebar.js", "language": "javascript", "content": "import { sidebar } from \"vuepress-theme-hope\";\n\nexport default sidebar({\n  \"/bin-encode-decode\": 'structure',\n  \"/china-identification-card\": 'structure',\n  \"/chunkify\": 'structure',\n  \"/clonelicious\": 'structure',\n  \"/cloud-file-storage\": 'structure',\n  \"/color-output\": 'structure',\n  \"/compare-version\": 'structure',\n  \"/development-standards\": 'structure',\n  \"/file-operation\": 'structure',\n  \"/future-fn\": 'structure',\n  \"/gtl\": 'structure',\n  \"/hot-restart\": 'structure',\n  \"/http-compress\": 'structure',\n  \"/http-constant\": 'structure',\n  \"/http-request\": 'structure',\n  \"/http-type\": 'structure',\n  \"/hyperlane\": 'structure',\n  \"/hyperlane-broadcast\": 'structure',\n  \"/hyperlane-log\": 'structure',\n  \"/hyperlane-macros\": 'structure',\n  \"/hyperlane-plugin-websocket\": 'structure',\n  \"/hyperlane-time\": 'structure',\n  \"/hyperlane-utils\": 'structure',\n  \"/lombok-macros\": 'structure',\n  \"/ltpp\": 'structure',\n  \"/ltpp-code-run\": 'structure',\n  \"/ltpp-event-publish-subscribe-in-javascript\": 'structure',\n  \"/ltpp-gitlab\": 'structure',\n  \"/ltpp-html-pdf\": 'structure',\n  \"/ltpp-leetcode-and-acwing-rank\": 'structure',\n  \"/ltpp-oj-judge-testdata-creat\": 'structure',\n  \"/ltpp-post-blog-user-crawler\": 'structure',\n  \"/ltpp-qrcode\": 'structure',\n  \"/ltpp-rust-get-proxy-request\": 'structure',\n  \"/ltpp-rust-web-server\": 'structure',\n  \"/ltpp-share\": 'structure',\n  \"/ltpp-sqs-douyin-collection-download\": 'structure',\n  \"/ltpp-ssh\": 'structure',\n  \"/ltpp-web-ide\": 'structure',\n  \"/recoverable-spawn\": 'structure',\n  \"/recoverable-thread-pool\": 'structure',\n  \"/server-manager\": 'structure',\n  \"/std-macro-extensions\": 'structure',\n  \"/tcp-request\": 'structure',\n  \"/tcplane\": 'structure',\n  \"/udp\": 'structure',\n  \"/udp-request\": 'structure',\n});", "file_size": 1749, "extension": ".js"}
{"file_path": "training_sources\\ltpp-docs\\src\\appreciate.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 赞赏作者,赞赏,appreciate,作者\ntitle: 赞赏作者\nindex: true\nicon: blog\ncategory:\n  - 赞赏\n  - appreciate\n  - 作者\nsidebar: false\n---\n\n<Share colorful />\n\n<Appreciate />\n\n<CratesDownloads />\n\n<GitHubMetrics />\n\n<Bottom />", "file_size": 259, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\version.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 版本记录,更新日志\ntitle: 版本记录\nicon: gears\ncategory:\n  - 更新日志\norder: 3\n---\n\n<Share colorful />\n\n## 版本更新记录\n\n### 更新公告\n\n##### 2.13.0 版本更新（2024/12/21）\n\n- 开放问答详情页和回答接口\n\n##### 2.12.0 版本更新（2024/12/21）\n\n- 开放文章详情页和评论接口\n- 取消文章详情页登录校验\n- 文章详情页未登录状态适配移动端\n- 开放文章详情页音乐组件\n\n##### 2.11.0 版本更新（2024/11/29）\n\n- 开放音乐接口\n\n##### 2.10.0 版本更新（2024/11/24）\n\n- 视频保存规则修改\n\n##### 2.9.6 版本更新（2024/9/21）\n\n- 新增代码分享\n- 修复题单搜索 BUG\n\n##### 2.9.5 版本更新（2024/9/17）\n\n- 视频解析修改\n- 聊天界面修改\n\n##### 2.9.4 版本更新（2024/8/10）\n\n- 1. 对于 WEB，后端下发视频代理地址\n- 2. 对于 APP, 后端下发视频源站地址\n- 3. 新增视频外链分享\n\n##### 2.9.3 版本更新（2024/8/4）\n\n- 1. 新增部分动画，页面布局修改\n\n##### 2.9.2 版本更新（2024/7/15）\n\n- 1. 布局优化\n\n##### 2.9.1 版本更新（2024/7/9）\n\n- 1. 修复后端处理文件下载路径解密错误的 BUG\n\n##### 2.9.0 版本更新（2024/6/22）\n\n- 1. 修复群聊上线失败的 BUG\n- 2. 短视频播放速度优化\n- 3. 优化复制体验\n\n##### 2.8.3 版本更新（2024/6/22）\n\n- 1. 网易云音乐登录界面优化\n- 2. 修复若干已知 BUG（图片上传在应用管理界面切换上传方式不生效）\n- 3. 新增应用重定向\n\n##### 2.8.2 版本更新（2024/6/21）\n\n- 1. 代码查重页面模板优化\n- 2. 新增网页端和客户端录屏和录屏保存\n- 3. 客户端新增对系统分辨率/缩放改变，应用界面自适应支持\n- 4. 修复客户端窗口关闭快捷键在子窗口中不生效\n\n##### 2.8.1 版本更新（2024/6/9）\n\n- 1. 图片加载失败自动隐藏，优化显示效果\n- 2. 取消文章，聊天，评论选择复制的限制\n- 3. 代码提示功能抽离，提示词与 [LTPP 在线 WEB 编辑器](/LTPP-WEB-IDE/) 合并\n\n##### 2.8.0 版本更新（2024/5/27）\n\n- 1. 系统新增兼容 win 平台部署\n- 2. MYSQL 配置优化\n- 3. SSH 服务内网和外网支持地址配置\n- 4. 后端图片上传接口新增图片压缩功能\n\n##### 2.7.9 版本更新（2024/5/11）\n\n- 1. 表格展示优化\n\n##### 2.7.8 版本更新（2024/5/11）\n\n- 1. 修复合成层页面闪烁\n- 2. 界面优化\n\n##### 2.7.6 版本更新（2024/5/9）\n\n- 1. 云服务器新增 CPU 和内存配置\n- 2. 优化静态资源加载速度\n\n##### 2.7.4 版本更新（2024/5/4）\n\n- 1. 展示细节优化\n- 2. 提示信息优化\n\n##### 2.7.3 版本更新（2024/5/4）\n\n- 1. 新增系统通知控制\n- 2. 新增图片保存方式控制\n- 3. 新增云服务器快照，重置，回滚等功能\n- 4. 修复创建群聊后信息未清空\n- 5. 聊天列表界面支持移除私聊用户\n- 6. 新增普通用户云服务器管理界面\n- 7. 权限管理优化\n- 8. 聊天通知优化\n\n##### 2.6.6 版本更新（2024/5/3）\n\n- 1. 部分页面请求加锁，防止发送相同请求\n\n##### 2.6.5 版本更新（2024/4/28）\n\n- 1. 用户主页聊天入口，新增跳转自动定位用户\n- 2. 聊天界面性能优化，减少事件监听\n\n##### 2.6.4 版本更新（2024/4/27）\n\n- 1. 用户主页新增添加聊天入口\n- 2. 云盘界面资源展示逻辑优化\n\n##### 2.6.2 版本更新（2024/4/19）\n\n- 1. UI 优化\n\n##### 2.6.0 版本更新（2024/4/19）\n\n- 1. 新增应用市场\n- 2. 用户支持创建和管理应用\n- 3. 下线公网内网切换，替换为代理功能\n\n##### 2.5.3 版本更新（2024/4/17）\n\n- 1. 界面展示细节优化\n\n##### 2.5.2 版本更新（2024/4/16）\n\n- 1. 分表策略优化\n\n##### 2.5.1 版本更新（2024/4/13）\n\n- 1. 新增题单系统\n- 2. 新增服务器管理系统\n- 3. 修复已知 BUG\n\n##### 2.4.3 版本更新（2024/4/9）\n\n- 1. 编辑器高度自适应\n- 2. 新增防止 XSS 攻击\n- 3. 表格 UI 统一\n- 4. 新增标题 UI 自定义\n- 5. 防盗链新增文件类型配置\n\n##### 2.3.4 版本更新（2024/4/5）\n\n- 1. 判题机架构优化\n- 2. 前端自定义主题优化\n- 3. 新增静态资源防盗链\n- 4. 直播系统迁移\n- 5. 音乐系统迁移\n\n##### 2.2.0 版本更新（2024/4/1）\n\n- 1. 后端内存优化\n- 2. 前端自定义主题优化\n\n##### 2.1.9 版本更新（2024/3/28）\n\n- 1. 后端第三方库版本升级\n- 2. 前端新增 F5 监听，支持快捷在线测试代码\n\n##### 2.1.8 版本更新（2024/3/28）\n\n- 1. LTPP 客户端性能优化\n- 2. LTPP 客户端支持自动更新\n\n##### 2.1.7 版本更新（2024/3/24）\n\n- 1. 代码编辑器主题优化\n- 2. LTPP-SSH 升级\n\n##### 2.1.5 版本更新（2024/3/21）\n\n- 1. 判题机状态优化\n- 2. 在线编辑器可展示最大输出提升至十万个字符\n\n##### 2.1.3 版本更新（2024/3/15）\n\n- 1. 离线错误处理优化\n\n##### 2.1.1 版本更新（2024/3/10）\n\n- 1. 竞赛权限逻辑优化\n- 2. 若干 BUG 修复\n\n##### 2.1.0 版本更新（2024/3/9）\n\n- 1. 判题机编译超时新增兜底\n- 2. 判题机运行超时新增兜底\n- 3. 新增离线化\n- 4. 性能优化\n\n##### 2.0.2 版本更新（2024/2/25）\n\n- 1. UI 优化\n- 2. 修复若干 BUG\n- 3. 用户隐私保护增强\n\n##### 2.0.0 版本更新（2024/2/24）\n\n- 1. 新增一键到底底部\n- 2. 云盘界面资源加载逻辑优化\n- 3. 代码查重文件分割，优化单文件过大导致带宽占用过高\n\n##### 1.9.8 版本更新（2024/2/23）\n\n- 1. 界面优化\n- 2. 排名新增类别（公开赛/私有赛），私有赛需要验证竞赛密码\n- 3. 性能优化\n\n##### 1.9.4 版本更新（2024/2/13）\n\n- 1. 竞赛排名性能优化\n- 2. 界面优化\n- 3. 文件系统优化\n- 4. 函数调用栈日志保存优化\n- 5. 异常通知优化\n\n##### 1.9.2 版本更新（2024/2/2）\n\n- 1. 聊天性能优化\n- 2. 静态资源文件永久有效\n- 3. 资源缓存机制优化\n- 4. 部分资源开启 gzip 压缩\n\n##### 1.8.9 版本更新（2024/1/28）\n\n- 1. 文件系统重构，移除文件夹支持\n- 2. 支持分布式\n- 3. 优化数据库配置\n- 4. 性能优化\n- 5. 安全性优化，反爬机制升级\n- 6. 修复聊天界面频繁切换用户导致聊天信息与用户不匹配\n\n##### 1.7.5 版本更新（2024/1/8）\n\n- 1. 加载动画优化\n- 2. 若干 BUG 修复\n\n##### 1.7.2 版本更新（2024/1/7）\n\n- 1. 界面优化\n- 2. 支持用户自定义 UI\n- 3. 解决弹框意外关闭\n- 4. 支持管理员下达 JS 脚本\n- 5. 下线文章图片预览功能\n\n##### 1.6.7 版本更新（2023/12/31）\n\n- 1. 界面优化\n- 2. 阻塞异常处理\n- 3. 后端服务重启，处于等待中和运行中的代码重新运行\n\n##### 1.6.5 版本更新（2023/12/30）\n\n- 1. 性能优化\n- 2. 监控系统升级\n- 3. 界面优化\n\n##### 1.6.4 版本更新（2023/12/3）\n\n- 1. 性能优化\n- 2. 修复已知 BUG\n\n##### 1.5.2 版本更新（2023/11/10）\n\n- 1. 界面美化\n- 2. 修复已知 BUG\n\n##### 1.4.2 版本更新（2023/10/17）\n\n- 1. 判题机性能优化\n- 2. 重构判题系统，降低服务器高峰时的压力\n- 3. 排名读写分离，多级缓冲优化性能\n\n##### 1.4.1 版本更新（2023/10/9）\n\n- 1. 新增在线 VSCODE 功能，通过购买 SSH 服务器获得\n\n##### 1.3.1 版本更新（2023/10/9）\n\n- 1. 修复若干 BUG\n- 2. 优化代码查重性能\n\n##### 1.3.0 版本更新（2023/9/29）\n\n- 1. 修复若干 BUG\n- 2. 修复判题机已知 BUG\n\n##### 1.2.9 版本更新（2023/9/16）\n\n- 1. 修复若干 BUG\n- 2. 优化题库，文章，竞赛等信息的加载速度\n- 3. 优化后端性能，减少内存开销\n\n##### 1.2.8 版本更新（2023/9/6）\n\n- 1. 修复若干 BUG\n\n##### 1.2.7 版本更新（2023/8/30）\n\n- 1. 修复若干 BUG\n\n##### 1.2.6 版本更新（2023/8/22）\n\n- 1. 修复若干 BUG\n\n##### 1.2.5 版本更新（2023/8/22）\n\n- 1. 修复若干 BUG\n- 2. 即时通讯功能性能升级\n\n##### 1.2.4 版本更新（2023/8/21）\n\n- 1. 云盘系统升级，支持 markdown 文件和代码文件分享和自动解析渲染\n\n##### 1.2.3 版本更新（2023/8/8）\n\n- 1. 编辑器升级，支持字体大小调整\n- 2. 编辑器性能大幅度优化\n- 3. 修复若干已知 BUG\n- 4. 判题机功能升级，安全机制全面升级\n\n##### 1.2.2 版本更新（2023/6/9）\n\n- 1. 优化排名计算速度\n- 2. 前端若干 BUG 修复\n- 3. 新增 C#，TypeScript，Ruby 语言支持\n- 4. 使用多线程优化页面性能\n- 5. 添加轻量云服务器功能\n\n##### 1.2.1 版本更新（2023/5/30）\n\n- 1. 新增外链排名\n- 2. 视频使用 CDN\n- 3. 安卓版内测已开放\n- 4. 修复路由跳转异常\n- 5. 新增竞赛排名外链\n- 6. 新增竞赛题目导出\n- 7. 新增竞赛题解导出\n- 8. 新增重判机制\n- 9. 优化性能\n\n##### 1.2.0 版本更新（2023/3/16）\n\n- 1. 优化界面布局\n- 2. 传输信息加密\n- 3. 优化性能\n- 4. 修复若干已知 BUG\n\n##### 1.1.9 版本更新（2023/1/28）\n\n- 1. 优化数据库\n- 2. 新增在线聊天，群聊，文件等功能\n- 3. 优化布局\n- 4. 新增，云存储，代码托管容量使用进度条\n- 5. 新增比赛时间进度条\n- 6. 新增视频背景\n\n##### 1.1.8 版本更新（2022/12/04）\n\n- 1. 修复比赛界面排名表格中颜色显示不正确的 BUG\n- 2. 优化一些显示问题\n- 3. 页面过度动画优化，修复旧版本可能存在闪屏的问题\n\n##### 1.1.7 版本更新（2022/11/28）\n\n- 1. 优化竞赛布局\n- 2. 支持直接查看自己的排名\n- 3. 支持下载一场比赛全部排名信息\n- 4. 后端性能优化\n- 5. 优化后端排名算法\n- 6. 优化前端竞赛界面性能\n\n##### 1.1.6 版本更新（2022/11/25）\n\n- 1. 丰富题库资源\n\n##### 1.1.5 版本更新（2022/11/03）\n\n- 1. 布局优化\n- 2. 数据库性能优化\n- 3. 文章触底加载，使用队列维护区间，队列的长度较短，减少 DOM 元素的渲染，优化了性能\n- 4. 前端加锁防止数据重复\n\n##### 1.1.4 版本更新（2022/10/27）\n\n- 1. 视频功能完善\n- 2. 页面性能优化\n- 3. 即时通讯安全性优化\n- 4. 页面布局优化\n- 5. 修复视频页面多次刷新后导致评论不加载的 BUG\n- 6. 代码托管安全性优化\n\n##### 1.1.3 版本更新（2022/10/18）\n\n- 1. 使用多线程解决慢请求导致的阻塞问题\n- 2. 优化比赛排名显示，人数过多不展示可视化图表\n\n##### 1.1.2 版本更新（2022/10/17）\n\n- 1. 优化比赛界面，开始自动拉取题目和排名\n\n##### 1.1.1 版本更新（2022/10/15）\n\n- 1. 添加题目题解社区，在题目详情页鼠标右击题目即可跳转该题的题解社区\n- 2. 比赛排名性能优化，优化 echarts 数据过多造成数据重叠，添加排名表格分页功能\n- 3. 页面性能若干优化\n- 4. 视频教程带宽优化，防止一次性加载过多视频导致服务器带宽占满\n- 5. 优化触底加载\n- 6. 单 ip 地址登录\n- 7. 优化后端排名查询速度\n- 8. 修复若干页面显示问题\n\n##### 1.1.0 版本更新（2022/10/06）\n\n- 1. 新增全局临时消息通知\n- 2. 优化界面动画\n- 3. 优化性能\n- 4. 优化路由统一管理，优化权限管理\n- 5. 增加文章下载功能\n- 6. 修复比赛用户总用时不准的 BUG\n- 7. 修复前端因为网络等原因造成的加载动画一直显示\n- 8. 优化数据库结构\n- 9. 支持赛制类型比赛中切换并且转换后的比赛结果为正确的\n- 10. 新增若干道题目\n- 11. 修复在线视频教学模块多个视频同时播放的问题\n- 12. 增加页面假数据，不会因为网络问题导致页面数据空白\n\n##### 1.0.0 版本更新（2022/2/01）\n\n- 1. 优化界面\n- 2. 修复若干已知 BUG\n- 3. 单点登录\n- 4. 鼠标侧边按钮控制前进后退\n- 5. 在线课堂聊天室布局优化\n\n<Bottom />", "file_size": 6271, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\merge-docs\\docs.md", "language": "markdown", "content": "# 二进制加解密库 (bin-encode-decode/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/bin-encode-decode)\n\n> 一个高性能的二进制编码和解码库，支持超越 Base64 的可自定义字符集。\n\n#### 特性\n\n- **自定义字符集**：可定义自己的字符集用于编码和解码，从而实现灵活的数据表示。\n- **高性能**：经过速度优化，适用于需要高效加密操作的应用程序。\n- **简单的 API**：编码和解码过程都有直观且易于使用的接口。\n- **强大的错误处理**：提供清晰且具描述性的错误消息，便于调试。\n- **丰富的文档**：有全面的指南和示例，帮助你快速上手。\n\n#### 安装\n\n要安装 `bin-encode-decode`，请运行以下命令：\n\n```sh\ncargo add bin-encode-decode\n```\n\n#### 使用方法\n\n##### 编码\n\n###### 使用结构体\n\n```rust\nuse bin_encode_decode::*;\n\nlet mut en_decode: Charset= Charset::new();\nlet test_str: &str = \"test\";\nlet mut charset: String = String::from(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=\");\nen_decode.charset(&charset);\nlet encode: Result= en_decode.encode(test_str);\n```\n\n###### 使用函数\n\n```rust\nuse bin_encode_decode::*;\n\nlet test_str: &str = \"test\";\nlet mut charset: String = String::from(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=\");\nlet encode: Result= Encode::execute(&charset, test_str);\n```\n\n##### 解码\n\n###### 使用结构体\n\n```rust\nuse bin_encode_decode::*;\n\nlet mut en_decode: Charset= Charset::new();\nlet test_str: &str = \"aab0aabLaabZaab0\";\nlet mut charset: String = String::from(\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=\");\nen_decode.charset(&charset);\nlet decode: Result= en_decode.decode(test_str);\n```\n\n###### 使用函数\n\n```rust\nuse bin_encode_decode::*;\n\nlet charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=\";\nlet encoded_str = \"aab0aabLaabZaab0\";\nlet decoded_str = Decode::execute(charset, encoded_str);\nlet charset = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_=\";\nlet original_str = \"test\";\nlet encoded_str = Encode::execute(charset, original_str);\n```\n\n# 中国身份证号校验库 (china-identification-card/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/china_identification_card)\n\n> 一个根据官方规则和校验和验证中国身份证号码的 Rust 库。\n\n## 功能\n\n- 校验中国身份证号码的长度和格式\n- 根据官方的权重因子计算并校验校验位\n- 轻量且易于集成\n\n## 安装\n\n使用此库，可以运行以下命令：\n\n```shell\ncargo add china_identification_card\n```\n\n## 示例\n\n```rust\nuse china_identification_card::*;\n\nlet valid: bool = ChineseIdCard::is_valid_id_number(\"110101202311012176\");\nassert_eq!(valid, true);\nlet un_valid: bool = ChineseIdCard::is_invalid_id_number(\"110101202311012171\");\nassert_eq!(un_valid, true);\n```\n\n# chunkify (chunkify/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/chunkify)\n\n[API 文档](https://docs.rs/chunkify/latest/chunkify/)\n\n> 一个简单高效的 Rust 分块处理库。\n\n## 安装\n\n使用该 crate，你可以运行以下命令：\n\n```shell\ncargo add chunkify\n```\n\n## 使用示例\n\n```rust\nuse chunkify::*;\n\nlet chunk_strategy: ChunkStrategy= ChunkStrategy::new(\n    0,\n    \"./uploads\",\n    \"abcdefg\",\n    \"test.txt\",\n    1,\n    |file_id: &str, chunk_index: usize| format!(\"{file_id}.{chunk_index}\"),\n)\n.unwrap();\nchunk_strategy.save_chunk(b\"test\", 0).await.unwrap();\nchunk_strategy.merge_chunks().await.unwrap();\n```\n\n# clonelicious (clonelicious/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/clonelicious)\n\n[API 文档](https://docs.rs/clonelicious/latest/clonelicious/)\n\n> 一个 Rust 宏库，它简化了克隆和闭包的执行。`clone!` 宏会自动克隆变量，并立即使用克隆的值执行闭包，从而简化了 Rust 编程中的常见模式。\n\n## 安装\n\n要安装 `clonelicious`，运行以下命令：\n\n```sh\ncargo add clonelicious\n```\n\n## 使用方法\n\n```rust\nuse clonelicious::*;\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res: String = clone!(s1, s2 => {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}\", s1, s2)\n});\nassert_eq!(res, format!(\"{} {}\", s1, s2));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res: String = clone!(s1, s2 => async move {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}\", s1, s2)\n})\n.await;\nassert_eq!(res, format!(\"{} {}\", s1, s2));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => |data| {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 =>  |data| async move {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\").await, String::from(\"Hello World!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => |data: &str| {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => |data: String| async move {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\".to_owned()).await, format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => move |data| {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => move |data| async move {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\").await, format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => move |data: &str| {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\nlet s1: String = String::from(\"Hello\");\nlet s2: String = String::from(\"World\");\nlet res = clone!(s1, s2 => move |data: String| async move {\n    assert_eq!(s1, String::from(\"Hello\"));\n    assert_eq!(s2, String::from(\"World\"));\n    format!(\"{} {}{}\", s1, s2, data)\n});\nassert_eq!(res(\"!\".to_owned()).await, format!(\"{} {}{}\", s1, s2, \"!\"));\n```\n\n# cloud-file-storage (cloud-file-storage/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/cloud-file-storage)\n\n> 基于 Rust hyperlane 框架的云文件存储服务器，支持多种文件类型的上传。\n\n## 本地部署\n\n### 克隆\n\n```sh\ngit clone git@github.com:eastspire/cloud-file-storage.git\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n## 接口\n\n### 添加资源接口\n\n#### 请求信息\n\n| 请求方法 | 请求路径  | 查询参数         | 请求体           | 描述                                             |\n| -------- | --------- | ---------------- | ---------------- | ------------------------------------------------ |\n| POST     | /add_file | key: `file_name` | 文件的二进制内容 | 上传文件，`file_name` 为文件完整名称（包含后缀） |\n\n#### 返回信息\n\n| 字段 | 类型   | 描述                             |\n| ---- | ------ | -------------------------------- |\n| code | int    | 请求处理结果，成功为 1，失败为 0 |\n| msg  | string | 说明信息                         |\n| data | string | 返回的 URL 地址                  |\n\n### 接口返回示例\n\n#### 成功\n\n```json\n{\n  \"code\": 1,\n  \"msg\": \"ok\",\n  \"data\": \"https://playground.ltpp.vip/\"\n}\n```\n\n#### 失败\n\n```json\n{\n  \"code\": 0,\n  \"msg\": \"missing file_name\",\n  \"data\": \"\"\n}\n```\n\n### 资源加载接口\n\n> 使用添加接口返回的地址即可\n\n# 输出库 (color-output/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/color-output)\n\n## 说明\n\n> 一个基于 Rust 的原子输出库，支持通过函数、构建器和其他方法实现输出功能。它允许自定义文本和背景颜色。\n\n## 功能\n\n- 支持输出格式化后时间\n- 支持自定义文字颜色，背景颜色，文字粗细等配置\n- 支持结构体定义，输出信息\n- 支持构造器定义，输出信息\n- 支持单行多任务输出\n- 支持多行多任务输出\n- 输出原子化\n\n## 安装\n\n```shell\ncargo add color-output\n```\n\n## 代码示例\n\n### 结构体输出\n\n#### 使用 `output` 函数\n\n```rust\nuse color_output::*;\noutput(Output {\n    text: \"test_output_struct\",\n    color: ColorType::Use(Color::Default),\n    bg_color: ColorType::Color256(0x000000),\n    endl: true,\n    ..Default::default()\n});\n```\n\n#### 使用 `output` 方法\n\n```rust\nuse color_output::*;\nOutput {\n    text: \"test_output_struct_output\",\n    color: ColorType::Use(Color::Default),\n    bg_color: ColorType::Use(Color::Blue),\n    endl: true,\n    ..Default::default()\n}\n.output();\n```\n\n### 数组结构体\n\n```rust\nuse color_output::*;\nOutputList(vec![\n    Output {\n        text: \"test_output_list_struct_1\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Color256(0x000000),\n        endl: false,\n        ..Default::default()\n    },\n    Output {\n        text: \"test_output_struct_output_2\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Use(Color::Blue),\n        endl: true,\n        ..Default::default()\n    },\n])\n.output();\n```\n\n### 构造器输出\n\n#### 使用 `output` 函数\n\n```rust\nuse color_output::*;\noutput(\n    OutputBuilder::new_from(Output::default())\n        .text(\"test_output_builder\")\n        .color(ColorType::Color256(0xffffff))\n        .bg_color(ColorType::Color256(0xffffff))\n        .blod(true)\n        .endl(true)\n        .build(),\n);\n```\n\n#### 使用 `output` 方法\n\n```rust\nuse color_output::*;\nOutputBuilder::new()\n    .text(\"test_output_builder_output\")\n    .bg_color(ColorType::Color256(0xffffff))\n    .color(ColorType::Color256(0xffffff))\n    .blod(true)\n    .endl(true)\n    .build()\n    .output();\n```\n\n### 数组构造器\n\n```rust\nuse color_output::*;\nOutputListBuilder::new_from(vec![Output::default()])\n    .add(\n        OutputBuilder::new()\n            .text(\"text\")\n            .bg_color(ColorType::Use(Color::Blue))\n            .endl(false)\n            .build(),\n    )\n    .add(Output {\n        text: \"test_new_from_output_list_builder_1\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Color256(0x3f3f3f),\n        endl: false,\n        ..Default::default()\n    })\n    .add(Output {\n        text: \"test_new_from_output_list_builder_2\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Use(Color::Cyan),\n        endl: true,\n        ..Default::default()\n    })\n    .run();\n```\n\n### 输出宏\n\n#### 结构体传入\n\n```rust\nuse color_output::*;\noutput_macro!(Output {\n    text: \"test_proc_macro\",\n    color: ColorType::default(),\n    bg_color: ColorType::Use(Color::Yellow),\n    endl: true,\n    ..Default::default()\n});\n```\n\n#### 构造器传入\n\n```rust\nuse color_output::*;\noutput_macro!(OutputBuilder::new()\n    .text(\"test_output_builder\")\n    .color(ColorType::Use(Color::Cyan))\n    .blod(true)\n    .endl(true)\n    .build());\n```\n\n#### 多个传入\n\n```rust\nuse color_output::*;\noutput_macro!(\n    Output {\n        text: \"test_proc_macro\",\n        color: ColorType::default(),\n        bg_color: ColorType::Use(Color::Yellow),\n        endl: true,\n        ..Default::default()\n    },\n    OutputBuilder::new()\n        .text(\"test_output_builder1\")\n        .color(ColorType::Color256(0xffffff))\n        .blod(true)\n        .endl(true)\n        .build(),\n    OutputBuilder::new()\n        .text(\"test_output_builder2\")\n        .color(ColorType::Color256(0xffffff))\n        .blod(true)\n        .endl(true)\n        .build()\n);\n```\n\n#### println_success!\n\n> 换行输出成功信息\n\n```rust\nuse color_output::*;\nprintln_success!(\"1234\", \"5678\");\n```\n\n#### println_warning!\n\n> 换行输出警告信息\n\n```rust\nuse color_output::*;\nprintln_warning!(\"1234\", \"5678\");\n```\n\n#### println_error!\n\n> 换行输出错误信息\n\n```rust\nuse color_output::*;\nprintln_error!(\"1234\", \"5678\");\n```\n\n### 颜色使用\n\n- `ColorType::Use`: 使用内置颜色\n- `ColorType::Color256`: 十六进制\n- `ColorType::Rgb`: rgb 颜色(r, g, b)\n\n#### ColorType::Use\n\n```rust\nColorType::Use(Color::White)\n```\n\n#### ColorType::Color256\n\n```rust\nColorType::Color256(0xffffff)\n```\n\n#### ColorType::Rgb\n\n```rust\nColorType::Rgb(255,255,255)\n```\n\n# 版本比较库 (compare-version/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/compare-version)\n\n## 说明\n\n> 这是一个用于比较语义版本字符串和检查版本兼容性的 Rust 库。\n\n## 特性\n\n- **版本比较**：比较两个语义版本字符串，以确定它们的顺序（大于、小于、等于）。\n- **版本范围匹配**：检查特定版本是否匹配指定范围，支持 `^` 和 `~` 语法。\n- **预发布支持**：正确处理预发布版本的比较逻辑。\n- **错误处理**：提供全面的错误类型，以优雅地处理版本解析和范围问题。\n\n## 安装\n\n要使用此库，可以运行以下命令：\n\n```shell\ncargo add COMPARE_VERSION\n```\n\n## 示例\n\n```rust\nuse compare_version::*;\n\nlet result = CompareVersion::compare_version(\"1.2.3\", \"1.2.4\");\nassert_eq!(result, Ok(VersionComparison::Less));\nlet matches = CompareVersion::matches_version_range(\"1.2.3\", \"^1.2.0\");\nassert_eq!(matches, Ok(true));\nlet matches = CompareVersion::matches_version_range(\"1.2.3\", \"~1.2.4\");\nassert_eq!(matches, Ok(false));\n```\n\n# 文件操作库 (file-operation/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/file-operation)\n\n## 文件操作\n\n[API 文档](https://docs.rs/file-operation/latest/file_operation/)\n\n> 一个 Rust 库，提供了一组常见的文件操作工具，如读取、写入和查询文件元数据（例如大小）。它旨在简化 Rust 项目中的文件处理，提供安全且高效的文件操作方法。\n\n## 安装\n\n要使用此库，可以运行以下命令：\n\n```shell\ncargo add file-operation\n```\n\n## 使用\n\n### 写入文件\n\n**代码**\n\n```rust\nlet _ = write_to_file(FILE_PATH, \"test\".as_bytes());\n```\n\n**描述**\n将给定的数据（`\"test\".as_bytes()`）写入指定路径的文件中。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 读取文件\n\n**代码**\n\n```rust\nlet res: Vec= read_from_file(FILE_PATH).unwrap_or_default();\n```\n\n**描述**\n读取指定路径文件的内容。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Vec`，包含文件内容，如果读取失败则返回一个空的向量。\n\n### 获取文件大小\n\n**代码**\n\n```rust\nlet size: Option= get_file_size(FILE_PATH);\n```\n\n**描述**\n获取指定路径文件的大小。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Option`，表示文件大小（字节数），如果文件不存在则返回 `None`。\n\n### 复制目录文件\n\n**代码**\n\n```rust\nlet res: Result= copy_dir_files(FILE_DIR, NEW_FILE_DIR);\n```\n\n**描述**\n将所有文件从 `FILE_DIR` 复制到 `NEW_FILE_DIR`。\n\n- `FILE_DIR` - 源目录路径。\n- `NEW_FILE_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 删除文件\n\n**代码**\n\n```rust\nlet res: Result= delete_file(FILE_PATH);\n```\n\n**描述**\n删除指定路径的文件。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 移动目录\n\n**代码**\n\n```rust\nlet res: Result= move_dir(FILE_DIR, NEW_TEST_DIR);\n```\n\n**描述**\n将 `FILE_DIR` 目录移动到 `NEW_TEST_DIR`。\n\n- `FILE_DIR` - 源目录路径。\n- `NEW_TEST_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 删除目录\n\n**代码**\n\n```rust\nlet res: Result= delete_dir(NEW_TEST_DIR);\n```\n\n**描述**\n删除指定路径的目录。\n\n- `NEW_TEST_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 异步写入文件\n\n**代码**\n\n```rust\nlet _ = async_write_to_file(FILE_PATH, \"test\".as_bytes()).await;\n```\n\n**描述**\n异步地将给定的数据（`\"test\".as_bytes()`）写入指定路径的文件中。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 异步读取文件\n\n**代码**\n\n```rust\nlet res: Vec= async_read_from_file(FILE_PATH).await.unwrap_or_default();\n```\n\n**描述**\n异步地读取指定路径文件的内容。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Vec`，包含文件内容，如果读取失败则返回一个空的向量。\n\n### 异步获取文件大小\n\n**代码**\n\n```rust\nlet size: Option= async_get_file_size(FILE_PATH).await;\n```\n\n**描述**\n异步地获取指定路径文件的大小。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Option`，表示文件大小（字节数），如果文件不存在则返回 `None`。\n\n### 异步复制目录文件\n\n**代码**\n\n```rust\nlet res: Result= async_copy_dir_files(FILE_DIR, NEW_FILE_DIR).await;\n```\n\n**描述**\n异步地将所有文件从 `FILE_DIR` 复制到 `NEW_FILE_DIR`。\n\n- `FILE_DIR` - 源目录路径。\n- `NEW_FILE_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 异步删除文件\n\n**代码**\n\n```rust\nlet res: Result= async_delete_file(FILE_PATH).await;\n```\n\n**描述**\n异步地删除指定路径的文件。\n\n- `FILE_PATH` - 目标文件路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 异步移动目录\n\n**代码**\n\n```rust\nlet res: Result= async_move_dir(FILE_DIR, NEW_TEST_DIR).await;\n```\n\n**描述**\n异步地将 `FILE_DIR` 目录移动到 `NEW_TEST_DIR`。\n\n- `FILE_DIR` - 源目录路径。\n- `NEW_TEST_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n### 异步删除目录\n\n**代码**\n\n```rust\nlet res: Result= async_delete_dir(NEW_TEST_DIR).await;\n```\n\n**描述**\n异步地删除指定路径的目录。\n\n- `NEW_TEST_DIR` - 目标目录路径。\n- 返回值 - 一个 `Result`，表示操作成功或失败。\n\n# future-fn (future-fn/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/future-fn)\n\n[API 文档](https://docs.rs/future-fn/latest/async_move/)\n\n> 一个 Rust 库，提供宏来简化异步闭包的创建，这些闭包通过移动（move）捕获外部状态。这对于轻松、清晰地构建异步代码非常有用。\n\n## 安装\n\n要安装 `future-fn`，请运行以下命令：\n\n```sh\ncargo add future-fn\n```\n\n## 使用\n\n```rust\nuse future_fn::*;\nuse std::time::Duration;\nuse tokio::time::sleep;\n\nlet string: String = String::from(\"test\");\nlet number: i32 = 1;\nlet future_fn = future_fn!(string, number, {\n    let tmp_string: String = String::from(\"test\");\n    assert_eq!(string, tmp_string);\n    assert_eq!(number, 1);\n});\nfuture_fn().await;\n\nlet future_fn = future_fn!(string, number, |data| {\n    let tmp_string: String = String::from(\"test\");\n    sleep(Duration::from_millis(360)).await;\n    assert_eq!(string, tmp_string);\n    assert_eq!(data, 1);\n    assert_eq!(number, 1);\n});\nfuture_fn(1).await;\n\nlet future_fn = future_fn!(string, number, |data: i32| {\n    let tmp_string: String = String::from(\"test\");\n    sleep(Duration::from_millis(360)).await;\n    assert_eq!(string, tmp_string);\n    assert_eq!(data, 1);\n    assert_eq!(number, 1);\n    sleep(Duration::from_millis(360)).await;\n});\nfuture_fn(1).await;\n\nlet future_fn = future_fn!(string, number, |data: i32| {\n    let tmp_string: String = String::from(\"test\");\n    sleep(Duration::from_millis(360)).await;\n    assert_eq!(string, tmp_string);\n    assert_eq!(data, 1);\n    assert_eq!(number, 1);\n});\nfuture_fn(1).await;\n```\n\n# GIT工具 (gtl/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/gtl)\n\n> `gtl` 是一个基于 Git 的工具，旨在简化多远程仓库的管理。它扩展了 Git 的功能，提供了一键初始化和推送到多个远程仓库的功能，特别适合需要同时维护多个远程仓库的开发者。\n\n## 特性\n\n- **多远程仓库管理**：支持为一个本地仓库配置多个远程仓库。\n- **一键初始化远程仓库**：通过简单的命令，一次性初始化并配置多个远程仓库。\n- **一键推送到多个远程仓库**：可以通过一条命令将代码推送到所有已配置的远程仓库，节省时间和精力。\n- **Git 命令扩展**：为 Git 提供了更多便捷的操作，提升工作效率。\n\n## 安装\n\n通过 `cargo` 安装 `gtl`：\n\n```bash\ncargo install gtl\n```\n\n## 使用\n\n### 配置文件\n\n> 路径: /home/.git_helper/config.json\n\n```json\n{\n  \"D:\\\\code\\\\gtl\": [\n    { \"name\": \"gitee\", \"url\": \"git@gitee.com:eastspire/gtl.git\" },\n    { \"name\": \"origin\", \"url\": \"git@github.com:eastspire/gtl.git\" }\n  ]\n}\n```\n\n### 初始化多个远程仓库\n\n假设你已经有一个本地 Git 仓库，并希望将其与多个远程仓库关联，使用以下命令：\n\n```bash\ngtl init\n```\n\n### 一键推送到所有远程仓库\n\n配置好多个远程仓库后，使用以下命令将代码推送到所有已配置的远程仓库：\n\n```bash\ngtl push\n```\n\n### Git 添加 & 提交 & 推送\n\n```bash\ngtl acp\n```\n\n### 发布到 Crates.io & Git 添加 & 提交 & 推送\n\n```bash\ngtl pacp\n```\n\n### 版本\n\n```bash\ngtl -v\ngtl version\ngtl --version\n```\n\n### 帮助\n\n```bash\ngtl help\n```\n\n## 赞赏\n\n**如果你觉得 `hyperlane` 对你有所帮助，欢迎捐赠。**\n\n# 热重启 (hot-restart/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hot-restart)\n\n[API 文档](https://docs.rs/hot-restart/latest/hot_restart/)\n\n> 一个用于热重启应用程序而无需停机的 Rust 库。为服务器和长时间运行的服务提供无缝的进程替换，从而实现零停机更新和配置重载。\n\n## 安装\n\n使用以下命令添加此依赖：\n\n```shell\ncargo add hot-restart\n```\n\n## 使用示例\n\n```rust\nuse hot_restart::*;\n\nasync fn before_restart_hook() {}\n\n#[tokio::main]\nasync fn main() {\n    let res = hot_restart(\n        &[\"--once\", \"-x\", \"check\", \"-x\", \"build\", \"--release\"],\n        before_restart_hook(),\n    )\n    .await;\n    println!(\"hot_restart result: {:?}\", res);\n}\n```\n\n# HTTP压缩解压库 (http-compress/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/http-compress)\n\n[API 文档](https://docs.rs/http-compress/latest/http_compress/)\n\n> 一个用于 HTTP 压缩/解压缩的高性能异步库，支持 Brotli、Deflate 和 Gzip 算法。提供压缩和解压缩功能，并优化了内存使用，非常适合 HTTP 客户端/服务器和网络编程。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add http-compress\n```\n\n## 使用示例\n\n### Compress 类型\n\n```rust\nuse http_compress::*;\nuse core::hash::BuildHasherDefault;\nuse std::{borrow::Cow, collections::HashMap};\n\nlet headers: HashMap> = HashMap::with_hasher(BuildHasherDefault::default());\nlet data: Vec= vec![];\nlet body: Cow> = Compress::from(&headers).decode(&data, 1_024_000);\nassert_eq!(*body, data);\n```\n\n### 编码\n\n```rust\nuse http_compress::*;\n\nlet _ = Compress::Gzip.encode(&[], 1_024_000);\nlet _ = Compress::Deflate.encode(&[], 1_024_000);\nlet _ = Compress::Br.encode(&[], 1_024_000);\n```\n\n### 解码\n\n```rust\nuse http_compress::*;\n\nlet _ = Compress::Gzip.decode(&[], 1_024_000);\nlet _ = Compress::Deflate.decode(&[], 1_024_000);\nlet _ = Compress::Br.decode(&[], 1_024_000);\n```\n\n# HTTP常量库 (http-constant/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/http-constant)\n\n[API 文档](https://docs.rs/http-constant/latest/http_constant/)\n\n> 一个提供常见 HTTP 常量的全面库，包括头部名称、版本、MIME 类型和协议标识符。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add http-constant\n```\n\n## 使用示例\n\n```rust\nuse http_constant::*;\n```\n\n# HTTP请求库 (http-request/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/http-request)\n\n[API 文档](https://docs.rs/http-request/latest/http_request/)\n\n> 一个轻量、高效的库，用于在 Rust 应用程序中构建、发送和处理 HTTP/HTTPS 请求。它提供了一个简单直观的 API，让开发者可以轻松地与 Web 服务进行交互，无论他们使用的是 “HTTP” 还是 “HTTPS” 协议。该库支持各种 HTTP 方法、自定义请求头、请求体、超时、自动处理重定向（包括检测重定向循环）以及增强的响应体解码（自动和手动），从而实现快速、安全的通信。无论是处理安全的 “HTTPS” 连接还是标准的 “HTTP” 请求，该库都经过优化，以实现高性能、最小的资源占用和轻松集成到 Rust 项目中。\n\n## 特性\n\n- **支持 HTTP/HTTPS**：支持 HTTP 和 HTTPS 协议。\n- **WebSocket 支持**：完整的 WebSocket 支持，提供同步和异步 API 用于实时通信。\n- **轻量级设计**：`http_request` crate 提供简单高效的 API 来构建、发送和处理 HTTP 请求，同时最小化资源消耗。\n- **支持常见 HTTP 方法**：支持常见的 HTTP 方法，如 GET 和 POST。\n- **灵活的请求构建**：通过 `RequestBuilder` 提供丰富的配置选项来设置请求头、请求体和 URL。\n- **简单的错误处理**：利用 `Result` 类型处理请求和响应中的错误，使错误处理变得简单直接。\n- **自定义头部和请求体**：轻松添加自定义头部和请求体。\n- **响应处理**：提供 HTTP 响应的简单包装器，便于访问和处理响应数据。\n- **优化的内存管理**：实现高效的内存管理，最小化不必要的内存分配并提高性能。\n- **重定向处理**：支持重定向处理，允许设置最大重定向次数，并包含重定向循环检测。\n- **超时**：支持超时。\n- **自动和手动响应体解码**：支持响应体的自动和手动解码，允许与不同内容类型（如 JSON、XML 等）无缝交互。\n- **代理支持**：全面的代理支持，包括 HTTP、HTTPS 和 SOCKS5 代理，支持 HTTP 请求和 WebSocket 连接的身份验证。\n\n## 安装\n\n要使用此 crate，您可以运行命令：\n\n```shell\ncargo add http-request\n```\n\n## 同步\n\n### 发送 GET 请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 发送 POST 请求\n\n#### 发送 JSON 请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet body: JsonValue = json_value!({\n    \"test\": 1\n});\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://code.ltpp.vip\")\n    .json(body)\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.decode(4096).text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n#### 发送文本请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://ide.ltpp.vip/?language=rust\")\n    .text(\"hello\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n#### 发送二进制请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://ide.ltpp.vip/?language=rust\")\n    .body(\"hello\".as_bytes())\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.decode(4096).text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 使用 HTTP 代理发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .http_proxy(\"127.0.0.1\", 7890)\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 使用 HTTP 代理身份验证发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 使用 SOCKS5 代理发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"http://ide.ltpp.vip/?language=rust\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .socks5_proxy(\"127.0.0.1\", 1080)\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 使用 SOCKS5 代理身份验证发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"http://ide.ltpp.vip/?language=rust\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n    .build_sync();\nrequest_builder\n    .send()\n    .and_then(|response| {\n        println!(\"{:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### WebSocket 连接\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"Authorization\", \"Bearer test-token\");\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .headers(header)\n    .timeout(10000)\n    .buffer(4096)\n    .protocols(&[\"chat\", \"superchat\"])\n    .build_sync();\n\nwebsocket_builder\n    .send_text(\"Hello WebSocket!\")\n    .and_then(|_| {\n        println!(\"Sync WebSocket text message sent successfully\");\n        websocket_builder.send_binary(b\"binary data\")\n    })\n    .and_then(|_| {\n        println!(\"Sync WebSocket binary message sent successfully\");\n        match websocket_builder.receive() {\n            Ok(message) => match message {\n                WebSocketMessage::Text(text) => println!(\"Received text: {}\", text),\n                WebSocketMessage::Binary(data) => println!(\"Received binary: {:?}\", data),\n                WebSocketMessage::Close => println!(\"Connection closed\"),\n                _ => println!(\"Received other message type\"),\n            },\n            Err(e) => println!(\"Error receiving message: {}\", e),\n        }\n        Ok(())\n    })\n    .and_then(|_| websocket_builder.close())\n    .unwrap_or_else(|e| println!(\"Error => {}\", e));\n```\n\n### 使用 HTTP 代理的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .http_proxy(\"127.0.0.1\", 7890)\n    .build_sync();\n\nmatch websocket_builder.send_text(\"Hello WebSocket with HTTP proxy!\") {\n    Ok(_) => println!(\"WebSocket HTTP proxy message sent successfully\"),\n    Err(e) => println!(\"WebSocket HTTP proxy error: {}\", e),\n}\n```\n\n### 使用 HTTP 代理身份验证的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n    .build_sync();\n\nmatch websocket_builder.send_text(\"Hello WebSocket with HTTP proxy auth!\") {\n    Ok(_) => println!(\"WebSocket HTTP proxy auth message sent successfully\"),\n    Err(e) => println!(\"WebSocket HTTP proxy auth error: {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .socks5_proxy(\"127.0.0.1\", 1080)\n    .build_sync();\n\nmatch websocket_builder.send_text(\"Hello WebSocket with SOCKS5 proxy!\") {\n    Ok(_) => println!(\"WebSocket SOCKS5 proxy message sent successfully\"),\n    Err(e) => println!(\"WebSocket SOCKS5 proxy error: {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理身份验证的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n    .build_sync();\n\nmatch websocket_builder.send_text(\"Hello WebSocket with SOCKS5 proxy auth!\") {\n    Ok(_) => println!(\"WebSocket SOCKS5 proxy auth message sent successfully\"),\n    Err(e) => println!(\"WebSocket SOCKS5 proxy auth error: {}\", e),\n}\n```\n\n## 异步\n\n### 发送 GET 请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### 发送 POST 请求\n\n#### 发送 JSON 请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet body: JsonValue = json_value!({\n    \"test\": 1\n});\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://code.ltpp.vip\")\n    .json(body)\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.decode(4096).text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n#### 发送文本请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://ide.ltpp.vip/?language=rust\")\n    .text(\"hello\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n#### 发送二进制请求体\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .post(\"http://ide.ltpp.vip/?language=rust\")\n    .body(\"hello\".as_bytes())\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.decode(4096).text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### 使用 HTTP 代理发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .http_proxy(\"127.0.0.1\", 7890)\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### 使用 HTTP 代理身份验证发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"https://ltpp.vip/\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"http://ide.ltpp.vip/?language=rust\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .socks5_proxy(\"127.0.0.1\", 1080)\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理身份验证发送请求\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"header-key\", \"header-value\");\nlet mut request_builder = RequestBuilder::new()\n    .get(\"http://ide.ltpp.vip/?language=rust\")\n    .headers(header)\n    .timeout(6000)\n    .redirect()\n    .max_redirect_times(8)\n    .http1_1_only()\n    .buffer(4096)\n    .decode()\n    .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n    .build_async();\nmatch request_builder.send().await {\n    Ok(response) => {\n        println!(\"{:?}\", response.text());\n    }\n    Err(e) => println!(\"Error => {}\", e),\n}\n```\n\n### WebSocket 连接\n\n```rust\nuse http_request::*;\n\nlet mut header: HashMapXxHash3_64= hash_map_xx_hash3_64();\nheader.insert(\"Authorization\", \"Bearer test-token\");\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .headers(header)\n    .timeout(10000)\n    .buffer(4096)\n    .protocols(&[\"chat\", \"superchat\"])\n    .build_async();\n\nmatch websocket_builder.send_text_async(\"Hello WebSocket!\").await {\n    Ok(_) => {\n        println!(\"Async WebSocket text message sent successfully\");\n        match websocket_builder.send_binary_async(b\"binary data\").await {\n            Ok(_) => {\n                println!(\"Async WebSocket binary message sent successfully\");\n                match websocket_builder.receive_async().await {\n                    Ok(message) => match message {\n                        WebSocketMessage::Text(text) => println!(\"Received text: {}\", text),\n                        WebSocketMessage::Binary(data) => println!(\"Received binary: {:?}\", data),\n                        WebSocketMessage::Close => println!(\"Connection closed\"),\n                        _ => println!(\"Received other message type\"),\n                    },\n                    Err(e) => println!(\"Error receiving message: {}\", e),\n                }\n            }\n            Err(e) => println!(\"Error sending binary: {}\", e),\n        }\n    }\n    Err(e) => println!(\"Error sending text: {}\", e),\n}\n\nwebsocket_builder\n    .close_async_method()\n    .await\n    .unwrap_or_else(|e| println!(\"Error closing: {}\", e));\n```\n\n### 使用 HTTP 代理的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .http_proxy(\"127.0.0.1\", 7890)\n    .build_async();\n\nmatch websocket_builder.send_text_async(\"Hello WebSocket with HTTP proxy!\").await {\n    Ok(_) => println!(\"Async WebSocket HTTP proxy message sent successfully\"),\n    Err(e) => println!(\"Async WebSocket HTTP proxy error: {}\", e),\n}\n```\n\n### 使用 HTTP 代理身份验证的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n    .build_async();\n\nmatch websocket_builder.send_text_async(\"Hello WebSocket with HTTP proxy auth!\").await {\n    Ok(_) => println!(\"Async WebSocket HTTP proxy auth message sent successfully\"),\n    Err(e) => println!(\"Async WebSocket HTTP proxy auth error: {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .socks5_proxy(\"127.0.0.1\", 1080)\n    .build_async();\n\nmatch websocket_builder.send_text_async(\"Hello WebSocket with SOCKS5 proxy!\").await {\n    Ok(_) => println!(\"Async WebSocket SOCKS5 proxy message sent successfully\"),\n    Err(e) => println!(\"Async WebSocket SOCKS5 proxy error: {}\", e),\n}\n```\n\n### 使用 SOCKS5 代理身份验证的 WebSocket\n\n```rust\nuse http_request::*;\n\nlet mut websocket_builder: WebSocket = WebSocketBuilder::new()\n    .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n    .timeout(10000)\n    .buffer(4096)\n    .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n    .build_async();\n\nmatch websocket_builder.send_text_async(\"Hello WebSocket with SOCKS5 proxy auth!\").await {\n    Ok(_) => println!(\"Async WebSocket SOCKS5 proxy auth message sent successfully\"),\n    Err(e) => println!(\"Async WebSocket SOCKS5 proxy auth error: {}\", e),\n}\n```\n\n## 帮助\n\n确保系统上已安装 CMake。\n\n# HTTP类型库 (http-type/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/http-type)\n\n[API 文档](https://docs.rs/http-type/latest/http_type/)\n\n> 一个全面的 Rust 库，为 HTTP 操作提供必要的类型。包括核心 HTTP 抽象（请求/响应、方法、状态码、版本）、内容类型、Cookie、WebSocket 支持以及线程安全的并发类型（ArcMutex、ArcRwLock）。还提供了方便的 Option 包装的原始类型，以实现灵活的 HTTP 处理。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add http-type\n```\n\n## 使用示例\n\n```rust\nuse http_type::*;\n```\n\n# Hyperlane广播库 (hyperlane-broadcast/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-broadcast)\n\n[API 文档](https://docs.rs/hyperlane-broadcast/latest/hyperlane_broadcast/)\n\n> hyperlane-broadcast 是对 Tokio 广播通道的一个轻量级且符合人体工程学的封装，旨在为异步 Rust 应用程序提供易于使用的发布-订阅消息传递。它通过提供一个直接的接口，以最少的样板代码向多个订阅者广播消息，\n\n## 安装方式\n\n你可以使用如下命令添加依赖：\n\n```shell\ncargo add hyperlane-broadcast\n```\n\n## 使用示例\n\n```rust\nuse hyperlane_broadcast::*;\n\nlet broadcast: Broadcast= Broadcast::new(10);\nlet mut rec1: BroadcastReceiver= broadcast.subscribe();\nlet mut rec2: BroadcastReceiver= broadcast.subscribe();\nbroadcast.send(20).unwrap();\nassert_eq!(rec1.recv().await, Ok(20));\nassert_eq!(rec2.recv().await, Ok(20));\n\nlet broadcast_map: BroadcastMap= BroadcastMap::new();\nbroadcast_map.insert(\"a\", 10);\nlet mut rec1: BroadcastMapReceiver= broadcast_map.subscribe(\"a\").unwrap();\nlet mut rec2: BroadcastMapReceiver= broadcast_map.subscribe(\"a\").unwrap();\nlet mut rec3: BroadcastMapReceiver=\n    broadcast_map.subscribe_or_insert(\"b\", DEFAULT_BROADCAST_SENDER_CAPACITY);\nbroadcast_map.send(\"a\", 20).unwrap();\nbroadcast_map.send(\"b\", 10).unwrap();\nassert_eq!(rec1.recv().await, Ok(20));\nassert_eq!(rec2.recv().await, Ok(20));\nassert_eq!(rec3.recv().await, Ok(10));\n```\n\n# hyperlane日志库 (hyperlane-log/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-log)\n\n[API 文档](https://docs.rs/hyperlane-log/latest/hyperlane_log/)\n\n> 一个支持异步和同步日志记录的 Rust 日志库。它提供多个日志级别，如错误、信息和调试。用户可以定义自定义的日志处理方法并配置日志文件路径。该库支持日志轮换，当当前文件达到指定的大小限制时，会自动创建一个新的日志文件。它允许灵活的日志配置，使其既适用于高性能的异步应用程序，也适用于传统的同步日志记录场景。异步模式利用 Tokio 的异步通道进行高效的日志缓冲，而同步模式则直接将日志写入文件系统。\n\n## 安装\n\n要使用此库，您可以运行以下命令：\n\n```shell\ncargo add hyperlane-log\n```\n\n## 日志存储位置说明\n\n> 会在用户指定的目录下生成三个目录，分别对应错误日志目录，信息日志目录，调试日志目录，这三个目录下还有一级目录使用日期命名，此目录下的日志文件命名是时间.下标.log\n\n## 使用同步\n\n```rust\nuse hyperlane_log::*;\n\nlet log: Log = Log::new(\"./logs\", 1_024_000);\nlog.error(\"error data!\", |error| {\n    let write_data: String = format!(\"User error func => {:?}\\n\", error);\n    write_data\n});\nlog.error(String::from(\"error data!\"), |error| {\n    let write_data: String = format!(\"User error func => {:?}\\n\", error);\n    write_data\n});\nlog.info(\"info data!\", |info| {\n    let write_data: String = format!(\"User info func => {:?}\\n\", info);\n    write_data\n});\nlog.info(String::from(\"info data!\"), |info| {\n    let write_data: String = format!(\"User info func => {:?}\\n\", info);\n    write_data\n});\nlog.debug(\"debug data!\", |debug| {\n    let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n    write_data\n});\nlog.debug(String::from(\"debug data!\"), |debug| {\n    let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n    write_data\n});\n```\n\n## 使用异步\n\n```rust\nuse hyperlane_log::*;\n\nlet log: Log = Log::new(\"./logs\", 1_024_000);\nlog.async_error(\"async error data!\", |error| {\n    let write_data: String = format!(\"User error func => {:?}\\n\", error);\n    write_data\n}).await;\nlog.async_error(String::from(\"async error data!\"), |error| {\n    let write_data: String = format!(\"User error func => {:?}\\n\", error);\n    write_data\n}).await;\nlog.async_info(\"async info data!\", |info| {\n    let write_data: String = format!(\"User info func => {:?}\\n\", info);\n    write_data\n}).await;\nlog.async_info(String::from(\"async info data!\"), |info| {\n    let write_data: String = format!(\"User info func => {:?}\\n\", info);\n    write_data\n}).await;\nlog.async_debug(\"async debug data!\", |debug| {\n    let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n    write_data\n}).await;\nlog.async_debug(String::from(\"async debug data!\"), |debug| {\n    let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n    write_data\n}).await;\n```\n\n## 禁用日志\n\n```rust\nlet log: Log = Log::new(\"./logs\", DISABLE_LOG_FILE_SIZE);\n```\n\n# hyperlane-macros (hyperlane-macros/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-macros)\n\n[API 文档](https://docs.rs/hyperlane-macros/latest/hyperlane_macros/)\n\n> 一个用于构建具有增强功能的 HTTP 服务器的综合性过程宏集合。该 crate 提供了属性宏，可简化 HTTP 请求处理、协议验证、响应管理和请求数据提取。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add hyperlane-macros\n```\n\n## 可用宏\n\n### Hyperlane 宏\n\n- `#[hyperlane(server: Server)]` - 使用指定的变量名创建一个新的 `Server` 或 `ServerConfig` 实例。\n- `#[hyperlane(config: ServerConfig)]` - 使用指定的变量名创建一个新的 `ServerConfig` 实例。\n\n### HTTP 方法宏\n\n- `#[methods(method1, method2, ...)]` - 接受多种 HTTP 方法\n- `#[get]` - GET 方法处理程序\n- `#[post]` - POST 方法处理程序\n- `#[put]` - PUT 方法处理程序\n- `#[delete]` - DELETE 方法处理程序\n- `#[patch]` - PATCH 方法处理程序\n- `#[head]` - HEAD 方法处理程序\n- `#[options]` - OPTIONS 方法处理程序\n- `#[connect]` - CONNECT 方法处理程序\n- `#[trace]` - TRACE 方法处理程序\n\n### 协议检查宏\n\n- `#[ws]` - WebSocket 检查，确保函数仅对 WebSocket 升级请求执行\n- `#[http]` - HTTP 检查，确保函数仅对标准 HTTP 请求执行\n- `#[h2c]` - HTTP/2 Cleartext 检查，确保函数仅对 HTTP/2 明文请求执行\n- `#[http0_9]` - HTTP/0.9 检查，确保函数仅对 HTTP/0.9 协议请求执行\n- `#[http1_0]` - HTTP/1.0 检查，确保函数仅对 HTTP/1.0 协议请求执行\n- `#[http1_1]` - HTTP/1.1 检查，确保函数仅对 HTTP/1.1 协议请求执行\n- `#[http1_1_or_higher]` - HTTP/1.1 或更高版本检查，确保函数仅对 HTTP/1.1 或更新的协议版本执行\n- `#[http2]` - HTTP/2 检查，确保函数仅对 HTTP/2 协议请求执行\n- `#[http3]` - HTTP/3 检查，确保函数仅对 HTTP/3 协议请求执行\n- `#[tls]` - TLS 检查，确保函数仅对 TLS 安全连接执行\n\n### 响应设置宏\n\n- `#[response_status_code(code)]` - 设置响应状态码（支持字面量和全局常量）\n- `#[response_reason_phrase(\"phrase\")]` - 设置响应原因短语（支持字面量和全局常量）\n- `#[response_header(\"key\", \"value\")]` - 添加响应头（支持字面量和全局常量）\n- `#[response_header(\"key\" => \"value\")]` - 设置响应头（支持字面量和全局常量）\n- `#[response_body(\"data\")]` - 设置响应正文（支持字面量和全局常量）\n- `#[response_version(version)]` - 设置响应的 HTTP 版本（支持字面量和全局常量）\n\n### 发送操作宏\n\n- `#[send]` - 函数执行后发送完整的响应（标头和正文）\n- `#[send_body]` - 函数执行后仅发送响应正文\n- `#[send_once]` - 函数执行后仅发送一次完整的响应\n- `#[send_once_body]` - 函数执行后仅发送一次响应正文\n\n### 刷新宏\n\n- `#[flush]` - 函数执行后刷新响应流以确保立即传输数据\n\n### 中止宏\n\n- `#[aborted]` - 处理中止的请求，为过早终止的连接提供清理逻辑\n\n### 关闭操作宏\n\n- `#[closed]` - 处理关闭的流，为已完成的连接提供清理逻辑\n\n### 过滤器宏\n\n- `#[filter_unknown_method]` - 过滤未知的 HTTP 方法，处理使用非标准方法的请求\n- `#[filter_unknown_upgrade]` - 过滤未知的升级请求，处理使用非标准升级协议的请求\n- `#[filter_unknown_version]` - 过滤未知的 HTTP 版本，处理使用非标准 HTTP 协议版本的请求\n- `#[filter_unknown]` - 未知方法、升级和版本的组合过滤器\n\n### 请求正文宏\n\n- `#[request_body(variable_name)]` - 将原始请求正文提取到具有 RequestBody 类型的指定变量中\n- `#[request_body_json(variable_name: type)]` - 将请求正文解析为 JSON 并存入指定的变量和类型中\n\n### 属性宏\n\n- `#[attribute(key => variable_name: type)]` - 通过键提取特定属性到类型化变量中\n\n### 多个属性宏\n\n- `#[attributes(variable_name)]` - 获取所有属性作为 HashMap 以进行全面的属性访问\n\n### 路由参数宏\n\n- `#[route_param(key => variable_name)]` - 通过键提取特定路由参数到变量中\n\n### 多个路由参数宏\n\n- `#[route_params(variable_name)]` - 获取所有路由参数作为集合\n\n### 请求查询宏\n\n- `#[request_query(key => variable_name)]` - 从 URL 查询字符串中通过键提取特定查询参数\n\n### 多个请求查询宏\n\n- `#[request_querys(variable_name)]` - 获取所有查询参数作为集合\n\n### 请求头宏\n\n- `#[request_header(key => variable_name)]` - 从请求中按名称提取特定 HTTP 头\n\n### 多个请求头宏\n\n- `#[request_headers(variable_name)]` - 获取所有 HTTP 头作为集合\n\n### 请求 Cookie 宏\n\n- `#[request_cookie(key => variable_name)]` - 从请求的 cookie 头中通过键提取特定 cookie 值\n\n### 多个请求 Cookie 宏\n\n- `#[request_cookies(variable_name)]` - 从 cookie 头中获取所有 cookie 作为原始字符串\n\n### 请求版本宏\n\n- `#[request_version(variable_name)]` - 将 HTTP 请求版本提取到变量中\n\n### 请求路径宏\n\n- `#[request_path(variable_name)]` - 将 HTTP 请求路径提取到变量中\n\n### Host 宏\n\n- `#[host(\"hostname\")]` - 限制函数仅对具有特定主机头值的请求执行\n- `#[host_filter(\"hostname\")]` - 过滤匹配特定主机头值的请求\n\n### Referer 宏\n\n- `#[referer(\"url\")]` - 限制函数仅对具有特定 referer 头值的请求执行\n- `#[referer_filter(\"url\")]` - 过滤匹配特定 referer 头值的请求\n\n### 钩子宏\n\n- `#[pre_hook(function_name)]` - 在主处理函数之前执行指定的函数\n- `#[post_hook(function_name)]` - 在主处理函数之后执行指定的函数\n\n### 响应头宏\n\n- `#[response_header(\"key\", \"value\")]` - 添加具有给定键和值的特定 HTTP 响应头（添加到现有头）\n- `#[response_header(\"key\" => \"value\")]` - 设置具有给定键和值的特定 HTTP 响应头（覆盖现有头）\n\n### 响应正文宏\n\n- `#[response_body(value)]` - 设置具有给定值的 HTTP 响应正文\n\n### 辅助提示\n\n- 与**请求**相关的宏（数据提取）使用 **`get`** 操作 - 它们从请求中检索/查询数据\n- 与**响应**相关的宏（数据设置）使用 **`set`** 操作 - 它们分配/配置响应数据\n\n### 最佳实践警告\n\n- 请求相关的宏主要是查询功能，而响应相关的宏主要是赋值功能。\n- 当使用 `pre_hook` 或 `post_hook` 宏时，不建议在同一函数上将它们与其他宏（如 `#[get]`、`#[post]`、`#[http]` 等）组合使用。这些宏应该放在钩子函数本身中。如果您不清楚宏是如何展开的，组合使用它们可能会导致有问题的代码行为。\n\n## 示例用法\n\n```rust\nuse hyperlane::*;\nuse hyperlane_macros::*;\nuse serde::{Deserialize, Serialize};\n\nconst TEST_ATTRIBUTE_KEY: &str = \"test_attribute_key\";\nconst CUSTOM_STATUS_CODE: i32 = 200;\nconst CUSTOM_REASON: &str = \"Accepted\";\nconst CUSTOM_HEADER_NAME: &str = \"X-Custom-Header\";\nconst CUSTOM_HEADER_VALUE: &str = \"custom-value\";\nconst RESPONSE_DATA: &str = \"{\\\"status\\\": \\\"success\\\"}\";\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct TestData {\n    name: String,\n    age: u32,\n}\n\n#[response_version(HttpVersion::HTTP1_1)]\nasync fn request_middleware(ctx: Context) {}\n\n#[get]\n#[http]\nasync fn ctx_pre_hook(ctx: Context) {}\n\n#[flush]\n#[send]\n#[response_status_code(200)]\nasync fn ctx_post_hook(ctx: Context) {}\n\n#[send]\n#[response_status_code(CUSTOM_STATUS_CODE)]\n#[response_reason_phrase(CUSTOM_REASON)]\n#[response_header(CUSTOM_HEADER_NAME => CUSTOM_HEADER_VALUE)]\n#[response_body(RESPONSE_DATA)]\nasync fn response(ctx: Context) {}\n\n#[connect]\nasync fn connect(ctx: Context) {\n    let _ = ctx.set_response_body(\"connect\").await.send().await;\n}\n\n#[delete]\nasync fn delete(ctx: Context) {\n    let _ = ctx.set_response_body(\"delete\").await.send().await;\n}\n\n#[head]\nasync fn head(ctx: Context) {\n    let _ = ctx.set_response_body(\"head\").await.send().await;\n}\n\n#[options]\nasync fn options(ctx: Context) {\n    let _ = ctx.set_response_body(\"options\").await.send().await;\n}\n\n#[patch]\nasync fn patch(ctx: Context) {\n    let _ = ctx.set_response_body(\"patch\").await.send().await;\n}\n\n#[put]\nasync fn put(ctx: Context) {\n    let _ = ctx.set_response_body(\"put\").await.send().await;\n}\n\n#[trace]\nasync fn trace(ctx: Context) {\n    let _ = ctx.set_response_body(\"trace\").await.send().await;\n}\n\n#[send]\n#[h2c]\nasync fn h2c(ctx: Context) {\n    let _ = ctx.set_response_body(\"h2c\").await;\n}\n\n#[send]\n#[http]\nasync fn http_only(ctx: Context) {\n    let _ = ctx.set_response_body(\"http\").await;\n}\n\n#[send]\n#[http0_9]\nasync fn http0_9(ctx: Context) {\n    let _ = ctx.set_response_body(\"http0.9\").await;\n}\n\n#[send]\n#[http1_0]\nasync fn http1_0(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.0\").await;\n}\n\n#[send]\n#[http1_1]\nasync fn http1_1(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.1\").await;\n}\n\n#[send]\n#[http2]\nasync fn http2(ctx: Context) {\n    let _ = ctx.set_response_body(\"http2\").await;\n}\n\n#[send]\n#[http3]\nasync fn http3(ctx: Context) {\n    let _ = ctx.set_response_body(\"http3\").await;\n}\n\n#[send]\n#[tls]\nasync fn tls(ctx: Context) {\n    let _ = ctx.set_response_body(\"tls\").await;\n}\n\n#[send]\n#[http1_1_or_higher]\nasync fn http1_1_or_higher(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.1+\").await;\n}\n\n#[send]\n#[filter_unknown_method]\nasync fn unknown_method(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown method\").await;\n}\n\n#[send]\n#[filter_unknown_upgrade]\nasync fn unknown_upgrade(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown upgrade\").await;\n}\n\n#[send]\n#[filter_unknown_version]\nasync fn unknown_version(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown version\").await;\n}\n\n#[send]\n#[filter_unknown]\nasync fn unknown_all(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown all\").await;\n}\n\n#[send_body]\n#[ws]\n#[get]\nasync fn get(ctx: Context) {\n    let _ = ctx.set_response_body(\"get\").await;\n}\n\n#[send_once]\n#[post]\nasync fn post(ctx: Context) {\n    let _ = ctx.set_response_body(\"post\").await;\n}\n\n#[send_once_body]\n#[ws]\nasync fn websocket(ctx: Context) {\n    let _ = ctx.set_response_body(\"websocket\").await;\n}\n\n#[send]\n#[pre_hook(ctx_pre_hook)]\n#[post_hook(ctx_post_hook)]\nasync fn ctx_hook(ctx: Context) {\n    let _ = ctx.set_response_body(\"Testing hook macro\").await;\n}\n\n#[closed]\n#[send]\n#[response_reason_phrase(\"OK\")]\n#[response_status_code(200)]\n#[methods(get, post)]\n#[http]\nasync fn get_post(ctx: Context) {\n    let _ = ctx.set_response_body(\"get_post\").await;\n}\n\n#[send]\n#[attributes(request_attributes)]\nasync fn attributes(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_attributes);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[route_params(request_route_params)]\nasync fn route_params(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_route_params);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_querys(request_querys)]\nasync fn request_querys(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_querys);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_headers(request_headers)]\nasync fn request_headers(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_headers);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[route_param(\"test\" => request_route_param)]\nasync fn route_param(ctx: Context) {\n    if let Some(data) = request_route_param {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_query(\"test\" => request_query_option)]\nasync fn request_query(ctx: Context) {\n    if let Some(data) = request_query_option {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_header(HOST => request_header_option)]\nasync fn request_header(ctx: Context) {\n    if let Some(data) = request_header_option {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_body(raw_body)]\nasync fn request_body(ctx: Context) {\n    let response: String = format!(\"Raw body: {:?}\", raw_body);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[host(\"localhost\")]\nasync fn host(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"host string literal: localhost\")\n        .await;\n}\n\n#[send]\n#[host_filter(\"filter.localhost\")]\nasync fn host_filter(ctx: Context) {\n    let _ = ctx.set_response_body(\"host filter string literal\").await;\n}\n\n#[send]\n#[attribute(TEST_ATTRIBUTE_KEY => request_attribute_option: TestData)]\nasync fn attribute(ctx: Context) {\n    if let Some(data) = request_attribute_option {\n        let response: String = format!(\"name={}, age={}\", data.name, data.age);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[request_body_json(request_data_result: TestData)]\nasync fn request_body_json(ctx: Context) {\n    if let Ok(data) = request_data_result {\n        let response: String = format!(\"name={}, age={}\", data.name, data.age);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[referer(\"http://localhost\")]\nasync fn referer(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"referer string literal: http://localhost\")\n        .await;\n}\n\n#[send]\n#[referer_filter(\"http://localhost\")]\nasync fn referer_filter(ctx: Context) {\n    let _ = ctx.set_response_body(\"referer filter string literal\").await;\n}\n\n#[send]\n#[request_cookies(cookie_value)]\nasync fn cookies(ctx: Context) {\n    let response: String = format!(\"All cookies: {:?}\", cookie_value);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_cookie(\"test\" => session_cookie_opt)]\nasync fn cookie(ctx: Context) {\n    if let Some(session) = session_cookie_opt {\n        let response: String = format!(\"Session cookie: {}\", session);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[request_version(http_version)]\nasync fn request_version_test(ctx: Context) {\n    let response: String = format!(\"HTTP Version: {:?}\", http_version);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_path(request_path)]\nasync fn request_path_test(ctx: Context) {\n    let response: String = format!(\"Request Path: {:?}\", request_path);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[response_header(\"X-Add-Header\", \"add-value\")]\n#[response_header(\"X-Set-Header\" => \"set-value\")]\nasync fn response_header_test(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"Testing header set and replace operations\")\n        .await;\n}\n\n#[send]\n#[response_status_code(201)]\n#[response_reason_phrase(HttpStatus::Created.to_string())]\n#[response_header(CONTENT_TYPE => APPLICATION_JSON)]\n#[response_body(\"{\\\"message\\\": \\\"Resource created\\\"}\")]\nasync fn literals(ctx: Context) {}\n\n#[hyperlane(server: Server)]\n#[hyperlane(config: ServerConfig)]\n#[tokio::main]\nasync fn main() {\n    config.disable_nodelay().await;\n    server.config(config).await;\n    server.request_middleware(request_middleware).await;\n    server.route(\"/response\", response).await;\n    server.route(\"/connect\", connect).await;\n    server.route(\"/delete\", delete).await;\n    server.route(\"/head\", head).await;\n    server.route(\"/options\", options).await;\n    server.route(\"/patch\", patch).await;\n    server.route(\"/put\", put).await;\n    server.route(\"/trace\", trace).await;\n    server.route(\"/h2c\", h2c).await;\n    server.route(\"/http\", http_only).await;\n    server.route(\"/http0_9\", http0_9).await;\n    server.route(\"/http1_0\", http1_0).await;\n    server.route(\"/http1_1\", http1_1).await;\n    server.route(\"/http2\", http2).await;\n    server.route(\"/http3\", http3).await;\n    server.route(\"/tls\", tls).await;\n    server.route(\"/http1_1_or_higher\", http1_1_or_higher).await;\n    server.route(\"/unknown_method\", unknown_method).await;\n    server.route(\"/unknown_upgrade\", unknown_upgrade).await;\n    server.route(\"/unknown_version\", unknown_version).await;\n    server.route(\"/unknown_all\", unknown_all).await;\n    server.route(\"/get\", get).await;\n    server.route(\"/post\", post).await;\n    server.route(\"/websocket\", websocket).await;\n    server.route(\"/ctx_hook\", ctx_hook).await;\n    server.route(\"/get_post\", get_post).await;\n    server.route(\"/attributes\", attributes).await;\n    server.route(\"/route_params/:test\", route_params).await;\n    server.route(\"/request_querys\", request_querys).await;\n    server.route(\"/request_headers\", request_headers).await;\n    server.route(\"/route_param/:test\", route_param).await;\n    server.route(\"/request_query\", request_query).await;\n    server.route(\"/request_header\", request_header).await;\n    server.route(\"/request_body\", request_body).await;\n    server.route(\"/host\", host).await;\n    server.route(\"/host_filter\", host_filter).await;\n    server.route(\"/attribute\", attribute).await;\n    server.route(\"/request_body_json\", request_body_json).await;\n    server.route(\"/referer\", referer).await;\n    server.route(\"/referer_filter\", referer_filter).await;\n    server.route(\"/cookies\", cookies).await;\n    server.route(\"/cookie\", cookie).await;\n    server.route(\"/request_version\", request_version_test).await;\n    server.route(\"/request_path\", request_path_test).await;\n    server.route(\"/response_header\", response_header_test).await;\n    server.route(\"/literals\", literals).await;\n    let server_hook: ServerHook = server.run().await.unwrap_or_default();\n    server_hook.wait().await;\n}\n```\n\n# HyperlaneWebSocket插件 (hyperlane-plugin-websocket/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-plugin-websocket)\n\n[API 文档](https://docs.rs/hyperlane-plugin-websocket/latest/hyperlane_plugin_websocket/)\n\n> Hyperlane 框架的 WebSocket 插件，提供强大的 WebSocket 通信功能，并与 hyperlane-broadcast 集成以实现高效的消息传播。\n\n## 安装\n\n使用以下命令添加此依赖：\n\n```shell\ncargo add hyperlane-plugin-websocket\n```\n\n## 使用示例\n\n```rust\nuse hyperlane::*;\nuse hyperlane_plugin_websocket::*;\n\nstatic BROADCAST_MAP: OnceLock= OnceLock::new();\n\nfn get_broadcast_map() -> &'static WebSocket {\n    BROADCAST_MAP.get_or_init(|| WebSocket::new())\n}\n\nasync fn connected_hook(ctx: Context) {\n    let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n    let broadcast_type: BroadcastType= BroadcastType::PointToGroup(group_name);\n    let receiver_count: ReceiverCount =\n        get_broadcast_map().receiver_count_after_increment(broadcast_type.clone());\n    let data: String = format!(\"receiver_count => {:?}\", receiver_count).into();\n    tokio::spawn(async move {\n        tokio::task::yield_now().await;\n        get_broadcast_map()\n            .send(broadcast_type, data.clone())\n            .unwrap_or_else(|err| {\n                println!(\"[connected_hook]send error => {:?}\", err.to_string());\n                None\n            });\n    });\n    println!(\"[connected_hook]receiver_count => {:?}\", receiver_count);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn group_chat_hook(ws_ctx: Context) {\n    let group_name: String = ws_ctx.get_route_param(\"group_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToGroup(group_name);\n    let mut receiver_count: ReceiverCount = get_broadcast_map().receiver_count(key.clone());\n    let mut body: RequestBody = ws_ctx.get_request_body().await;\n    if body.is_empty() {\n        receiver_count = get_broadcast_map().receiver_count_after_decrement(key);\n        body = format!(\"receiver_count => {:?}\", receiver_count).into();\n    }\n    ws_ctx.set_response_body(body).await;\n    println!(\"[group_chat]receiver_count => {:?}\", receiver_count);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn group_closed(ctx: Context) {\n    let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToGroup(group_name);\n    let receiver_count: ReceiverCount =\n        get_broadcast_map().receiver_count_after_decrement(key.clone());\n    let body: String = format!(\"receiver_count => {:?}\", receiver_count);\n    ctx.set_response_body(body).await;\n    println!(\"[group_closed]receiver_count => {:?}\", receiver_count);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn private_chat_hook(ctx: Context) {\n    let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n    let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToPoint(my_name, your_name);\n    let mut receiver_count: ReceiverCount = get_broadcast_map().receiver_count(key.clone());\n    let mut body: RequestBody = ctx.get_request_body().await;\n    if body.is_empty() {\n        receiver_count = get_broadcast_map().receiver_count_after_decrement(key);\n        body = format!(\"receiver_count => {:?}\", receiver_count).into();\n    }\n    ctx.set_response_body(body).await;\n    println!(\"[private_chat]receiver_count => {:?}\", receiver_count);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn private_closed(ctx: Context) {\n    let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n    let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToPoint(my_name, your_name);\n    let receiver_count: ReceiverCount = get_broadcast_map().receiver_count_after_decrement(key);\n    let body: String = format!(\"receiver_count => {:?}\", receiver_count);\n    ctx.set_response_body(body).await;\n    println!(\"[private_closed]receiver_count => {:?}\", receiver_count);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn sended(ctx: Context) {\n    let msg: String = ctx.get_response_body_string().await;\n    println!(\"[sended_hook]msg => {}\", msg);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\nasync fn private_chat(ctx: Context) {\n    let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n    let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToPoint(my_name, your_name);\n    let config: WebSocketConfig= WebSocketConfig::new()\n        .set_context(ctx.clone())\n        .set_broadcast_type(key)\n        .set_buffer_size(4096)\n        .set_capacity(1024)\n        .set_request_hook(private_chat_hook)\n        .set_sended_hook(sended)\n        .set_closed_hook(private_closed);\n    get_broadcast_map().run(config).await;\n}\n\nasync fn group_chat(ctx: Context) {\n    let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n    let key: BroadcastType= BroadcastType::PointToGroup(group_name);\n    let config: WebSocketConfig= WebSocketConfig::new()\n        .set_context(ctx.clone())\n        .set_broadcast_type(key)\n        .set_buffer_size(4096)\n        .set_capacity(1024)\n        .set_request_hook(group_chat_hook)\n        .set_sended_hook(sended)\n        .set_closed_hook(group_closed);\n    get_broadcast_map().run(config).await;\n}\n\n#[tokio::main]\nasync fn main() {\n    let server: Server = Server::new().await;\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(60000).await;\n    config.enable_nodelay().await;\n    config.http_buffer(4096).await;\n    config.ws_buffer(4096).await;\n    server.config(config).await;\n    server.disable_ws_hook(\"/{group_name}\").await;\n    server.route(\"/{group_name}\", group_chat).await;\n    server.disable_ws_hook(\"/{my_name}/{your_name}\").await;\n    server.route(\"/{my_name}/{your_name}\", private_chat).await;\n    server.connected_hook(connected_hook).await;\n    let server_hook: ServerHook = server.run().await.unwrap_or_default();\n    server_hook.wait().await;\n}\n```\n\n# hyperlane时间库 (hyperlane-time/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-time)\n\n[API 文档](https://docs.rs/hyperlane-time/latest/hyperlane_time/)\n\n> 一个根据系统区域设置获取当前时间的库。\n\n## 安装\n\n要使用这个库，你可以运行以下命令：\n\n```shell\ncargo add hyperlane-time\n```\n\n## 使用\n\n```rust\nuse hyperlane_time::*;\n\nprintln!(\"Current Time: {}\", time());\nprintln!(\"Current Date: {}\", date());\nprintln!(\"GMT Date: {}\", gmt());\nprintln!(\"Timestamp (s): {}\", timestamp());\nprintln!(\"Timestamp (ms): {}\", timestamp_millis());\nprintln!(\"Timestamp (μs): {}\", timestamp_micros());\nprintln!(\"Current Year: {}\", year());\nprintln!(\"Current Month: {}\", month());\nprintln!(\"Current Day: {}\", day());\nprintln!(\"Current Hour: {}\", hour());\nprintln!(\"Current Minute: {}\", minute());\nprintln!(\"Current Second: {}\", second());\nprintln!(\"Current Millis: {}\", millis());\nprintln!(\"Current Micros: {}\", micros());\nprintln!(\"Is Leap Year (1949): {}\", is_leap_year(1949));\nprintln!(\"Calculate Current Time: {:?}\", calculate_time());\nprintln!(\"Compute Date (10000 days): {:?}\", compute_date(10000));\nprintln!(\"Current Time with Millis: {}\", time_millis());\nprintln!(\"Current Time with Micros: {}\", time_micros());\n```\n\n# Hyperlane工具库 (hyperlane-utils/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-utils)\n\n[API 文档](https://docs.rs/hyperlane-utils/latest/hyperlane_utils/)\n\n> 一个为 hyperlane 提供工具的库。\n\n## 安装\n\n您可以使用以下命令安装该 crate：\n\n```shell\ncargo add hyperlane-utils\n```\n\n## 使用方式\n\n```rust\nuse hyperlane_utils::*;\n```\n\n# 服务配置 (hyperlane/config/config.md)\n\n### 设置 `host`\n\n> `hyperlane` 框架绑定 `host` 方式如下：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.host(\"0.0.0.0\").await;\n```\n\n### 设置 `port`\n\n> `hyperlane` 框架绑定端口方式如下：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.port(60000).await;\n```\n\n### 设置 `http_buffer`\n\n> `hyperlane` 框架设置 `HTTP` 缓冲区大小方式如下（不设置或者设置为 `0` 则默认是 `4096` 字节）：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.http_buffer(4096).await;\n```\n\n### 设置 `ws_buffer`\n\n> `hyperlane` 框架设置 `websocket` 缓冲区大小方式如下：\n> 不设置或者设置为 `0` 则默认是 `4096` 字节。\n\n```rust\nserver.ws_buffer(4096).await;\n```\n\n### 设置 `linger`\n\n> `hyperlane` 框架支持配置 `linger`，该选项基于 `Tokio` 的 `TcpStream::set_linger`，用于控制 `SO_LINGER` 选项，以决定连接关闭时未发送数据的处理方式，从而影响连接终止时的行为。\n\n### 设置 `linger`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.linger(Duration::from_millis(10)).await;\n```\n\n### 设置 `nodelay`\n\n> `hyperlane` 框架支持配置 `nodelay`，该选项基于 `Tokio` 的 `TcpStream::set_nodelay`，用于控制 `TCP_NODELAY` 选项，以减少 `Nagle` 算法的影响，提高低延迟场景下的数据传输效率。\n\n### 启用 `nodelay`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.enable_nodelay().await;\n```\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.nodelay(true).await;\n```\n\n### 禁用 `nodelay`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.disable_nodelay().await;\n```\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.nodelay(false).await;\n```\n\n### 设置 `ttl`\n\n> `hyperlane` 框架支持配置 `ttl`，该选项基于 `Tokio` 的 `TcpStream::set_ttl`，用于控制 `IP_TTL` 选项，以设置传输数据包的生存时间（`Time To Live`），从而影响数据包在网络中的跳数限制。\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.ttl(128).await;\n```\n\n### 设置 `config_str`\n\n> `hyperlane` 框架支持直接传入配置字符串。\n\n```rust\nlet config_str: &'static str = r#\"\n    {\n        \"host\": \"0.0.0.0\",\n        \"port\": 80,\n        \"ws_buffer\": 4096,\n        \"http_buffer\": 4096,\n        \"nodelay\": true,\n        \"linger\": { \"secs\": 64, \"nanos\": 0 },\n        \"ttl\": 64\n    }\n\"#;\nserver.config_str(config_str).await;\n```\n\n### 设置 `config`\n\n```rust\nlet config_str: &'static str = r#\"\n    {\n        \"host\": \"0.0.0.0\",\n        \"port\": 80,\n        \"ws_buffer\": 4096,\n        \"http_buffer\": 4096,\n        \"nodelay\": true,\n        \"linger\": { \"secs\": 64, \"nanos\": 0 },\n        \"ttl\": 64\n    }\n\"#;\nlet config: ServerConfig = ServerConfig::from_str(config_str).unwrap();\nserver.config(config).await;\n```\n\n# 连接钩子 (hyperlane/config/connected-hook.md)\n\n> `hyperlane` 框架支持配置连接回调，此方法会在 `http` 连接建立 和 `websocket` 握手成功后调用，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `connected_hook` 将不会执行。\n\n## 配置单个连接回调\n\n```rust\nserver.connected_hook(|ctx: Context| async move {\n    // 处理\n}).await;\n```\n\n## 配置多个连接回调\n\n> 根据注册顺序进行调用。\n\n```rust\nserver.connected_hook(|ctx: Context| async move {\n    // 1\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 2\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 3\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n# HTTP钩子 (hyperlane/config/http-hook.md)\n\n> `hyperlane` 框架支持配置是否启用 `http` 内部处理钩子，默认启用，\n> 值得一提的是此配置支持动态路由设置。\n\n## 启用框架内部 `http` 处理\n\n### 静态路由\n\n```rust\nserver.enable_http_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.enable_http_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.enable_http_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n## 禁用 `http` 内部处理\n\n### 静态路由\n\n```rust\nserver.disable_http_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.disable_http_hook(\"/路由/:id\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.disable_http_hook(\"/路由/:number:\\\\d+\").await;\n```\n\n# 中间件 (hyperlane/config/middleware.md)\n\n> `hyperlane` 框架支持请求中间件和响应中间件，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的逻辑将不会执行。\n\n### 请求中间件\n\n#### 注册请求中间件\n\n```rust\n// 省略 server 创建\nserver.request_middleware(|ctx: Context| async move {\n    // code\n}).await;\n```\n\n#### 注册多个请求中间件\n\n```rust\n// 省略 server 创建\nserver.request_middleware(|ctx: Context| async move {\n    // 1\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 2\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 3\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n### 设置响应中间件\n\n#### 注册响应中间件\n\n```rust\n// 省略 server 创建\nserver.response_middleware(|ctx: Context| async move {\n    // code\n}).await;\n```\n\n#### 注册多个响应中间件\n\n```rust\n// 省略 server 创建\nserver.response_middleware(|ctx: Context| async move {\n    // 1\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 2\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 3\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n# 恐慌钩子 (hyperlane/config/panic-hook.md)\n\n> `hyperlane` 框架内部会对 `panic` 进行捕获，用户可通过钩子进行设置（不设置，框架默认不处理），\n> 需要注意的是，触发 `panic` 后在执行 `panic_hook` 之前，框架会重置 `aborted` 状态，\n> 支持多次注册，触发 `panic` 会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `panic_hook` 将不会执行。\n\n```rust\nserver.panic_hook(|cxt: Context| {\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    // do something\n}).await;\n```\n\n# 协议升级前钩子 (hyperlane/config/pre-upgrade-hook.md)\n\n> `hyperlane` 框架支持配置 `websocket` 协议升级前回调，此方法会在 `websocket` 协议升级前调用，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `pre_upgrade_hook` 将不会执行。\n\n## 配置单个 `websocket` 协议升级前钩子\n\n```rust\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 处理\n}).await;\n```\n\n## 配置多个 `websocket` 协议升级前钩子\n\n```rust\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 1\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 2\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 3\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n# 框架配置 (hyperlane/config/README.md)\n\n# 路由 (hyperlane/config/route.md)\n\n> `hyperlane` 框架使用 `route` 接口进行路由注册，第一个参数是路由名称，第二个参数是路由处理函数，\n> 框架支持动态路由，更多路由详细使用请参考[官方文档](../usage-introduction/route.md)，\n> 路由处理函数参数类型参考 [controller-data 文档](../type/controller-data.md)。\n\n### 注册路由\n\n```rust\n// 省略 server 创建\nserver.route(\"路由名称\", |ctx: Context| async move {\n    // code\n}).await;\n```\n\n# 运行时 (hyperlane/config/runtime.md)\n\n> `hyperlane` 框架基于 `tokio`，可以参考 `tokio` [官方文档](https://docs.rs/tokio/latest/tokio/) 进行配置。\n\n### 快速配置\n\n```rust\n#[tokio::main]\nasync fn main() {}\n```\n\n### 精细化配置\n\n```rust\nfn main() {\n    let thread_count: usize = get_thread_count();\n    let runtime: tokio::runtime::Runtime = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(thread_count)\n        .thread_stack_size(2097152)\n        .max_blocking_threads(5120)\n        .max_io_events_per_tick(5120)\n        .enable_all()\n        .build()\n        .unwrap();\n    runtime().block_on(async move {}).unwrap();\n}\n```\n\n# 创建 Server (hyperlane/config/server.md)\n\n> `hyperlane` 框架创建服务方式如下，需要调用 `run` 方法，服务才会正常运行。\n\n> `ServerHook` 提供了等待框架运行完成和框架停止运行的 `hook`\n\n> - `wait`: `server.run().await.unwrap_or_default().wait()` 实现等待框架运行完成\n> - `shutdown`: `server.run().await.unwrap_or_default().shutdown()` 实现框架停止运行\n\n## Server::new\n\n```rust\nlet server: Server = Server::new().await;\nlet result: ServerResult= server.run().await;\nprintln!(\"Server result: {:?}\", result);\nlet _ = std::io::Write::flush(&mut std::io::stderr());\n```\n\n## Server::from\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nlet server: Server = Server::from(config).await;\nlet result: ServerResult= server.run().await;\nprintln!(\"Server result: {:?}\", result);\nlet _ = std::io::Write::flush(&mut std::io::stderr());\n```\n\n# Websocket钩子 (hyperlane/config/ws-hook.md)\n\n> `hyperlane` 框架支持配置是否启用 `websocket` 内部处理钩子，默认启用，\n> 值得一提的是此配置支持动态路由设置。\n> 需要在路由注册的处理函数中手动处理请求。如果启用，需要设置具体的路由，则会自动处理请求缓存设置，一般用于单发场景。\n> 如果不启用，则需要在业务代码中使用死循环去循环处理请求，一般用于群发场景。\n\n## 启用内部 `websocket` 钩子\n\n### 静态路由\n\n```rust\nserver.enable_ws_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.enable_ws_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.enable_ws_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n## 禁用 `websocket` 内部处理\n\n### 静态路由\n\n```rust\nserver.disable_ws_hook(\"/路由\").await;\n```\n\n### 动态路由\n\n```rust\nserver.disable_ws_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.disable_ws_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n# 异步 (hyperlane/help/async.md)\n\n### 异步\n> 由于 `hyperlane` 框架本身涉及到锁的数据均采取 `tokio`中的读写锁实现，所以涉及到锁的方法调用均需要 `await`。\n\n# 构建 (hyperlane/help/build.md)\n\n### 构建\n\n```sh\ncargo build --release\n```\n\n### 使用 `docker` 进行静态链接\n\n#### Linux / MacOS\n\n```sh\ndocker run --rm -v \"$(pwd):/tmp/cargo_build\" ccr.ccs.tencentyun.com/linux_environment/cargo:1.0.0 /bin/bash -c \"source ~/.bashrc && cd /tmp/cargo_build && RUSTFLAGS='-C target-feature=-crt-static' cargo build --release --target x86_64-unknown-linux-gnu\"\n```\n\n#### Windows\n\n```sh\ndocker run --rm -v \"${pwd}:/tmp/cargo_build\" ccr.ccs.tencentyun.com/linux_environment/cargo:1.0.0 /bin/bash -c \"source ~/.bashrc && cd /tmp/cargo_build && RUSTFLAGS='-C target-feature=-crt-static' cargo build --release --target x86_64-unknown-linux-gnu\"\n```\n\n# 说明 (hyperlane/help/explain.md)\n\n### 框架说明\n\n> `hyperlane` 仅提供最核心的功能(路由、中间件、异常处理、请求处理等基础核心的功能)。其余功能支持全部复用 `crate.io` 生态，这意味着你可以在 `hyperlane` 里使用 `crate.io` 里的第三方库，在 `hyperlane` 里集成他们是非常容易的事情。\n\n### 推荐阅读\n> 推荐阅读 [点击阅读](../../hyperlane-utils/README.md) 。\n\n# 火焰图 (hyperlane/help/flamegraph.md)\n\n> `hyperlane` 框架使用 `flamegraph`，使用前提是需要有 `perf` 环境，生成火焰图步骤如下：\n\n### 安装\n\n```sh\ncargo install flamegraph\n```\n\n### 使用\n\n```sh\nCARGO_PROFILE_RELEASE_DEBUG=true cargo flamegraph --release\n```\n\n# 安装 (hyperlane/help/install.md)\n\n### 安装\n\n> 如果不使用 `Cargo.lock` 提交到 `git`，请在 `Cargo.toml` 文件的版本号前加 `=` 来锁定版本。\n\n#### 命令\n\n```shell\ncargo add hyperlane;\n```\n\n# 帮助 (hyperlane/help/README.md)\n\n# 身份校验中间件 (hyperlane/middleware/auth.md)\n\n> `hyperlane` 框架支持身份校验中间件，用于处理身份校验。\n\n### 身份校验中间件\n\n```rs\nuse hyperlane::*;\n\nasync fn http_version_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1).await;\n}\n\nasync fn auth(ctx: Context) {\n    let auth_str: String = ctx\n        .get_request_header_back(AUTHORIZATION)\n        .await\n        .unwrap_or_default();\n    if auth_str.is_empty() {\n        ctx.set_response_status_code(401)\n            .await\n            .set_response_body(\"Unauthorized\")\n            .await\n            .send()\n            .await\n            .unwrap();\n        ctx.aborted().await;\n    }\n}\n\nasync fn index(ctx: Context) {\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(http_version_middleware)\n        .await\n        .request_middleware(auth)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n# 跨域中间件 (hyperlane/middleware/cross.md)\n\n> `hyperlane` 框架支持跨域中间件，用于处理跨域请求的情况。\n\n### 跨域中间件\n\n```rust\npub async fn cross_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_ORIGIN, ANY)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_METHODS, ALL_METHODS)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_HEADERS, ANY)\n        .await;\n}\n\nasync fn index(ctx: Context) {\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(cross_middleware)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n# 中间件 (hyperlane/middleware/README.md)\n\n# 超时中间件 (hyperlane/middleware/timeout.md)\n\n> `hyperlane` 框架支持超时中间件，用于处理请求超时的情况。\n\n### 超时中间件\n\n```rust\nuse hyperlane::{\n    tokio::{\n        spawn,\n        time::{sleep, timeout},\n    },\n    *,\n};\nuse std::time::Duration;\n\nasync fn http_version_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1).await;\n}\n\nasync fn timeout_middleware(ctx: Context) {\n    spawn(async move {\n        timeout(Duration::from_millis(100), async move {\n            ctx.set_response_status_code(504)\n                .await\n                .set_response_body(\"timeout\")\n                .await\n                .send()\n                .await\n                .unwrap();\n            ctx.aborted().await;\n        })\n        .await\n        .unwrap();\n    });\n}\n\nasync fn index(ctx: Context) {\n    sleep(Duration::from_secs(1)).await;\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(http_version_middleware)\n        .await\n        .request_middleware(timeout_middleware)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n# FileChunk (hyperlane/project/file-chunk.md)\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-quick-start/tree/playground)\n\n> 基于 `hyperlane` 框架，使用 `chunkify`\n> （[官方文档](../../chunkify/README.md)） 开发的的文件分块项目\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### 切换分支\n\n```sh\ngit checkout playground;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n### 浏览器访问\n\n```sh\nhttp://127.0.0.1:60006/upload\n```\n\n# GroupChat (hyperlane/project/group-chat.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/playground)\n\n> 基于 `hyperlane` 框架开发的全栈在线群聊项目\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### 切换分支\n\n```sh\ngit checkout group-chat;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n### 浏览器访问\n\n```sh\nhttp://127.0.0.1:60007/chat\n```\n\n# Mysql (hyperlane/project/mysql.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/mysql)\n\n> 基于 `hyperlane` 框架，使用 `sqlx` 开发的 `mysql` 数据库 `demo`。\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### Mysql 配置\n\n修改代码文件：[src/config/mysql/constant.rs](https://github.com/hyperlane-dev/hyperlane-quick-start/blob/mysql/src/config/mysql/constant.rs)\n\n### 切换分支\n\n```sh\ngit checkout mysql;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n# 示例项目 (hyperlane/project/README.md)\n\n# Redis (hyperlane/project/redis.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/redis)\n\n> 基于 `hyperlane` 框架，使用 `redis` 和 `server-manager` 开发的 `redis` 数据库 `demo`。\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### Redis 配置\n\n修改代码文件：[src/config/redis.rs](https://github.com/hyperlane-dev/hyperlane-quick-start/blob/redis/src/config/redis.rs)\n\n### 切换分支\n\n```sh\ngit checkout redis;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n# 目录结构 (hyperlane/quick-start/directory.md)\n\n> 基于 `hyperlane` 设计的目录结构，配置和业务分离，扩展以插件形式存在，便于开发和维护。\n\n```txt\n├── app                      # app目录\n│   ├── aspect               # 切面编程层\n│   ├── controller           # 接口控制层\n│   ├── exception            # 异常处理层\n│   ├── filter               # 过滤器层\n│   ├── mapper               # 数据访问层\n│   ├── middleware           # 中间件层\n│   ├── model                # 数据模型层\n│      ├── application       # 应用对象\n│      ├── bean              # 实体对象\n│      ├── business          # 业务对象\n│      ├── data              # 数据对象\n│      ├── data_access       # 数据访问对象\n│      ├── data_transfer     # 数据传输对象\n│      ├── domain            # 领域对象\n│      ├── param             # 参数对象\n│      ├── persistent        # 持久化对象\n│      ├── view              # 视图对象\n│   ├── service              # 业务逻辑层\n│   ├── utils                # 工具层\n│   ├── view                 # 视图层\n├── config                   # 配置目录\n│   ├── business             # 业务配置\n│   ├── framework            # 框架配置\n│   ├── server_manager       # 服务管理配置\n├── init                     # 初始化目录\n│   ├── business             # 业务初始化\n│   ├── framework            # 框架始化\n├── plugin                   # 插件目录\n│   ├── log                  # 日志插件\n│   ├── server_manager       # 服务进程管理插件\n├── resources                # 资源目录\n│   ├── static               # 静态资源目录\n│      ├── html              # HTML静态资源\n│      ├── img               # 图片静态资源\n│   ├── templates            # 模板目录\n│      ├── html              # HTML模板\n```\n\n## 🗂 各层级调用关系详解\n\n### `app/controller`（接口控制层）\n\n- 调用：\n\n  - `service`：处理业务逻辑。\n  - `model/param`：接收请求参数。\n  - `model/view`：返回视图对象。\n  - `model/data_transfer`：构建 DTO 返回。\n  - `utils`：使用工具函数处理请求数据。\n  - `exception`：统一异常抛出。\n  - `filter` / `middleware`：作为请求链的入口或出口。\n  - `aspect`：被 AOP 织入切面逻辑。\n  - `view`：视图渲染。\n  - `resources/templates`：页面模板渲染。\n  - `resources/static`：静态资源引用。\n  - `plugin/*`：调用日志记录、服务管理等插件。\n\n### `app/service`（业务逻辑层）\n\n- 调用：\n\n  - `mapper`：访问数据库。\n  - `model/business`：封装业务对象。\n  - `model/domain`：应用领域建模。\n  - `model/data_transfer`：服务返回值封装。\n  - `exception`：业务异常处理。\n  - `utils`：辅助计算、验证、转换等。\n  - `plugin/*`：调用插件完成增强能力。\n\n- 被调用：\n\n  - `controller`\n\n### `app/mapper`（数据访问层）\n\n- 调用：\n\n  - `model/data_access`：数据库表映射。\n  - `model/persistent`：持久化结构体。\n  - `utils`：SQL 构建等辅助操作。\n\n- 被调用：\n\n  - `service`\n\n### `app/model/*`（数据模型层）\n\n> 被多个模块依赖和使用，不主动调用其他层。\n\n#### 常用子模块说明：\n\n| 子模块          | 使用场景                                           |\n| --------------- | -------------------------------------------------- |\n| `application`   | 应用级上下文对象，用于 service/mapper 层组合数据。 |\n| `bean`          | 通用实体定义，如 User、Order 等。                  |\n| `business`      | 业务组合对象，如 OrderDetail + PaymentInfo。       |\n| `data`          | 中间数据对象，在服务流程中传递状态。               |\n| `data_access`   | 映射 DAO/ORM 结构，数据库字段。                    |\n| `data_transfer` | DTO 层，controller → client 层数据输出。           |\n| `domain`        | 领域建模，对应 DDD 的 Aggregate/Entity/VO。        |\n| `param`         | controller 接收参数封装。                          |\n| `persistent`    | 映射数据库存储模型。                               |\n| `view`          | 用于最终渲染视图页面的模型。                       |\n\n**Model 详细介绍**\n\n| 目录名          | 中文名       | 典型职责                                             | 使用场景举例                                        | 与其它层关系                               |\n| --------------- | ------------ | ---------------------------------------------------- | --------------------------------------------------- | ------------------------------------------ |\n| `application`   | 应用对象     | 编排多个业务对象，处理用户用例                       | 服务层 `UserService` 聚合多个 `UserBO` 处理注册流程 | 调用 `business`，传递 `param`、返回 `view` |\n| `bean`          | 实体对象     | 数据实体，表现为 Struct 或 ORM 实体                  | `UserEntity`、`ArticleEntity`，保存于数据库         | 被 `persistent` 持久化，供 `domain` 使用   |\n| `business`      | 业务对象     | 封装核心业务逻辑（BO）                               | `UserBO::register` 内部逻辑完整，不依赖框架         | 被 `application` 调用                      |\n| `data`          | 数据对象     | 数据结构本身，不带行为（值对象、常量等）             | `GenderEnum`、`IdVO`、`DateRange`                   | 被 `domain` 和 `dto` 等层使用              |\n| `data_access`   | 数据访问对象 | 封装数据库交互（DAO、Repository）                    | `UserRepository::find_by_email()`                   | 操作 `bean` 或 `persistent`                |\n| `data_transfer` | 数据传输对象 | 接口中传输的数据载体，常用于请求响应、分页、统一结构 | `ApiResponse`、`Page`、`UserDto`              | 被 controller、OpenAPI 文档广泛使用        |\n| `param`         | 参数对象     | 接口入参、查询条件、分页等                           | `LoginParam`、`SearchQueryParam`                    | 传入 `application` 层                      |\n| `persistent`    | 持久化对象   | ORM 映射专用结构体，有时带属性注解                   | `UserPersistent` 映射数据库字段                     | 与 `bean` 相似，偏向实现层                 |\n| `domain`        | 领域对象     | 领域模型（实体和值对象），封装行为                   | `OrderAggregate`，可带行为如 `Order::cancel()`      | 被 `business` 聚合使用                     |\n| `view`          | 视图对象     | 接口输出结果的表现结构，适配前端需求                 | `UserProfileView`、`ArticleDetailView`              | 从 `dto` 或 `bean` 转换而来                |\n\n### `app/exception`（异常处理层）\n\n- 被调用：\n\n  - `controller`\n  - `service`\n  - `mapper`\n\n### `app/filter`（过滤器层）\n\n- 被调用：\n\n  - `controller` 请求前过滤。\n\n### `app/middleware`（中间件层）\n\n- 被调用：\n\n  - `controller` 请求或响应阶段增强，如权限校验、Header 注入等。\n\n### `app/aspect`（切面编程层）\n\n- 被调用：\n\n  - 自动织入 `controller`、`service` 等层处理日志、安全等横切关注点。\n\n### `app/utils`（工具层）\n\n- 被调用：\n\n  - `controller`\n  - `service`\n  - `mapper`\n  - `model`（可选）\n\n### `app/view`（视图层）\n\n- 被调用：\n\n  - `controller` 用于模板渲染（结合 `resources/templates`）\n\n---\n\n### `config`（配置目录）\n\n- 被调用：\n\n  - `init`：读取配置初始化。\n  - `app`：全局配置使用，如数据库、缓存、超时等。\n\n- 子目录说明：\n\n  - `business`：业务层配置，如风控策略、规则开关。\n  - `hyperlane`：服务监听、路由、中间件配置。\n  - `server_manager`：进程托管策略。\n\n### `init`（初始化目录）\n\n- 调用：\n\n  - `config`：读取配置。\n  - `plugin`：初始化日志、服务等插件。\n  - `app`：初始化 controller/service 等组件。\n\n- 被调用：\n\n  - 由主程序启动时触发。\n\n### `plugin`（插件目录）\n\n- 被调用：\n\n  - `controller` / `service` / `init` 均可能调用。\n\n- 子模块：\n\n  - `log`：日志记录、链路追踪。\n  - `server_manager`：守护进程、PID 控制等。\n\n---\n\n### `resources`（资源目录）\n\n- 子目录说明：\n\n  - `static/html`、`img`：被 `view` 层或浏览器直接访问。\n  - `templates/html`：被 `controller` 或 `view` 用于渲染页面。\n\n# 框架流程 (hyperlane/quick-start/process.md)\n\n## 框架详细流程分析\n\n### 1. 框架总体架构\n\n#### 1.1 核心组件关系图\n\n```mermaid\ngraph TB\n    Server[\"Server (主服务器)\"] --> ServerInner[\"ServerInner (内部状态)\"]\n    ServerInner --> Config[\"ServerConfig (配置)\"]\n    ServerInner --> Router[\"RouteMatcher (路由匹配器)\"]\n    ServerInner --> Middleware[\"Middleware (中间件集合)\"]\n    ServerInner --> Hooks[\"Hooks (钩子函数)\"]\n\n    Server --> Context[\"Context (上下文)\"]\n    Context --> ContextInner[\"ContextInner (内部状态)\"]\n    ContextInner --> Request[\"Request (请求)\"]\n    ContextInner --> Response[\"Response (响应)\"]\n    ContextInner --> Stream[\"ArcRwLockStream (流)\"]\n\n    HttpType[\"http-type crate\"] --> Request\n    HttpType --> Response\n    HttpType --> Stream\n    HttpType --> WebSocketFrame[\"WebSocketFrame (WS帧)\"]\n\n    Broadcast[\"hyperlane-broadcast\"] --> WebSocketPlugin[\"hyperlane-plugin-websocket\"]\n    WebSocketPlugin --> Server\n```\n\n#### 1.2 主要组件说明\n\n> - **Server**: 主服务器结构，提供线程安全的服务器状态访问\n> - **ServerInner**: 包含服务器的所有核心组件，包括配置、路由、中间件和钩子\n> - **Context**: 请求-响应周期的应用上下文，提供线程安全的访问\n> - **ArcRwLockStream**: 线程安全的 `TCP` 流包装器，用于读写操作\n\n### 2. 服务器启动流程\n\n#### 2.1 启动时序图\n\n```mermaid\nsequenceDiagram\n    participant Main as 主程序\n    participant Server as Server\n    participant TcpListener as TcpListener\n    participant PanicHook as 全局异常钩子\n\n    Main->>Server: Server::new()\n    Main->>Server: 配置host/port/buffer等\n    Main->>Server: 注册路由和中间件\n    Main->>Server: run()\n\n    Server->>PanicHook: init_panic_hook()\n    Server->>TcpListener: create_tcp_listener()\n    TcpListener-->>Server: 绑定成功\n\n    loop 接受连接\n        Server->>TcpListener: accept()\n        TcpListener-->>Server: (stream, socket_addr)\n        Server->>Server: configure_stream()\n        Server->>Server: spawn_connection_handler()\n    end\n```\n\n#### 2.2 启动流程详细步骤\n\n> - **服务器初始化**: 创建 `ServerInner` 实例，初始化所有组件为默认值\n> - **配置设置**: 设置主机地址、端口、缓冲区大小等参数\n> - **异常钩子初始化**: 设置全局 `panic` 处理器\n> - **TCP 监听器创建**: 绑定到指定的地址和端口\n> - **连接接受循环**: 持续接受新的 `TCP` 连接\n\n### 3. 连接处理流程\n\n#### 3.1 连接处理时序图\n\n```mermaid\nsequenceDiagram\n    participant TcpListener as TcpListener\n    participant Server as Server\n    participant Stream as ArcRwLockStream\n    participant Context as Context\n    participant Request as Request\n\n    TcpListener->>Server: accept() 新连接\n    Server->>Stream: configure_stream() 配置Socket选项\n    Server->>Server: spawn_connection_handler() 异步任务\n\n    par 异步处理连接\n        Server->>Request: http_from_stream() 解析请求\n        Server->>Context: create_context() 创建上下文\n\n        alt HTTP请求\n            Server->>Server: http_hook()\n        else WebSocket请求\n            Server->>Server: ws_hook()\n        end\n    end\n```\n\n#### 3.2 Socket 配置流程\n\n> 服务器对每个新连接配置以下 `Socket` 选项：\n\n> - **SO_LINGER**: 控制连接关闭时的行为\n> - **TCP_NODELAY**: 禁用 `Nagle` 算法以减少延迟\n> - **IP_TTL**: 设置数据包生存时间\n\n### 4. HTTP 请求处理流程\n\n#### 4.1 HTTP 处理时序图\n\n```mermaid\nsequenceDiagram\n    participant Stream as TCP Stream\n    participant Request as Request Parser\n    participant Context as Context\n    participant Middleware as 中间件\n    participant Router as 路由器\n    participant Handler as 路由处理器\n    participant Response as 响应\n    participant Lifecycle as 生命周期\n\n    Stream->>Request: 读取HTTP数据\n    Request->>Request: 解析请求行\n    Request->>Request: 解析请求头\n    Request->>Request: 读取请求体\n    Request-->>Context: 构建Request对象\n\n    Context->>Lifecycle: 初始化生命周期\n    Context->>Middleware: run_connected_hook()\n\n    alt 未中止\n        Context->>Middleware: run_request_middleware()\n        alt 未中止\n            Context->>Router: resolve_route()\n            Router-->>Context: 返回处理器\n            Context->>Handler: run_route_hook()\n            alt 未中止\n                Context->>Middleware: run_response_middleware()\n            end\n        end\n    end\n\n    Context->>Response: 发送响应\n\n    alt Keep-Alive\n        loop 持续处理请求\n            Stream->>Request: 读取下一个请求\n            Note over Context,Handler: 重复处理流程\n        end\n    end\n```\n\n#### 4.2 HTTP 请求解析详细流程\n\n```mermaid\nflowchart TD\n    Start[开始解析] --> ReadLine[读取请求行]\n    ReadLine --> ParseParts[解析Method/Path/Version]\n    ParseParts --> CheckParts{检查部分数量}\n    CheckParts -->||>= 3| ParseQuery[解析查询参数]\n    ParseQuery --> ParsePath[解析路径]\n    ParsePath --> ReadHeaders[读取请求头]\n    ReadHeaders --> CheckHeader{头部为空?}\n    CheckHeader -->|否| ProcessHeader[处理头部键值对]\n    ProcessHeader --> ReadHeaders\n    CheckHeader -->|是| ReadBody[读取请求体]\n    ReadBody --> BuildRequest[构建Request对象]\n    BuildRequest --> End[解析完成]\n```\n\n### 5. WebSocket 处理流程\n\n#### 5.1 WebSocket 升级时序图\n\n```mermaid\nsequenceDiagram\n    participant Client as 客户端\n    participant Server as 服务器\n    participant Context as Context\n    participant Router as 路由器\n    participant WSHandler as WebSocket处理器\n\n    Client->>Server: WebSocket握手请求\n    Server->>Context: 检测WebSocket请求\n    Server->>Router: resolve_route() 解析路由\n    Server->>Context: run_pre_upgrade_hook() 预升级钩子\n\n    alt 升级成功\n        Server->>Context: upgrade_to_ws() 升级连接\n        Server->>Context: run_connected_hook() 连接钩子\n\n        loop WebSocket帧处理\n            Client->>Server: WebSocket帧\n            Server->>Context: ws_from_stream() 解析帧\n            Server->>WSHandler: 处理WebSocket消息\n            Server->>Client: 发送响应帧\n        end\n    else 升级失败\n        Server->>Client: 返回错误响应\n    end\n```\n\n#### 5.2 WebSocket 帧处理流程\n\n```mermaid\nflowchart TD\n    Start[开始读取] --> ReadBuffer[读取缓冲区数据]\n    ReadBuffer --> CheckLength{数据长度检查}\n    CheckLength -->|长度为0| ConnClosed[连接关闭]\n    CheckLength -->|有数据| AppendBuffer[追加到动态缓冲区]\n    AppendBuffer --> ParseFrame[尝试解析帧]\n    ParseFrame --> CheckComplete{帧是否完整?}\n    CheckComplete -->|否| ReadBuffer\n    CheckComplete -->|是| ProcessFrame[处理帧]\n\n    ProcessFrame --> CheckOpcode{检查操作码}\n    CheckOpcode -->|Text/Binary| ProcessData[处理数据帧]\n    CheckOpcode -->|Ping| SendPong[发送Pong帧]\n    CheckOpcode -->|Pong| ProcessPong[处理Pong帧]\n    CheckOpcode -->|Close| CloseConn[关闭连接]\n    CheckOpcode -->|Continuation| ContinueData[继续数据帧]\n\n    ProcessData --> UpdateRequest[更新Request对象]\n    SendPong --> ReadBuffer\n    ProcessPong --> ReadBuffer\n    ContinueData --> UpdateRequest\n    UpdateRequest --> Complete[处理完成]\n    CloseConn --> End[结束]\n    ConnClosed --> End\n    Complete --> ReadBuffer\n```\n\n### 6. Stream 处理流程\n\n#### 6.1 Stream 读写操作流程\n\n```mermaid\nsequenceDiagram\n    participant App as 应用层\n    participant Stream as ArcRwLockStream\n    participant RwLock as RwLockparticipant TcpStream as TcpStream\n\n    Note over App,TcpStream: 读操作\n    App->>Stream: read()\n    Stream->>RwLock: read().await\n    RwLock-->>Stream: ReadGuard\n    Stream-->>App: 返回读取守护\n\n    Note over App,TcpStream: 写操作\n    App->>Stream: send(data)\n    Stream->>RwLock: write().await\n    RwLock-->>Stream: WriteGuard\n    Stream->>TcpStream: write_all(data)\n    TcpStream-->>Stream: Result\n    Stream-->>App: ResponseResult\n\n    Note over App,TcpStream: WebSocket发送\n    App->>Stream: send_ws_body(body)\n    Stream->>Stream: send_body_conditional(body, true)\n    Stream->>Stream: WebSocketFrame::create_response_frame_list()\n    loop 发送每个帧\n        Stream->>TcpStream: write_all(frame)\n    end\n```\n\n#### 6.2 Stream 并发安全机制\n\n> `Stream` 使用 `Arc>` 实现线程安全：\n\n> - **读锁**: 允许多个并发读操作\n> - **写锁**: 确保写操作的独占访问\n> - **异步支持**: 使用 `tokio` 的异步 `RwLock`\n\n### 7. 中间件管道流程\n\n#### 7.1 中间件执行时序\n\n```mermaid\nsequenceDiagram\n    participant Context as Context\n    participant ReqMw as 请求中间件\n    participant Router as 路由处理器\n    participant ResMw as 响应中间件\n    participant Lifecycle as 生命周期管理\n\n    Context->>Lifecycle: 初始化Continue状态\n\n    loop 请求中间件\n        Context->>ReqMw: 执行中间件函数\n        ReqMw->>Lifecycle: 更新生命周期状态\n        alt 状态为Abort\n            Note over Context,Lifecycle: 中止后续处理\n        end\n    end\n\n    alt 继续处理\n        Context->>Router: 执行路由处理器\n        Router->>Lifecycle: 更新生命周期状态\n\n        alt 继续处理\n            loop 响应中间件\n                Context->>ResMw: 执行中间件函数\n                ResMw->>Lifecycle: 更新生命周期状态\n            end\n        end\n    end\n\n    Context->>Context: 返回keep_alive状态\n```\n\n#### 7.2 钩子函数执行流程\n\n> 服务器支持多种类型的钩子函数：\n\n> - **connected_hook**: 新连接建立时执行\n> - **pre_upgrade_hook**: `WebSocket` 升级前执行\n> - **request_middleware**: 请求处理中间件\n> - **response_middleware**: 响应处理中间件\n\n### 8. 路由匹配流程\n\n#### 8.1 路由匹配算法\n\n```mermaid\nflowchart TD\n    Start[开始路由匹配] --> CheckStatic[检查静态路由]\n    CheckStatic --> StaticFound{找到静态路由?}\n    StaticFound -->|是| ReturnStatic[返回静态路由处理器]\n    StaticFound -->|否| CheckDynamic[检查动态路由]\n\n    CheckDynamic --> DynamicLoop[遍历动态路由]\n    DynamicLoop --> DynamicMatch{匹配动态路由?}\n    DynamicMatch -->|是| ExtractParams[提取路径参数]\n    DynamicMatch -->|否| NextDynamic[下一个动态路由]\n    NextDynamic --> DynamicLoop\n    ExtractParams --> ReturnDynamic[返回动态路由处理器]\n\n    DynamicLoop --> CheckRegex[检查正则路由]\n    CheckRegex --> RegexLoop[遍历正则路由]\n    RegexLoop --> RegexMatch{匹配正则路由?}\n    RegexMatch -->|是| ReturnRegex[返回正则路由处理器]\n    RegexMatch -->|否| NextRegex[下一个正则路由]\n    NextRegex --> RegexLoop\n\n    RegexLoop --> NotFound[未找到路由]\n\n    ReturnStatic --> End[返回处理器]\n    ReturnDynamic --> End\n    ReturnRegex --> End\n    NotFound --> End\n```\n\n#### 8.2 路由类型说明\n\n> 路由匹配器将路由分为三类：\n\n> - **静态路由**: 精确路径匹配\n> - **动态路由**: 包含变量段的路径（如 `/users/{id}` ）\n> - **正则路由**: 基于正则表达式的复杂匹配\n\n### 9. 生命周期管理流程\n\n#### 9.1 生命周期状态转换\n\n```mermaid\nstateDiagram-v2\n    [*] --> Continue : 初始化\n    Continue --> Continue : 中间件执行成功\n    Continue --> Abort : 中间件调用abort()\n    Abort --> Abort : 保持中止状态\n\n    state Continue {\n        [*] --> KeepAliveTrue : keep_alive=true\n        [*] --> KeepAliveFalse : keep_alive=false\n    }\n\n    state Abort {\n        [*] --> KeepAliveTrue : keep_alive=true\n        [*] --> KeepAliveFalse : keep_alive=false\n    }\n\n    Continue --> [*] : 处理完成\n    Abort --> [*] : 处理完成\n```\n\n#### 9.2 生命周期控制方法\n\n> 生命周期管理器提供以下控制方法：\n\n> - **update_status()**: 根据中止和保持连接标志更新状态\n> - **is_abort()**: 检查是否为中止状态\n> - **keep_alive()**: 返回连接保持状态\n\n### 10. 广播系统集成\n\n#### 10.1 WebSocket 广播架构\n\n```mermaid\ngraph TB\n    WebSocketPlugin[hyperlane-plugin-websocket] --> Broadcast[hyperlane-broadcast]\n    Broadcast --> BroadcastMap[BroadcastMap]\n    BroadcastMap --> PointToPoint[点对点广播]\n    BroadcastMap --> PointToGroup[群组广播]\n\n    WebSocketConfig --> BroadcastType[广播类型]\n    BroadcastType --> PointToPoint\n    BroadcastType --> PointToGroup\n\n    WebSocketConfig --> Hooks[WebSocket钩子]\n    Hooks --> RequestHook[请求钩子]\n    Hooks --> SendedHook[发送钩子]\n    Hooks --> ClosedHook[关闭钩子]\n```\n\n#### 10.2 广播消息流程\n\n> `WebSocket` 插件支持两种广播模式：\n\n> - **点对点通信**: 两个特定用户之间的私聊\n> - **群组通信**: 多个用户在同一群组中的广播\n\n### 11. 错误处理流程\n\n#### 11.1 异常处理时序图\n\n```mermaid\nsequenceDiagram\n    participant Task as 异步任务\n    participant Server as Server\n    participant PanicHook as Panic钩子\n    participant Context as Context\n\n    Task->>Task: panic!() 发生异常\n    Task->>Server: JoinError\n    Server->>Server: handle_task_panic()\n    Server->>Server: Panic::from_join_error()\n    Server->>Context: set_panic()\n    Server->>PanicHook: 调用panic钩子\n    PanicHook->>Context: 处理异常上下文\n```\n\n#### 11.2 全局异常钩子机制\n\n> 服务器在启动时设置全局异常处理器，能够：\n\n> - 捕获 `panic` 信息\n> - 关联到请求上下文\n> - 异步处理异常响应\n> - 自定义异常处理逻辑\n\n# 快速开始 (hyperlane/quick-start/README.md)\n\n## 快速开始\n> 这是基于 `hyperlane` 封装的项目（[hyperlane-quick-start](https://github.com/hyperlane-dev/hyperlane-quick-start)），旨在简化使用和规范项目代码结构。\n\n### 克隆项目\n\n```sh\ngit clone https://github.com/hyperlane-dev/hyperlane-quick-start.git\n```\n\n### 进入项目\n\n```sh\ncd hyperlane-quick-start\n```\n\n### 运行\n> 此项目使用 `server-manager` 进行服务管理。\n> 使用参考 [官方文档](../../server-manager/README.md)。\n\n#### 运行\n\n```sh\ncargo run\n```\n\n#### 在后台运行\n\n```sh\ncargo run -d\n```\n\n#### 停止\n\n```sh\ncargo run stop\n```\n\n#### 重启\n\n```sh\ncargo run restart\n```\n\n#### 重启在后台运行\n\n```sh\ncargo run restart -d\n```\n\n#### 热重启\n\n```sh\ncargo run hot\n```\n\n# Web后端框架 (hyperlane/README.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane)\n\n[API 文档](https://docs.rs/hyperlane/latest/hyperlane/)\n\n> 一个轻量级、高性能、跨平台的 Rust HTTP 服务器库，构建于 Tokio 之上，旨在简化现代 Web 服务开发。它内建对中间件、WebSocket、服务器发送事件（SSE）以及原始 TCP 通信的支持，同时在 Windows、Linux 和 macOS 平台上提供统一且符合人体工学的 API，使开发者能够以最小的开销和最大的灵活性构建健壮、可扩展、事件驱动的网络应用程序。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add hyperlane\n```\n\n## 快速开始\n\n- [hyperlane-quick-start git](https://github.com/hyperlane-dev/hyperlane-quick-start)\n- [hyperlane-quick-start docs](https://docs.ltpp.vip/hyperlane/quick-start/)\n\n```sh\ngit clone https://github.com/hyperlane-dev/hyperlane-quick-start.git\n```\n\n## 使用示例\n\n```rust\nuse hyperlane::*;\n\nasync fn connected_hook(ctx: Context) {\n    if !ctx.get_request().await.is_ws() {\n        return;\n    }\n    let socket_addr: String = ctx.get_socket_addr_or_default_string().await;\n    let _ = ctx.set_response_body(socket_addr).await.send_body().await;\n}\n\nasync fn request_middleware(ctx: Context) {\n    let socket_addr: String = ctx.get_socket_addr_or_default_string().await;\n    ctx.set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(200)\n        .await\n        .set_response_header(SERVER, HYPERLANE)\n        .await\n        .set_response_header(CONNECTION, KEEP_ALIVE)\n        .await\n        .set_response_header(CONTENT_TYPE, TEXT_PLAIN)\n        .await\n        .set_response_header(\"SocketAddr\", socket_addr)\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    if ctx.get_request().await.is_ws() {\n        return;\n    }\n    let _ = ctx.send().await;\n}\n\nasync fn root_route(ctx: Context) {\n    let path: RequestPath = ctx.get_request_path().await;\n    let response_body: String = format!(\"Hello hyperlane => {}\", path);\n    let cookie1: String = CookieBuilder::new(\"key1\", \"value1\").http_only().build();\n    let cookie2: String = CookieBuilder::new(\"key2\", \"value2\").http_only().build();\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_header(SET_COOKIE, cookie1)\n        .await\n        .set_response_header(SET_COOKIE, cookie2)\n        .await\n        .set_response_body(response_body)\n        .await;\n}\n\nasync fn ws_route(ctx: Context) {\n    let key: RequestHeadersValueItem = ctx\n        .get_request_header_back(SEC_WEBSOCKET_KEY)\n        .await\n        .unwrap_or_default();\n    let request_body: Vec= ctx.get_request_body().await;\n    let _ = ctx.set_response_body(key).await.send_body().await;\n    let _ = ctx.set_response_body(request_body).await.send_body().await;\n}\n\nasync fn sse_route(ctx: Context) {\n    let _ = ctx\n        .set_response_header(CONTENT_TYPE, TEXT_EVENT_STREAM)\n        .await\n        .send()\n        .await;\n    for i in 0..10 {\n        let _ = ctx\n            .set_response_body(format!(\"data:{}{}\", i, HTTP_DOUBLE_BR))\n            .await\n            .send_body()\n            .await;\n    }\n    let _ = ctx.closed().await;\n}\n\nasync fn dynamic_route(ctx: Context) {\n    let param: RouteParams = ctx.get_route_params().await;\n    panic!(\"Test panic {:?}\", param);\n}\n\nasync fn panic_hook(ctx: Context) {\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    let response_body: String = error.to_string();\n    eprintln!(\"{}\", response_body);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n    let content_type: String = ContentType::format_content_type_with_charset(TEXT_PLAIN, UTF8);\n    let _ = ctx\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(500)\n        .await\n        .clear_response_headers()\n        .await\n        .set_response_header(SERVER, HYPERLANE)\n        .await\n        .set_response_header(CONTENT_TYPE, content_type)\n        .await\n        .set_response_body(response_body)\n        .await\n        .send()\n        .await;\n}\n\n#[tokio::main]\nasync fn main() {\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(60000).await;\n    config.enable_nodelay().await;\n    config.http_buffer(4096).await;\n    config.ws_buffer(4096).await;\n    let server: Server = Server::from(config).await;\n    server.panic_hook(panic_hook).await;\n    server.connected_hook(connected_hook).await;\n    server.pre_upgrade_hook(request_middleware).await;\n    server.request_middleware(request_middleware).await;\n    server.response_middleware(response_middleware).await;\n    server.route(\"/\", root_route).await;\n    server.route(\"/ws\", ws_route).await;\n    server.route(\"/sse\", sse_route).await;\n    server.route(\"/dynamic/{routing}\", dynamic_route).await;\n    server.route(\"/regex/{file:^.*$}\", dynamic_route).await;\n    let server_hook: ServerHook = server.run().await.unwrap_or_default();\n    server_hook.wait().await;\n}\n```\n\n# 关闭Keep Alive (hyperlane/speed/close-keep-alive.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement/tree/master/close-keep-alive)\n\n### wrk\n\n#### 压测命令\n\n```sh\nwrk -c360 -d60s -H \"Connection: close\" http://127.0.0.1:60000/\n```\n\n#### 压测结果\n> 测试 `360` 并发，持续 `60s` 请求。`QPS` 结果如下：\n\n> - 1 `Hyperlane框架` ：51031.27\n> - 2 `Tokio` ：49555.87\n> - 3 `Rocket框架` ：49345.76\n> - 4 `Gin框架` ：40149.75\n> - 5 `Go标准库` ：38364.06\n> - 6 `Rust标准库` ：30142.55\n> - 7 `Node标准库` ：28286.96\n\n#### hyperlane 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.51ms    2.12ms 254.29ms   74.68%\n    Req/Sec    25.69k     1.78k   42.56k    74.94%\n  3066756 requests in 1.00m, 298.32MB read\nRequests/sec:  51031.27\nTransfer/sec:      4.96MB\n```\n\n#### Rust 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    13.39ms   39.09ms 938.33ms   93.24%\n    Req/Sec    15.17k     1.25k   19.88k    71.08%\n  1811006 requests in 1.00m, 151.99MB read\nRequests/sec:  30142.55\nTransfer/sec:      2.53MB\n```\n\n#### Tokio 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.64ms    2.97ms 331.60ms   89.67%\n    Req/Sec    24.93k     2.37k   31.57k    64.49%\n  2976845 requests in 1.00m, 249.83MB read\nRequests/sec:  49555.87\nTransfer/sec:      4.16MB\n```\n\n#### Rocket 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.70ms    3.23ms 246.75ms   92.68%\n    Req/Sec    24.83k     2.31k   47.87k    71.72%\n  2963056 requests in 1.00m, 729.05MB read\nRequests/sec:  49345.76\nTransfer/sec:     12.14MB\n```\n\n#### Gin 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.69ms    2.66ms  37.49ms   68.89%\n    Req/Sec    20.22k     3.79k   28.13k    59.02%\n  2412349 requests in 1.00m, 322.08MB read\nRequests/sec:  40149.75\nTransfer/sec:      5.36MB\n```\n\n#### Go 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.96ms    3.17ms 248.63ms   75.61%\n    Req/Sec    19.33k     4.01k   28.20k    59.12%\n  2303964 requests in 1.00m, 307.61MB read\nRequests/sec:  38364.06\nTransfer/sec:      5.12MB\n```\n\n#### Node 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.76ms    3.48ms  55.44ms   68.85%\n    Req/Sec    14.22k     2.88k   28.04k    83.54%\n  1699058 requests in 1.00m, 233.33MB read\n  Socket errors: connect 337, read 0, write 0, timeout 0\nRequests/sec:  28286.96\nTransfer/sec:      3.88MB\n```\n\n### ab\n\n#### 压测命令\n\n```sh\nab -n 1000000 -c 1000 -r http://127.0.0.1:60000/\n```\n\n#### 压测结果\n> 测试 `1000` 并发，一共 `100w` 请求。`QPS` 结果如下：\n\n> - 1 `Tokio` ：51825.13\n> - 2 `Hyperlane框架` ：51554.47\n> - 3 `Rocket框架` ：49621.02\n> - 4 `Go标准库` ：47915.20\n> - 5 `Gin框架` ：47081.05\n> - 6 `Node标准库` ：44763.11\n> - 7 `Rust标准库` ：31511.00\n\n#### hyperlane 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   19.397 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      107000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    51554.47 [#/sec] (mean)\nTime per request:       19.397 [ms] (mean)\nTime per request:       0.019 [ms] (mean, across all concurrent requests)\nTransfer rate:          5387.04 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9   9.1      8    1069\nProcessing:     0   10   4.7     10     289\nWaiting:        0    9   4.5      9     286\nTotal:          1   19  11.1     19    1085\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     22\n  75%     24\n  80%     25\n  90%     29\n  95%     33\n  98%     37\n  99%     41\n 100%   1085 (longest request)\n```\n\n#### Rust 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   31.735 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      88000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    31511.00 [#/sec] (mean)\nTime per request:       31.735 [ms] (mean)\nTime per request:       0.032 [ms] (mean, across all concurrent requests)\nTransfer rate:          2707.98 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0   22 167.7      0    7232\nProcessing:     0    9  45.2      4    5771\nWaiting:        0    9  45.2      4    5771\nTotal:          0   31 178.6      4    7441\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      5\n  75%      5\n  80%      6\n  90%      7\n  95%      8\n  98%    426\n  99%   1050\n 100%   7441 (longest request)\n```\n\n#### Tokio 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   19.296 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      88000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    51825.13 [#/sec] (mean)\nTime per request:       19.296 [ms] (mean)\nTime per request:       0.019 [ms] (mean, across all concurrent requests)\nTransfer rate:          4453.72 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  19.4      8    1091\nProcessing:     0   10   5.4      9     284\nWaiting:        0    9   5.2      8     284\nTotal:          0   19  20.6     18    1107\n\nPercentage of the requests served within a certain time (ms)\n  50%     18\n  66%     21\n  75%     23\n  80%     25\n  90%     29\n  95%     33\n  98%     38\n  99%     42\n 100%   1107 (longest request)\n```\n\n#### Rocket 框架\n\n```sh\nServer Software:        Rocket\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   20.153 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      247000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    49621.02 [#/sec] (mean)\nTime per request:       20.153 [ms] (mean)\nTime per request:       0.020 [ms] (mean, across all concurrent requests)\nTransfer rate:          11969.13 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  11.2      9    1094\nProcessing:     0   11   5.4     10     305\nWaiting:        0   10   5.2      9     305\nTotal:          0   20  13.3     19    1107\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     22\n  75%     25\n  80%     26\n  90%     30\n  95%     34\n  98%     39\n  99%     43\n 100%   1107 (longest request)\n```\n\n#### Gin 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   21.240 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      140000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    47081.05 [#/sec] (mean)\nTime per request:       21.240 [ms] (mean)\nTime per request:       0.021 [ms] (mean, across all concurrent requests)\nTransfer rate:          6436.86 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0   10  13.0      9    1095\nProcessing:     0   12   6.0     11     288\nWaiting:        0   11   5.8     10     286\nTotal:          1   21  15.1     20    1114\n\nPercentage of the requests served within a certain time (ms)\n  50%     20\n  66%     23\n  75%     26\n  80%     27\n  90%     32\n  95%     35\n  98%     40\n  99%     44\n 100%   1114 (longest request)\n```\n\n#### Go 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   20.870 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      149000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    47915.20 [#/sec] (mean)\nTime per request:       20.870 [ms] (mean)\nTime per request:       0.021 [ms] (mean, across all concurrent requests)\nTransfer rate:          6972.04 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  21.1      8    1103\nProcessing:     0   11   6.5     11     323\nWaiting:        0   10   6.3     10     322\nTotal:          1   21  22.6     19    1120\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     23\n  75%     25\n  80%     27\n  90%     31\n  95%     35\n  98%     41\n  99%     46\n 100%   1120 (longest request)\n```\n\n#### Node 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   22.340 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      114000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    44763.11 [#/sec] (mean)\nTime per request:       22.340 [ms] (mean)\nTime per request:       0.022 [ms] (mean, across all concurrent requests)\nTransfer rate:          4983.39 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    6  42.1      4    1086\nProcessing:     0   16  11.7     15     453\nWaiting:        0   13  11.2     12     452\nTotal:          1   22  43.7     20    1108\n\nPercentage of the requests served within a certain time (ms)\n  50%     20\n  66%     22\n  75%     23\n  80%     24\n  90%     27\n  95%     29\n  98%     33\n  99%     37\n 100%   1108 (longest request)\n```\n\n# 环境信息 (hyperlane/speed/env.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement)\n\n### 环境信息\n\n- 系统: `Ubuntu20.04.6 LTS`\n- CPU: `i9-14900KF`\n- 内存: `192GB 6400MT/S（实际运行 4000MT/S）`\n- 硬盘: `SKC3000D2048G * 2`\n- GPU: `AMD Radeon RX 6750 GRE 10GB`\n\n### 调优\n\n#### Linux 内核调优\n\n> 打开文件 `/etc/sysctl.conf`，增加以下设置。\n\n```sh\n#该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除\nnet.ipv4.tcp_max_tw_buckets = 20000\n#定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数\nnet.core.somaxconn = 65535\n#对于还未获得对方确认的连接请求，可保存在队列中的最大数目\nnet.ipv4.tcp_max_syn_backlog = 262144\n#在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目\nnet.core.netdev_max_backlog = 30000\n#此选项会导致处于NAT网络的客户端超时，建议为0。Linux从4.12内核开始移除了 tcp_tw_recycle 配置，如果报错\"No such file or directory\"请忽略\nnet.ipv4.tcp_tw_recycle = 0\n#系统所有进程一共可以打开的文件数量\nfs.file-max = 6815744\n#防火墙跟踪表的大小。注意：如果防火墙没开则会提示error: \"net.netfilter.nf_conntrack_max\" is an unknown key，忽略即可\nnet.netfilter.nf_conntrack_max = 2621440\nnet.ipv4.ip_local_port_range = 10240 65000\n```\n\n#### 控制台执行 `ulimit`\n\n```sh\nulimit -n 1024000\n```\n\n#### 打开文件数\n\n> 修改 `open files` 的数值重启后永久生效，修改配置文件：`/etc/security/limits.conf`。在这个文件后加上\n\n```sh\n* soft nofile 1024000\n* hard nofile 1024000\nroot soft nofile 1024000\nroot hard nofile 1024000\n```\n\n#### 运行命令\n\n```sh\nRUSTFLAGS=\"-C target-cpu=native -C link-arg=-fuse-ld=lld\" cargo run --release\n```\n\n# 火焰图 (hyperlane/speed/flamegraph.md)\n\n## plaintext\n\n## query db\n\n## sleep 100ms\n\n# 开启Keep Alive (hyperlane/speed/open-keep-alive.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement/tree/master/open-keep-alive)\n\n### wrk\n\n#### 压测命令\n\n```sh\nwrk -c360 -d60s http://127.0.0.1:60000/\n```\n\n#### 压测结果\n> 测试 `360` 并发，持续 `60s` 请求。`QPS` 结果如下：\n\n> - 1 `Tokio` ：340130.92\n> - 2 `Hyperlane框架` ：324323.71\n> - 3 `Rocket框架` ：298945.31\n> - 4 `Rust标准库` ：291218.96\n> - 5 `Gin框架` ：242570.16\n> - 6 `Go标准库` ：234178.93\n> - 7 `Node标准库` ：139412.13\n\n#### hyperlane 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.46ms    7.74ms 230.59ms   99.57%\n    Req/Sec   163.12k     9.54k  187.65k    67.75%\n  19476349 requests in 1.00m, 1.94GB read\nRequests/sec: 324323.71\nTransfer/sec:     33.10MB\n```\n\n#### Rust 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.64ms    8.62ms 238.68ms   99.48%\n    Req/Sec   146.49k    20.42k  190.38k    61.42%\n  17494266 requests in 1.00m, 1.52GB read\nRequests/sec: 291218.96\nTransfer/sec:     25.83MB\n```\n\n#### Tokio 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.22ms    5.96ms 230.76ms   99.76%\n    Req/Sec   171.05k     7.56k  192.19k    70.08%\n  20423683 requests in 1.00m, 1.77GB read\nRequests/sec: 340130.92\nTransfer/sec:     30.17MB\n```\n\n#### Rocket 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.42ms    6.67ms 228.04ms   99.67%\n    Req/Sec   150.37k     7.48k  172.42k    70.08%\n  17955815 requests in 1.00m, 4.00GB read\nRequests/sec: 298945.31\nTransfer/sec:     68.14MB\n```\n\n#### Gin 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.67ms    4.67ms 249.72ms   99.63%\n    Req/Sec   122.08k     4.39k  133.88k    69.58%\n  14577127 requests in 1.00m, 1.97GB read\nRequests/sec: 242570.16\nTransfer/sec:     33.54MB\n```\n\n#### Go 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.58ms    1.15ms  32.24ms   78.06%\n    Req/Sec   117.80k     4.43k  130.07k    70.67%\n  14064777 requests in 1.00m, 1.90GB read\nRequests/sec: 234178.93\nTransfer/sec:     32.38MB\n```\n\n#### Node 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.58ms  837.62us  45.39ms   89.66%\n    Req/Sec    70.11k     2.79k   74.29k    98.33%\n  8371733 requests in 1.00m, 1.16GB read\nRequests/sec: 139412.13\nTransfer/sec:     19.81MB\n```\n\n### ab\n\n#### 压测命令\n\n```sh\nab -n 1000000 -c 1000 -r -k http://127.0.0.1:60000/\n```\n\n#### 压测结果\n> 测试 `1000` 并发，一共 `100w` 请求。`QPS` 结果如下：\n\n> - 1 `Tokio` ：308596.26\n> - 2 `Hyperlane框架` ：307568.90\n> - 3 `Rocket框架` ：267931.52\n> - 4 `Rust标准库` ：260514.56\n> - 5 `Go标准库` ：226550.34\n> - 6 `Gin框架` ：224296.16\n> - 7 `Node标准库` ：85357.18\n\n#### hyperlane 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.251 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      107000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    307568.90 [#/sec] (mean)\nTime per request:       3.251 [ms] (mean)\nTime per request:       0.003 [ms] (mean, across all concurrent requests)\nTransfer rate:          32138.55 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.3      0      11\nProcessing:     0    3   1.4      3      13\nWaiting:        0    3   1.4      3      13\nTotal:          0    3   1.4      3      16\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      7\n  99%      7\n 100%     16 (longest request)\n```\n\n#### Rust 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.839 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      93000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    260514.56 [#/sec] (mean)\nTime per request:       3.839 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          23660.01 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0  21.2      0    1069\nProcessing:     0    3   5.5      3     419\nWaiting:        0    3   5.5      3     419\nTotal:          0    4  23.4      3    1286\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      8\n  99%      8\n 100%   1286 (longest request)\n```\n\n#### Tokio 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.240 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      93000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    308596.26 [#/sec] (mean)\nTime per request:       3.240 [ms] (mean)\nTime per request:       0.003 [ms] (mean, across all concurrent requests)\nTransfer rate:          28026.81 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.3      0      11\nProcessing:     0    3   1.3      3      16\nWaiting:        0    3   1.3      3      16\nTotal:          0    3   1.4      3      16\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      7\n  99%      7\n 100%     16 (longest request)\n```\n\n#### Rocket 框架\n\n```sh\nServer Software:        Rocket\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.732 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      271000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    267931.52 [#/sec] (mean)\nTime per request:       3.732 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          70907.66 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0      14\nProcessing:     0    4   1.4      4      17\nWaiting:        0    4   1.4      4      17\nTotal:          0    4   1.4      4      21\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      4\n  75%      5\n  80%      5\n  90%      6\n  95%      6\n  98%      7\n  99%      8\n 100%     21 (longest request)\n```\n\n#### Gin 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   4.458 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      145000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    224296.16 [#/sec] (mean)\nTime per request:       4.458 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          31760.69 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       7\nProcessing:     0    4   4.7      4     181\nWaiting:        0    4   4.7      4     181\nTotal:          0    4   4.8      4     184\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      5\n  75%      5\n  80%      6\n  90%      8\n  95%     10\n  98%     12\n  99%     13\n 100%    184 (longest request)\n```\n\n#### Go 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   4.414 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      154000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    226550.34 [#/sec] (mean)\nTime per request:       4.414 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          34071.05 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       7\nProcessing:     0    4   3.9      4     172\nWaiting:        0    4   3.9      4     172\nTotal:          0    4   4.0      4     176\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      4\n  75%      5\n  80%      5\n  90%      7\n  95%      8\n  98%      8\n  99%      9\n 100%    176 (longest request)\n```\n\n#### Node 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   11.715 seconds\nComplete requests:      1000000\nFailed requests:        811908\n   (Connect: 0, Receive: 14737, Length: 499810, Exceptions: 297361)\nKeep-Alive requests:    500200\nTotal transferred:      59523800 bytes\nHTML transferred:       6502600 bytes\nRequests per second:    85357.18 [#/sec] (mean)\nTime per request:       11.715 [ms] (mean)\nTime per request:       0.012 [ms] (mean, across all concurrent requests)\nTransfer rate:          4961.70 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    3  33.5      0    1082\nProcessing:     0    8   9.6      7     247\nWaiting:        0    7  10.5      3     247\nTotal:          0   12  35.3      9    1102\n\nPercentage of the requests served within a certain time (ms)\n  50%      9\n  66%     15\n  75%     17\n  80%     18\n  90%     21\n  95%     23\n  98%     27\n  99%     30\n 100%   1102 (longest request)\n```\n\n# 性能测试 (hyperlane/speed/README.md)\n\n# 响应时间测试 (hyperlane/speed/request-time.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/test-request)\n> 测试累计请求 `1w` 次\n\n| 场景      | http-request 平均耗时 | hyper 平均耗时 |\n| --------- | --------------------- | -------------- |\n| TCP 失败  | 39us                  | 78us           |\n| hyperlane | 100us                 | 150us          |\n| 阿帕奇    | 300us                 | 2500us         |\n\n# Content-Type (hyperlane/type/content-type.md)\n\n> `hyperlane` 框架的 `Content-Type` 内部 `value` 定义参考 [Content-Type](https://docs.rs/http-constant/latest/src/http_constant/content_type_value/const.rs.html)。\n\n# Context (hyperlane/type/context.md)\n\n> `hyperlane` 框架的 `Context` 作为中间件和路由处理函数的唯一的参数类型，其内部保存了上下文数据，具体类型定义如下：\n\n```rust\n/// Represents the internal state of the application context.\n///\n/// This structure holds all the data associated with a single request-response cycle,\n/// including the stream, request, response, and any custom attributes.\n#[derive(Clone, Data, Default, CustomDebug, DisplayDebug)]\npub(crate) struct ContextInner {\n    /// A flag indicating whether the request handling has been aborted.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    aborted: bool,\n    /// A flag indicating whether the connection has been closed.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    closed: bool,\n    /// The underlying network stream for the connection.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    stream: OptionArcRwLockStream,\n    /// The incoming HTTP request.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    request: Request,\n    /// The outgoing HTTP response.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    response: Response,\n    /// Parameters extracted from the route path.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    route_params: RouteParams,\n    /// A collection of custom attributes for sharing data within the request lifecycle.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    attributes: HashMapArcAnySendSync,\n}\n\n/// The main application context, providing thread-safe access to request and response data.\n///\n/// This is a wrapper around `ContextInner` that uses an `Arc>` to allow\n/// for shared, mutable access across asynchronous tasks.\n#[derive(Clone, Default, Getter, CustomDebug, DisplayDebug)]\npub struct Context(#[get(pub(super))] pub(super) ArcRwLock);\n```\n\n# Cookie (hyperlane/type/cookie.md)\n\n> `hyperlane` 框架的 `Cookie` 相关类型定义如下\n\n```rust\n/// Builder for constructing HTTP cookies.\n///\n/// Provides methods to set various cookie attributes like expiration,\n/// domain, path, and security flags before building the final cookie string.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct CookieBuilder {\n    /// Cookie name identifier.\n    pub(super) name: CookieKey,\n    /// Cookie value content.\n    pub(super) value: CookieValue,\n    /// Optional expiration date/time string.\n    pub(super) expires: OptionCookieExpires,\n    /// Optional maximum age in seconds.\n    pub(super) max_age: OptionCookieMaxAge,\n    /// Optional domain scope for the cookie.\n    pub(super) domain: OptionCookieDomain,\n    /// Optional path scope for the cookie.\n    pub(super) path: OptionCookiePath,\n    /// Flag indicating secure (HTTPS-only) transmission.\n    pub(super) secure: bool,\n    /// Flag preventing JavaScript access.\n    pub(super) http_only: bool,\n    /// Optional SameSite policy setting.\n    pub(super) same_site: OptionCookieSameSite,\n}\n\n/// Parser for HTTP Cookie headers.\n///\n/// Provides functionality to parse Cookie header strings into key-value pairs.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct Cookie;\n```\n\n# FileExtension (hyperlane/type/file-extension.md)\n\n> `hyperlane` 框架的 `FileExtension` 内部具体类型定义参考 [FileExtension](https://docs.rs/http-type/latest/http_type/enum.FileExtension.html)。\n\n# HttpStatus (hyperlane/type/http-status.md)\n\n> `hyperlane` 框架的 `HttpStatus` 内部具体类型定义如下\n\n```rust\n/// Standard HTTP status codes.\n///\n/// Includes informational, success, redirection, client and server error codes.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpStatus {\n    /// HTTP 100 Continue\n    Continue,\n    /// HTTP 101 Switching Protocols\n    SwitchingProtocols,\n    /// HTTP 102 Processing (WebDAV)\n    Processing,\n    /// HTTP 103 Early Hints\n    EarlyHints,\n    /// HTTP 200 OK\n    Ok,\n    /// HTTP 201 Created\n    Created,\n    /// HTTP 202 Accepted\n    Accepted,\n    /// HTTP 203 Non-Authoritative Information\n    NonAuthoritativeInformation,\n    /// HTTP 204 No Content\n    NoContent,\n    /// HTTP 205 Reset Content\n    ResetContent,\n    /// HTTP 206 Partial Content\n    PartialContent,\n    /// HTTP 207 Multi-Status (WebDAV)\n    MultiStatus,\n    /// HTTP 208 Already Reported (WebDAV)\n    AlreadyReported,\n    /// HTTP 226 IM Used\n    IMUsed,\n    /// HTTP 300 Multiple Choices\n    MultipleChoices,\n    /// HTTP 301 Moved Permanently\n    MovedPermanently,\n    /// HTTP 302 Found\n    Found,\n    /// HTTP 303 See Other\n    SeeOther,\n    /// HTTP 304 Not Modified\n    NotModified,\n    /// HTTP 305 Use Proxy\n    UseProxy,\n    /// HTTP 307 Temporary Redirect\n    TemporaryRedirect,\n    /// HTTP 308 Permanent Redirect\n    PermanentRedirect,\n    /// HTTP 400 Bad Request\n    BadRequest,\n    /// HTTP 401 Unauthorized\n    Unauthorized,\n    /// HTTP 402 Payment Required\n    PaymentRequired,\n    /// HTTP 403 Forbidden\n    Forbidden,\n    /// HTTP 404 Not Found\n    NotFound,\n    /// HTTP 405 Method Not Allowed\n    MethodNotAllowed,\n    /// HTTP 406 Not Acceptable\n    NotAcceptable,\n    /// HTTP 407 Proxy Authentication Required\n    ProxyAuthenticationRequired,\n    /// HTTP 408 Request Timeout\n    RequestTimeout,\n    /// HTTP 409 Conflict\n    Conflict,\n    /// HTTP 410 Gone\n    Gone,\n    /// HTTP 411 Length Required\n    LengthRequired,\n    /// HTTP 412 Precondition Failed\n    PreconditionFailed,\n    /// HTTP 413 Payload Too Large\n    PayloadTooLarge,\n    /// HTTP 414 URI Too Long\n    URITooLong,\n    /// HTTP 415 Unsupported Media Type\n    UnsupportedMediaType,\n    /// HTTP 416 Range Not Satisfiable\n    RangeNotSatisfiable,\n    /// HTTP 417 Expectation Failed\n    ExpectationFailed,\n    /// HTTP 418 I'm a teapot\n    ImATeapot,\n    /// HTTP 421 Misdirected Request\n    MisdirectedRequest,\n    /// HTTP 422 Unprocessable Entity (WebDAV)\n    UnprocessableEntity,\n    /// HTTP 423 Locked (WebDAV)\n    Locked,\n    /// HTTP 424 Failed Dependency (WebDAV)\n    FailedDependency,\n    /// HTTP 425 Too Early\n    TooEarly,\n    /// HTTP 426 Upgrade Required\n    UpgradeRequired,\n    /// HTTP 428 Precondition Required\n    PreconditionRequired,\n    /// HTTP 429 Too Many Requests\n    TooManyRequests,\n    /// HTTP 431 Request Header Fields Too Large\n    RequestHeaderFieldsTooLarge,\n    /// HTTP 451 Unavailable For Legal Reasons\n    UnavailableForLegalReasons,\n    /// HTTP 500 Internal Server Error\n    InternalServerError,\n    /// HTTP 501 Not Implemented\n    NotImplemented,\n    /// HTTP 502 Bad Gateway\n    BadGateway,\n    /// HTTP 503 Service Unavailable\n    ServiceUnavailable,\n    /// HTTP 504 Gateway Timeout\n    GatewayTimeout,\n    /// HTTP 505 HTTP Version Not Supported\n    HTTPVersionNotSupported,\n    /// HTTP 506 Variant Also Negotiates\n    VariantAlsoNegotiates,\n    /// HTTP 507 Insufficient Storage (WebDAV)\n    InsufficientStorage,\n    /// HTTP 508 Loop Detected (WebDAV)\n    LoopDetected,\n    /// HTTP 510 Not Extended\n    NotExtended,\n    /// HTTP 511 Network Authentication Required\n    NetworkAuthenticationRequired,\n    /// HTTP Unknown status code\n    Unknown,\n}\n```\n\n# HttpVersion (hyperlane/type/http-version.md)\n\n> `hyperlane` 框架的 `UpgradeType` 内部具体类型定义如下\n\n```rust\n/// Standard HTTP status codes.\n///\n/// Includes informational, success, redirection, client and server error codes.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpStatus {\n    /// HTTP 100 Continue\n    Continue,\n    /// HTTP 101 Switching Protocols\n    SwitchingProtocols,\n    /// HTTP 102 Processing (WebDAV)\n    Processing,\n    /// HTTP 103 Early Hints\n    EarlyHints,\n    /// HTTP 200 OK\n    Ok,\n    /// HTTP 201 Created\n    Created,\n    /// HTTP 202 Accepted\n    Accepted,\n    /// HTTP 203 Non-Authoritative Information\n    NonAuthoritativeInformation,\n    /// HTTP 204 No Content\n    NoContent,\n    /// HTTP 205 Reset Content\n    ResetContent,\n    /// HTTP 206 Partial Content\n    PartialContent,\n    /// HTTP 207 Multi-Status (WebDAV)\n    MultiStatus,\n    /// HTTP 208 Already Reported (WebDAV)\n    AlreadyReported,\n    /// HTTP 226 IM Used\n    IMUsed,\n    /// HTTP 300 Multiple Choices\n    MultipleChoices,\n    /// HTTP 301 Moved Permanently\n    MovedPermanently,\n    /// HTTP 302 Found\n    Found,\n    /// HTTP 303 See Other\n    SeeOther,\n    /// HTTP 304 Not Modified\n    NotModified,\n    /// HTTP 305 Use Proxy\n    UseProxy,\n    /// HTTP 307 Temporary Redirect\n    TemporaryRedirect,\n    /// HTTP 308 Permanent Redirect\n    PermanentRedirect,\n    /// HTTP 400 Bad Request\n    BadRequest,\n    /// HTTP 401 Unauthorized\n    Unauthorized,\n    /// HTTP 402 Payment Required\n    PaymentRequired,\n    /// HTTP 403 Forbidden\n    Forbidden,\n    /// HTTP 404 Not Found\n    NotFound,\n    /// HTTP 405 Method Not Allowed\n    MethodNotAllowed,\n    /// HTTP 406 Not Acceptable\n    NotAcceptable,\n    /// HTTP 407 Proxy Authentication Required\n    ProxyAuthenticationRequired,\n    /// HTTP 408 Request Timeout\n    RequestTimeout,\n    /// HTTP 409 Conflict\n    Conflict,\n    /// HTTP 410 Gone\n    Gone,\n    /// HTTP 411 Length Required\n    LengthRequired,\n    /// HTTP 412 Precondition Failed\n    PreconditionFailed,\n    /// HTTP 413 Payload Too Large\n    PayloadTooLarge,\n    /// HTTP 414 URI Too Long\n    URITooLong,\n    /// HTTP 415 Unsupported Media Type\n    UnsupportedMediaType,\n    /// HTTP 416 Range Not Satisfiable\n    RangeNotSatisfiable,\n    /// HTTP 417 Expectation Failed\n    ExpectationFailed,\n    /// HTTP 418 I'm a teapot\n    ImATeapot,\n    /// HTTP 421 Misdirected Request\n    MisdirectedRequest,\n    /// HTTP 422 Unprocessable Entity (WebDAV)\n    UnprocessableEntity,\n    /// HTTP 423 Locked (WebDAV)\n    Locked,\n    /// HTTP 424 Failed Dependency (WebDAV)\n    FailedDependency,\n    /// HTTP 425 Too Early\n    TooEarly,\n    /// HTTP 426 Upgrade Required\n    UpgradeRequired,\n    /// HTTP 428 Precondition Required\n    PreconditionRequired,\n    /// HTTP 429 Too Many Requests\n    TooManyRequests,\n    /// HTTP 431 Request Header Fields Too Large\n    RequestHeaderFieldsTooLarge,\n    /// HTTP 451 Unavailable For Legal Reasons\n    UnavailableForLegalReasons,\n    /// HTTP 500 Internal Server Error\n    InternalServerError,\n    /// HTTP 501 Not Implemented\n    NotImplemented,\n    /// HTTP 502 Bad Gateway\n    BadGateway,\n    /// HTTP 503 Service Unavailable\n    ServiceUnavailable,\n    /// HTTP 504 Gateway Timeout\n    GatewayTimeout,\n    /// HTTP 505 HTTP Version Not Supported\n    HTTPVersionNotSupported,\n    /// HTTP 506 Variant Also Negotiates\n    VariantAlsoNegotiates,\n    /// HTTP 507 Insufficient Storage (WebDAV)\n    InsufficientStorage,\n    /// HTTP 508 Loop Detected (WebDAV)\n    LoopDetected,\n    /// HTTP 510 Not Extended\n    NotExtended,\n    /// HTTP 511 Network Authentication Required\n    NetworkAuthenticationRequired,\n    /// HTTP Unknown status code\n    Unknown,\n}\n```\n\n# Method (hyperlane/type/method.md)\n\n> `hyperlane` 框架的 `Method` 内部具体类型定义如下\n\n```rust\n/// Defines the `Method` enum, representing HTTP request methods.\n///\n/// This enum provides a comprehensive list of standard HTTP methods,\n/// such as GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT, and TRACE.\n/// It also includes an `UNKNOWN` variant for unrecognized methods.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Method {\n    /// Represents the HTTP `GET` method.\n    GET,\n    /// Represents the HTTP `POST` method.\n    POST,\n    /// Represents the HTTP `PUT` method.\n    PUT,\n    /// Represents the HTTP `DELETE` method.\n    DELETE,\n    /// Represents the HTTP `PATCH` method.\n    PATCH,\n    /// Represents the HTTP `HEAD` method.\n    HEAD,\n    /// Represents the HTTP `OPTIONS` method.\n    OPTIONS,\n    /// Represents the HTTP `CONNECT` method.\n    CONNECT,\n    /// Represents the HTTP `TRACE` method.\n    TRACE,\n    /// Unknown\n    UNKNOWN(String),\n}\n```\n\n# Protocol (hyperlane/type/protocol.md)\n\n> `hyperlane` 框架的 `Protocol` 内部具体类型定义如下\n\n```rust\n/// Represents HTTP-related protocols.\n///\n/// This enum defines the different protocols that can be used in HTTP communication.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Protocol {\n    /// Represents the HTTP protocol.\n    ///\n    /// This is the standard protocol for unencrypted communication over the web.\n    HTTP,\n    /// Represents the HTTPS protocol.\n    ///\n    /// This is the secure version of HTTP, using encryption for communication.\n    HTTPS,\n    /// Represents an unknown or custom protocol.\n    ///\n    /// This variant is used for protocols that are not explicitly defined as HTTP or HTTPS,\n    /// or when the protocol string is not recognized.\n    Unknown(String),\n}\n```\n\n# 类型定义 (hyperlane/type/README.md)\n\n# Request (hyperlane/type/request.md)\n\n> `hyperlane` 框架的 `Request` 内部具体类型定义如下\n\n```rust\n/// An alias for `Method`, representing the HTTP request method.\npub type RequestMethod = Method;\n/// An alias for `String`, representing the host part of an HTTP request.\npub type RequestHost = String;\n/// An alias for `HttpVersion`, representing the HTTP version.\npub type RequestVersion = HttpVersion;\n/// An alias for `String`, representing the path portion of the request URL.\npub type RequestPath = String;\n/// An alias for `String`, representing the key type for request query parameters.\npub type RequestQuerysKey = String;\n/// An alias for `String`, representing the value type for request query parameters.\npub type RequestQuerysValue = String;\n/// An alias for `Option`, representing an optional query parameter value.\npub type OptionRequestQuerysValue = Option;\n/// An alias for `HashMapXxHash3_64`, representing all query parameters parsed from the request URL.\npub type RequestQuerys = HashMapXxHash3_64;\n/// An alias for `Vec`, representing the raw binary body of the request.\npub type RequestBody = Vec;\n/// An alias for `String`, representing the request body as a UTF-8 encoded string.\npub type RequestBodyString = String;\n/// An alias for `String`, representing the key type for request headers.\npub type RequestHeadersKey = String;\n/// An alias for `String`, representing a single value for an HTTP request header.\npub type RequestHeadersValueItem = String;\n/// An alias for `Option`, representing an optional header value item.\npub type OptionRequestHeadersValueItem = Option;\n/// An alias for `VecDeque`, representing a collection of values for a single HTTP request header.\npub type RequestHeadersValue = VecDeque;\n/// An alias for `Option`, representing an optional collection of header values.\npub type OptionRequestHeadersValue = Option;\n/// An alias for `HashMapXxHash3_64`, representing all headers sent with the HTTP request.\npub type RequestHeaders = HashMapXxHash3_64;\n/// An alias for `Result`, representing the result type returned from a request reader handler.\npub type RequestReaderHandleResult = Result;\n/// An alias for `RwLockReadGuard`, representing a read guard for a `Request` wrapped in a `RwLock`.\npub type RwLockReadGuardRequest= RwLockReadGuard;\n/// An alias for `RwLockWriteGuard`, representing a write guard for a `Request` wrapped in a `RwLock`.\npub type RwLockWriteGuardRequest= RwLockWriteGuard;\n\n/// HTTP request representation.\n///\n/// Contains all components of an HTTP request.\n#[derive(Debug, Clone, PartialEq, Eq, Getter, DisplayDebug)]\npub struct Request {\n    /// HTTP request method.\n    pub(super) method: RequestMethod,\n    /// Request host.\n    pub(super) host: RequestHost,\n    /// HTTP protocol version.\n    pub(super) version: RequestVersion,\n    /// Request path.\n    pub(super) path: RequestPath,\n    /// URL query parameters.\n    pub(super) querys: RequestQuerys,\n    /// HTTP headers collection.\n    pub(super) headers: RequestHeaders,\n    /// Request body content.\n    pub(super) body: RequestBody,\n}\n```\n\n# Response (hyperlane/type/response.md)\n\n> `hyperlane` 框架的 `Response` 内部具体类型定义如下\n\n```rust\n/// An alias for `Vec`, representing the binary body of the HTTP response.\npub type ResponseBody = Vec;\n/// An alias for `String`, representing the body of the HTTP response as a UTF-8 string.\npub type ResponseBodyString = String;\n/// An alias for `String`, representing the key type used in HTTP response headers.\npub type ResponseHeadersKey = String;\n/// An alias for `String`, representing a single value string for an HTTP response header.\npub type ResponseHeadersValueItem = String;\n/// An alias for `Option`, representing an optional value string for an HTTP response header.\npub type OptionResponseHeadersValueItem = Option;\n/// An alias for `VecDeque`, representing a collection of values for a single HTTP response header.\npub type ResponseHeadersValue = VecDeque;\n/// An alias for `HashMapXxHash3_64`, representing a map of HTTP response headers.\npub type ResponseHeaders = HashMapXxHash3_64;\n/// An alias for `HttpVersion`, representing the HTTP version of the response.\npub type ResponseVersion = HttpVersion;\n/// An alias for `usize`, representing the numeric status code of the HTTP response.\npub type ResponseStatusCode = usize;\n/// An alias for `String`, representing the reason phrase associated with the HTTP status code.\npub type ResponseReasonPhrase = String;\n/// An alias for `Result`, representing the result type returned after writing an HTTP response.\npub type ResponseResult = Result;\n/// An alias for `Vec`, representing the full serialized binary content of the HTTP response.\npub type ResponseData = Vec;\n/// An alias for `String`, representing the full serialized content of the HTTP response as a UTF-8 string.\npub type ResponseDataString = String;\n/// An alias for `RwLockReadGuard`, representing a read guard to a shared `Response` value protected by `RwLock`.\npub type RwLockReadGuardResponse= RwLockReadGuard;\n/// An alias for `RwLockWriteGuard`, representing a write guard to a shared `Response` value protected by `RwLock`.\npub type RwLockWriteGuardResponse= RwLockWriteGuard;\n/// An alias for `Option`, representing an optional collection of values for a response header.\npub type OptionResponseHeadersValue = Option;\n\n/// Represents a parsed HTTP response.\n#[derive(Debug, Clone, PartialEq, Eq, Data, DisplayDebug)]\npub struct Response {\n    /// The HTTP version used in the response.\n    pub(super) version: ResponseVersion,\n    /// The HTTP status code.\n    pub(super) status_code: ResponseStatusCode,\n    /// The reason phrase associated with the status code.\n    #[set(skip)]\n    pub(super) reason_phrase: ResponseReasonPhrase,\n    /// The response headers as key-value pairs.\n    #[set(skip)]\n    pub(super) headers: ResponseHeaders,\n    /// The binary body content of the response.\n    #[set(skip)]\n    pub(super) body: ResponseBody,\n}\n```\n\n# ServerConfig (hyperlane/type/server-config.md)\n\n> `hyperlane` 框架的 `ServerConfig` 相关类型定义如下\n\n```rust\n/// Represents the server configuration.\n///\n/// This structure holds all the settings for the HTTP and WebSocket server,\n/// including network parameters and buffer sizes.\n#[derive(Clone, Data, CustomDebug, DisplayDebug, PartialEq, Eq, Deserialize, Serialize)]\npub struct ServerConfig {\n    /// The host address the server will bind to.\n    pub(super) host: String,\n    /// The port number the server will listen on.\n    pub(super) port: usize,\n    /// The buffer size for WebSocket connections.\n    pub(super) ws_buffer: usize,\n    /// The buffer size for HTTP connections.\n    pub(super) http_buffer: usize,\n    /// The TCP_NODELAY option for sockets.\n    pub(super) nodelay: OptionBool,\n    /// The SO_LINGER option for sockets.\n    pub(super) linger: OptionDuration,\n    /// The IP_TTL option for sockets.\n    pub(super) ttl: OptionU32,\n}\n```\n\n# Stream (hyperlane/type/stream.md)\n\n> `hyperlane` 框架的 `Stream` 内部具体类型定义如下\n\n```rust\n/// A thread-safe reference-counted `TcpStream`.\npub type ArcStream = Arc;\n/// An optional thread-safe reference-counted `TcpStream`.\npub type OptionArcTcpStream = Option;\n/// An optional thread-safe read-write locked `TcpStream` wrapper.\npub type OptionArcRwLockStream = Option;\n/// A read guard for a `RwLock`.\npub type RwLockReadGuardTcpStream= RwLockReadGuard;\n/// A write guard for a `RwLock`.\npub type RwLockWriteGuardTcpStream= RwLockWriteGuard;\n/// A thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type ArcRwLockWriteGuardTcpStream= Arc>;\n/// An optional thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type OptionArcRwLockWriteGuardTcpStream= Option>;\n/// A thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type ArcMutexGuardTcpStream= Arc>;\n/// An optional thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type OptionArcMutexGuardTcpStream= Option>;\n/// A socket host represented by an IP address.\npub type SocketHost = IpAddr;\n/// A socket port number.\npub type SocketPort = u16;\n/// An optional socket host.\npub type OptionSocketHost = Option;\n/// An optional socket port.\npub type OptionSocketPort = Option;\n/// An optional full socket address.\npub type OptionSocketAddr = Option;\n\n/// Thread-safe TCP stream wrapper.\n///\n/// Provides shared access to a TcpStream using Arc and RwLock.\n///\n/// # Fields\n///\n/// - `Arc>` - The protected TCP stream.\n#[derive(Clone, Debug, Getter)]\npub struct ArcRwLockStream(#[get(pub(super))] pub(super) ArcRwLock);\n```\n\n# UpgradeType (hyperlane/type/upgrade-type.md)\n\n> `hyperlane` 框架的 `UpgradeType` 内部具体类型定义如下\n\n```rust\n/// Represents different upgrade types.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum UpgradeType {\n    /// Represents an upgrade to the WebSocket protocol.\n    WebSocket,\n    /// Represents an upgrade to HTTP/2 cleartext (h2c).\n    H2c,\n    /// Represents a TLS upgrade, which is rare and experimental. It includes the specific TLS protocol string.\n    Tls(String),\n    /// Represents other custom or unknown upgrade protocols, including the protocol string.\n    Unknown(String),\n}\n```\n\n# 客户端地址 (hyperlane/usage-introduction/addr.md)\n\n> `hyperlane` 框架封装了获取客户端地址的方法\n\n### 使用\n\n#### 获取 `SocketAddr`\n\n```rust\nctx.get_socket_addr().await;\n```\n\n#### 获取 `SocketAddr` 如果失败使用默认值\n\n```rust\nctx.get_socket_addr_or_default().await;\n```\n\n#### 获取 `SocketAddr` 字符串\n\n```rust\nctx.get_socket_addr_string().await;\n```\n\n#### 获取 `SocketAddr` 字符串，如果失败使用默认值\n\n```rust\nctx.get_socket_addr_or_default_string().await;\n```\n\n#### 获取 `SocketHost`\n\n```rust\nctx.get_socket_host().await;\n```\n\n#### 获取 `SocketPort`\n\n```rust\nctx.get_socket_port().await;\n```\n\n# 异步运行时 (hyperlane/usage-introduction/async.md)\n\n> `hyperlane` 框架在 `v3.0.0` 之前不对异步做任何处理，如果需要异步操作，可以引入第三方库\n\n> `hyperlane` 框架在 `v3.0.0` 之后内置异步机制\n\n> `hyperlane` 框架在 `v4.0.0` 之前支持同步和异步中间件/路由共存。\n> `hyperlane` 框架在 `v4.0.0` 之后为了性能移除了同步中间件和路由（ `all in async` ），在开启 `keep-alive` 情况下带来了效果 `QPS 10w+`的提升\n\n### 框架本身异步使用\n\n```rust\nserver.route(\"/\", move |_| async move {\n    println!(\"hello\");\n}).await;\n```\n\n### 下面是使用 `tokio` 库的异步运行时示例代码\n\n#### v4.0.0 之后版本的示例代码\n\n```rust\nuse hyperlane::*;\nuse runtime::Runtime;\n\nasync fn some_async_task() -> i32 {\n    println!(\"Starting the task...\");\n    // 模拟异步操作\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n    println!(\"Task completed!\");\n    0\n}\n\n#[tokio::main]\nasync fn main() {\n    let server: Server = Server::new().await;\n    server.route(\"/\", move |ctx: Context| {\n        some_async_task().await;\n    });\n    server.listen();\n}\n```\n\n### 异步闭包捕获外部变量\n\n#### 使用 async move\n\n```rust\nlet test_string: String = \"test\".to_owned();\nserver.route(\"/test/async\", move |_| {\n    let tmp_test_string = test_string.clone();\n    async move {\n        println!(\"{:?}\", tmp_test_string);\n    }\n}).await;\n```\n\n#### 使用 future_fn!\n\n```rust\nlet test_string: String = \"test\".to_owned();\nlet func = future_fn!(test_string, |_| {\n    println!(\"async_move => {:?}\", test_string);\n});\nserver.route(\"/test/async\", func).await;\n```\n\n# 属性 (hyperlane/usage-introduction/attribute.md)\n\n> `hyperlane` 框架支持临时上下文属性以 `key-value` 形式存储，生命周期贯穿一个完整的请求和响应。\n> 存储的 `value` 支持实现了`Any + Send + Sync + Clone` 的 `trait` 的类型。\n\n### 设置某个临时上下文属性\n\n```rust\nctx.set_attribute(\"key\", &\"value\").await;\n```\n\n### 获取某个临时上下文属性\n\n```rust\nlet value: Option= ctx.get_attribute::(\"key\").await;\n```\n\n### 移除某个临时上下文属性\n\n```rust\nctx.remove_attribute(\"key\").await;\n```\n\n### 清空临时上下文属性\n\n```rust\nctx.clear_attribute().await;\n```\n\n### 额外示例\n\n#### 设置闭包\n> 闭包需要实现 `Send + Sync` 的 `trait`，否则无法跨线程调用。\n> 不推荐 `value` 存储函数，这里只是提供一个示例\n\n```rust\nlet func: &(dyn Fn(&str) + Send + Sync) = &|msg: &str| {\n    println_success!(\"hyperlane: \", msg);\n};\nctx.set_attribute(\"println_hyperlane\", func).await;\nlet println_hyperlane = ctx\n    .get_attribute::(\"println_hyperlane\")\n    .await\n    .unwrap();\nprintln_hyperlane(\"test\");\n```\n\n# 连接管理 (hyperlane/usage-introduction/connection.md)\n\n> `hyperlane` 框架提供了完整的连接状态管理功能，包括连接的中止、关闭状态控制，以及 `Keep-Alive` 连接支持。\n\n## 连接状态管理\n\n### 获取连接状态\n\n```rust\n// 是否中止生命周期中的后续流程\nlet is_aborted: bool = ctx.get_aborted().await;\n// 连接是否断开\nlet is_closed: bool = ctx.get_closed().await;\n// 是否停止（等价于is_aborted || is_closed）\nlet is_terminated: bool = ctx.is_terminated().await;\n```\n\n### 设置连接状态\n\n```rust\nctx.set_aborted(true).await;\nctx.set_closed(true).await;\n```\n\n### 快捷方法\n\n```rust\n// 中止连接\nctx.aborted().await;\n// 关闭连接\nctx.closed().await;\n// 取消中止\nctx.cancel_aborted().await;\n// 取消关闭\nctx.cancel_closed().await;\n```\n\n## Keep-Alive 连接\n\n### 检查是否启用 Keep-Alive\n\n```rust\nlet keep_alive: bool = ctx.is_enable_keep_alive().await;\n```\n\n## 基本使用示例\n\n### 连接状态检查\n\n```rust\nif ctx.get_closed().await {\n    return;\n}\n```\n\n### 长连接处理\n\n```rust\nwhile !ctx.get_closed().await && !ctx.get_aborted().await {\n    let _ = ctx.http_from_stream(8192).await;\n    if !ctx.is_enable_keep_alive().await {\n        ctx.closed().await;\n        break;\n    }\n}\n```\n\n# Cookie 操作 (hyperlane/usage-introduction/cookie.md)\n\n> `hyperlane` 框架提供了完整的 Cookie 处理功能，支持请求和响应中的 Cookie 操作。\n\n## 请求 Cookie 操作\n\n### 获取所有请求 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_request_cookies().await;\n```\n\n### 获取特定请求 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_request_cookie(\"session_id\").await;\n```\n\n> Cookie 名称通常是自定义的，所以使用字符串字面量。但对于标准的请求头操作，建议使用框架常量。\n\n## 响应 Cookie 操作\n\n### 获取所有响应 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_response_cookies().await;\n```\n\n### 获取特定响应 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_response_cookie(\"user_token\").await;\n```\n\n### 设置响应 Cookie\n\n#### 使用字符串直接设置\n\n```rust\nctx.set_response_header(SET_COOKIE, \"session_id=abc123; Path=/; HttpOnly\").await;\n```\n\n#### 使用 CookieBuilder 构建\n\n```rust\nlet cookie_value: String = CookieBuilder::new(\"session_id\", \"abc123\")\n    .path(\"/\")\n    .http_only()\n    .build();\nctx.set_response_header(SET_COOKIE, cookie_value).await;\n```\n\n### 设置多个 Cookie\n\n```rust\nlet session_cookie: String = CookieBuilder::new(\"session_id\", \"abc123\")\n    .path(\"/\")\n    .http_only()\n    .secure()\n    .max_age(3600)\n    .build();\n\nlet pref_cookie: String = CookieBuilder::new(\"user_pref\", \"dark_mode\")\n    .path(\"/\")\n    .max_age(86400)\n    .build();\n\nctx.set_response_header(SET_COOKIE, session_cookie).await\n   .set_response_header(SET_COOKIE, pref_cookie).await;\n```\n\n## CookieBuilder 方法\n\n### 基本构建\n\n```rust\nlet cookie: String = CookieBuilder::new(\"name\", \"value\").build();\n```\n\n### 设置属性\n\n```rust\nlet cookie: String = CookieBuilder::new(\"session\", \"token123\")\n    .expires(\"Wed, 21 Oct 2025 07:28:00 GMT\")\n    .max_age(3600)\n    .domain(\"example.com\")\n    .path(\"/\")\n    .secure()\n    .http_only()\n    .same_site(\"Strict\")\n    .build();\n```\n\n### 解析现有 Cookie\n\n```rust\nlet cookie_builder: CookieBuilder = CookieBuilder::parse(\"name=value; Path=/; HttpOnly\");\nlet rebuilt_cookie: String = cookie_builder.build();\n```\n\n## 基本使用示例\n\n### 会话管理\n\n```rust\nlet session_cookie: String = CookieBuilder::new(\"session\", \"token123\")\n    .http_only()\n    .secure()\n    .max_age(3600)\n    .build();\nctx.set_response_header(SET_COOKIE, session_cookie).await;\n\nif let Some(session) = ctx.get_request_cookie(\"session\").await {}\n```\n\n### 清除 Cookie\n\n```rust\nlet clear_cookie: String = CookieBuilder::new(\"session\", \"\")\n    .max_age(0)\n    .build();\nctx.set_response_header(SET_COOKIE, clear_cookie).await;\n```\n\n# 多服务 (hyperlane/usage-introduction/multi-server.md)\n\n> `hyperlane` 框架支持多服务模式，仅需创建多个 `server` 实例并进行监听即可\n\n### 多服务\n> 启动多个服务，监听多个端口\n\n```rust\nlet app1 = spawn(async move {\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(80).await;\n    let server: Server = Server::from(config).await;\n    server.route(\"/\", |ctx: Context| async move {\n        let _ = ctx.send_status_body(200, \"hello world\").await;\n    }).await;\n    let _ = server.listen().await;\n});\nlet app2 = spawn(async move {\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(81).await;\n    let server: Server = Server::from(config).await;\n    server.route(\"/\", |ctx: Context| async move {\n        let _ = ctx.send_status_body(200, \"hello world\").await;\n    }).await;\n    let _ = server.listen().await;\n});\nlet _ = tokio::join!(app1, app2);\n```\n\n# 恐慌 (hyperlane/usage-introduction/panic.md)\n\n> `hyperlane` 框架对于用户线程 `panic` 会进行捕获并写入错误日志，`hook` 支持发送响应\n> 需注意对于一个请求如果在任一中间件环节触发 `panic` 当前请求的后续注册的路由处理函数将不会执行。\n\n### 代码示例\n\n```rust\nasync fn default_panic_hook(ctx: Context) {\nlet request_string: String = ctx.get_request_string().await;\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    let mut response_body: String = error.to_string();\n    let content_type: String = ContentType::format_content_type_with_charset(TEXT_PLAIN, UTF8);\n    if ctx.get_response().await != Response::default() {\n        response_body.push_str(BR);\n        response_body.push_str(&request_string);\n        response_body.push_str(BR);\n    }\n    eprintln!(\"{}\", response_body);\n    let _ = Write::flush(&mut io::stderr());\n    let _ = ctx\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(500)\n        .await\n        .clear_response_headers()\n        .await\n        .set_response_header(SERVER, HYPERLANE)\n        .await\n        .set_response_header(CONTENT_TYPE, content_type)\n        .await\n        .set_response_body(response_body)\n        .await\n        .send()\n        .await;\n}\n\n// 省略 server 创建\nserver.panic_hook(default_panic_hook);\n```\n\n# 使用介绍 (hyperlane/usage-introduction/README.md)\n\n# 请求 (hyperlane/usage-introduction/request.md)\n\n> `hyperlane` 框架对 `ctx` 额外封装了子字段的方法，可以直接调用大部分子字段的 `get` 和 `set` 方法名称。\n> 例如：调用 `request` 上的 `get_method` 方法，\n> 一般需要从 `ctx` 解出 `request`，再调用`request.get_method()`，\n> 可以简化成直接调用 `ctx.get_request_method().await`。\n\n> **调用规律**\n\n> - `request` 仅支持`get`，不支持`set`，框架保证请求信息不会被意外修改。\n> - 原 `request` 的 `get` 方法的 `get` 名称后加 `request` 名称，中间使用\\_拼接。\n\n## 获取请求信息\n\n#### 获取 `request`\n\n```rust\nlet request: Request = ctx.get_request().await;\n```\n\n#### 获取 `method`\n\n```rust\nlet method: RequestMethod = ctx.get_request_method().await;\n```\n\n#### 获取 `host`\n\n```rust\nlet host: RequestHost = ctx.get_request_host().await;\n```\n\n#### 获取 `path`\n\n```rust\nlet path: RequestPath = ctx.get_request_path().await;\n```\n\n#### 获取 `version`\n\n```rust\nlet version: RequestVersion = ctx.get_request_version().await;\n```\n\n#### 获取 `querys`\n\n```rust\nlet querys: RequestQuerys = ctx.get_request_querys().await;\n```\n\n#### 获取特定查询参数\n\n```rust\nlet query_value: OptionRequestQuerysValue = ctx.get_request_query(\"key\").await;\n```\n\n#### 获取 `header`\n\n> `hyperlane` 框架请求头的 `key` 是经过全小写处理，建议使用框架定义的常量。\n\n```rust\nlet header: OptionRequestHeadersValue = ctx.get_request_header(CONTENT_TYPE).await;\n```\n\n#### 获取 `headers`\n\n```rust\nlet headers: RequestHeaders = ctx.get_request_headers().await;\n```\n\n#### 获取请求头的第一个值\n\n```rust\nlet header_value: OptionRequestHeadersValueItem = ctx.get_request_header_front(CONTENT_TYPE).await;\n```\n\n#### 获取请求头的最后一个值\n\n```rust\nlet header_value: OptionRequestHeadersValueItem = ctx.get_request_header_back(ACCEPT).await;\n```\n\n#### 获取请求头值的数量\n\n```rust\nlet header_count: usize = ctx.get_request_header_len(ACCEPT_ENCODING).await;\n```\n\n#### 获取所有请求头值的总数量\n\n```rust\nlet total_values: usize = ctx.get_request_headers_values_length().await;\n```\n\n#### 获取请求头的数量\n\n```rust\nlet headers_count: usize = ctx.get_request_headers_length().await;\n```\n\n#### 检查是否存在特定请求头\n\n```rust\nlet has_header: bool = ctx.has_request_header(CONTENT_TYPE).await;\n```\n\n#### 检查请求头是否包含特定值\n\n```rust\nlet has_value: bool = ctx.has_request_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 获取请求体\n\n```rust\nlet body: RequestBody = ctx.get_request_body().await;\n```\n\n#### 获取 `string` 格式的请求体\n\n```rust\nlet body: String = ctx.get_request_body_string().await;\n```\n\n#### 获取 `json` 格式的请求体\n\n```rust\nlet body: T = ctx.get_request_body_json::().await;\n```\n\n#### 获取请求升级类型\n\n```rust\nlet upgrade_type: UpgradeType = ctx.get_request_upgrade_type().await;\n```\n\n## 执行闭包操作\n\n#### 使用请求执行异步闭包\n\n```rust\nlet result = ctx.with_request(|request| async move {\n    request.get_method()\n}).await;\n```\n\n## 转字符串\n\n#### 通过 `to_string`\n> 将获得完整的原始结构体字符串结构。\n\n```rust\nctx.get_request().await.to_string();\n```\n\n#### 通过 `get_string`\n> 将获得简化的结构体字符串结构。\n\n```rust\nctx.get_request().await.get_string();\n```\n\n#### 通过 `ctx.get_request_string`\n\n```rust\nlet request_string: String = ctx.get_request_string().await;\n```\n\n# 响应 (hyperlane/usage-introduction/response.md)\n\n> `hyperlane` 框架没有发送响应前通过 `ctx` 中 `get_response` 获取的只是响应的初始化实例，里面其实没有数据，\n> 只有当用户发送响应时才会构建出完整 `http` 响应，此后再次 `get_response` 才能获取到响应内容。\n\n> `hyperlane` 框架对 `ctx` 额外封装了子字段的方法，可以直接调用大部分子字段的 `get` 和 `set` 方法名称，\n> 例如：调用 `response` 上的 `get_status_code` 方法。\n\n> **调用规律**\n\n> - 原 `response` 的 `get` 方法的 `get` 名称后加 `response` 名称，中间使用\\_拼接。\n> - 原 `response` 的 `set` 方法的 `set` 名称后加 `response` 名称，中间使用\\_拼接。\n\n### 获取响应\n\n#### 获取 `response`\n\n```rust\nlet response: Response = ctx.get_response().await;\n```\n\n#### 获取响应版本\n\n```rust\nlet version: ResponseVersion = ctx.get_response_version().await;\n```\n\n#### 获取响应状态码\n\n```rust\nlet status_code: ResponseStatusCode = ctx.get_response_status_code().await;\n```\n\n#### 获取响应原因短语\n\n```rust\nlet reason_phrase: ResponseReasonPhrase = ctx.get_response_reason_phrase().await;\n```\n\n#### 获取完整响应头\n\n```rust\nlet headers: ResponseHeaders = ctx.get_response_headers().await;\n```\n\n#### 获取某个响应头\n\n```rust\nlet value: OptionResponseHeadersValue = ctx.get_response_header(CONTENT_TYPE).await;\n```\n\n#### 获取响应头的第一个值\n\n```rust\nlet header_value: OptionResponseHeadersValueItem = ctx.get_response_header_front(CONTENT_TYPE).await;\n```\n\n#### 获取响应头的最后一个值\n\n```rust\nlet header_value: OptionResponseHeadersValueItem = ctx.get_response_header_back(CONTENT_TYPE).await;\n```\n\n#### 检查是否存在特定响应头\n\n```rust\nlet has_header: bool = ctx.get_response_has_header(CONTENT_TYPE).await;\n```\n\n#### 检查响应头是否包含特定值\n\n```rust\nlet has_value: bool = ctx.has_response_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 获取响应头数量\n\n```rust\nlet headers_count: usize = ctx.get_response_headers_length().await;\n```\n\n#### 获取响应头值的数量\n\n```rust\nlet header_count: usize = ctx.get_response_header_len(CONTENT_TYPE).await;\n```\n\n#### 获取所有响应头值的总数量\n\n```rust\nlet total_values: usize = ctx.get_response_headers_values_length().await;\n```\n\n#### 获取响应体\n\n```rust\nlet body: ResponseBody = ctx.get_response_body().await;\n```\n\n#### 获取 `string` 格式的响应体\n\n```rust\nlet body: String = ctx.get_response_body_string().await;\n```\n\n#### 获取 `json` 格式的响应体\n\n```rust\nlet body: T = ctx.get_response_body_json::().await;\n```\n\n#### 获取响应 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_response_cookies().await;\n```\n\n#### 获取特定响应 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_response_cookie(\"session_id\").await;\n```\n\n### 设置响应\n\n#### 设置 `response`\n\n```rust\nctx.set_response(Response::default()).await;\n```\n\n#### 设置响应版本\n\n> 特别注意的是需要设置响应版本，框架默认的版本是空字符串，客户端处理会异常。\n\n```rust\nctx.set_response_version(HttpVersion::HTTP1_1).await;\n```\n\n#### 设置响应状态码\n\n```rust\nctx.set_response_status_code(200).await;\n```\n\n#### 设置响应原因短语\n\n```rust\nctx.set_response_reason_phrase(\"OK\").await;\n```\n\n#### 设置响应体\n\n```rust\nctx.set_response_body(\"Hello World\").await;\n```\n\n#### 设置（添加）响应头\n\n> `hyperlane` 框架对响应头的 `key` 是不做大小写处理的，建议使用框架定义的常量。\n\n```rust\nctx.add_response_header(SERVER, \"hyperlane\").await;\n```\n\n#### 设置（替换）响应头\n\n```rust\nctx.set_response_header(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 移除响应头\n\n```rust\nctx.remove_response_header(CONTENT_TYPE).await;\n```\n\n#### 移除响应头的特定值\n\n```rust\nctx.remove_response_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 清空所有响应头\n\n```rust\nctx.clear_response_headers().await;\n```\n\n### 执行闭包操作\n\n#### 使用响应执行异步闭包\n\n```rust\nlet result = ctx.with_response(|response| async move {\n    response.get_status_code()\n}).await;\n```\n\n### 转字符串\n\n#### 通过 `to_string`\n> 将获得完整的原始结构体字符串结构。\n\n```rust\nctx.get_response().await.to_string();\n```\n\n#### 通过 `get_string`\n> 将获得简化的结构体字符串结构。\n\n```rust\nctx.get_response().await.get_string();\n```\n\n#### 通过 `ctx.get_response_string`\n\n```rust\nlet response_string: String = ctx.get_response_string().await;\n```\n\n# 路由 (hyperlane/usage-introduction/route.md)\n\n## 静态路由\n\n> `hyperlane` 框架支持静态路由（如果重复注册相同的静态路由，框架会抛出异常，程序退出运行），使用方法如下：\n\n### 注册\n\n```rust\nserver.route(\"/test\", |ctx: Context| {}).await;\n```\n\n## 动态路由\n\n> `hyperlane` 框架支持动态路由（如果重复注册相同模式的动态路由，框架会抛出异常，程序退出运行），具体使用方法如下：\n\n### 注册\n> 动态路由使用 `{}` 包裹，有两种写法\n\n> - `{key}`内直接些字符串，则将匹配的 `value` 存入 `key` 对应的 `value` 中。\n> - `{key:regex}` 则将正则表达式匹配的 `value` 存入 `key` 对应的 `value` 中，如果路径的最后是正则动态路由，则匹配后续所有路径，例如 `/test/{file:^.*$}` 匹配 `/test/a/b/c/d` 会成功，`file` 的 `value` 为 `a/b/c/d`。如果路径的最后不是正则动态路由，则仅使用正则匹配当前段的路由，例如 `/test/{file:^.*$}/b` 匹配 `/test/a/b` 会成功，`file` 的 `value` 为 `a`。\n\n### 朴素动态路由\n\n```rust\nserver.route(\"/test/{text}\", |ctx: Context| {}).await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.route(\"/test/{number:\\\\d+}\", |ctx: Context| {}).await;\n```\n\n### 获取全部动态路由参数\n\n```rust\nctx.get_route_params().await;\n```\n\n### 获取某个动态路由参数\n\n```rust\nctx.get_route_param(\"text\").await;\n```\n\n# 发送响应 (hyperlane/usage-introduction/send.md)\n\n> `hyperlane` 框架提供了多种响应发送方法，支持完整 HTTP 响应发送、仅响应体发送，以及连接管理。\n\n## 发送完整 HTTP 响应\n\n### send 方法\n> 发送完整的 HTTP 响应，发送后 TCP 连接保留。\n\n```rust\nlet send_result: ResponseResult = ctx.send().await;\n```\n\n### send_once 方法\n> 发送完整的 HTTP 响应，发送后立即关闭 TCP 连接。\n\n```rust\nlet send_result: ResponseResult = ctx.send_once().await;\n```\n\n## 发送响应体\n\n### send_body 方法\n> 仅发送响应体内容，发送后 TCP 连接保留。适用于流式响应和 WebSocket。\n\n```rust\nlet send_result: ResponseResult = ctx.send_body().await;\n```\n\n### send_once_body 方法\n> 仅发送响应体内容，发送后立即关闭 TCP 连接。\n\n```rust\nlet send_result: ResponseResult = ctx.send_once_body().await;\n```\n\n## 刷新缓冲区\n\n### flush 方法\n> 强制刷新网络缓冲区，确保数据立即发送。\n\n```rust\nlet flush_result: ResponseResult = ctx.flush().await;\n```\n\n## 基本使用示例\n\n### 使用框架常量\n\n```rust\nctx.set_response_header(CONTENT_TYPE, APPLICATION_JSON).await\n   .set_response_body(r#\"{\"status\": \"ok\"}\"#).await\n   .send().await;\n```\n\n### 流式发送\n\n```rust\nctx.set_response_header(CONTENT_TYPE, TEXT_PLAIN).await;\nfor i in 1..=3 {\n    let _ = ctx.set_response_body(format!(\"chunk {}\\n\", i)).await.send_body().await;\n    ctx.flush().await;\n}\n```\n\n### WebSocket 发送\n\n```rust\nctx.upgrade_to_ws().await;\nlet _ = ctx.set_response_body(\"websocket message\").await.send_body().await;\n```\n\n# SSE (hyperlane/usage-introduction/sse.md)\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/sse)\n\n> `hyperlane` 框架支持 `sse`，服务端主动推送，下面是每隔 `1s` 完成一次推送，并在 `10` 次后关闭连接。\n\n> `sse` 规范: 服务器使用 `\"content-type: text/event-stream\"` 表示响应是一个 `sse` 事件流。\n> 接着使用 `\"data\"` 字段来发送事件数据，每个事件以 `\"data:\"` 开头，后面跟着事件的内容和一个空行。\n> 客户端收到这样的响应后，就可以解析其中的事件数据并进行相应的处理。\n> 如果开发者非首次响应尝试调用 `send` 会正常发送响应，但是会包含整个 `http` 协议内容，所以对于 `sse`，\n> 非首次响应请统一使用 `send_body` 方法。\n\n### 服务端代码\n\n```rust\nuse crate::{tokio::time::sleep, *};\nuse std::time::Duration;\n\npub async fn root(ctx: Context) {\n    let _ = ctx\n        .set_response_header(CONTENT_TYPE, TEXT_EVENT_STREAM)\n        .await\n        .set_response_status_code(200)\n        .await\n        .send()\n        .await\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await;\n    for i in 0..10 {\n        let _ = ctx\n            .set_response_body(format!(\"data:{}{}\", i, HTTP_DOUBLE_BR))\n            .await\n            .send_body()\n            .await;\n        sleep(Duration::from_secs(1)).await;\n    }\n    let _ = ctx.closed().await;\n}\n```\n\n### 客户端代码\n\n## 客户端代码\n\n#### 断线重连\n\n```js\nconst eventSource = new EventSource('http://127.0.0.1:60000');\n\neventSource.onopen = function (event) {\n  console.log('Connection opened.');\n};\n\neventSource.onmessage = function (event) {\n  const eventData = JSON.parse(event.data);\n  console.log('Received event data:', eventData);\n};\n\neventSource.onerror = function (event) {\n  if (event.eventPhase === EventSource.CLOSED) {\n    console.log('Connection was closed.');\n  } else {\n    console.error('Error occurred:', event);\n  }\n};\n```\n\n#### 取消断线重连\n\n```js\nconst eventSource = new EventSource('http://127.0.0.1:60000');\n\neventSource.onopen = function (event) {\n  console.log('Connection opened.');\n};\n\neventSource.onmessage = function (event) {\n  const eventData = JSON.parse(event.data);\n  console.log('Received event data:', eventData);\n};\n\neventSource.onerror = function (event) {\n  if (event.eventPhase === EventSource.CLOSED) {\n    console.log('Connection was closed.');\n    // 关闭连接，防止自动重连\n    eventSource.close();\n  } else {\n    console.error('Error occurred:', event);\n  }\n};\n```\n\n# 流 (hyperlane/usage-introduction/stream.md)\n\n> `hyperlane` 框架接收请求和发送响应均依赖 `stream`，类型是 [`ArcRwLockStream`](../type/stream.md) 需要注意框架提供的 `stream` 仅可读，使用方式如下：\n\n### 获取 `stream`\n\n```rust\nlet stream_lock: ArcRwLockStream = ctx.get_stream().await.clone().unwrap();\n```\n\n### 获取客户端地址\n\n> 完整接口参阅[官方文档](./addr.md)，此处只介绍通过 `stream` 解析使用。\n\n```rust\nlet socket_addr: String = ctx\n    .get_stream()\n    .await\n    .unwrap()\n    .read()\n    .await\n    .peer_addr()\n    .and_then(|host| Ok(host.to_string()))\n    .unwrap_or(\"Unknown\".to_owned());\n```\n\n### 关闭连接\n> 此方法会关闭 `TCP` 连接，不会终止当前的生命周期（当前声明周期结束不会进入下一次生命周期循环，需要重新建立 `TCP` 连接），当前声明周期内的代码正常执行，但是不会再发送响应。\n\n```rust\nctx.closed().await;\n```\n\n# WebSocket (hyperlane/usage-introduction/websocket.md)\n\n> `hyperlane` 框架支持 `websocket` 协议，服务端自动处理协议升级，支持请求中间件，路由处理，响应中间件。\n\n### 服务端代码\n\n> `hyperlane` 框架发送 `websocket` 响应使用`send_body`，与 `sse` 相同。\n> 由于 `websocket`协议基于`http`，所以可以像使用 `http` 一样处理请求。\n> 如果开发者尝试调用 `send` 会导致客户端处理错误，\n> （服务端发送响应前需要处理成符合`websocket` 规范的响应，客户端才能正确解析）。所以对于 `websocket`，\n> 请统一使用 `send_body` 方法。\n\n#### 单点发送\n\n```rust\npub async fn handle(ctx: Context) {\n    let request_body: Vec= ctx.get_request_body().await;\n    let _ = ctx.set_response_body(request_body).await.send_body().await;\n}\n```\n\n#### 广播发送\n\n> 需要阻塞住当前处理函数，将后续所有请求在处理函数中处理。\n> 这里使用 `tokio` 的 `select` 来处理多个请求，使用 [`hyperlane-broadcast`](../../hyperlane-broadcast/README.md) 来实现广播。\n> 需要特别注意，如果 `server` 没有配置 [`disable_ws_hook`](../config/ws-handle.md) ，群发消息必须要求客户端连接后主动向服务端发送一条消息（空消息即可），否则不会接收到广播的信息，\n> 因为服务端在框架内部会先完成握手，然后等待读取一次客户端请求，才会执行到用户代码。\n> 如果配置了则连接后即可接收到广播的信息。\n\n> 完整代码参考 [`GroupChat`](../project/group-chat.md) 。\n\n### 客户端代码\n\n```js\nconst ws = new WebSocket('ws://localhost:60000/websocket');\n\nws.onopen = () => {\n  console.log('WebSocket opened');\n  setInterval(() => {\n    ws.send(`Now time: ${new Date().toISOString()}`);\n  }, 1000);\n};\n\nws.onmessage = (event) => {\n  console.log('Receive: ', event.data);\n};\n\nws.onerror = (error) => {\n  console.error('WebSocket error: ', error);\n};\n\nws.onclose = () => {\n  console.log('WebSocket closed');\n};\n```\n\n# 框架内置工具 (hyperlane/utils/inner-utils.md)\n\n## http-constant\n\n> `hyperlane` 框架使用了 `http-constant` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-constant/README.md)。\n\n## http-compress\n\n> `hyperlane` 框架使用了 `http-compress` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-compress/README.md)。\n\n## http-type\n\n> `hyperlane` 框架使用了 `http-type` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-type/README.md)。\n\n# 工具使用 (hyperlane/utils/README.md)\n\n# 推荐工具 (hyperlane/utils/recommend-utils.md)\n\n## hyperlane-utils\n\n> `hyperlane` 框架推荐使用 `hyperlane-utils` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-utils/README.md)。\n\n## lombok\n\n> `hyperlane` 框架推荐使用 `lombok` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../lombok-macros/README.md)。\n\n## clonelicious\n\n> `hyperlane` 框架推荐使用 `clonelicious` 库，内部提供变量捕获和克隆（需额外安装和导入），\n> 使用参考 [官方文档](../../clonelicious/README.md)。\n\n## future-fn\n\n> `hyperlane` 框架推荐使用 `future-fn` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../future-fn/README.md)。\n\n## std-macro-extensions\n\n> `hyperlane` 框架推荐使用 `std-macro-extensions` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../std-macro-extensions/README.md)。\n\n## color-output\n\n> `hyperlane` 框架推荐使用 `color-output` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../color-output/README.md)。\n\n## bin-encode-decode\n\n> `hyperlane` 框架推荐使用 `bin-encode-decode` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../bin-encode-decode/README.md)。\n\n## file-operation\n\n> `hyperlane` 框架推荐使用 `file-operation` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../file-operation/README.md)。\n\n## compare-version\n\n> `hyperlane` 框架推荐使用 `compare-version` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../compare-version/README.md)。\n\n## hyperlane-log\n\n> `hyperlane` 框架使用 `hyperlane-log` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-log/README.md)。\n\n## hyperlane-time\n\n> `hyperlane` 框架推荐使用 `hyperlane-time` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-time/README.md)。\n\n## recoverable-spawn\n\n> `hyperlane` 框架推荐使用 `recoverable-spawn` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../recoverable-spawn/README.md)。\n\n## recoverable-thread-pool\n\n> `hyperlane` 框架推荐使用 `recoverable-thread-pool` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../recoverable-thread-pool/README.md)。\n\n## http-request\n\n> `hyperlane` 框架推荐使用 `http-request` 库，支持 `http` 和 `https`（需额外安装和导入），\n> 使用参考 [官方文档](../../http-request/README.md)。\n\n## hyperlane-broadcast\n\n> `hyperlane` 框架推荐使用 `hyperlane-broadcast` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-broadcast/README.md)。\n\n## hyperlane-plugin-websocket\n\n> `hyperlane` 框架推荐使用 `hyperlane-plugin-websocket` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-plugin-websocket/README.md)。\n\n## urlencoding\n\n> `hyperlane` 框架推荐使用 `urlencoding` 库（需额外安装和导入），可以实现 `url` 编解码。\n\n## server-manager\n\n> `hyperlane` 框架推荐使用 `server-manager` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../server-manager/README.md)。\n\n## chunkify\n\n> `hyperlane` 框架推荐使用 `chunkify` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../chunkify/README.md)。\n\n## china_identification_card\n\n> `hyperlane` 框架推荐使用 `china_identification_card` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../china-identification-card/README.md)。\n\n## utoipa\n\n> `hyperlane` 框架推荐使用 `utoipa` 库实现 `openapi`，下面是一段简单的示例代码\n\n```rust\nuse hyperlane::*;\nuse serde::Serialize;\nuse serde_json;\nuse utoipa::{OpenApi, ToSchema};\nuse utoipa_rapidoc::RapiDoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\n#[derive(Serialize, ToSchema)]\nstruct User {\n    name: String,\n    age: usize,\n}\n\n#[derive(OpenApi)]\n#[openapi(\n    components(schemas(User)),\n    info(title = \"Hyperlane\", version = \"1.0.0\"),\n    paths(index, user, openapi_json, swagger)\n)]\nstruct ApiDoc;\n\nasync fn request_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(200).await;\n}\n\n#[utoipa::path(\n    get,\n    path = \"/openapi.json\",\n    responses(\n        (status = 200, description = \"Openapi docs\", body = String)\n    )\n)]\nasync fn openapi_json(ctx: Context) {\n    ctx.set_response_body(ApiDoc::openapi().to_json().unwrap())\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/{file}\",\n    responses(\n        (status = 200, description = \"Openapi json\", body = String)\n    )\n)]\nasync fn swagger(ctx: Context) {\n    SwaggerUi::new(\"/{file}\").url(\"/openapi.json\", ApiDoc::openapi());\n    let res: String = RapiDoc::with_openapi(\"/openapi.json\", ApiDoc::openapi()).to_html();\n    ctx.set_response_header(CONTENT_TYPE, TEXT_HTML)\n        .await\n        .set_response_body(res)\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/\",\n    responses(\n        (status = 302, description = \"Redirect to index.html\")\n    )\n)]\nasync fn index(ctx: Context) {\n    ctx.set_response_header(LOCATION, \"/index.html\")\n        .await\n        .set_response_body(vec![])\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/user/{name}\",\n    responses(\n        (status = 200, description = \"User\", body = User)\n    )\n)]\nasync fn user(ctx: Context) {\n    let name: String = ctx.get_route_param(\"name\").await.unwrap();\n    let user: User = User { name, age: 0 };\n    ctx.set_response_body(serde_json::to_vec(&user).unwrap())\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    let server: Server = Server::new().await;\n    server.request_middleware(request_middleware).await;\n    server.route(\"/\", index).await;\n    server.route(\"/user/{name}\", user).await;\n    server.route(\"/openapi.json\", openapi_json).await;\n    server.route(\"/{file}\", swagger).await;\n    server.run().await.unwrap();\n}\n```\n\n# lombok属性宏 (lombok-macros/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/lombok-macros)\n\n[API 文档](https://docs.rs/lombok-macros/latest/lombok_macros/)\n\n> 一个提供类似 Lombok 功能的 Rust 过程宏集合。可自动生成带有字段级可见性控制的 getter/setter、可跳过字段的自定义 Debug 实现以及 Display trait 的实现。支持结构体、枚举、泛型和生命周期。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add lombok-macros\n```\n\n## 使用\n\n### DisplayDebug\n\n#### 代码\n\n```rust\n#![allow(warnings)]\n\nuse lombok_macros::*;\nuse std::fmt::Debug;\n\n#[derive(Data, Debug, Clone, DisplayDebugFormat)]\nstruct LombokTest{\n    #[get(pub(crate))]\n    #[set(pub(crate))]\n    list: Vec,\n    #[get(pub(crate))]\n    opt_value: Option,\n    #[get_mut(pub(crate))]\n    #[set(private)]\n    name: String,\n}\n\n#[derive(CustomDebug)]\nstruct User {\n    name: String,\n    #[debug(skip)]\n    password: String,\n    email: String,\n}\n\n#[derive(Data, Debug, Clone)]\nstruct TupleStruct(\n    #[get(pub)] String,\n    #[set(pub)] i32,\n    #[get(pub)]\n    #[set(pub)]\n    bool,\n);\n\n#[derive(CustomDebug)]\nenum Response {\n    Success {\n        data: String,\n    },\n    Error {\n        message: String,\n        #[debug(skip)]\n        internal_code: u32,\n    },\n}\n\nfn main() {\n    let mut data: LombokTest= LombokTest {\n        list: Vec::new(),\n        opt_value: None,\n        name: \"test\".to_string(),\n    };\n    let list: Vec= vec![\"hello\".to_string(), \"world\".to_string()];\n    data.set_list(list.clone());\n    assert_eq!(*data.get_list(), list);\n    let opt_value: &Option= data.get_opt_value();\n    assert_eq!(*opt_value, None);\n    let name_mut: &mut String = data.get_mut_name();\n    *name_mut = \"updated\".to_string();\n    assert!(!data.to_string().is_empty());\n    let mut tuple_data: TupleStruct = TupleStruct(\"hello\".to_string(), 42, true);\n    let field0: &String = tuple_data.get_0();\n    assert_eq!(field0, \"hello\");\n    tuple_data.set_1(100);\n    let field2: &bool = tuple_data.get_2();\n    assert_eq!(*field2, true);\n    tuple_data.set_2(false);\n    let user: User = User {\n        name: \"Alice\".to_string(),\n        password: \"secret123\".to_string(),\n        email: \"alice@example.com\".to_string(),\n    };\n    let user_debug: String = format!(\"{:?}\", user);\n    assert!(user_debug.contains(\"Alice\"));\n    assert!(user_debug.contains(\"alice@example.com\"));\n    assert!(!user_debug.contains(\"secret123\"));\n    let success: Response = Response::Success {\n        data: \"Operation completed\".to_string(),\n    };\n    let success_debug: String = format!(\"{:?}\", success);\n    assert!(success_debug.contains(\"Operation completed\"));\n    let error: Response = Response::Error {\n        message: \"Something went wrong\".to_string(),\n        internal_code: 500,\n    };\n    let error_debug: String = format!(\"{:?}\", error);\n    assert!(error_debug.contains(\"Something went wrong\"));\n    assert!(!error_debug.contains(\"500\"));\n}\n```\n\n#### 宏展开结果\n\n```rust\n#![feature(prelude_import)]\n#![allow(warnings)]\n#[prelude_import]\nuse std::prelude::rust_2024::*;\n#[macro_use]\nextern crate std;\nuse lombok_macros::*;\nuse std::fmt::Debug;\nstruct LombokTest{\n    #[get(pub(crate))]\n    #[set(pub(crate))]\n    list: Vec,\n    #[get(pub(crate))]\n    opt_value: Option,\n    #[get_mut(pub(crate))]\n    #[set(private)]\n    name: String,\n}\nimplLombokTest{\n    pub(crate) fn get_list(&self) -> &Vec{\n        &self.list\n    }\n    pub(crate) fn set_list(&mut self, val: Vec) -> &mut Self {\n        self.list = val;\n        self\n    }\n    pub fn get_mut_list(&mut self) -> &mut Vec{\n        &mut self.list\n    }\n    pub(crate) fn get_opt_value(&self) -> &Option{\n        &self.opt_value\n    }\n    pub fn get_mut_opt_value(&mut self) -> &mut Option{\n        &mut self.opt_value\n    }\n    pub fn set_opt_value(&mut self, val: Option) -> &mut Self {\n        self.opt_value = val;\n        self\n    }\n    pub(crate) fn get_mut_name(&mut self) -> &mut String {\n        &mut self.name\n    }\n    fn set_name(&mut self, val: String) -> &mut Self {\n        self.name = val;\n        self\n    }\n    pub fn get_name(&self) -> &String {\n        &self.name\n    }\n}\n#[automatically_derived]\nimpl::core::fmt::Debug\nfor LombokTest{\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_struct_field3_finish(\n            f,\n            \"LombokTest\",\n            \"list\",\n            &self.list,\n            \"opt_value\",\n            &self.opt_value,\n            \"name\",\n            &&self.name,\n        )\n    }\n}\n#[automatically_derived]\nimpl::core::clone::Clone\nfor LombokTest{\n    #[inline]\n    fn clone(&self) -> LombokTest{\n        LombokTest {\n            list: ::core::clone::Clone::clone(&self.list),\n            opt_value: ::core::clone::Clone::clone(&self.opt_value),\n            name: ::core::clone::Clone::clone(&self.name),\n        }\n    }\n}\nimplstd::fmt::Display for LombokTest{\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        f.write_fmt(format_args!(\"{0:#?}\", self))\n    }\n}\nstruct User {\n    name: String,\n    #[debug(skip)]\n    password: String,\n    email: String,\n}\nimpl std::fmt::Debug for User {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        f.debug_struct(\"User\")\n            .field(\"name\", &self.name)\n            .field(\"email\", &self.email)\n            .finish()\n    }\n}\nstruct TupleStruct(#[get(pub)] String, #[set(pub)] i32, #[get(pub)] #[set(pub)] bool);\nimpl TupleStruct {\n    pub fn get_0(&self) -> &String {\n        &self.0\n    }\n    pub fn get_mut_0(&mut self) -> &mut String {\n        &mut self.0\n    }\n    pub fn set_0(&mut self, val: String) -> &mut Self {\n        self.0 = val;\n        self\n    }\n    pub fn set_1(&mut self, val: i32) -> &mut Self {\n        self.1 = val;\n        self\n    }\n    pub fn get_1(&self) -> &i32 {\n        &self.1\n    }\n    pub fn get_mut_1(&mut self) -> &mut i32 {\n        &mut self.1\n    }\n    pub fn get_2(&self) -> &bool {\n        &self.2\n    }\n    pub fn set_2(&mut self, val: bool) -> &mut Self {\n        self.2 = val;\n        self\n    }\n    pub fn get_mut_2(&mut self) -> &mut bool {\n        &mut self.2\n    }\n}\n#[automatically_derived]\nimpl ::core::fmt::Debug for TupleStruct {\n    #[inline]\n    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n        ::core::fmt::Formatter::debug_tuple_field3_finish(\n            f,\n            \"TupleStruct\",\n            &self.0,\n            &self.1,\n            &&self.2,\n        )\n    }\n}\n#[automatically_derived]\nimpl ::core::clone::Clone for TupleStruct {\n    #[inline]\n    fn clone(&self) -> TupleStruct {\n        TupleStruct(\n            ::core::clone::Clone::clone(&self.0),\n            ::core::clone::Clone::clone(&self.1),\n            ::core::clone::Clone::clone(&self.2),\n        )\n    }\n}\nenum Response {\n    Success { data: String },\n    Error { message: String, #[debug(skip)] internal_code: u32 },\n}\nimpl std::fmt::Debug for Response {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        match self {\n            Response::Success { data } => {\n                f.debug_struct(\"Success\").field(\"data\", data).finish()\n            }\n            Response::Error { message, internal_code } => {\n                f.debug_struct(\"Error\").field(\"message\", message).finish()\n            }\n        }\n    }\n}\nfn main() {\n    let mut data: LombokTest= LombokTest {\n        list: Vec::new(),\n        opt_value: None,\n        name: \"test\".to_string(),\n    };\n    let list: Vec= ::into_vec(\n        #[rustc_box]\n        ::alloc::boxed::Box::new([\"hello\".to_string(), \"world\".to_string()]),\n    );\n    data.set_list(list.clone());\n    match (&*data.get_list(), &list) {\n        (left_val, right_val) => {\n            if !(*left_val == *right_val) {\n                let kind = ::core::panicking::AssertKind::Eq;\n                ::core::panicking::assert_failed(\n                    kind,\n                    &*left_val,\n                    &*right_val,\n                    ::core::option::Option::None,\n                );\n            }\n        }\n    };\n    let opt_value: &Option= data.get_opt_value();\n    match (&*opt_value, &None) {\n        (left_val, right_val) => {\n            if !(*left_val == *right_val) {\n                let kind = ::core::panicking::AssertKind::Eq;\n                ::core::panicking::assert_failed(\n                    kind,\n                    &*left_val,\n                    &*right_val,\n                    ::core::option::Option::None,\n                );\n            }\n        }\n    };\n    let name_mut: &mut String = data.get_mut_name();\n    *name_mut = \"updated\".to_string();\n    if !!data.to_string().is_empty() {\n        ::core::panicking::panic(\"assertion failed: !data.to_string().is_empty()\")\n    }\n    let mut tuple_data: TupleStruct = TupleStruct(\"hello\".to_string(), 42, true);\n    let field0: &String = tuple_data.get_0();\n    match (&field0, &\"hello\") {\n        (left_val, right_val) => {\n            if !(*left_val == *right_val) {\n                let kind = ::core::panicking::AssertKind::Eq;\n                ::core::panicking::assert_failed(\n                    kind,\n                    &*left_val,\n                    &*right_val,\n                    ::core::option::Option::None,\n                );\n            }\n        }\n    };\n    tuple_data.set_1(100);\n    let field2: &bool = tuple_data.get_2();\n    match (&*field2, &true) {\n        (left_val, right_val) => {\n            if !(*left_val == *right_val) {\n                let kind = ::core::panicking::AssertKind::Eq;\n                ::core::panicking::assert_failed(\n                    kind,\n                    &*left_val,\n                    &*right_val,\n                    ::core::option::Option::None,\n                );\n            }\n        }\n    };\n    tuple_data.set_2(false);\n    let user: User = User {\n        name: \"Alice\".to_string(),\n        password: \"secret123\".to_string(),\n        email: \"alice@example.com\".to_string(),\n    };\n    let user_debug: String = ::alloc::__export::must_use({\n        let res = ::alloc::fmt::format(format_args!(\"{0:?}\", user));\n        res\n    });\n    if !user_debug.contains(\"Alice\") {\n        ::core::panicking::panic(\"assertion failed: user_debug.contains(\\\"Alice\\\")\")\n    }\n    if !user_debug.contains(\"alice@example.com\") {\n        ::core::panicking::panic(\n            \"assertion failed: user_debug.contains(\\\"alice@example.com\\\")\",\n        )\n    }\n    if !!user_debug.contains(\"secret123\") {\n        ::core::panicking::panic(\"assertion failed: !user_debug.contains(\\\"secret123\\\")\")\n    }\n    let success: Response = Response::Success {\n        data: \"Operation completed\".to_string(),\n    };\n    let success_debug: String = ::alloc::__export::must_use({\n        let res = ::alloc::fmt::format(format_args!(\"{0:?}\", success));\n        res\n    });\n    if !success_debug.contains(\"Operation completed\") {\n        ::core::panicking::panic(\n            \"assertion failed: success_debug.contains(\\\"Operation completed\\\")\",\n        )\n    }\n    let error: Response = Response::Error {\n        message: \"Something went wrong\".to_string(),\n        internal_code: 500,\n    };\n    let error_debug: String = ::alloc::__export::must_use({\n        let res = ::alloc::fmt::format(format_args!(\"{0:?}\", error));\n        res\n    });\n    if !error_debug.contains(\"Something went wrong\") {\n        ::core::panicking::panic(\n            \"assertion failed: error_debug.contains(\\\"Something went wrong\\\")\",\n        )\n    }\n    if !!error_debug.contains(\"500\") {\n        ::core::panicking::panic(\"assertion failed: !error_debug.contains(\\\"500\\\")\")\n    }\n}\n```\n\n# 可恢复线程 (recoverable-spawn/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/recoverable-spawn)\n\n[API 文档](https://docs.rs/recoverable-spawn/latest/recoverable_spawn/)\n\n> 一个支持从 panic 中自动恢复的线程，允许线程在发生 panic 后重新启动。这对于在网络和 Web 编程中实现弹性和容错的并发非常有用。\n\n## 安装\n\n要使用此库，可以运行以下命令：\n\n```shell\ncargo add recoverable-spawn\n```\n\n## 使用\n\n### recoverable_spawn\n\n```rust\nuse recoverable_spawn::*;\n\nlet msg: &str = \"test\";\nlet res: SyncSpawnResult = recoverable_spawn(move || {\n    panic!(\"{}\", msg);\n});\nlet res: SyncSpawnResult = recoverable_spawn_with_error_handle(\n    move || {\n        panic!(\"{}\", msg);\n    },\n    |err| {\n        println!(\"handle error => {}\", err);\n    },\n);\n```\n\n### recoverable_spawn_with_error_handle\n\n```rust\nuse recoverable_spawn::*;\n\nlet msg: &str = \"test\";\nlet res: SyncSpawnResult = recoverable_spawn_with_error_handle(\n    move || {\n        panic!(\"{}\", msg);\n    },\n    |err| {\n        println!(\"handle error => {}\", err);\n    },\n);\n```\n\n### async_recoverable_spawn\n\n```rust\nuse recoverable_spawn::*;\n\nlet msg: &str = \"test\";\nlet res: AsyncSpawnResult = async_recoverable_spawn(move || async move {\n    panic!(\"{}\", msg);\n});\n```\n\n### async_recoverable_spawn_catch\n\n```rust\nuse recoverable_spawn::*;\n\nlet msg: &str = \"test\";\nlet res: AsyncSpawnResult = async_recoverable_spawn_catch(\n    move || async move {\n        panic!(\"{}\", msg);\n    },\n    move |err| async move {\n        println!(\"handle error => {}\", err);\n    },\n);\n```\n\n### async_recoverable_spawn_catch_finally\n\n```rust\nuse recoverable_spawn::*;\n\nlet msg: &str = \"test\";\nlet res: AsyncSpawnResult = async_recoverable_spawn_catch_finally(\n    move || async move {\n        panic!(\"{}\", msg);\n    },\n    move |err| async move {\n        println!(\"handle error => {}\", err);\n        panic!(\"{}\", err);\n    },\n    move || async move {\n        println!(\"finally\");\n    },\n);\n```\n\n# 可恢复线程池 (recoverable-thread-pool/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/recoverable-thread-pool)\n\n[API 文档](https://docs.rs/recoverable-thread-pool/latest/recoverable_thread_pool/)\n\n> 一个支持从 panic 中自动恢复的线程池，允许线程在发生 panic 后重新启动。这对于在网络和 Web 编程中实现弹性和容错的并发非常有用。\n\n## 安装\n\n要使用此 crate，可以运行以下命令：\n\n```shell\ncargo add recoverable-thread-pool\n```\n\n## 使用示例\n\n### 同步\n\n```rust\nuse recoverable_thread_pool::*;\nuse std::{thread::sleep, time::Duration};\nlet thread_pool: ThreadPool = ThreadPool::new(1);\nlet first_res: SendResult = thread_pool.execute(|| {\n    println!(\"first\");\n});\nprintln!(\"{:?}\", first_res);\nlet panic_res: SendResult = thread_pool.execute_with_catch(\n    || {\n        panic!(\"[panic]\");\n    },\n    |err| {\n        println!(\"Catch panic {}\", err);\n    },\n);\nprintln!(\"{:?}\", panic_res);\nlet second_res: SendResult = thread_pool.execute_with_catch_finally(\n    || {\n        panic!(\"[panic]\");\n    },\n    |_err| {\n        panic!(\"[panic]\");\n    },\n    || {\n        println!(\"finally\");\n    },\n);\nprintln!(\"{:?}\", second_res);\nsleep(Duration::from_secs(10));\n```\n\n### 异步\n\n```rust\nuse recoverable_thread_pool::*;\nuse std::{thread::sleep, time::Duration};\nlet thread_pool: ThreadPool = ThreadPool::new(1);\nlet first_res: SendResult = thread_pool.async_execute(|| async {\n    println!(\"first\");\n});\nprintln!(\"{:?}\", first_res);\nlet panic_res: SendResult = thread_pool.async_execute_with_catch(\n    || async {\n        panic!(\"[panic]\");\n    },\n    |err| async move {\n        println!(\"Catch panic {}\", err);\n    },\n);\nprintln!(\"{:?}\", panic_res);\nlet second_res: SendResult = thread_pool.async_execute_with_catch_finally(\n    || async {\n        panic!(\"[panic]\");\n    },\n    |_err| async {\n        panic!(\"[panic]\");\n    },\n    || async {\n        println!(\"finally\");\n    },\n);\nprintln!(\"{:?}\", second_res);\nsleep(Duration::from_secs(10));\n```\n\n# server-manager (server-manager/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/server-manager)\n\n[Api 文档](https://docs.rs/server-manager/latest/server_manager/)\n\n> server-manager 是一个用于管理服务器进程的 Rust 库。它封装了服务的启动、关闭和后台守护进程模式。用户可以通过自定义设置指定 PID 文件、日志文件路径和其他配置，同时也可以传入自己的异步服务器函数来执行。该库支持同步和异步操作。在 Unix 和 Windows 平台上，它支持后台守护进程。\n\n## 安装\n\n在项目目录下执行下面的命令，将 server-manager 添加为依赖项：\n\n```shell\ncargo add server-manager\n```\n\n## 使用\n\n```rust\nuse server_manager::*;\nuse std::fs;\nuse std::time::Duration;\n\nlet pid_file: String = \"./process/test_pid.pid\".to_string();\nlet _ = fs::remove_file(&pid_file);\nlet server = || async {\n    tokio::time::sleep(Duration::from_secs(1)).await;\n};\nlet mut manager: ServerManager = ServerManager::new();\nmanager\n    .set_pid_file(&pid_file)\n    .set_start_hook(|| async {\n        println!(\"Before start daemon hook executed\");\n    })\n    .set_server_hook(server)\n    .set_stop_hook(|| async {\n        println!(\"Before stop hook executed\");\n    });\nlet res: ServerManagerResult = manager.start_daemon().await;\nprintln!(\"start_daemon {:?}\", res);\nlet res: ServerManagerResult = manager.stop().await;\nprintln!(\"stop {:?}\", res);\nmanager.start().await;\nlet _ = fs::remove_file(&pid_file);\n```\n\n# 标准库宏扩展 (std-macro-extensions/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/std-macro-extensions)\n\n## 说明\n\n> 一个为 Rust 标准库数据结构提供的宏扩展集合，简化了如 HashMap、Vec 等常用集合的创建和操作。\n\n## 特性\n\n- **简化初始化**：使用宏轻松创建常见数据结构的实例。\n- **支持多种数据结构**：包括 `Vec`、`HashMap`、`Arc` 等的宏。\n- **易于使用**：直观的语法使数据结构的创建更加迅速。\n\n## 安装\n\n要安装 `std-macro-extensions`，请运行以下命令：\n\n```sh\ncargo add std-macro-extensions\n```\n\n## 用法\n\n以下是如何使用该 crate 提供的宏的一些示例：\n\n### 示例：使用 `arc!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let value = arc!(5);\n}\n```\n\n### 示例：使用 `b_tree_map!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let empty_map: BTreeMap= b_tree_map!();\n    let b_tree_map_a: BTreeMap= b_tree_map!(\n        \"a\" => \"a\",\n        \"b\" => \"b\"\n    );\n}\n```\n\n### 示例：使用 `b_tree_map!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let empty_set: BTreeSet= b_tree_set!();\n    let number_set: BTreeSet= b_tree_set!(1, 2, 3);\n}\n```\n\n### 示例：使用 `boxed!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let boxed_value = boxed!(10);\n}\n```\n\n### 示例：使用 `cell!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let cell_value: Cell= cell!(5);\n}\n```\n\n### 示例：使用 `hash_map!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_map: HashMap= hash_map!();\n    let my_map: HashMap= hash_map!(\"a\" => 1, \"b\" => 2);\n}\n```\n\n### 示例：使用 `hash_set!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_set: HashSet= hash_set!();\n    let my_set: HashSet= hash_set!(1, 2, 3);\n}\n```\n\n### 示例：使用 `linked_list!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_list: LinkedList= linked_list!();\n    let my_list: LinkedList= linked_list!(1, 2, 3);\n}\n```\n\n### 示例：使用 `mutex!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_mutex: Mutex= mutex!(5);\n    let lock: MutexGuard= my_mutex.lock().unwrap();\n}\n```\n\n### 示例：使用 `rc!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_rc = rc!(5);\n}\n```\n\n### 示例：使用 `refcell!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_refcell = refcell!(5);\n}\n```\n\n### 示例：使用 `rw_lock!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let my_rwlock = rw_lock!(5);\n}\n```\n\n### 示例：使用 `string!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let empty_string = string!();\n    let hello_string = string!(\"Hello\");\n}\n```\n\n### 示例：使用 `vector!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let empty_vector: Vec= vector!();\n    let numbers = vector!(1, 2, 3);\n}\n```\n\n### 示例：使用 `vector_deque!`\n\n```rust\nuse std_macro_extensions::*;\n\nfn main() {\n    let empty_deque: VecDeque= vector_deque!();\n    let numbers = vector_deque!(1, 2, 3);\n}\n```\n\n### 示例：使用 `join_paths!`\n\n```rust\nlet combined_path: String = join_paths!(\"/home/\", \"/user/\", \"/documents\", \"file.txt\");\nlet another_path: String = join_paths!(\"C:/\", \"/Program Files\", \"App\");\n```\n\n### 示例：使用 `cin!`\n\n```rust\nlet input: String = cin!();\nprintln!(\"You typed: {}\", input);\n```\n\n### 示例：使用 `cin_parse!`\n\n```rust\nlet input: &str = \"1 2 3\";\nlet numbers: Vec= cin_parse!(input, Vec);\nassert_eq!(numbers, vec![1, 2, 3]);\nlet single_input: &str = \"12\";\nlet number: i32 = cin_parse!(single_input, i32);\nassert_eq!(number, 12);\n```\n\n### 示例：使用 `cout!`\n\n```rust\nlet name: &str = \"Alice\";\nlet age: i32 = 30;\ncout!(\"Name: {}, Age: {}\\n\", name, age);\n```\n\n### 示例：使用 `endl!`\n\n```rust\nendl!();\n```\n\n### 示例：使用 `cout_endl!`\n\n```rust\nlet name: &str = \"Alice\";\nlet age: i32 = 30;\ncout_endl!(\"Name: {}, Age: {}\\n\", name, age);\n```\n\n### 示例：使用 `execute!`\n\n```rust\nfn sum(data: &[i32]) -> i32 {\n    data.iter().sum()\n}\nfn add_offset(data: &[i32], offset: i32) -> i32 {\n    data.iter().map(|x| x + offset).sum()\n}\nlet nums: Vec= vec![1, 2, 3];\nlet total: i32 = execute!(sum, &nums);\nassert_eq!(total, 6);\nlet total_with_offset: i32 = execute!(add_offset, &nums, 10);\nassert_eq!(total_with_offset, 36);\n```\n\n### 示例：使用 `execute_async!`\n\n```rust\nlet data: Vec= vec![1, 2, 3];\nasync fn async_func(data: &[i32], offset: i32) -> i32 {\n    data.iter().map(|x| x + offset).sum()\n}\nlet res: i32 = execute_async!(async_func, &data, 1).await;\nassert_eq!(res, 9);\n```\n\n## 可用的宏\n\n- `arc!`：创建一个 `Arc`。\n- `vector!`：创建一个 `Vec`。\n- `map!`：创建一个 `HashMap`。\n- `set!`：创建一个 `HashSet`。\n- `b_tree_map!`：创建一个 `BTreeMap`。\n- `b_tree_set!`：创建一个 `BTreeSet`。\n- `list!`：创建一个 `LinkedList`。\n- `heap!`：创建一个 `BinaryHeap`。\n- `string!`：创建一个 `String`。\n- `boxed!`：创建一个 `Box`。\n- `rc!`：创建一个 `Rc`。\n- `arc!`：创建一个 `Arc`。\n- `mutex!`：创建一个 `Mutex`。\n- `rw_lock!`：创建一个 `RwLock`。\n- `cell!`：创建一个 `Cell`。\n- `ref_cell!`：创建一个 `RefCell`。\n- `vector_deque!`: Creates a `VecDeque`。\n- `join_paths!`: 将多个路径组合成一个有效的路径，并处理重叠的斜杠。\n- `cin!`: 从标准输入读取一行字符串输入。\n- `cin_parse!`: 将输入解析为指定的类型或类型数组。\n- `cout!`: 将格式化输出打印到标准输出（不换行）。\n- `endl!`: 打印一个换行符到标准输出。\n- `cout_endl!`: 打印格式化输出并追加一个换行符到标准输出，同时刷新缓冲区。\n- `execute!`: 使用提供的参数调用并执行指定函数。\n- `execute_async!`: 使用提供的参数调用并异步执行指定函数。\n\n# TCP请求库 (tcp-request/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/tcp-request)\n\n[API 文档](https://docs.rs/tcp-request/latest/tcp_request/)\n\n> 一个 Rust 库，用于发送原始 TCP 请求，支持处理响应、管理重定向以及在 TCP 连接中处理压缩数据。\n\n### 安装\n\n通过以下命令安装该 crate：\n\n```shell\ncargo add tcp-request\n```\n\n### 使用方法\n\n#### 接收文本数据\n\n```rust\nuse tcp_request::*;\n\nlet mut request_builder = RequestBuilder::new()\n    .host(\"127.0.0.1\")\n    .port(80)\n    .build();\nrequest_builder\n    .send(\"tcp send\".as_bytes())\n    .and_then(|response| {\n        println!(\"ResponseTrait => {:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n```\n\n#### 接收二进制数据\n\n```rust\nuse tcp_request::*;\n\nlet mut request_builder = RequestBuilder::new()\n    .host(\"127.0.0.1\")\n    .port(80)\n    .build();\nrequest_builder\n    .send(\"tcp send\".as_bytes())\n    .and_then(|response| {\n        println!(\"ResponseTrait => {:?}\", response.binary());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n```\n\n### 注意事项\n\n确保系统中已安装 CMake。\n\n###\n\n# TCP后端框架 (tcplane/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/tcplane)\n\n[API 文档](https://docs.rs/tcplane/latest/tcplane/)\n\n> **tcplane** 是一个轻量级且高性能的 Rust TCP 服务器库，旨在简化网络服务开发。它支持 TCP 通信、数据流管理和连接处理，专注于提供高效的底层网络连接和数据传输能力，非常适合构建现代网络服务。\n\n## 安装\n\n可以通过以下命令安装该库：\n\n```shell\ncargo add tcplane\n```\n\n## 使用示例\n\n```rust\nuse tcplane::*;\n\nasync fn test_func(ctx: Context) {\n    ctx.send(\"tcplane: 1\").await.unwrap();\n}\n\nfn error_handle(error: String) {\n    eprintln!(\"{}\", error);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut server: Server = Server::new().await;\n    server.host(\"0.0.0.0\").await;\n    server.port(60000).await;\n    server.buffer(100_024_000).await;\n    server.error_handle(error_handle).await;\n    server.func(test_func).await;\n    server\n        .func(|ctx: Context| async move {\n            ctx.send(\"tcplane: 2\").await.unwrap();\n        })\n        .await;\n    server.run().await;\n}\n```\n\n# UDP请求库 (udp-request/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/udp-request)\n\n[API 文档](https://docs.rs/udp-request/latest/tcp_request/)\n\n> 一个简单的 UDP 请求库，用于在 Rust 应用程序中发送和接收 UDP 数据包，设计用于处理网络通信。\n\n## 安装\n\n要使用这个库，你可以运行以下命令：\n\n```shell\ncargo add udp-request\n```\n\n## 使用\n\n#### 接收文本\n\n```rust\nuse udp_request::*;\n\nlet mut request_builder = RequestBuilder::new()\n    .host(\"127.0.0.1\")\n    .port(80)\n    .build();\nrequest_builder\n    .send(\"udp send\".as_bytes())\n    .and_then(|response| {\n        println!(\"ResponseTrait => {:?}\", response.text());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n```\n\n#### 接收二进制\n\n```rust\nuse udp_request::*;\n\nlet mut request_builder = RequestBuilder::new()\n    .host(\"127.0.0.1\")\n    .port(80)\n    .build();\nrequest_builder\n    .send(\"udp send\".as_bytes())\n    .and_then(|response| {\n        println!(\"ResponseTrait => {:?}\", response.binary());\n        Ok(())\n    })\n    .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n```\n\n# UDP后端框架 (udp/README.md)\n\n[GITHUB 地址](https://github.com/crates-dev/udp)\n\n[API 文档](https://docs.rs/udp/latest/udp/)\n\n> 一个轻量高效的 Rust 库，用于构建支持请求-响应处理的 UDP 服务器\n\n## 安装\n\n要使用此 crate，你可以运行以下命令：\n\n```shell\ncargo add udp\n```\n\n## 使用方法\n\n```rust\nuse udp::*;\n\nasync fn test_func(ctx: Context) {\n    ctx.send(\"udp: 1\").await.unwrap();\n}\n\nfn error_handle(error: String) {\n    eprintln!(\"{}\", error);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}\n\n#[tokio::main]\nasync fn main() {\n    let mut server: Server = Server::new().await;\n    server.host(\"0.0.0.0\").await;\n    server.port(60000).await;\n    server.buffer(100_024_000).await;\n    server.error_handle(error_handle).await;\n    server.func(test_func).await;\n    server\n        .func(|ctx: Context| async move {\n            ctx.send(\"udp: 2\").await.unwrap();\n        })\n        .await;\n    server.run().await;\n}\n```", "file_size": 197954, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\package.json", "language": "json", "content": "{\n  \"name\": \"ltpp-docs\",\n  \"version\": \"1.0.0\",\n  \"description\": \"ltpp-docs\",\n  \"license\": \"MIT\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"merge\": \"node scripts/merge-markdown.js\",\n    \"build\": \"node scripts/merge-markdown.js && node plugin/creat-sidebar.js && vuepress-vite build src\",\n    \"clean-dev\": \"node plugin/creat-sidebar.js && vuepress-vite dev src --clean-cache\",\n    \"dev\": \"node plugin/creat-sidebar.js && vuepress-vite dev src\",\n    \"serve\": \"node plugin/creat-sidebar.js && vuepress-vite dev src\",\n    \"server\": \"node plugin/creat-sidebar.js && vuepress-vite dev src\",\n    \"update-package\": \"pnpm dlx vp-update\"\n  },\n  \"devDependencies\": {\n    \"@vuepress/bundler-vite\": \"2.0.0-rc.19\",\n    \"mermaid\": \"^11.6.0\",\n    \"sass-embedded\": \"^1.85.0\",\n    \"vue\": \"^3.5.13\",\n    \"vuepress\": \"2.0.0-rc.19\",\n    \"vuepress-theme-hope\": \"2.0.0-rc.71\"\n  },\n  \"dependencies\": {\n    \"@vue/repl\": \"^4.5.0\",\n    \"@vuepress/plugin-register-components\": \"2.0.0-rc.66\",\n    \"@vuepress/plugin-search\": \"2.0.0-rc.74\",\n    \"artplayer\": \"^5.2.2\",\n    \"dashjs\": \"5.0.0\",\n    \"hls.js\": \"1.5.20\",\n    \"mpegts.js\": \"^1.8.0\",\n    \"vidstack\": \"^1.12.12\"\n  }\n}", "file_size": 1140, "extension": ".json"}
{"file_path": "training_sources\\ltpp-docs\\src\\development-standards\\semver.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 语义化版本 2.0.0,development-standards,semver\ntitle: 语义化版本 2.0.0\nindex: true\nicon: book\ncategory:\n  - development-standards\n  - semver\ndir:\n  order: 2\n---\n\n<Share colorful />\n\n[原文地址](https://semver.org/lang/zh-CN/)\n\n<div id=\"spec\">\n  <h1 id=\"语义化版本-200\">\n    <a class=\"anchor-link\" href=\"#语义化版本-200\"></a>语义化版本 2.0.0</h1>\n  <h2 id=\"摘要\">\n    <a class=\"anchor-link\" href=\"#摘要\"></a>摘要</h2>\n  <p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n  <ol>\n    <li>主版本号：当你做了不兼容的 API 修改，</li>\n    <li>次版本号：当你做了向下兼容的功能性新增，</li>\n    <li>修订号：当你做了向下兼容的问题修正。</li></ol>\n  <p>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n  <h2 id=\"简介\">\n    <a class=\"anchor-link\" href=\"#简介\"></a>简介</h2>\n  <p>在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。</p>\n  <p>在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。</p>\n  <p>作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。</p>\n  <p>我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。</p>\n  <h2 id=\"语义化版本控制规范semver\">\n    <a class=\"anchor-link\" href=\"#语义化版本控制规范semver\"></a>语义化版本控制规范（SemVer）</h2>\n  <p>以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。</p>\n  <ol>\n    <li id=\"spec-item-1\">\n      <a class=\"anchor-link\" href=\"#spec-item-1\"></a>\n      <p>使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。</p>\n    </li>\n    <li id=\"spec-item-2\">\n      <a class=\"anchor-link\" href=\"#spec-item-2\"></a>\n      <p>标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -&gt; 1.10.0 -&gt; 1.11.0。</p>\n    </li>\n    <li id=\"spec-item-3\">\n      <a class=\"anchor-link\" href=\"#spec-item-3\"></a>\n      <p>标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。</p>\n    </li>\n    <li id=\"spec-item-4\">\n      <a class=\"anchor-link\" href=\"#spec-item-4\"></a>\n      <p>主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。</p>\n    </li>\n    <li id=\"spec-item-5\">\n      <a class=\"anchor-link\" href=\"#spec-item-5\"></a>\n      <p>1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。</p>\n    </li>\n    <li id=\"spec-item-6\">\n      <a class=\"anchor-link\" href=\"#spec-item-6\"></a>\n      <p>修订号 Z（x.y.Z\n        <code class=\"language-plaintext highlighter-rouge\">|</code>x &gt; 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。</p></li>\n    <li id=\"spec-item-7\">\n      <a class=\"anchor-link\" href=\"#spec-item-7\"></a>\n      <p>次版本号 Y（x.Y.z\n        <code class=\"language-plaintext highlighter-rouge\">|</code>x &gt; 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。</p></li>\n    <li id=\"spec-item-8\">\n      <a class=\"anchor-link\" href=\"#spec-item-8\"></a>\n      <p>主版本号 X（X.y.z\n        <code class=\"language-plaintext highlighter-rouge\">|</code>X &gt; 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。</p></li>\n    <li id=\"spec-item-9\">\n      <a class=\"anchor-link\" href=\"#spec-item-9\"></a>\n      <p>先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。</p>\n    </li>\n    <li id=\"spec-item-10\">\n      <a class=\"anchor-link\" href=\"#spec-item-10\"></a>\n      <p>版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。</p>\n    </li>\n    <li id=\"spec-item-11\">\n      <a class=\"anchor-link\" href=\"#spec-item-11\"></a>\n      <p>版本的优先层级指的是不同版本在排序时如何比较。</p>\n      <ol>\n        <li>\n          <p>判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。</p>\n        </li>\n        <li>\n          <p>由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。</p>\n          <p>例如：1.0.0 &lt; 2.0.0 &lt; 2.1.0 &lt; 2.1.1。</p>\n        </li>\n        <li>\n          <p>当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。</p>\n          <p>例如：1.0.0-alpha &lt; 1.0.0。</p>\n        </li>\n        <li>\n          <p>有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：</p>\n          <ol>\n            <li>\n              <p>只有数字的标识符以数值高低比较。</p>\n            </li>\n            <li>\n              <p>有字母或连接号时则逐字以 ASCII 的排序来比较。</p>\n            </li>\n            <li>\n              <p>数字的标识符比非数字的标识符优先层级低。</p>\n            </li>\n            <li>\n              <p>若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。</p>\n            </li>\n          </ol>\n          <p>例如：1.0.0-alpha &lt; 1.0.0-alpha.1 &lt; 1.0.0-alpha.beta &lt; 1.0.0-beta &lt; 1.0.0-beta.2 &lt; 1.0.0-beta.11 &lt; 1.0.0-rc.1 &lt; 1.0.0。</p>\n        </li>\n      </ol>\n    </li>\n  </ol>\n  <h2 id=\"合法语义化版本的巴科斯范式语法\">\n    <a class=\"anchor-link\" href=\"#合法语义化版本的巴科斯范式语法\"></a>合法语义化版本的巴科斯范式语法</h2>\n  <div class=\"language-plaintext highlighter-rouge\">\n    <div class=\"highlight\">\n      <pre class=\"highlight\">\n        <code>&lt;valid semver&gt; ::= &lt;version core&gt; | &lt;version core&gt; \"-\" &lt;pre-release&gt; | &lt;version core&gt; \"+\" &lt;build&gt; | &lt;version core&gt; \"-\" &lt;pre-release&gt; \"+\" &lt;build&gt; &lt;version core&gt; ::= &lt;major&gt; \".\" &lt;minor&gt; \".\" &lt;patch&gt; &lt;major&gt; ::= &lt;numeric identifier&gt; &lt;minor&gt; ::= &lt;numeric identifier&gt; &lt;patch&gt; ::= &lt;numeric identifier&gt; &lt;pre-release&gt; ::= &lt;dot-separated pre-release identifiers&gt; &lt;dot-separated pre-release identifiers&gt; ::= &lt;pre-release identifier&gt; | &lt;pre-release identifier&gt; \".\" &lt;dot-separated pre-release identifiers&gt; &lt;build&gt; ::= &lt;dot-separated build identifiers&gt; &lt;dot-separated build identifiers&gt; ::= &lt;build identifier&gt; | &lt;build identifier&gt; \".\" &lt;dot-separated build identifiers&gt; &lt;pre-release identifier&gt; ::= &lt;alphanumeric identifier&gt; | &lt;numeric identifier&gt; &lt;build identifier&gt; ::= &lt;alphanumeric identifier&gt; | &lt;digits&gt; &lt;alphanumeric identifier&gt; ::= &lt;non-digit&gt; | &lt;non-digit&gt; &lt;identifier characters&gt; | &lt;identifier characters&gt; &lt;non-digit&gt; | &lt;identifier characters&gt; &lt;non-digit&gt; &lt;identifier characters&gt; &lt;numeric identifier&gt; ::= \"0\" | &lt;positive digit&gt; | &lt;positive digit&gt; &lt;digits&gt; &lt;identifier characters&gt; ::= &lt;identifier character&gt; | &lt;identifier character&gt; &lt;identifier characters&gt; &lt;identifier character&gt; ::= &lt;digit&gt; | &lt;non-digit&gt; &lt;non-digit&gt; ::= &lt;letter&gt; | \"-\" &lt;digits&gt; ::= &lt;digit&gt; | &lt;digit&gt; &lt;digits&gt; &lt;digit&gt; ::= \"0\" | &lt;positive digit&gt; &lt;positive digit&gt; ::= \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" &lt;letter&gt; ::= \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\" | \"H\" | \"I\" | \"J\" | \"K\" | \"L\" | \"M\" | \"N\" | \"O\" | \"P\" | \"Q\" | \"R\" | \"S\" | \"T\" | \"U\" | \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\" | \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" | \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\" | \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" | \"z\"</code></pre>\n    </div>\n  </div>\n  <h2 id=\"为什么要使用语义化的版本控制\">\n    <a class=\"anchor-link\" href=\"#为什么要使用语义化的版本控制\"></a>为什么要使用语义化的版本控制？</h2>\n  <p>这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。</p>\n  <p>举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。</p>\n  <p>作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。</p>\n  <p>如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。</p>\n  <h2 id=\"faq\">\n    <a class=\"anchor-link\" href=\"#faq\"></a>FAQ</h2>\n  <h3 id=\"在-0yz-初始开发阶段我该如何进行版本控制\">\n    <a class=\"anchor-link\" href=\"#在-0yz-初始开发阶段我该如何进行版本控制\"></a>在 0.y.z 初始开发阶段，我该如何进行版本控制？</h3>\n  <p>最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。</p>\n  <h3 id=\"如何判断发布-100-版本的时机\">\n    <a class=\"anchor-link\" href=\"#如何判断发布-100-版本的时机\"></a>如何判断发布 1.0.0 版本的时机？</h3>\n  <p>当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。</p>\n  <h3 id=\"这不会阻碍快速开发和迭代吗\">\n    <a class=\"anchor-link\" href=\"#这不会阻碍快速开发和迭代吗\"></a>这不会阻碍快速开发和迭代吗？</h3>\n  <p>主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。</p>\n  <h3 id=\"对于公共-api若即使是最小但不向下兼容的改变都需要产生新的主版本号岂不是很快就达到-4200-版\">\n    <a class=\"anchor-link\" href=\"#对于公共-api若即使是最小但不向下兼容的改变都需要产生新的主版本号岂不是很快就达到-4200-版\"></a>对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？</h3>\n  <p>这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。</p>\n  <h3 id=\"为整个公共-api-写文档太费事了\">\n    <a class=\"anchor-link\" href=\"#为整个公共-api-写文档太费事了\"></a>为整个公共 API 写文档太费事了！</h3>\n  <p>为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部分是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。</p>\n  <h3 id=\"万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办\">\n    <a class=\"anchor-link\" href=\"#万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办\"></a>万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？</h3>\n  <p>一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。</p>\n  <h3 id=\"如果我更新了自己的依赖但没有改变公共-api-该怎么办\">\n    <a class=\"anchor-link\" href=\"#如果我更新了自己的依赖但没有改变公共-api-该怎么办\"></a>如果我更新了自己的依赖但没有改变公共 API 该怎么办？</h3>\n  <p>由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。</p>\n  <h3 id=\"如果我变更了公共-api-但无意中未遵循版本号的改动怎么办呢意即在修订等级的发布中误将重大且不兼容的改变加到代码之中\">\n    <a class=\"anchor-link\" href=\"#如果我变更了公共-api-但无意中未遵循版本号的改动怎么办呢意即在修订等级的发布中误将重大且不兼容的改变加到代码之中\"></a>如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）</h3>\n  <p>自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。</p>\n  <h3 id=\"我该如何处理即将弃用的功能\">\n    <a class=\"anchor-link\" href=\"#我该如何处理即将弃用的功能\"></a>我该如何处理即将弃用的功能？</h3>\n  <p>弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部分公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。</p>\n  <h3 id=\"语义化版本对于版本的字符串长度是否有限制呢\">\n    <a class=\"anchor-link\" href=\"#语义化版本对于版本的字符串长度是否有限制呢\"></a>语义化版本对于版本的字符串长度是否有限制呢？</h3>\n  <p>没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。</p>\n  <h3 id=\"v123-是一个语义化版本号吗\">\n    <a class=\"anchor-link\" href=\"#v123-是一个语义化版本号吗\"></a>“v1.2.3” 是一个语义化版本号吗？</h3>\n  <p>“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：\n    <code class=\"language-plaintext highlighter-rouge\">git tag v1.2.3 -m \"Release version 1.2.3\"</code>中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。</p>\n  <h3 id=\"是否有推荐的正则表达式用以检查语义化版本号的正确性\">\n    <a class=\"anchor-link\" href=\"#是否有推荐的正则表达式用以检查语义化版本号的正确性\"></a>是否有推荐的正则表达式用以检查语义化版本号的正确性？</h3>\n  <p>有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。</p>\n  <p>参见：\n    <a href=\"https://regex101.com/r/Ly7O1x/3/\">https://regex101.com/r/Ly7O1x/3/</a></p>\n  <div class=\"language-plaintext highlighter-rouge\">\n    <div class=\"highlight\">\n      <pre class=\"highlight\">\n        <code>^(?P&lt;major&gt;0|[1-9]\\d*)\\.(?P&lt;minor&gt;0|[1-9]\\d*)\\.(?P&lt;patch&gt;0|[1-9]\\d*)(?:-(?P&lt;prerelease&gt;(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?P&lt;buildmetadata&gt;[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$</code></pre>\n    </div>\n  </div>\n  <p>第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。 参见：\n    <a href=\"https://regex101.com/r/vkijKf/1/\">https://regex101.com/r/vkijKf/1/</a></p>\n  <div class=\"language-plaintext highlighter-rouge\">\n    <div class=\"highlight\">\n      <pre class=\"highlight\">\n        <code>^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$</code></pre>\n    </div>\n  </div>\n  <h2 id=\"关于\">\n    <a class=\"anchor-link\" href=\"#关于\"></a>关于</h2>\n  <p>语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者\n    <a href=\"http://tom.preston-werner.com\">Tom Preston-Werner</a>所建立。</p>\n  <p>如果您有任何建议，请到\n    <a href=\"https://github.com/semver/semver/issues\">GitHub 上提出您的问题</a>。</p>\n  <h2 id=\"许可证\">\n    <a class=\"anchor-link\" href=\"#许可证\"></a>许可证</h2>\n  <p>\n    <a href=\"http://creativecommons.org/licenses/by/3.0/\">知识共享 署名 3.0 (CC BY 3.0)</a></p>\n</div>\n\n<Bottom />", "file_size": 13049, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\sidebar.ts", "language": "typescript", "content": "import { sidebar } from 'vuepress-theme-hope';\nexport default sidebar({\n  '/': 'structure',\n  'bin-encode-decode': 'structure',\n  'china-identification-card': 'structure',\n  'color-output': 'structure',\n  'compare-version': 'structure',\n  'file-operation': 'structure',\n  'http-compress': 'structure',\n  'http-constant': 'structure',\n  'http-request': 'structure',\n  'http-response': 'structure',\n  'http-type': 'structure',\n  hyperlane: 'structure',\n  'hyperlane-log': 'structure',\n  'hyperlane-time': 'structure',\n  'lombok-macros': 'structure',\n  ltpp: 'structure',\n  'ltpp-code-run': 'structure',\n  'ltpp-event-publish-subscribe-in-javascript': 'structure',\n  'ltpp-gitlab': 'structure',\n  'ltpp-html-pdf': 'structure',\n  'ltpp-leetcode-and-acwing-rank': 'structure',\n  'ltpp-oj-judge-testdata-creat': 'structure',\n  'ltpp-post-blog-user-crawler': 'structure',\n  'ltpp-qrcode': 'structure',\n  'ltpp-rust-get-proxy-request': 'structure',\n  'ltpp-rust-web-server': 'structure',\n  'ltpp-share': 'structure',\n  'ltpp-sqs-douyin-collection-download': 'structure',\n  'ltpp-ssh': 'structure',\n  'ltpp-web-ide': 'structure',\n  'markdown-images': 'structure',\n  'recoverable-spawn': 'structure',\n  'recoverable-thread-pool': 'structure',\n  'std-macro-extensions': 'structure',\n  'tcp-request': 'structure',\n  tcplane: 'structure',\n});", "file_size": 1329, "extension": ".ts"}
{"file_path": "training_sources\\ltpp-docs\\src\\tcplane\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\norder: 5\n---\n\n<Share colorful />\n\nMIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n\n<Bottom />", "file_size": 1211, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-share\\mc.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: LTPP公益MC服务器分享,LTPP公益MC服务器文档\ntitle: LTPP公益MC服务器分享\nindex: true\nicon: fas fa-gamepad\ncategory:\n  - LTPP公益MC服务器文档\n---\n\n<Share colorful />\n\n#### LTPP 公益 MC 服务器\n\n> [!tip]\n>\n> - 服务器地址：free-mc-server.ltpp.vip\n> - MC 版本：1.19.4\n\n<Bottom />", "file_size": 286, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\test.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 后端压测,后端压测文档,压测,后端接口\ntitle: 后端压测\nindex: true\nicon: fas fa-vial\ncategory:\n  - 后端压测文档\n  - 压测\n  - 后端接口\norder: 2\n---\n\n`测试服务器配置：CPU（E5-2650V2），内存（128G DDR3），硬盘（NVME协议1TB固态），带宽（100Mbps）`\n\n`测试主机配置：CPU（AMD R7-4800H），内存（16G DDR4），硬盘（1TB固态），带宽（100Mbps）`\n\n`测试软件：Apache JMeter`\n\n由于判题请求比较耗费服务器资源（因为要进行进程的创建以及 `OI` 操作），\n为了不限制判题并发数目，暂时将最大并发判题数目设置成 `10000（比测试的并发量` `10000` 大即可），\n以下为 `10000` 并发的判题请求，可以看出 `10000` 并发的竞赛请求有百分之 `6.13` 失败，\n即 `10000` 个并发请求有 `613` 个请求失败，结果较为理想。\n\n![](markdown-images/image-62.png)\n\n对于一场竞赛排名的请求，从发起请求开始计时到获取到结果停止计时，一次请求后端逻辑运算花费 `31.08` 毫秒，数据下载花费 `0.63` 毫秒，一共耗时 `32.75` 毫秒，分析得出后端处理速度极快，响应速度极快的结果。\n\n![](markdown-images/image-63.png)\n\n模拟用户提交代码并运行（由于代码需要进行运行，所以更消耗 `CPU` 和 `内存`），`10000` 并发，一共 `101942729` 个请求，成功率高达 99.97%。\n\n![](markdown-images/image-64.png)\n\n服务器 `5000` 并发的判题情况下的负载情况（期间 `CPU` 满载运行，内存占用逐步提升到 `90%`，即 5000 并发的判题消耗内存 102.4GB）。\n\n![](markdown-images/image-65.png)\n\n对于普通页面的数据获取，服务器消耗较低，经过 `10000` 并发的测试，一共 `1000000` 次请求，数据全部获取成功，没有失败的结果。\n\n![](markdown-images/image-66.png)\n\n![](markdown-images/image-67.png)\n\n![](markdown-images/image-68.png)\n\n<Bottom />", "file_size": 1126, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\component\\crates-downloads.vue", "language": "vue", "content": "<template>\n  <div class=\"crates-downloads\">\n    <div class=\"downloads-header\">\n      <div class=\"title-section\">\n        <span class=\"hint-container-title\">Crates.io 统计</span>\n        <div class=\"downloads-icon\">\n          <svg\n            width=\"20\"\n            height=\"20\"\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              d=\"M12 2L13.09 8.26L20 9L13.09 9.74L12 16L10.91 9.74L4 9L10.91 8.26L12 2Z\"\n              fill=\"currentColor\"\n            />\n          </svg>\n        </div>\n      </div>\n      <div class=\"downloads-content\">\n        <div v-if=\"loading\" class=\"loading\">\n          <span>加载中...</span>\n        </div>\n        <div v-else-if=\"error\" class=\"error\">\n          <span>加载失败</span>\n        </div>\n        <div v-else class=\"downloads-display\">\n          <span class=\"downloads-label\">总下载量：</span>\n          <span class=\"downloads-value\">{{ totalDownloads }}</span>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'CratesDownloads',\n  data() {\n    return {\n      totalDownloads: 0,\n      loading: true,\n      error: null,\n    };\n  },\n  async mounted() {\n    await this.fetchDownloads();\n  },\n  methods: {\n    async fetchDownloads() {\n      try {\n        this.loading = true;\n        this.error = null;\n\n        const response = await fetch(\n          'https://crates.io/api/v1/users/295797/stats'\n        );\n\n        if (!response.ok) {\n          throw new Error(`HTTP error! status: ${response.status}`);\n        }\n\n        const data = await response.json();\n        this.totalDownloads = data.total_downloads || 0;\n      } catch (err) {\n        console.error('Failed to fetch crates.io downloads:', err);\n        this.error = '获取下载量数据失败，请稍后重试';\n      } finally {\n        this.loading = false;\n      }\n    },\n  },\n};\n</script>\n\n<style scoped>\n.crates-downloads {\n  margin: 1rem 0rem;\n}\n\n.downloads-header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 0.75rem 1rem;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);\n  border-radius: 8px;\n  border-left: 4px solid #007acc;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n}\n\n.title-section {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.hint-container-title {\n  font-size: 1.1rem;\n  font-weight: 600;\n  color: #2c3e50;\n  margin: 0;\n}\n\n.downloads-icon {\n  color: #007acc;\n  display: flex;\n  align-items: center;\n}\n\n.downloads-content {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.loading {\n  color: #666;\n  font-style: italic;\n  font-size: 0.9rem;\n}\n\n.error {\n  color: #e74c3c;\n  font-size: 0.9rem;\n}\n\n.downloads-display {\n  display: flex;\n  align-items: center;\n  gap: 0.5rem;\n}\n\n.downloads-label {\n  font-weight: 500;\n  color: #2c3e50;\n  font-size: 0.95rem;\n}\n\n.downloads-value {\n  font-weight: bold;\n  font-size: 1.2rem;\n  color: #e67e22;\n  background: linear-gradient(135deg, #ff6b35, #f7931e);\n  background-clip: text;\n  -webkit-background-clip: text;\n  -webkit-text-fill-color: transparent;\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);\n}\n\n@media (max-width: 768px) {\n  .downloads-header {\n    flex-direction: column;\n    gap: 0.75rem;\n    align-items: flex-start;\n  }\n\n  .downloads-content {\n    align-self: flex-end;\n  }\n\n  .downloads-value {\n    font-size: 1.1rem;\n  }\n}\n\n@media (max-width: 480px) {\n  .downloads-header {\n    padding: 0.5rem 0.75rem;\n  }\n\n  .hint-container-title {\n    font-size: 1rem;\n  }\n\n  .downloads-value {\n    font-size: 1rem;\n  }\n}\n</style>", "file_size": 3558, "extension": ".vue"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-code-run\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: License,LICENSE\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\n---\n\n<Share colorful />\n\nEnd User License Agreement (EULA)\nCopyright (c) 2024 尤雨东\nVersion: 1.0\nEffective Date: Permanent\n\n1. Definitions\n   Software: Refers to the program developed by the software developer, including all related files, resources, and updates.\n   Licensor: Refers to the copyright owner of the software.\n   User: Refers to any individual who downloads, installs, or uses the software.\n\n2. License Scope\n   The Licensor grants the User a non-exclusive, non-transferable, and non-sublicensable right to use the software for personal, non-commercial purposes only.\n   This license does not include ownership of the software. The Licensor retains all rights, titles, and interests in the software.\n\n3. Restrictions\n   The User must not modify, decompile, reverse engineer, disassemble, or attempt to obtain the source code of the software.\n   The User must not use the software for illegal activities.\n   The User must not distribute, lease, transfer, or sublicense the software unless explicitly permitted by the Licensor in writing.\n   The User must not remove or alter any copyright notices or branding information included in the software.\n\n4. Updates and Support\n   The Licensor may provide updates to the software but is under no obligation to offer maintenance, technical support, or upgrades.\n   Any updates provided will be subject to the terms of this agreement unless otherwise specified.\n\n5. Privacy\n   Use of the software may involve the collection and processing of user data, as governed by the Licensor's privacy policy (if applicable).\n\n6. Disclaimer\n   The software is provided \"as is\" without any express or implied warranties, including but not limited to warranties of merchantability, fitness for a particular purpose, and non-infringement.\n   The Licensor shall not be liable for any direct or indirect damages arising from the use or inability to use the software.\n\n7. Termination\n   The Licensor reserves the right to terminate this agreement immediately if the User breaches any of its terms.\n   Upon termination, the User must delete all copies of the software and cease any further use.\n\n8. Miscellaneous\n   If any provision of this agreement is deemed invalid or unenforceable, the remaining provisions shall remain in full force and effect.\n\nThis agreement constitutes the entire agreement between the User and the Licensor regarding the software and supersedes all prior communications and agreements.\n\n<Bottom />", "file_size": 2580, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-rust-get-proxy-request\\run.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 运行效果\ntitle: 运行效果\nindex: true\nicon: fas fa-cogs\ncategory:\n  - 运行效果\n---\n\n<Share colorful />\n\n> [!tip]\n> 控制台输出\n\n![](markdown-images/image-6.png)\n\n> [!tip]\n> 运行日志\n\n![](markdown-images/image-7.png)\n\n> [!tip]\n> 访问：[URL 地址](http://localhost/?url=http%3A%2F%2Fv26-web.douyinvod.com%2F58ec2cbe01a030eece612dcfb7ab7e84%2F6695f502%2Fvideo%2Ftos%2Fcn%2Ftos-cn-ve-15c001-alinc2%2FosgBRh80zAXLgYZGAzBD8m7GfQGIDEte4AHc3n%2F%3Fa%3D6383%26ch%3D42%26cr%3D3%26dr%3D0%26lr%3Dall%26cd%3D0%257C0%257C0%257C3%26cv%3D1%26br%3D1020%26bt%3D1020%26cs%3D0%26ds%3D3%26ft%3DpEaFx4hZffPdlW~-avjNvAq-antLjrKjhgg.Rkad5qc9UjVhWL6%26mime_type%3Dvideo_mp4%26qs%3D0%26rc%3DODQ8OGRkZmg4NDk1Omk7NEBpanJrNDk6ZmZycjMzNGkzM0BeNGJjXmBgXjAxMDNjNjA0YSNnL3JicjRvM29gLS1kLTBzcw%253D%253D%26btag%3Dc0000e00008000%26cquery%3D100o_101r_100B_100x_100z%26dy_q%3D1721092807%26feature_id%3Df0150a16a324336cda5d6dd0b69ed299%26l%3D20240716092007C7D4EF501C1259646688&request_header=Referer%3Dhttp%3A%2F%2Fv26-web.douyinvod.com%2F58ec2cbe01a030eece612dcfb7ab7e84%2F6695f502%2Fvideo%2Ftos%2Fcn%2Ftos-cn-ve-15c001-alinc2%2FosgBRh80zAXLgYZGAzBD8m7GfQGIDEte4AHc3n%2F%3Fa%3D6383%26ch%3D42%26cr%3D3%26dr%3D0%26lr%3Dall%26cd%3D0%257C0%257C0%257C3%26cv%3D1%26br%3D1020%26bt%3D1020%26cs%3D0%26ds%3D3%26ft%3DpEaFx4hZffPdlW~-avjNvAq-antLjrKjhgg.Rkad5qc9UjVhWL6%26mime_type%3Dvideo_mp4%26qs%3D0%26rc%3DODQ8OGRkZmg4NDk1Omk7NEBpanJrNDk6ZmZycjMzNGkzM0BeNGJjXmBgXjAxMDNjNjA0YSNnL3JicjRvM29gLS1kLTBzcw%253D%253D%26btag%3Dc0000e00008000%26cquery%3D100o_101r_100B_100x_100z%26dy_q%3D1721092807%26feature_id%3Df0150a16a324336cda5d6dd0b69ed299%26l%3D20240716092007C7D4EF501C1259646688&response_header=Connection%3Dkeep-alive%26Content-Type%3Dvideo%2Fmp4&original=1)\n\n![](markdown-images/image.png)\n![](markdown-images/image-1.png)\n![](markdown-images/image-2.png)\n\n> [!tip]\n> 访问：[URL 地址](http://localhost/?url=)\n\n![](markdown-images/image-3.png)\n![](markdown-images/image-4.png)\n![](markdown-images/image-5.png)\n\n<Bottom />", "file_size": 2001, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\navbar.ts", "language": "typescript", "content": "import { navbar } from 'vuepress-theme-hope';\n\nexport default navbar([\n  '/',\n  '/catalog',\n  {\n    text: 'WEB项目',\n    icon: 'laptop-code',\n    children: [\n      {\n        text: 'LTPP-在线开发平台',\n        icon: 'laptop-code',\n        children: [\n          { text: '打开', icon: 'laptop-code', link: 'https://ltpp.vip' },\n        ],\n      },\n      {\n        text: 'LTPP-GITLAB',\n        icon: 'laptop-code',\n        children: [\n          { text: '打开', icon: 'laptop-code', link: 'https://git.ltpp.vip' },\n        ],\n      },\n      {\n        text: 'LTPP-WEB-IDE',\n        icon: 'laptop-code',\n        children: [\n          {\n            text: 'C',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=c',\n          },\n          {\n            text: 'C++',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=cpp',\n          },\n          {\n            text: 'JavaScript',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=javascript',\n          },\n          {\n            text: 'TypeScript',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=typescript',\n          },\n          {\n            text: 'Rust',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=rust',\n          },\n          {\n            text: 'Golang',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=golang',\n          },\n          {\n            text: 'PHP',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=php',\n          },\n          {\n            text: 'Ruby',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=ruby',\n          },\n          {\n            text: 'Python3',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=py',\n          },\n          {\n            text: 'Java',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=java',\n          },\n          {\n            text: 'C#',\n            icon: 'laptop-code',\n            link: 'https://ide.ltpp.vip/?language=csharp',\n          },\n        ],\n      },\n      {\n        text: 'QRCODE',\n        icon: 'laptop-code',\n        children: [\n          {\n            text: '打开',\n            icon: 'laptop-code',\n            link: 'https://qrcode.ltpp.vip',\n          },\n        ],\n      },\n    ],\n  },\n  '/appreciate',\n]);", "file_size": 2455, "extension": ".ts"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-share\\online-vscode.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: LTPP在线VSCODE使用教程,B站,视频教程\ntitle: LTPP在线VSCODE使用教程\nindex: true\nicon: fas fa-code\ncategory:\n  - LTPP在线VSCODE使用教程\n  - B站\n  - 视频教程\n---\n\n<Share colorful />\n\n#### 在线版本 VSCODE 使用教程\n\n## 运行效果\n\n![](markdown-images/image-4.png)\n\n<Bottom />", "file_size": 284, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-share\\linux.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: LTPP公益LINUX服务器分享,LTPP公益LINUX服务器文档\ntitle: LTPP公益LINUX服务器分享\nindex: true\nicon: fab fa-linux\ncategory:\n  - LTPP公益LINUX服务器文档\n---\n\n<Share colorful />\n\n#### LTPP 公益服务器\n\n> [!tip]\n>\n> - 开机脚本路径：`/shell/start.sh`，用户进入服务器后可以创建此文件，里面的脚本内容会在开机时执行\n> - `root` 用户密码为 `ltpp`\n\n##### LTPP-SSH 一号服务器\n\n> [!tip]\n>\n> - 登录命令：ssh -p 60100 ltpp@linux.ltpp.vip（SSH 端口已于 2025/2/1 关闭）\n> - 登陆密码：ltpp（root 用户密码同登陆密码）\n> - 在线版本 VSCODE 访问地址：[点击打开](https://free-linux-1.ltpp.vip)\n> - 一共可用 4 个公网端口【60100-60103】\n> - 61002-61003 端口空闲，用户可自行创建服务（空闲端口需要联系站长配置对外域名）\n\n##### LTPP-SSH 二号服务器\n\n> [!tip]\n>\n> - 登录命令：ssh -p 60104 ltpp@linux.ltpp.vip（SSH 端口已于 2025/2/1 关闭）\n> - 登陆密码：ltpp（root 用户密码同登陆密码）\n> - 在线版本 VSCODE 访问地址：[点击打开](https://free-linux-2.ltpp.vip)\n> - 一共可用 4 个公网端口【60104-60107】\n> - 60106-60107 端口空闲，用户可自行创建服务（空闲端口需要联系站长配置对外域名）\n\n##### LTPP-SSH 三号服务器\n\n> [!tip]\n>\n> - 登录命令：ssh -p 60108 ltpp@linux.ltpp.vip（SSH 端口已于 2025/2/1 关闭）\n> - 登陆密码：ltpp（root 用户密码同登陆密码）\n> - 在线版本 VSCODE 访问地址：[点击打开](https://free-linux-3.ltpp.vip)\n> - 一共可用 4 个公网端口【60108-60111】\n> - 60108-60111 端口空闲，用户可自行创建服务（空闲端口需要联系站长配置对外域名）\n\n<Bottom />", "file_size": 1123, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-rust-web-server\\log.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 日志示例\ntitle: 日志示例\nindex: true\nicon: fas fa-file-alt\ncategory:\n  - 日志示例\n---\n\n<Share colorful />\n\n```php\n[2024-06-01 11:17:42]\nResource load fail => ./index.html\nError => Matched to hotlink protection\n\n\n[2024-06-01 11:17:42]\nResource load fail => ./index.html\nError => Matched to hotlink protection\n\n\n[2024-06-01 11:17:42]\nResource load fail => ./index.html\n\n\n[2024-06-01 11:17:42]\nResource load fail => ./index.html\n\n\n[2024-06-01 11:17:42]\nHttpRequest {\n    path: \"/\",\n    method: \"GET\",\n    headers: {\n        \"sec-ch-ua\": \"\\\"Microsoft Edge\\\";v=\\\"125\\\", \\\"Chromium\\\";v=\\\"125\\\", \\\"Not.A/Brand\\\";v=\\\"24\\\"\",\n        \"sec-ch-ua-platform\": \"\\\"Windows\\\"\",\n        \"sec-fetch-site\": \"none\",\n        \"sec-fetch-user\": \"?1\",\n        \"connection\": \"keep-alive\",\n        \"sec-ch-ua-mobile\": \"?0\",\n        \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0\",\n        \"host\": \"127.0.0.1\",\n        \"cookie\": \"SameSite=Lax; Hm_lvt_9793f42b498361373512340937deb2a0=1689155374; _ga=GA1.1.39230079.1707025003; _ga_69MPZE94D5=GS1.1.1707025002.1.1.1707026740.0.0.0; pma_lang=zh_CN; pma_theme=bootstrap; pmaUser-1=5RJrrwsVlvqY7uteEWcRoXI%2BvTKWWpA23SKZpX9BCDRw8Q17ueAcTXRd8Po%3D\",\n        \"accept-language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n        \"cache-control\": \"max-age=0\",\n        \"sec-fetch-dest\": \"document\",\n        \"accept-encoding\": \"gzip, deflate, br, zstd\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\",\n        \"sec-fetch-mode\": \"navigate\",\n    },\n    body: {},\n}\n\n[2024-06-01 11:17:42]\nResource load fail => ./index.html\n\n\n[2024-06-01 11:17:44]\nHttpRequest {\n    path: \"/_static/out/browser/serviceWorker.js\",\n    method: \"GET\",\n    headers: {\n        \"cookie\": \"SameSite=Lax; Hm_lvt_9793f42b498361373512340937deb2a0=1689155374; _ga=GA1.1.39230079.1707025003; _ga_69MPZE94D5=GS1.1.1707025002.1.1.1707026740.0.0.0; pma_lang=zh_CN; pma_theme=bootstrap; pmaUser-1=5RJrrwsVlvqY7uteEWcRoXI%2BvTKWWpA23SKZpX9BCDRw8Q17ueAcTXRd8Po%3D\",\n        \"host\": \"127.0.0.1\",\n        \"service-worker\": \"script\",\n        \"sec-fetch-site\": \"same-origin\",\n        \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0\",\n        \"connection\": \"keep-alive\",\n        \"cache-control\": \"max-age=0\",\n        \"accept\": \"*/*\",\n        \"sec-fetch-mode\": \"same-origin\",\n        \"referer\": \"http://127.0.0.1/_static/out/browser/serviceWorker.js\",\n        \"accept-encoding\": \"gzip, deflate, br, zstd\",\n        \"accept-language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n        \"sec-fetch-dest\": \"serviceworker\",\n    },\n    body: {},\n}\n\n[2024-06-01 11:17:44]\nResource load fail => ./_static/out/browser/serviceWorker.js\n\n\n[2024-06-01 11:17:44]\nHttpRequest {\n    path: \"/Version/getVersion\",\n    method: \"GET\",\n    headers: {\n        \"sec-fetch-site\": \"none\",\n        \"connection\": \"keep-alive\",\n        \"host\": \"localhost\",\n        \"cookie\": \"SameSite=Lax; NMTID=00O6oBSFUZ8KxSqKEY4tcbYD677Qa8AAAGKxntltw; pma_lang=zh_CN; pma_theme=bootstrap; pmaUser-1=c3t%2FwkS4xVdqQ2GLp7IkQdf9cc4d3ClA8ae5euc5DJ4EKvgSZv6qnjCaabI%3D; BD_HOME=1\",\n        \"cache-control\": \"max-age=0\",\n        \"sec-fetch-mode\": \"navigate\",\n        \"sec-ch-ua-mobile\": \"?0\",\n        \"accept-language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\",\n        \"user-agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0\",\n        \"sec-ch-ua\": \"\\\"Microsoft Edge\\\";v=\\\"125\\\", \\\"Chromium\\\";v=\\\"125\\\", \\\"Not.A/Brand\\\";v=\\\"24\\\"\",\n        \"accept\": \"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\",\n        \"sec-ch-ua-platform\": \"\\\"Windows\\\"\",\n        \"sec-fetch-user\": \"?1\",\n        \"upgrade-insecure-requests\": \"1\",\n        \"accept-encoding\": \"gzip, deflate, br, zstd\",\n        \"sec-fetch-dest\": \"document\",\n    },\n    body: {},\n}\n\n[2024-06-01 11:17:44]\nProxy url info => https://api.ltpp.vip:443/Version/getVersion?origin=proxy1\n\n\n[2024-06-01 11:17:44]\nProxy request info:\nGET https://api.ltpp.vip:443/Version/getVersion?origin=proxy1 HTTP/1.1\ncontent-type: application/x-www-form-urlencoded\nsec-fetch-site: none\nconnection: close\nhost: api.ltpp.vip\ncookie: SameSite=Lax; NMTID=00O6oBSFUZ8KxSqKEY4tcbYD677Qa8AAAGKxntltw; pma_lang=zh_CN; pma_theme=bootstrap; pmaUser-1=c3t%2FwkS4xVdqQ2GLp7IkQdf9cc4d3ClA8ae5euc5DJ4EKvgSZv6qnjCaabI%3D; BD_HOME=1\ncache-control: max-age=0\ncontent-length: 13\nsec-fetch-mode: navigate\nsec-ch-ua-mobile: ?0\naccept-language: zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\nuser-agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/125.0.0.0 Safari/537.36 Edg/125.0.0.0\nreferer: https://api.ltpp.vip:443/Version/getVersion\nsec-ch-ua: \"Microsoft Edge\";v=\"125\", \"Chromium\";v=\"125\", \"Not.A/Brand\";v=\"24\"\naccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7\nsec-ch-ua-platform: \"Windows\"\nsec-fetch-user: ?1\norigin: https://api.ltpp.vip:443/Version/getVersion\nupgrade-insecure-requests: 1\naccept-encoding: gzip, deflate, br, zstd\nsec-fetch-dest: document\n\norigin=proxy1\n\n\n[2024-06-01 11:17:45]\nRequest response info:\nHTTP/1.1 200 OK\ncontent-length: 90\naccess-control-allow-methods: GET, POST, PATCH\ncontent-encoding: gzip\naccess-control-allow-headers: Authorization,Requestid,Key,Content-Type,If-Match,If-Modified-Since,If-None-Match,If-Unmodified-Since,X-CSRF-TOKEN,X-Requested-With\ncontent-type: application/json\nconnection: close\naccess-control-allow-credentials: true\ngit: https://github.com/crates-dev/RUST-WEB-SERVE.git\naccess-control-allow-origin: https://api.ltpp.vip:443/Version/getVersion\naccess-control-max-age: 88888888\nserver: nginx\ndate: Sat, 01 Jun 2024 03:17:42 GMT\nstrict-transport-security: max-age=88888888\n\n\n{\"code\":1,\"version\":\"2.8.0\",\"ltpp_win_download_url\":\"\",\"ltpp_mac_download_url\":\"\",\"ltpp_apk_download_url\":\"\"}\n\n\n\n```\n\n<Bottom />", "file_size": 6317, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: License,LICENSE\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\norder: 4\n---\n\n<Share colorful />\n\nEnd User License Agreement (EULA)\nCopyright (c) 2024 尤雨东\nVersion: 1.0\nEffective Date: Permanent\n\n1. Definitions\n   Software: Refers to the program developed by the software developer, including all related files, resources, and updates.\n   Licensor: Refers to the copyright owner of the software.\n   User: Refers to any individual who downloads, installs, or uses the software.\n\n2. License Scope\n   The Licensor grants the User a non-exclusive, non-transferable, and non-sublicensable right to use the software for personal, non-commercial purposes only.\n   This license does not include ownership of the software. The Licensor retains all rights, titles, and interests in the software.\n\n3. Restrictions\n   The User must not modify, decompile, reverse engineer, disassemble, or attempt to obtain the source code of the software.\n   The User must not use the software for illegal activities.\n   The User must not distribute, lease, transfer, or sublicense the software unless explicitly permitted by the Licensor in writing.\n   The User must not remove or alter any copyright notices or branding information included in the software.\n\n4. Updates and Support\n   The Licensor may provide updates to the software but is under no obligation to offer maintenance, technical support, or upgrades.\n   Any updates provided will be subject to the terms of this agreement unless otherwise specified.\n\n5. Privacy\n   Use of the software may involve the collection and processing of user data, as governed by the Licensor's privacy policy (if applicable).\n\n6. Disclaimer\n   The software is provided \"as is\" without any express or implied warranties, including but not limited to warranties of merchantability, fitness for a particular purpose, and non-infringement.\n   The Licensor shall not be liable for any direct or indirect damages arising from the use or inability to use the software.\n\n7. Termination\n   The Licensor reserves the right to terminate this agreement immediately if the User breaches any of its terms.\n   Upon termination, the User must delete all copies of the software and cease any further use.\n\n8. Miscellaneous\n   If any provision of this agreement is deemed invalid or unenforceable, the remaining provisions shall remain in full force and effect.\n\nThis agreement constitutes the entire agreement between the User and the Licensor regarding the software and supersedes all prior communications and agreements.\n\n<Bottom />", "file_size": 2589, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\ltpp-git.yml", "language": "yaml", "content": "image: ccr.ccs.tencentyun.com/linux_environment/debian:1.0.0\n\nvariables:\n  LTPP: \"LTPP\"\n\npages:\n  stage: deploy\n  environment: production\n  publish: docs\n  script:\n    - echo \"The site will be deployed to $CI_PAGES_URL\"     \n    - pnpm i\n    - pnpm run build\n  artifacts:\n    paths:\n      - docs\n  rules:\n    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH", "file_size": 354, "extension": ".yml"}
{"file_path": "training_sources\\ltpp-docs\\src\\development-standards\\rust.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Rust开发规范,development-standards,rust\ntitle: Rust开发规范\nindex: true\nicon: book\ncategory:\n  - development-standards\n  - rust\ndir:\n  order: 1\n---\n\n<Share colorful />\n\n## 命名\n\n- 变量名使用蛇形命名法\n- 常量名使用全大写字母，单词之间用下划线分隔\n- 函数名使用蛇形命名法\n- 结构体名使用大驼峰命名法\n- 枚举名使用大驼峰命名法\n- 模块名使用蛇形命名法\n- 宏名使用蛇形命名法\n\n## Package\n\n- `lib` 项目包在根 `crate` 导入依赖，子模块引入根 `crate`\n- `bin` 项目包在各自 `mod` 导入依赖\n\n## Cargo.lock\n\n- `lib` 项目不需要上传 `lock` 文件\n- `bin` 项目需要上传 `lock` 文件\n\n## Monorepo\n\n- 需要尽可能拆分子 `crate`\n\n## 目录\n\n- 目录名根据功能划分，例如 `utils` 等\n- 目录下文件名根据关键字划分，例如 `fn.rs, const.rs, struct.rs, enum.rs` 等\n\n## 导入\n\n- 优先导入顺序：pub use、pub(crate)、pub(super)\n- 其次导入顺序：本地库、标准库、外部库、单元测试独享的库\n\n**例如**\n\n```rust\npub(crate) mod cfg;\npub(crate) mod config;\npub(crate) mod context;\npub(crate) mod error;\npub(crate) mod handler;\npub(crate) mod middleware;\npub(crate) mod route;\npub(crate) mod server;\n\npub use context::*;\npub use error::*;\npub use handler::*;\npub use server::*;\n\npub use http_type::*;\n\npub(crate) use config::*;\npub(crate) use middleware::*;\npub(crate) use route::*;\n\npub(crate) use core::hash::BuildHasherDefault;\npub(crate) use std::{\n    collections::HashMap,\n    error::Error as StdError,\n    fmt::{self, Display},\n    future::Future,\n    net::SocketAddr,\n    panic::{PanicHookInfo, set_hook},\n    pin::Pin,\n    sync::Arc,\n    time::Duration,\n};\n\npub(crate) use lombok_macros::*;\npub(crate) use serde::de::DeserializeOwned;\npub(crate) use tokio::{\n    net::TcpListener,\n    sync::{RwLockReadGuard, RwLockWriteGuard},\n    task::yield_now,\n};\n```\n\n<Bottom />", "file_size": 1557, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\component\\appreciate.vue", "language": "vue", "content": "<template>\n  <div>\n    <div class=\"hint-container tip\">\n      <p class=\"hint-container-title\">赞赏</p>\n      <p>\n        每一行代码都承载着我对技术的热爱与执着，每一个项目都是我在深夜里与键盘的对话。作为一名<strong>独立开发者</strong>，我用心雕琢着每一个功能，希望能为这个世界带来一些微小而美好的改变。\n      </p>\n      <p>\n        如果这些项目曾经帮助过您，或者您愿意支持一个在代码世界里默默耕耘的人，<strong>您的每一份赞赏都是对我最温暖的鼓励</strong>。不论金额多少，都是您对我做开源事业的认可，也是我继续前行的动力。\n      </p>\n      <p>感谢您的善意与支持，愿我们都能在各自的道路上闪闪发光。✨</p>\n      <div class=\"pay-wrap\">\n        <div class=\"wechat-pay\">\n          <p>微信支付</p>\n          <a id=\"微信支付\" href=\"#微信支付\">\n            <figure>\n              <img\n                src=\"/img/wechat-pay.png\"\n                alt=\"\"\n                width=\"180\"\n                tabindex=\"0\"\n                loading=\"lazy\"\n                photo-swipe=\"\"\n                style=\"cursor: zoom-in\"\n              />\n              <figcaption></figcaption></figure\n          ></a>\n        </div>\n        <div class=\"alipay-pay\">\n          <p>支付宝支付</p>\n          <a id=\"支付宝支付\" href=\"#支付宝支付\">\n            <figure id=\"支付宝支付\">\n              <img\n                src=\"/img/alipay-pay.jpg\"\n                alt=\"\"\n                width=\"180\"\n                tabindex=\"0\"\n                loading=\"lazy\"\n                photo-swipe=\"\"\n                style=\"cursor: zoom-in\"\n              />\n              <figcaption></figcaption></figure\n          ></a>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"appreciation-list\">\n      <h3>赞赏记录</h3>\n      <table>\n        <thead>\n          <tr>\n            <th>赞赏者</th>\n            <th>金额 (元)</th>\n            <th>时间</th>\n            <th>方式</th>\n          </tr>\n        </thead>\n        <tbody>\n          <tr v-for=\"item in sortedList\" :key=\"item.time\">\n            <td>{{ item.name }}</td>\n            <td>{{ item.money.toFixed(2) }}</td>\n            <td>{{ item.time }}</td>\n            <td>{{ item.app }}</td>\n          </tr>\n        </tbody>\n      </table>\n    </div>\n  </div>\n</template>\n\n<script>\nexport default {\n  data() {\n    const list = [\n      {\n        name: 'H*L',\n        money: 20,\n        time: '2024.10.21 9:51:47',\n        app: '微信',\n      },\n      {\n        name: 's*i',\n        money: 52,\n        time: '2025.07.25 13:16:37',\n        app: '微信',\n      },\n      {\n        name: 's*i',\n        money: 52,\n        time: '2025.07.25 19:58:08',\n        app: '微信',\n      },\n    ];\n\n    const sortedList = list.sort((a, b) => {\n      const dateA = new Date(a.time.replace(/\\./g, '/'));\n      const dateB = new Date(b.time.replace(/\\./g, '/'));\n      return dateB - dateA;\n    });\n\n    return {\n      sortedList,\n    };\n  },\n};\n</script>\n\n<style scoped>\n.pay-wrap {\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-items: flex-start;\n  gap: 4rem;\n  flex-wrap: wrap;\n  margin: 1.5rem 0;\n}\n\n.wechat-pay,\n.alipay-pay {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: flex-start;\n  border-radius: 12px;\n  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n  transition: transform 0.3s ease, box-shadow 0.3s ease;\n  min-width: 160px;\n  min-height: 280px;\n  padding: 1.5rem 1rem;\n}\n\n.wechat-pay p,\n.alipay-pay p {\n  font-size: 1.1rem;\n  font-weight: 600;\n  margin-bottom: 1rem;\n  color: #333;\n}\n\n.wechat-pay p {\n  color: #07c160;\n}\n\n.alipay-pay p {\n  color: #1677ff;\n}\n\n.wechat-pay img,\n.alipay-pay img {\n  border-radius: 8px;\n  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);\n  transition: transform 0.3s ease;\n}\n\n@media (max-width: 768px) {\n  .pay-wrap {\n    flex-direction: column;\n    gap: 1.5rem;\n    align-items: center;\n  }\n\n  .wechat-pay,\n  .alipay-pay {\n    min-width: 240px;\n    max-width: 280px;\n  }\n}\n\n.appreciation-list {\n  width: 100%;\n  margin-top: 2rem;\n  background-color: #f8f9fa;\n  border-radius: 12px;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);\n  overflow-x: auto;\n}\n\n.appreciation-list h3 {\n  text-align: center;\n  margin-bottom: 1.5rem;\n  font-size: 1.5rem;\n  color: #333;\n  border-bottom: 2px solid #e9ecef;\n  padding-bottom: 0.5rem;\n}\n\n.appreciation-list table {\n  width: 100%;\n  text-align: center;\n  display: table;\n}\n\n.appreciation-list th,\n.appreciation-list td {\n  padding: 0.75rem 1rem;\n  border-bottom: 1px solid #dee2e6;\n  color: #495057;\n  text-align: center;\n  vertical-align: middle;\n}\n\n.appreciation-list th {\n  background-color: #e9ecef;\n  font-weight: 600;\n  color: #212529;\n}\n\n.appreciation-list tbody tr:nth-child(odd) {\n  background-color: #ffffff;\n}\n\n.appreciation-list tbody tr:hover {\n  background-color: #e9ecef;\n}\n</style>", "file_size": 4523, "extension": ".vue"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp-rust-get-proxy-request\\license.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: License,LICENSE\ntitle: License\nicon: gears\ncategory:\n  - LICENSE\n---\n\n<Share colorful />\n\nMIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", "file_size": 1206, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\sh\\install.sh", "language": "shell", "content": "#!/bin/bash\npnpm --registry https://registry.npmmirror.com install any-touch;\npnpm i vuepress-vite -g;", "file_size": 102, "extension": ".sh"}
{"file_path": "training_sources\\ltpp-docs\\tsconfig.json", "language": "json", "content": "{\n  \"compilerOptions\": {\n    \"module\": \"NodeNext\",\n    \"moduleResolution\": \"NodeNext\",\n    \"target\": \"ES2022\"\n  },\n  \"include\": [\n    \"src/.vuepress/**/*.ts\",\n    \"src/.vuepress/**/*.vue\"\n  ],\n  \"exclude\": [\n    \"node_modules\"\n  ]\n}", "file_size": 232, "extension": ".json"}
{"file_path": "training_sources\\ltpp-docs\\component\\github-metrics.vue", "language": "vue", "content": "<template>\n  <div class=\"github-metrics\">\n    <div class=\"metrics-container\">\n      <div class=\"metrics-header\">\n        <h3 class=\"metrics-title\">GitHub 统计</h3>\n        <div class=\"metrics-icon\">\n          <svg\n            width=\"20\"\n            height=\"20\"\n            viewBox=\"0 0 24 24\"\n            fill=\"none\"\n            xmlns=\"http://www.w3.org/2000/svg\"\n          >\n            <path\n              d=\"M12 0C5.374 0 0 5.373 0 12 0 17.302 3.438 21.8 8.207 23.387c.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23A11.509 11.509 0 0112 5.803c1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576C20.566 21.797 24 17.3 24 12c0-6.627-5.373-12-12-12z\"\n              fill=\"currentColor\"\n            />\n          </svg>\n        </div>\n      </div>\n      <div class=\"metrics-content\">\n        <div v-if=\"loading\" class=\"loading\">\n          <div class=\"loading-spinner\"></div>\n          <span>正在加载统计数据...</span>\n        </div>\n        <div v-else-if=\"error\" class=\"error\">\n          <span>{{ error }}</span>\n          <button @click=\"retryLoad\" class=\"retry-btn\">重试</button>\n        </div>\n        <div v-else class=\"metrics-image-container\">\n          <div class=\"image-wrapper\" :class=\"{ 'image-loaded': imageLoaded }\">\n            <img\n              :src=\"metricsUrl\"\n              alt=\"GitHub 统计图表\"\n              class=\"metrics-image no-click\"\n              :class=\"{ 'fade-in': imageLoaded }\"\n              @load=\"onImageLoad\"\n              @error=\"onImageError\"\n            />\n            <div v-if=\"!imageLoaded\" class=\"image-placeholder\">\n              <div class=\"placeholder-spinner\"></div>\n              <span class=\"placeholder-text\">加载图表中...</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport NoClickMixin from './mixins/no-click-mixin.js';\n\nconst metricsUrl = 'https://eastspire.github.io/eastspire/metrics.svg';\n\nexport default {\n  name: 'GitHubMetrics',\n  mixins: [NoClickMixin],\n  data() {\n    return {\n      metricsUrl: metricsUrl,\n      loading: true,\n      error: null,\n      imageLoaded: false,\n    };\n  },\n  mounted() {\n    this.loadMetrics();\n  },\n  methods: {\n    loadMetrics() {\n      this.loading = false;\n      this.error = null;\n      this.imageLoaded = false;\n    },\n    onImageLoad() {\n      this.loading = false;\n      this.error = null;\n      this.imageLoaded = true;\n    },\n    onImageError() {\n      this.loading = false;\n      this.error = '加载 GitHub 统计图表失败';\n      this.imageLoaded = false;\n    },\n    retryLoad() {\n      this.loading = true;\n      this.error = null;\n      this.imageLoaded = false;\n      this.$nextTick(() => {\n        this.loadMetrics();\n        const img = this.$el.querySelector('.metrics-image');\n        if (img) {\n          img.src = this.metricsUrl + '?t=' + Date.now();\n        }\n      });\n    },\n  },\n};\n</script>\n\n<style scoped>\n.github-metrics {\n  margin: 1rem 0;\n}\n\n.metrics-container {\n  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);\n  border-radius: 12px;\n  padding: 1.5rem;\n  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);\n  border: 1px solid #e1e8ed;\n}\n\n.metrics-header {\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.75rem;\n  margin-bottom: 1.5rem;\n}\n\n.metrics-title {\n  font-size: 1.25rem;\n  font-weight: 600;\n  color: #24292f;\n  margin: 0;\n}\n\n.metrics-icon {\n  color: #24292f;\n  display: flex;\n  align-items: center;\n}\n\n.metrics-content {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 200px;\n}\n\n.loading {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 1rem;\n  color: #666;\n}\n\n.loading-spinner {\n  width: 32px;\n  height: 32px;\n  border: 3px solid #f3f3f3;\n  border-top: 3px solid #24292f;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n}\n\n@keyframes spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n\n.error {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 1rem;\n  color: #d73a49;\n  text-align: center;\n}\n\n.retry-btn {\n  padding: 0.5rem 1rem;\n  background: #24292f;\n  color: white;\n  border: none;\n  border-radius: 6px;\n  cursor: pointer;\n  font-size: 0.9rem;\n  transition: background-color 0.2s ease;\n}\n\n.retry-btn:hover {\n  background: #1c2128;\n}\n\n.metrics-image-container {\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n\n.image-wrapper {\n  position: relative;\n  width: 100%;\n  min-height: 400px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  background: rgba(255, 255, 255, 0.5);\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.image-wrapper.image-loaded {\n  min-height: auto;\n  background: transparent;\n}\n\n.metrics-image {\n  max-width: 100%;\n  height: auto;\n  border-radius: 8px;\n  opacity: 0;\n  transition: opacity 0.5s ease-in-out;\n}\n\n.metrics-image.fade-in {\n  opacity: 1;\n}\n\n.image-placeholder {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 1rem;\n  color: #666;\n  z-index: 1;\n}\n\n.placeholder-spinner {\n  width: 24px;\n  height: 24px;\n  border: 2px solid #f3f3f3;\n  border-top: 2px solid #24292f;\n  border-radius: 50%;\n  animation: spin 1s linear infinite;\n}\n\n.placeholder-text {\n  font-size: 0.9rem;\n  color: #888;\n}\n\n@media (max-width: 768px) {\n  .metrics-container {\n    padding: 1rem;\n    margin: 0 0.5rem;\n  }\n\n  .metrics-title {\n    font-size: 1.1rem;\n  }\n\n  .metrics-header {\n    margin-bottom: 1rem;\n  }\n\n  .metrics-content {\n    min-height: 150px;\n  }\n\n  .image-wrapper {\n    min-height: 300px;\n  }\n}\n\n@media (max-width: 480px) {\n  .metrics-container {\n    padding: 0.75rem;\n  }\n\n  .metrics-title {\n    font-size: 1rem;\n  }\n\n  .image-wrapper {\n    min-height: 250px;\n  }\n\n  .placeholder-text {\n    font-size: 0.8rem;\n  }\n}\n</style>", "file_size": 6299, "extension": ".vue"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\LTPP-EXE\\electron-log.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: Electron版本日志示例\nindex: true\nicon: fas fa-file-alt\ncategory:\n  - Electron\n  - 日志\n  - 示例\n---\n\n<Share colorful />\n\n```php\n[2024-06-21T09:05:34.819Z]\nRequest URL => https://api.ltpp.vip/Version/getVersion\n\n[2024-06-21T09:05:34.891Z]\nhttps://api.ltpp.vip/Version/getVersion => {\n  \"id\": 104,\n  \"url\": \"https://api.ltpp.vip/Version/getVersion\",\n  \"method\": \"POST\",\n  \"timestamp\": 1718960734890.9011,\n  \"resourceType\": \"xhr\",\n  \"ip\": \"127.0.0.1\",\n  \"fromCache\": false,\n  \"statusLine\": \"HTTP/1.1 200\",\n  \"statusCode\": 200,\n  \"responseHeaders\": {\n    \"access-control-allow-credentials\": [\n      \"true\"\n    ],\n    \"access-control-allow-headers\": [\n      \"Authorization,Requestid,Key,Content-Type,If-Match,If-Modified-Since,If-None-Match,If-Unmodified-Since,X-CSRF-TOKEN,X-Requested-With\"\n    ],\n    \"access-control-allow-methods\": [\n      \"GET, POST, PATCH\"\n    ],\n    \"access-control-allow-origin\": [\n      \"https://www.ltpp.vip\"\n    ],\n    \"access-control-max-age\": [\n      \"88888888\"\n    ],\n    \"content-length\": [\n      \"109\"\n    ],\n    \"content-type\": [\n      \"application/json\"\n    ],\n    \"date\": [\n      \"Fri, 21 Jun 2024 09:05:36 GMT\"\n    ],\n    \"server\": [\n      \"nginx\"\n    ],\n    \"strict-transport-security\": [\n      \"max-age=88888888\"\n    ]\n  },\n  \"frame\": {},\n  \"webContents\": {\n    \"ipc\": {\n      \"_events\": {},\n      \"_eventsCount\": 1,\n      \"_invokeHandlers\": {}\n    },\n    \"_events\": {},\n    \"_eventsCount\": 14\n  },\n  \"webContentsId\": 2,\n  \"referrer\": \"https://www.ltpp.vip/\",\n  \"error\": \"net::OK\"\n}\n\n[2024-06-21T09:05:40.163Z]\nRequest URL => https://api.ltpp.vip/Version/getVersion\n\n[2024-06-21T09:05:40.236Z]\nhttps://api.ltpp.vip/Version/getVersion => {\n  \"id\": 105,\n  \"url\": \"https://api.ltpp.vip/Version/getVersion\",\n  \"method\": \"POST\",\n  \"timestamp\": 1718960740235.86,\n  \"resourceType\": \"xhr\",\n  \"ip\": \"127.0.0.1\",\n  \"fromCache\": false,\n  \"statusLine\": \"HTTP/1.1 200\",\n  \"statusCode\": 200,\n  \"responseHeaders\": {\n    \"access-control-allow-credentials\": [\n      \"true\"\n    ],\n    \"access-control-allow-headers\": [\n      \"Authorization,Requestid,Key,Content-Type,If-Match,If-Modified-Since,If-None-Match,If-Unmodified-Since,X-CSRF-TOKEN,X-Requested-With\"\n    ],\n    \"access-control-allow-methods\": [\n      \"GET, POST, PATCH\"\n    ],\n    \"access-control-allow-origin\": [\n      \"https://www.ltpp.vip\"\n    ],\n    \"access-control-max-age\": [\n      \"88888888\"\n    ],\n    \"content-length\": [\n      \"109\"\n    ],\n    \"content-type\": [\n      \"application/json\"\n    ],\n    \"date\": [\n      \"Fri, 21 Jun 2024 09:05:42 GMT\"\n    ],\n    \"server\": [\n      \"nginx\"\n    ],\n    \"strict-transport-security\": [\n      \"max-age=88888888\"\n    ]\n  },\n  \"frame\": {},\n  \"webContents\": {\n    \"ipc\": {\n      \"_events\": {},\n      \"_eventsCount\": 1,\n      \"_invokeHandlers\": {}\n    },\n    \"_events\": {},\n    \"_eventsCount\": 14\n  },\n  \"webContentsId\": 2,\n  \"referrer\": \"https://www.ltpp.vip/\",\n  \"error\": \"net::OK\"\n}\n```\n\n<Bottom />", "file_size": 2972, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\route.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 路由,hyperlane,web,rust,config,route\ntitle: 路由\nindex: true\nicon: fas fa-route\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - route\norder: 10\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架使用 `route` 接口进行路由注册，第一个参数是路由名称，第二个参数是路由处理函数，\n> 框架支持动态路由，更多路由详细使用请参考[官方文档](../usage-introduction/route.md)，\n> 路由处理函数参数类型参考 [controller-data 文档](../type/controller-data.md)。\n\n### 注册路由\n\n```rust\n// 省略 server 创建\nserver.route(\"路由名称\", |ctx: Context| async move {\n    // code\n}).await;\n```\n\n<Bottom />", "file_size": 550, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\LTPP-EXE\\electron-dev.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: Electron版本开发指南\nindex: true\nicon: fas fa-tools\ncategory:\n  - Electron\n  - 开发指南\n---\n\n## Electron BrowserWindow 配置\n\n```bash\nwidth Integer - 窗口宽度,单位像素. 默认是 800 .\n\nheight Integer - 窗口高度,单位像素. 默认是 600 .\n\nx Integer - 窗口相对于屏幕的左偏移位置.默认居中. y Integer - 窗口相对于屏幕的顶部偏移位置.默认居中. useContentSize Boolean - width 和 height 使用web网页size, 这意味着实际窗口的size应该包括窗口框架的 size，稍微会大一点，默认为 false . center\n\nBoolean - 窗口屏幕居中. minWidth Integer - 窗口最小宽度，默认为 0 .\n\nminHeight Integer - 窗口最小高度，默认为 0 .\n\nmaxWidth Integer - 窗口最大宽度，默认无限制.\n\nmaxHeight Integer - 窗口最大高度，默认无限制.\n\nresizable Boolean - 是否可以改变窗口size，默认为 true .\n\nmovable Boolean - 窗口是否可以拖动. 在 Linux 上无效. 默认为 true .\n\nminimizable Boolean - 窗口是否可以最小化. 在 Linux 上无效. 默认为 true .\n\nmaximizable Boolean - 窗口是否可以最大化. 在 Linux 上无效. 默认为 true .\n\nclosable Boolean - 窗口是否可以关闭. 在 Linux上无效. 默认为 true .\n\nalwaysOnTop Boolean - 窗口是否总是显示在其他窗口之前. 在 Linux上无效. 默认为 false .\n\nfullscreen Boolean - 窗口是否可以全屏幕. 当明确设置值为When false ，全屏化按钮将会隐藏，在 macOS 将禁用. 默认 false .\n\nfullscreenable Boolean - 在 macOS 上，全屏化按钮是否可用，默认为 true . skipTaskbar Boolean - 是否在任务栏中显示窗口. 默认是 false .\n\nkiosk Boolean - kiosk 方式. 默认为 false . title String - 窗口默认title. 默认 \"Electron\" .\n\nicon NativeImage - 窗口图标, 如果不设置，窗口将使用可用的默认图标.\n\nshow Boolean - 窗口创建的时候是否显示. 默认为 true .\n\nframe Boolean - 指定 false 来创建一个 Frameless Window. 默认为 true .\n\nacceptFirstMouse Boolean - 是否允许单击web view来激活窗口 . 默认为 false .\n\ndisableAutoHideCursor Boolean - 当 typing 时是否隐藏鼠标.默认 false .\n\nautoHideMenuBar Boolean - 除非点击 Alt ，否则隐藏菜单栏.默认为 false .\n\nenableLargerThanScreen Boolean - 是否允许允许改变窗口大小大于屏幕. 默认是 false .\n\nbackgroundColor String -窗口的 background color 值为十六进制,如 #66CD00 或 #FFF 或 #80FFFFFF (支持透明 度). 默认为在 Linux和 Windows 上为 #000 (黑色) , Mac上为 #FFF (或透明).\n\nhasShadow Boolean - 窗口是否有阴影. 只在 macOS 上有效. 默认为 true .\n\ndarkTheme Boolean - 为窗口使用 dark 主题, 只在一些拥有 GTK+3 桌面环境上有效. 默认为 false .\n\ntransparent Boolean - 窗口 透明. 默认为 false .\n\ntype String - 窗口type, 默认普通窗口. 下面查看更多. titleBarStyle String - 窗口标题栏样式. 下面查看更多.\n\nwebPreferences Object - 设置界面特性. 下面查看更多.\n```\n\n## Electron build 参数\n\n```shell\n--mac, -m, -o, --macos   Build for macOS,                             [array]\n--linux, -l             Build for Linux                               [array]\n--win, -w, --windows     Build for Windows                             [array]\n--x64                   Build for x64 (64 位安装包)                     [boolean]\n--ia32                   Build for ia32(32 位安装包)                     [boolean]\n--armv7l                 Build for armv7l                             [boolean]\n--arm64                 Build for arm64                               [boolean]\n--dir                   Build unpacked dir. Useful to test.           [boolean]\n--prepackaged, --pd     预打包应用程序的路径（以可分发的格式打包）\n--projectDir, --project 项目目录的路径。 默认为当前工作目录。\n--config, -c             配置文件路径，默认为`electron-builder.yml`（或`js`，或`js5`)\n```\n\n<Bottom />", "file_size": 2862, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\connected-hook.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 连接钩子,clone,web,rust,config,connected-hook\ntitle: 连接钩子\nindex: true\nicon: fas fa-link\ncategory:\n  - clone\n  - web\n  - rust\n  - config\n  - connected-hook\norder: 5\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置连接回调，此方法会在 `http` 连接建立 和 `websocket` 握手成功后调用，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `connected_hook` 将不会执行。\n\n## 配置单个连接回调\n\n```rust\nserver.connected_hook(|ctx: Context| async move {\n    // 处理\n}).await;\n```\n\n## 配置多个连接回调\n\n> [!tip]\n>\n> 根据注册顺序进行调用。\n\n```rust\nserver.connected_hook(|ctx: Context| async move {\n    // 1\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 2\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 3\n}).await;\nserver.connected_hook(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n<Bottom />", "file_size": 826, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\middleware.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 中间件,hyperlane,web,rust,config,middleware\ntitle: 中间件\nindex: true\nicon: fas fa-layer-group\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - middleware\norder: 9\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持请求中间件和响应中间件，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的逻辑将不会执行。\n\n### 请求中间件\n\n#### 注册请求中间件\n\n```rust\n// 省略 server 创建\nserver.request_middleware(|ctx: Context| async move {\n    // code\n}).await;\n```\n\n#### 注册多个请求中间件\n\n```rust\n// 省略 server 创建\nserver.request_middleware(|ctx: Context| async move {\n    // 1\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 2\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 3\n}).await;\nserver.request_middleware(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n### 设置响应中间件\n\n#### 注册响应中间件\n\n```rust\n// 省略 server 创建\nserver.response_middleware(|ctx: Context| async move {\n    // code\n}).await;\n```\n\n#### 注册多个响应中间件\n\n```rust\n// 省略 server 创建\nserver.response_middleware(|ctx: Context| async move {\n    // 1\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 2\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 3\n}).await;\nserver.response_middleware(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n<Bottom />", "file_size": 1297, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\server.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 创建 Server,hyperlane,web,rust,config,server\ntitle: 创建 Server\nindex: true\nicon: fas fa-server\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - server\norder: 3\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架创建服务方式如下，需要调用 `run` 方法，服务才会正常运行。\n>\n> `ServerHook` 提供了等待框架运行完成和框架停止运行的 `hook`\n>\n> - `wait`: `server.run().await.unwrap_or_default().wait()` 实现等待框架运行完成\n> - `shutdown`: `server.run().await.unwrap_or_default().shutdown()` 实现框架停止运行\n\n## Server::new\n\n```rust\nlet server: Server = Server::new().await;\nlet result: ServerResult<ServerHook> = server.run().await;\nprintln!(\"Server result: {:?}\", result);\nlet _ = std::io::Write::flush(&mut std::io::stderr());\n```\n\n## Server::from\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nlet server: Server = Server::from(config).await;\nlet result: ServerResult<ServerHook> = server.run().await;\nprintln!(\"Server result: {:?}\", result);\nlet _ = std::io::Write::flush(&mut std::io::stderr());\n```\n\n<Bottom />", "file_size": 1025, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\runtime.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 运行时,hyperlane,web,rust,config,runtime\ntitle: 运行时\nindex: true\nicon: fas fa-running\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - runtime\norder: 1\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架基于 `tokio`，可以参考 `tokio` [官方文档](https://docs.rs/tokio/latest/tokio/) 进行配置。\n\n### 快速配置\n\n```rust\n#[tokio::main]\nasync fn main() {}\n```\n\n### 精细化配置\n\n```rust\nfn main() {\n    let thread_count: usize = get_thread_count();\n    let runtime: tokio::runtime::Runtime = tokio::runtime::Builder::new_multi_thread()\n        .worker_threads(thread_count)\n        .thread_stack_size(2097152)\n        .max_blocking_threads(5120)\n        .max_io_events_per_tick(5120)\n        .enable_all()\n        .build()\n        .unwrap();\n    runtime().block_on(async move {}).unwrap();\n}\n```\n\n<Bottom />", "file_size": 835, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\help\\explain.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 说明,hyperlane,web,rust,help,explain\ntitle: 说明\nindex: true\nicon: fas fa-info-circle\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - help\n  - explain\norder: 1\n---\n\n<Share colorful />\n\n### 框架说明\n\n> [!tip]\n>\n> `hyperlane` 仅提供最核心的功能(路由、中间件、异常处理、请求处理等基础核心的功能)。其余功能支持全部复用 `crate.io` 生态，这意味着你可以在 `hyperlane` 里使用 `crate.io` 里的第三方库，在 `hyperlane` 里集成他们是非常容易的事情。\n\n### 推荐阅读\n\n> [!tip]\n> 推荐阅读 [点击阅读](../../hyperlane-utils/README.md) 。\n\n<Bottom />", "file_size": 483, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\middleware\\timeout.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 超时中间件\nindex: true\nicon: fas fa-stopwatch\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - middleware\n  - timeout\norder: 2\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持超时中间件，用于处理请求超时的情况。\n\n### 超时中间件\n\n```rust\nuse hyperlane::{\n    tokio::{\n        spawn,\n        time::{sleep, timeout},\n    },\n    *,\n};\nuse std::time::Duration;\n\nasync fn http_version_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1).await;\n}\n\nasync fn timeout_middleware(ctx: Context) {\n    spawn(async move {\n        timeout(Duration::from_millis(100), async move {\n            ctx.set_response_status_code(504)\n                .await\n                .set_response_body(\"timeout\")\n                .await\n                .send()\n                .await\n                .unwrap();\n            ctx.aborted().await;\n        })\n        .await\n        .unwrap();\n    });\n}\n\nasync fn index(ctx: Context) {\n    sleep(Duration::from_secs(1)).await;\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(http_version_middleware)\n        .await\n        .request_middleware(timeout_middleware)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n<Bottom />", "file_size": 1552, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\help\\build.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 构建,hyperlane,web,rust,help,install\ntitle: 构建\nindex: true\nicon: fas fa-box-open\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - help\n  - install\norder: 4\n---\n\n<Share colorful />\n\n### 构建\n\n```sh\ncargo build --release\n```\n\n### 使用 `docker` 进行静态链接\n\n#### Linux / MacOS\n\n```sh\ndocker run --rm -v \"$(pwd):/tmp/cargo_build\" ccr.ccs.tencentyun.com/linux_environment/cargo:1.0.0 /bin/bash -c \"source ~/.bashrc && cd /tmp/cargo_build && RUSTFLAGS='-C target-feature=-crt-static' cargo build --release --target x86_64-unknown-linux-gnu\"\n```\n\n#### Windows\n\n```sh\ndocker run --rm -v \"${pwd}:/tmp/cargo_build\" ccr.ccs.tencentyun.com/linux_environment/cargo:1.0.0 /bin/bash -c \"source ~/.bashrc && cd /tmp/cargo_build && RUSTFLAGS='-C target-feature=-crt-static' cargo build --release --target x86_64-unknown-linux-gnu\"\n```\n\n<Bottom />", "file_size": 871, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\http-hook.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: HTTP钩子,clone,web,rust,config,http-hook,http_hook\ntitle: HTTP钩子\nindex: true\nicon: fas fa-anchor\ncategory:\n  - clone\n  - web\n  - rust\n  - config\n  - http-hook\n  - http_hook\norder: 6\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置是否启用 `http` 内部处理钩子，默认启用，\n> 值得一提的是此配置支持动态路由设置。\n\n## 启用框架内部 `http` 处理\n\n### 静态路由\n\n```rust\nserver.enable_http_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.enable_http_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.enable_http_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n## 禁用 `http` 内部处理\n\n### 静态路由\n\n```rust\nserver.disable_http_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.disable_http_hook(\"/路由/:id\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.disable_http_hook(\"/路由/:number:\\\\d+\").await;\n```\n\n<Bottom />", "file_size": 809, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\panic-hook.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 恐慌钩子,clone,web,rust,config,panic-hook\ntitle: 恐慌钩子\nindex: true\nicon: fas fa-bug\ncategory:\n  - clone\n  - web\n  - rust\n  - config\n  - panic-hook\norder: 4\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架内部会对 `panic` 进行捕获，用户可通过钩子进行设置（不设置，框架默认不处理），\n> 需要注意的是，触发 `panic` 后在执行 `panic_hook` 之前，框架会重置 `aborted` 状态，\n> 支持多次注册，触发 `panic` 会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `panic_hook` 将不会执行。\n\n```rust\nserver.panic_hook(|cxt: Context| {\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    // do something\n}).await;\n```\n\n<Bottom />", "file_size": 599, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\ltpp\\LTPP-APP\\dev-build.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 开发构建说明\nindex: true\nicon: fas fa-tools\ncategory:\n  - LTPP-在线开发平台APP\n  - APP\n---\n\n## 查看设备命令如下\n\n```shell\nflutter devices\n```\n\n```shell\n# 输出类似如下，这里选择 21051182C\n21051182C (mobile) • 670e4f20 • android-arm64  • Android 13 (API 33)\nWindows (desktop)• windows  • windows-x64    • Microsoft Windows [版本 10.0.19045.4651]\nChrome (web)     • chrome   • web-javascript • Google Chrome 126.0.6478.127\nEdge (web)       • edge     • web-javascript • Microsoft Edge 126.0.2592.102\n```\n\n## 运行命令如下\n\n```shell\nflutter run -d 21051182C\n```\n\n## 构建 `APK` 命令如下\n\n```shell\nflutter build apk\n```\n\n## Execution failed for task ‘:path_provider:verifyReleaseResources’.\n\n> [!tip]\n> 看到了 path_provider ，应该是 path_provider 的问题。解决办法就是修改 path_provider 的 build.gradle 中的 compileSdkVersion 版本为 28，就可以成功了。\n> 该文件的目录是在 flutter 的安装目录 C:\\Users\\14915\\AppData\\Local\\Pub\\Cache\\hosted\\pub.flutter-io.cn\\path_provider-0.4.1\\android\\build.gradle\n\n## Flutter 卡在 Running Gradle task ‘assembleDebug‘... 的解决方法\n\n> [!tip]\n> flutter 项目的 android 目录中，项目的 build.gradle\n\n```dart\n    maven { url 'https://maven.aliyun.com/repository/google' }\n    maven { url 'https://maven.aliyun.com/repository/jcenter' }\n    maven { url 'https://maven.aliyun.com/nexus/content/groups/public'}\n    google()\n    mavenCentral()\n```\n\n> [!tip]\n> flutter 的 sdk 中进行设置，处于此目录下 C:\\fluttersdk\\packages\\flutter_tools\\gradle\\flutter.gradle\n\n```dart\nbuildscript {\n    repositories {\n        maven { url 'https://maven.aliyun.com/repository/google' }\n        maven { url 'https://maven.aliyun.com/repository/jcenter' }\n        maven { url 'https://maven.aliyun.com/nexus/content/groups/public' }\n    }\n    dependencies {\n        classpath 'com.android.tools.build:gradle:3.4.0'\n    }\n}\n```\n\n> [!tip]\n> flutter 的 sdk 中进行设置，处于此目录下，C:\\fluttersdk\\packages\\flutter_tools\\gradle\\resolve_dependencies.gradle\n\n```dart\nrepositories {\n    maven { url 'https://maven.aliyun.com/repository/google' }\n    maven { url 'https://maven.aliyun.com/repository/jcenter' }\n    maven { url 'https://maven.aliyun.com/nexus/content/groups/public' }\n    maven {\n        url \"https://storage.flutter-io.cn/download.flutter.io\"\n    }\n}\n```\n\n## A network error occurred while checking “https://maven.google.com/”: 信号灯超时时间已到\n\n> [!tip]\n>\n> - 1、找到 flutter sdk 的文件目录，打开 flutter\\packages\\flutter_tools\\lib\\src\\http_host_validator.dart\n> - 2、将https://maven.google.com/ 修改为https://dl.google.com/dl/android/maven2/\n> - 3、关闭 cmd 命令窗口，重新打开 cmd 窗口\n> - 4、先将原 cache 文件备份到任意文件夹下。去到 flutter\\bin 目录，删除 cache 文件夹\n> - 5、在 cmd 命令窗口重新运行 flutter doctor,问题解决。\n\n<Bottom />", "file_size": 2594, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\pre-upgrade-hook.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 协议升级前钩子,clone,web,rust,config,pre-upgrade-hook,pre_upgrade_hook\ntitle: 协议升级前钩子\nindex: true\nicon: fas fa-level-up-alt\ncategory:\n  - clone\n  - web\n  - rust\n  - config\n  - pre-upgrade-hook\n  - pre_upgrade_hook\norder: 8\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置 `websocket` 协议升级前回调，此方法会在 `websocket` 协议升级前调用，\n> 支持多次注册，会按照注册顺序进行执行，如果任何阶段设置了 `aborted`，则后续注册的 `pre_upgrade_hook` 将不会执行。\n\n## 配置单个 `websocket` 协议升级前钩子\n\n```rust\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 处理\n}).await;\n```\n\n## 配置多个 `websocket` 协议升级前钩子\n\n```rust\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 1\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 2\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 3\n}).await;\nserver.pre_upgrade_hook(|ctx: Context| async move {\n    // 4\n}).await;\n```\n\n<Bottom />", "file_size": 902, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\help\\async.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 异步,hyperlane,web,rust,help,install\ntitle: 异步\nindex: true\nicon: fas fa-bolt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - help\n  - install\norder: 3\n---\n\n<Share colorful />\n\n### 异步\n\n> [!tip]\n> 由于 `hyperlane` 框架本身涉及到锁的数据均采取 `tokio`中的读写锁实现，所以涉及到锁的方法调用均需要 `await`。\n\n<Bottom />", "file_size": 327, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\ws-hook.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Websocket钩子,clone,web,rust,config,ws-hook,ws_hook\ntitle: Websocket钩子\nindex: true\nicon: fab fa-get-pocket\ncategory:\n  - clone\n  - web\n  - rust\n  - config\n  - ws-hook\n  - ws_hook\norder: 7\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置是否启用 `websocket` 内部处理钩子，默认启用，\n> 值得一提的是此配置支持动态路由设置。\n> 需要在路由注册的处理函数中手动处理请求。如果启用，需要设置具体的路由，则会自动处理请求缓存设置，一般用于单发场景。\n> 如果不启用，则需要在业务代码中使用死循环去循环处理请求，一般用于群发场景。\n\n## 启用内部 `websocket` 钩子\n\n### 静态路由\n\n```rust\nserver.enable_ws_hook(\"/路由\").await;\n```\n\n### 朴素动态路由\n\n```rust\nserver.enable_ws_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.enable_ws_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n## 禁用 `websocket` 内部处理\n\n### 静态路由\n\n```rust\nserver.disable_ws_hook(\"/路由\").await;\n```\n\n### 动态路由\n\n```rust\nserver.disable_ws_hook(\"/路由/{id}\").await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.disable_ws_hook(\"/路由/{number:\\\\d+}\").await;\n```\n\n<Bottom />", "file_size": 916, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\project\\mysql.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: Mysql\nindex: true\nicon: fas fa-database\ncategory:\n  - clone\n  - web\n  - rust\n  - project\n  - mysql\norder: 2\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/mysql)\n\n> [!tip]\n>\n> 基于 `hyperlane` 框架，使用 `sqlx` 开发的 `mysql` 数据库 `demo`。\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### Mysql 配置\n\n修改代码文件：[src/config/mysql/constant.rs](https://github.com/hyperlane-dev/hyperlane-quick-start/blob/mysql/src/config/mysql/constant.rs)\n\n### 切换分支\n\n```sh\ngit checkout mysql;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n<Bottom />", "file_size": 710, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\help\\flamegraph.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 火焰图,hyperlane,web,rust,help,flamegraph\ntitle: 火焰图\nindex: true\nicon: fas fa-fire-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - help\n  - flamegraph\norder: 5\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架使用 `flamegraph`，使用前提是需要有 `perf` 环境，生成火焰图步骤如下：\n\n### 安装\n\n```sh\ncargo install flamegraph\n```\n\n### 使用\n\n```sh\nCARGO_PROFILE_RELEASE_DEBUG=true cargo flamegraph --release\n```\n\n<Bottom />", "file_size": 447, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\project\\group-chat.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: GroupChat\nindex: true\nicon: fas fa-comments\ncategory:\n  - clone\n  - web\n  - rust\n  - project\n  - group-chat\norder: 4\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/playground)\n\n> [!tip]\n>\n> 基于 `hyperlane` 框架开发的全栈在线群聊项目\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### 切换分支\n\n```sh\ngit checkout group-chat;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n### 浏览器访问\n\n```sh\nhttp://127.0.0.1:60007/chat\n```\n\n<Bottom />", "file_size": 607, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\quick-start\\process.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 框架流程\nindex: true\nicon: fas fa-project-diagram\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - quick-start\n  - process\norder: 2\n---\n\n<Share colorful />\n\n## 框架详细流程分析\n\n### 1. 框架总体架构\n\n#### 1.1 核心组件关系图\n\n```mermaid\ngraph TB\n    Server[\"Server (主服务器)\"] --> ServerInner[\"ServerInner (内部状态)\"]\n    ServerInner --> Config[\"ServerConfig (配置)\"]\n    ServerInner --> Router[\"RouteMatcher (路由匹配器)\"]\n    ServerInner --> Middleware[\"Middleware (中间件集合)\"]\n    ServerInner --> Hooks[\"Hooks (钩子函数)\"]\n\n    Server --> Context[\"Context (上下文)\"]\n    Context --> ContextInner[\"ContextInner (内部状态)\"]\n    ContextInner --> Request[\"Request (请求)\"]\n    ContextInner --> Response[\"Response (响应)\"]\n    ContextInner --> Stream[\"ArcRwLockStream (流)\"]\n\n    HttpType[\"http-type crate\"] --> Request\n    HttpType --> Response\n    HttpType --> Stream\n    HttpType --> WebSocketFrame[\"WebSocketFrame (WS帧)\"]\n\n    Broadcast[\"hyperlane-broadcast\"] --> WebSocketPlugin[\"hyperlane-plugin-websocket\"]\n    WebSocketPlugin --> Server\n```\n\n#### 1.2 主要组件说明\n\n> [!tip]\n>\n> - **Server**: 主服务器结构，提供线程安全的服务器状态访问\n> - **ServerInner**: 包含服务器的所有核心组件，包括配置、路由、中间件和钩子\n> - **Context**: 请求-响应周期的应用上下文，提供线程安全的访问\n> - **ArcRwLockStream**: 线程安全的 `TCP` 流包装器，用于读写操作\n\n### 2. 服务器启动流程\n\n#### 2.1 启动时序图\n\n```mermaid\nsequenceDiagram\n    participant Main as 主程序\n    participant Server as Server\n    participant TcpListener as TcpListener\n    participant PanicHook as 全局异常钩子\n\n    Main->>Server: Server::new()\n    Main->>Server: 配置host/port/buffer等\n    Main->>Server: 注册路由和中间件\n    Main->>Server: run()\n\n    Server->>PanicHook: init_panic_hook()\n    Server->>TcpListener: create_tcp_listener()\n    TcpListener-->>Server: 绑定成功\n\n    loop 接受连接\n        Server->>TcpListener: accept()\n        TcpListener-->>Server: (stream, socket_addr)\n        Server->>Server: configure_stream()\n        Server->>Server: spawn_connection_handler()\n    end\n```\n\n#### 2.2 启动流程详细步骤\n\n> [!tip]\n>\n> - **服务器初始化**: 创建 `ServerInner` 实例，初始化所有组件为默认值\n> - **配置设置**: 设置主机地址、端口、缓冲区大小等参数\n> - **异常钩子初始化**: 设置全局 `panic` 处理器\n> - **TCP 监听器创建**: 绑定到指定的地址和端口\n> - **连接接受循环**: 持续接受新的 `TCP` 连接\n\n### 3. 连接处理流程\n\n#### 3.1 连接处理时序图\n\n```mermaid\nsequenceDiagram\n    participant TcpListener as TcpListener\n    participant Server as Server\n    participant Stream as ArcRwLockStream\n    participant Context as Context\n    participant Request as Request\n\n    TcpListener->>Server: accept() 新连接\n    Server->>Stream: configure_stream() 配置Socket选项\n    Server->>Server: spawn_connection_handler() 异步任务\n\n    par 异步处理连接\n        Server->>Request: http_from_stream() 解析请求\n        Server->>Context: create_context() 创建上下文\n\n        alt HTTP请求\n            Server->>Server: http_hook()\n        else WebSocket请求\n            Server->>Server: ws_hook()\n        end\n    end\n```\n\n#### 3.2 Socket 配置流程\n\n> [!tip]\n>\n> 服务器对每个新连接配置以下 `Socket` 选项：\n>\n> - **SO_LINGER**: 控制连接关闭时的行为\n> - **TCP_NODELAY**: 禁用 `Nagle` 算法以减少延迟\n> - **IP_TTL**: 设置数据包生存时间\n\n### 4. HTTP 请求处理流程\n\n#### 4.1 HTTP 处理时序图\n\n```mermaid\nsequenceDiagram\n    participant Stream as TCP Stream\n    participant Request as Request Parser\n    participant Context as Context\n    participant Middleware as 中间件\n    participant Router as 路由器\n    participant Handler as 路由处理器\n    participant Response as 响应\n    participant Lifecycle as 生命周期\n\n    Stream->>Request: 读取HTTP数据\n    Request->>Request: 解析请求行\n    Request->>Request: 解析请求头\n    Request->>Request: 读取请求体\n    Request-->>Context: 构建Request对象\n\n    Context->>Lifecycle: 初始化生命周期\n    Context->>Middleware: run_connected_hook()\n\n    alt 未中止\n        Context->>Middleware: run_request_middleware()\n        alt 未中止\n            Context->>Router: resolve_route()\n            Router-->>Context: 返回处理器\n            Context->>Handler: run_route_hook()\n            alt 未中止\n                Context->>Middleware: run_response_middleware()\n            end\n        end\n    end\n\n    Context->>Response: 发送响应\n\n    alt Keep-Alive\n        loop 持续处理请求\n            Stream->>Request: 读取下一个请求\n            Note over Context,Handler: 重复处理流程\n        end\n    end\n```\n\n#### 4.2 HTTP 请求解析详细流程\n\n```mermaid\nflowchart TD\n    Start[开始解析] --> ReadLine[读取请求行]\n    ReadLine --> ParseParts[解析Method/Path/Version]\n    ParseParts --> CheckParts{检查部分数量}\n    CheckParts -->|< 3| Error[返回错误]\n    CheckParts -->|>= 3| ParseQuery[解析查询参数]\n    ParseQuery --> ParsePath[解析路径]\n    ParsePath --> ReadHeaders[读取请求头]\n    ReadHeaders --> CheckHeader{头部为空?}\n    CheckHeader -->|否| ProcessHeader[处理头部键值对]\n    ProcessHeader --> ReadHeaders\n    CheckHeader -->|是| ReadBody[读取请求体]\n    ReadBody --> BuildRequest[构建Request对象]\n    BuildRequest --> End[解析完成]\n```\n\n### 5. WebSocket 处理流程\n\n#### 5.1 WebSocket 升级时序图\n\n```mermaid\nsequenceDiagram\n    participant Client as 客户端\n    participant Server as 服务器\n    participant Context as Context\n    participant Router as 路由器\n    participant WSHandler as WebSocket处理器\n\n    Client->>Server: WebSocket握手请求\n    Server->>Context: 检测WebSocket请求\n    Server->>Router: resolve_route() 解析路由\n    Server->>Context: run_pre_upgrade_hook() 预升级钩子\n\n    alt 升级成功\n        Server->>Context: upgrade_to_ws() 升级连接\n        Server->>Context: run_connected_hook() 连接钩子\n\n        loop WebSocket帧处理\n            Client->>Server: WebSocket帧\n            Server->>Context: ws_from_stream() 解析帧\n            Server->>WSHandler: 处理WebSocket消息\n            Server->>Client: 发送响应帧\n        end\n    else 升级失败\n        Server->>Client: 返回错误响应\n    end\n```\n\n#### 5.2 WebSocket 帧处理流程\n\n```mermaid\nflowchart TD\n    Start[开始读取] --> ReadBuffer[读取缓冲区数据]\n    ReadBuffer --> CheckLength{数据长度检查}\n    CheckLength -->|长度为0| ConnClosed[连接关闭]\n    CheckLength -->|有数据| AppendBuffer[追加到动态缓冲区]\n    AppendBuffer --> ParseFrame[尝试解析帧]\n    ParseFrame --> CheckComplete{帧是否完整?}\n    CheckComplete -->|否| ReadBuffer\n    CheckComplete -->|是| ProcessFrame[处理帧]\n\n    ProcessFrame --> CheckOpcode{检查操作码}\n    CheckOpcode -->|Text/Binary| ProcessData[处理数据帧]\n    CheckOpcode -->|Ping| SendPong[发送Pong帧]\n    CheckOpcode -->|Pong| ProcessPong[处理Pong帧]\n    CheckOpcode -->|Close| CloseConn[关闭连接]\n    CheckOpcode -->|Continuation| ContinueData[继续数据帧]\n\n    ProcessData --> UpdateRequest[更新Request对象]\n    SendPong --> ReadBuffer\n    ProcessPong --> ReadBuffer\n    ContinueData --> UpdateRequest\n    UpdateRequest --> Complete[处理完成]\n    CloseConn --> End[结束]\n    ConnClosed --> End\n    Complete --> ReadBuffer\n```\n\n### 6. Stream 处理流程\n\n#### 6.1 Stream 读写操作流程\n\n```mermaid\nsequenceDiagram\n    participant App as 应用层\n    participant Stream as ArcRwLockStream\n    participant RwLock as RwLock<TcpStream>\n    participant TcpStream as TcpStream\n\n    Note over App,TcpStream: 读操作\n    App->>Stream: read()\n    Stream->>RwLock: read().await\n    RwLock-->>Stream: ReadGuard\n    Stream-->>App: 返回读取守护\n\n    Note over App,TcpStream: 写操作\n    App->>Stream: send(data)\n    Stream->>RwLock: write().await\n    RwLock-->>Stream: WriteGuard\n    Stream->>TcpStream: write_all(data)\n    TcpStream-->>Stream: Result\n    Stream-->>App: ResponseResult\n\n    Note over App,TcpStream: WebSocket发送\n    App->>Stream: send_ws_body(body)\n    Stream->>Stream: send_body_conditional(body, true)\n    Stream->>Stream: WebSocketFrame::create_response_frame_list()\n    loop 发送每个帧\n        Stream->>TcpStream: write_all(frame)\n    end\n```\n\n#### 6.2 Stream 并发安全机制\n\n> [!tip]\n>\n> `Stream` 使用 `Arc<RwLock<TcpStream>>` 实现线程安全：\n>\n> - **读锁**: 允许多个并发读操作\n> - **写锁**: 确保写操作的独占访问\n> - **异步支持**: 使用 `tokio` 的异步 `RwLock`\n\n### 7. 中间件管道流程\n\n#### 7.1 中间件执行时序\n\n```mermaid\nsequenceDiagram\n    participant Context as Context\n    participant ReqMw as 请求中间件\n    participant Router as 路由处理器\n    participant ResMw as 响应中间件\n    participant Lifecycle as 生命周期管理\n\n    Context->>Lifecycle: 初始化Continue状态\n\n    loop 请求中间件\n        Context->>ReqMw: 执行中间件函数\n        ReqMw->>Lifecycle: 更新生命周期状态\n        alt 状态为Abort\n            Note over Context,Lifecycle: 中止后续处理\n        end\n    end\n\n    alt 继续处理\n        Context->>Router: 执行路由处理器\n        Router->>Lifecycle: 更新生命周期状态\n\n        alt 继续处理\n            loop 响应中间件\n                Context->>ResMw: 执行中间件函数\n                ResMw->>Lifecycle: 更新生命周期状态\n            end\n        end\n    end\n\n    Context->>Context: 返回keep_alive状态\n```\n\n#### 7.2 钩子函数执行流程\n\n> [!tip]\n>\n> 服务器支持多种类型的钩子函数：\n>\n> - **connected_hook**: 新连接建立时执行\n> - **pre_upgrade_hook**: `WebSocket` 升级前执行\n> - **request_middleware**: 请求处理中间件\n> - **response_middleware**: 响应处理中间件\n\n### 8. 路由匹配流程\n\n#### 8.1 路由匹配算法\n\n```mermaid\nflowchart TD\n    Start[开始路由匹配] --> CheckStatic[检查静态路由]\n    CheckStatic --> StaticFound{找到静态路由?}\n    StaticFound -->|是| ReturnStatic[返回静态路由处理器]\n    StaticFound -->|否| CheckDynamic[检查动态路由]\n\n    CheckDynamic --> DynamicLoop[遍历动态路由]\n    DynamicLoop --> DynamicMatch{匹配动态路由?}\n    DynamicMatch -->|是| ExtractParams[提取路径参数]\n    DynamicMatch -->|否| NextDynamic[下一个动态路由]\n    NextDynamic --> DynamicLoop\n    ExtractParams --> ReturnDynamic[返回动态路由处理器]\n\n    DynamicLoop --> CheckRegex[检查正则路由]\n    CheckRegex --> RegexLoop[遍历正则路由]\n    RegexLoop --> RegexMatch{匹配正则路由?}\n    RegexMatch -->|是| ReturnRegex[返回正则路由处理器]\n    RegexMatch -->|否| NextRegex[下一个正则路由]\n    NextRegex --> RegexLoop\n\n    RegexLoop --> NotFound[未找到路由]\n\n    ReturnStatic --> End[返回处理器]\n    ReturnDynamic --> End\n    ReturnRegex --> End\n    NotFound --> End\n```\n\n#### 8.2 路由类型说明\n\n> [!tip]\n>\n> 路由匹配器将路由分为三类：\n>\n> - **静态路由**: 精确路径匹配\n> - **动态路由**: 包含变量段的路径（如 `/users/{id}` ）\n> - **正则路由**: 基于正则表达式的复杂匹配\n\n### 9. 生命周期管理流程\n\n#### 9.1 生命周期状态转换\n\n```mermaid\nstateDiagram-v2\n    [*] --> Continue : 初始化\n    Continue --> Continue : 中间件执行成功\n    Continue --> Abort : 中间件调用abort()\n    Abort --> Abort : 保持中止状态\n\n    state Continue {\n        [*] --> KeepAliveTrue : keep_alive=true\n        [*] --> KeepAliveFalse : keep_alive=false\n    }\n\n    state Abort {\n        [*] --> KeepAliveTrue : keep_alive=true\n        [*] --> KeepAliveFalse : keep_alive=false\n    }\n\n    Continue --> [*] : 处理完成\n    Abort --> [*] : 处理完成\n```\n\n#### 9.2 生命周期控制方法\n\n> [!tip]\n>\n> 生命周期管理器提供以下控制方法：\n>\n> - **update_status()**: 根据中止和保持连接标志更新状态\n> - **is_abort()**: 检查是否为中止状态\n> - **keep_alive()**: 返回连接保持状态\n\n### 10. 广播系统集成\n\n#### 10.1 WebSocket 广播架构\n\n```mermaid\ngraph TB\n    WebSocketPlugin[hyperlane-plugin-websocket] --> Broadcast[hyperlane-broadcast]\n    Broadcast --> BroadcastMap[BroadcastMap<T>]\n    BroadcastMap --> PointToPoint[点对点广播]\n    BroadcastMap --> PointToGroup[群组广播]\n\n    WebSocketConfig --> BroadcastType[广播类型]\n    BroadcastType --> PointToPoint\n    BroadcastType --> PointToGroup\n\n    WebSocketConfig --> Hooks[WebSocket钩子]\n    Hooks --> RequestHook[请求钩子]\n    Hooks --> SendedHook[发送钩子]\n    Hooks --> ClosedHook[关闭钩子]\n```\n\n#### 10.2 广播消息流程\n\n> [!tip]\n>\n> `WebSocket` 插件支持两种广播模式：\n>\n> - **点对点通信**: 两个特定用户之间的私聊\n> - **群组通信**: 多个用户在同一群组中的广播\n\n### 11. 错误处理流程\n\n#### 11.1 异常处理时序图\n\n```mermaid\nsequenceDiagram\n    participant Task as 异步任务\n    participant Server as Server\n    participant PanicHook as Panic钩子\n    participant Context as Context\n\n    Task->>Task: panic!() 发生异常\n    Task->>Server: JoinError\n    Server->>Server: handle_task_panic()\n    Server->>Server: Panic::from_join_error()\n    Server->>Context: set_panic()\n    Server->>PanicHook: 调用panic钩子\n    PanicHook->>Context: 处理异常上下文\n```\n\n#### 11.2 全局异常钩子机制\n\n> [!tip]\n>\n> 服务器在启动时设置全局异常处理器，能够：\n>\n> - 捕获 `panic` 信息\n> - 关联到请求上下文\n> - 异步处理异常响应\n> - 自定义异常处理逻辑\n\n<Bottom />", "file_size": 11167, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\config\\config.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: ServerConfig,hyperlane,web,rust,config,config_str,host,port,http_buffer,ws_buffer,linger,nodelay,ttl\ntitle: 服务配置\nindex: true\nicon: fas fa-cogs\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - ServerConfig\n  - host\n  - port\n  - http_buffer\n  - ws_buffer\n  - linger\n  - nodelay\n  - ttl\n  - config_str\n  - config\norder: 2\n---\n\n<Share colorful />\n\n### 设置 `host`\n\n> [!tip]\n>\n> `hyperlane` 框架绑定 `host` 方式如下：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.host(\"0.0.0.0\").await;\n```\n\n### 设置 `port`\n\n> [!tip]\n>\n> `hyperlane` 框架绑定端口方式如下：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.port(60000).await;\n```\n\n### 设置 `http_buffer`\n\n> [!tip]\n>\n> `hyperlane` 框架设置 `HTTP` 缓冲区大小方式如下（不设置或者设置为 `0` 则默认是 `4096` 字节）：\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.http_buffer(4096).await;\n```\n\n### 设置 `ws_buffer`\n\n> [!tip]\n>\n> `hyperlane` 框架设置 `websocket` 缓冲区大小方式如下：\n> 不设置或者设置为 `0` 则默认是 `4096` 字节。\n\n```rust\nserver.ws_buffer(4096).await;\n```\n\n### 设置 `linger`\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置 `linger`，该选项基于 `Tokio` 的 `TcpStream::set_linger`，用于控制 `SO_LINGER` 选项，以决定连接关闭时未发送数据的处理方式，从而影响连接终止时的行为。\n\n### 设置 `linger`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.linger(Duration::from_millis(10)).await;\n```\n\n### 设置 `nodelay`\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置 `nodelay`，该选项基于 `Tokio` 的 `TcpStream::set_nodelay`，用于控制 `TCP_NODELAY` 选项，以减少 `Nagle` 算法的影响，提高低延迟场景下的数据传输效率。\n\n### 启用 `nodelay`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.enable_nodelay().await;\n```\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.nodelay(true).await;\n```\n\n### 禁用 `nodelay`\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.disable_nodelay().await;\n```\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.nodelay(false).await;\n```\n\n### 设置 `ttl`\n\n> [!tip]\n>\n> `hyperlane` 框架支持配置 `ttl`，该选项基于 `Tokio` 的 `TcpStream::set_ttl`，用于控制 `IP_TTL` 选项，以设置传输数据包的生存时间（`Time To Live`），从而影响数据包在网络中的跳数限制。\n\n```rust\nlet config: ServerConfig = ServerConfig::new().await;\nconfig.ttl(128).await;\n```\n\n### 设置 `config_str`\n\n> [!tip]\n>\n> `hyperlane` 框架支持直接传入配置字符串。\n\n```rust\nlet config_str: &'static str = r#\"\n    {\n        \"host\": \"0.0.0.0\",\n        \"port\": 80,\n        \"ws_buffer\": 4096,\n        \"http_buffer\": 4096,\n        \"nodelay\": true,\n        \"linger\": { \"secs\": 64, \"nanos\": 0 },\n        \"ttl\": 64\n    }\n\"#;\nserver.config_str(config_str).await;\n```\n\n### 设置 `config`\n\n```rust\nlet config_str: &'static str = r#\"\n    {\n        \"host\": \"0.0.0.0\",\n        \"port\": 80,\n        \"ws_buffer\": 4096,\n        \"http_buffer\": 4096,\n        \"nodelay\": true,\n        \"linger\": { \"secs\": 64, \"nanos\": 0 },\n        \"ttl\": 64\n    }\n\"#;\nlet config: ServerConfig = ServerConfig::from_str(config_str).unwrap();\nserver.config(config).await;\n```\n\n<Bottom />", "file_size": 2908, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\middleware\\auth.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 身份校验中间件\nindex: true\nicon: fas fa-user-shield\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - middleware\n  - auth\norder: 3\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持身份校验中间件，用于处理身份校验。\n\n### 身份校验中间件\n\n```rs\nuse hyperlane::*;\n\nasync fn http_version_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1).await;\n}\n\nasync fn auth(ctx: Context) {\n    let auth_str: String = ctx\n        .get_request_header_back(AUTHORIZATION)\n        .await\n        .unwrap_or_default();\n    if auth_str.is_empty() {\n        ctx.set_response_status_code(401)\n            .await\n            .set_response_body(\"Unauthorized\")\n            .await\n            .send()\n            .await\n            .unwrap();\n        ctx.aborted().await;\n    }\n}\n\nasync fn index(ctx: Context) {\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(http_version_middleware)\n        .await\n        .request_middleware(auth)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n<Bottom />", "file_size": 1381, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\quick-start\\directory.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 目录结构\nindex: true\nicon: fas fa-folder-open\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - quick-start\norder: 1\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> 基于 `hyperlane` 设计的目录结构，配置和业务分离，扩展以插件形式存在，便于开发和维护。\n\n```txt\n├── app                      # app目录\n│   ├── aspect               # 切面编程层\n│   ├── controller           # 接口控制层\n│   ├── exception            # 异常处理层\n│   ├── filter               # 过滤器层\n│   ├── mapper               # 数据访问层\n│   ├── middleware           # 中间件层\n│   ├── model                # 数据模型层\n│      ├── application       # 应用对象\n│      ├── bean              # 实体对象\n│      ├── business          # 业务对象\n│      ├── data              # 数据对象\n│      ├── data_access       # 数据访问对象\n│      ├── data_transfer     # 数据传输对象\n│      ├── domain            # 领域对象\n│      ├── param             # 参数对象\n│      ├── persistent        # 持久化对象\n│      ├── view              # 视图对象\n│   ├── service              # 业务逻辑层\n│   ├── utils                # 工具层\n│   ├── view                 # 视图层\n├── config                   # 配置目录\n│   ├── business             # 业务配置\n│   ├── framework            # 框架配置\n│   ├── server_manager       # 服务管理配置\n├── init                     # 初始化目录\n│   ├── business             # 业务初始化\n│   ├── framework            # 框架始化\n├── plugin                   # 插件目录\n│   ├── log                  # 日志插件\n│   ├── server_manager       # 服务进程管理插件\n├── resources                # 资源目录\n│   ├── static               # 静态资源目录\n│      ├── html              # HTML静态资源\n│      ├── img               # 图片静态资源\n│   ├── templates            # 模板目录\n│      ├── html              # HTML模板\n```\n\n## 🗂 各层级调用关系详解\n\n### `app/controller`（接口控制层）\n\n- 调用：\n\n  - `service`：处理业务逻辑。\n  - `model/param`：接收请求参数。\n  - `model/view`：返回视图对象。\n  - `model/data_transfer`：构建 DTO 返回。\n  - `utils`：使用工具函数处理请求数据。\n  - `exception`：统一异常抛出。\n  - `filter` / `middleware`：作为请求链的入口或出口。\n  - `aspect`：被 AOP 织入切面逻辑。\n  - `view`：视图渲染。\n  - `resources/templates`：页面模板渲染。\n  - `resources/static`：静态资源引用。\n  - `plugin/*`：调用日志记录、服务管理等插件。\n\n### `app/service`（业务逻辑层）\n\n- 调用：\n\n  - `mapper`：访问数据库。\n  - `model/business`：封装业务对象。\n  - `model/domain`：应用领域建模。\n  - `model/data_transfer`：服务返回值封装。\n  - `exception`：业务异常处理。\n  - `utils`：辅助计算、验证、转换等。\n  - `plugin/*`：调用插件完成增强能力。\n\n- 被调用：\n\n  - `controller`\n\n### `app/mapper`（数据访问层）\n\n- 调用：\n\n  - `model/data_access`：数据库表映射。\n  - `model/persistent`：持久化结构体。\n  - `utils`：SQL 构建等辅助操作。\n\n- 被调用：\n\n  - `service`\n\n### `app/model/*`（数据模型层）\n\n> 被多个模块依赖和使用，不主动调用其他层。\n\n#### 常用子模块说明：\n\n| 子模块          | 使用场景                                           |\n| --------------- | -------------------------------------------------- |\n| `application`   | 应用级上下文对象，用于 service/mapper 层组合数据。 |\n| `bean`          | 通用实体定义，如 User、Order 等。                  |\n| `business`      | 业务组合对象，如 OrderDetail + PaymentInfo。       |\n| `data`          | 中间数据对象，在服务流程中传递状态。               |\n| `data_access`   | 映射 DAO/ORM 结构，数据库字段。                    |\n| `data_transfer` | DTO 层，controller → client 层数据输出。           |\n| `domain`        | 领域建模，对应 DDD 的 Aggregate/Entity/VO。        |\n| `param`         | controller 接收参数封装。                          |\n| `persistent`    | 映射数据库存储模型。                               |\n| `view`          | 用于最终渲染视图页面的模型。                       |\n\n**Model 详细介绍**\n\n| 目录名          | 中文名       | 典型职责                                             | 使用场景举例                                        | 与其它层关系                               |\n| --------------- | ------------ | ---------------------------------------------------- | --------------------------------------------------- | ------------------------------------------ |\n| `application`   | 应用对象     | 编排多个业务对象，处理用户用例                       | 服务层 `UserService` 聚合多个 `UserBO` 处理注册流程 | 调用 `business`，传递 `param`、返回 `view` |\n| `bean`          | 实体对象     | 数据实体，表现为 Struct 或 ORM 实体                  | `UserEntity`、`ArticleEntity`，保存于数据库         | 被 `persistent` 持久化，供 `domain` 使用   |\n| `business`      | 业务对象     | 封装核心业务逻辑（BO）                               | `UserBO::register` 内部逻辑完整，不依赖框架         | 被 `application` 调用                      |\n| `data`          | 数据对象     | 数据结构本身，不带行为（值对象、常量等）             | `GenderEnum`、`IdVO`、`DateRange`                   | 被 `domain` 和 `dto` 等层使用              |\n| `data_access`   | 数据访问对象 | 封装数据库交互（DAO、Repository）                    | `UserRepository::find_by_email()`                   | 操作 `bean` 或 `persistent`                |\n| `data_transfer` | 数据传输对象 | 接口中传输的数据载体，常用于请求响应、分页、统一结构 | `ApiResponse<T>`、`Page<T>`、`UserDto`              | 被 controller、OpenAPI 文档广泛使用        |\n| `param`         | 参数对象     | 接口入参、查询条件、分页等                           | `LoginParam`、`SearchQueryParam`                    | 传入 `application` 层                      |\n| `persistent`    | 持久化对象   | ORM 映射专用结构体，有时带属性注解                   | `UserPersistent` 映射数据库字段                     | 与 `bean` 相似，偏向实现层                 |\n| `domain`        | 领域对象     | 领域模型（实体和值对象），封装行为                   | `OrderAggregate`，可带行为如 `Order::cancel()`      | 被 `business` 聚合使用                     |\n| `view`          | 视图对象     | 接口输出结果的表现结构，适配前端需求                 | `UserProfileView`、`ArticleDetailView`              | 从 `dto` 或 `bean` 转换而来                |\n\n### `app/exception`（异常处理层）\n\n- 被调用：\n\n  - `controller`\n  - `service`\n  - `mapper`\n\n### `app/filter`（过滤器层）\n\n- 被调用：\n\n  - `controller` 请求前过滤。\n\n### `app/middleware`（中间件层）\n\n- 被调用：\n\n  - `controller` 请求或响应阶段增强，如权限校验、Header 注入等。\n\n### `app/aspect`（切面编程层）\n\n- 被调用：\n\n  - 自动织入 `controller`、`service` 等层处理日志、安全等横切关注点。\n\n### `app/utils`（工具层）\n\n- 被调用：\n\n  - `controller`\n  - `service`\n  - `mapper`\n  - `model`（可选）\n\n### `app/view`（视图层）\n\n- 被调用：\n\n  - `controller` 用于模板渲染（结合 `resources/templates`）\n\n---\n\n### `config`（配置目录）\n\n- 被调用：\n\n  - `init`：读取配置初始化。\n  - `app`：全局配置使用，如数据库、缓存、超时等。\n\n- 子目录说明：\n\n  - `business`：业务层配置，如风控策略、规则开关。\n  - `hyperlane`：服务监听、路由、中间件配置。\n  - `server_manager`：进程托管策略。\n\n### `init`（初始化目录）\n\n- 调用：\n\n  - `config`：读取配置。\n  - `plugin`：初始化日志、服务等插件。\n  - `app`：初始化 controller/service 等组件。\n\n- 被调用：\n\n  - 由主程序启动时触发。\n\n### `plugin`（插件目录）\n\n- 被调用：\n\n  - `controller` / `service` / `init` 均可能调用。\n\n- 子模块：\n\n  - `log`：日志记录、链路追踪。\n  - `server_manager`：守护进程、PID 控制等。\n\n---\n\n### `resources`（资源目录）\n\n- 子目录说明：\n\n  - `static/html`、`img`：被 `view` 层或浏览器直接访问。\n  - `templates/html`：被 `controller` 或 `view` 用于渲染页面。\n\n<Bottom />", "file_size": 6272, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\help\\install.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: 安装,hyperlane,web,rust,help,install\ntitle: 安装\nindex: true\nicon: fas fa-download\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - help\n  - install\norder: 2\n---\n\n<Share colorful />\n\n### 安装\n\n> [!tip]\n>\n> 如果不使用 `Cargo.lock` 提交到 `git`，请在 `Cargo.toml` 文件的版本号前加 `=` 来锁定版本。\n\n#### 命令\n\n```shell\ncargo add hyperlane;\n```\n\n<Bottom />", "file_size": 373, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\content-type.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Content-Type\ntitle: Content-Type\nindex: true\nicon: fas fa-file-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - content-type\norder: 9\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Content-Type` 内部 `value` 定义参考 [Content-Type](https://docs.rs/http-constant/latest/src/http_constant/content_type_value/const.rs.html)。\n\n<Bottom />", "file_size": 401, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\http-status.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: HttpStatus\ntitle: HttpStatus\nindex: true\nicon: fas fa-signal\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - http-status\norder: 6\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `HttpStatus` 内部具体类型定义如下\n\n```rust\n/// Standard HTTP status codes.\n///\n/// Includes informational, success, redirection, client and server error codes.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpStatus {\n    /// HTTP 100 Continue\n    Continue,\n    /// HTTP 101 Switching Protocols\n    SwitchingProtocols,\n    /// HTTP 102 Processing (WebDAV)\n    Processing,\n    /// HTTP 103 Early Hints\n    EarlyHints,\n    /// HTTP 200 OK\n    Ok,\n    /// HTTP 201 Created\n    Created,\n    /// HTTP 202 Accepted\n    Accepted,\n    /// HTTP 203 Non-Authoritative Information\n    NonAuthoritativeInformation,\n    /// HTTP 204 No Content\n    NoContent,\n    /// HTTP 205 Reset Content\n    ResetContent,\n    /// HTTP 206 Partial Content\n    PartialContent,\n    /// HTTP 207 Multi-Status (WebDAV)\n    MultiStatus,\n    /// HTTP 208 Already Reported (WebDAV)\n    AlreadyReported,\n    /// HTTP 226 IM Used\n    IMUsed,\n    /// HTTP 300 Multiple Choices\n    MultipleChoices,\n    /// HTTP 301 Moved Permanently\n    MovedPermanently,\n    /// HTTP 302 Found\n    Found,\n    /// HTTP 303 See Other\n    SeeOther,\n    /// HTTP 304 Not Modified\n    NotModified,\n    /// HTTP 305 Use Proxy\n    UseProxy,\n    /// HTTP 307 Temporary Redirect\n    TemporaryRedirect,\n    /// HTTP 308 Permanent Redirect\n    PermanentRedirect,\n    /// HTTP 400 Bad Request\n    BadRequest,\n    /// HTTP 401 Unauthorized\n    Unauthorized,\n    /// HTTP 402 Payment Required\n    PaymentRequired,\n    /// HTTP 403 Forbidden\n    Forbidden,\n    /// HTTP 404 Not Found\n    NotFound,\n    /// HTTP 405 Method Not Allowed\n    MethodNotAllowed,\n    /// HTTP 406 Not Acceptable\n    NotAcceptable,\n    /// HTTP 407 Proxy Authentication Required\n    ProxyAuthenticationRequired,\n    /// HTTP 408 Request Timeout\n    RequestTimeout,\n    /// HTTP 409 Conflict\n    Conflict,\n    /// HTTP 410 Gone\n    Gone,\n    /// HTTP 411 Length Required\n    LengthRequired,\n    /// HTTP 412 Precondition Failed\n    PreconditionFailed,\n    /// HTTP 413 Payload Too Large\n    PayloadTooLarge,\n    /// HTTP 414 URI Too Long\n    URITooLong,\n    /// HTTP 415 Unsupported Media Type\n    UnsupportedMediaType,\n    /// HTTP 416 Range Not Satisfiable\n    RangeNotSatisfiable,\n    /// HTTP 417 Expectation Failed\n    ExpectationFailed,\n    /// HTTP 418 I'm a teapot\n    ImATeapot,\n    /// HTTP 421 Misdirected Request\n    MisdirectedRequest,\n    /// HTTP 422 Unprocessable Entity (WebDAV)\n    UnprocessableEntity,\n    /// HTTP 423 Locked (WebDAV)\n    Locked,\n    /// HTTP 424 Failed Dependency (WebDAV)\n    FailedDependency,\n    /// HTTP 425 Too Early\n    TooEarly,\n    /// HTTP 426 Upgrade Required\n    UpgradeRequired,\n    /// HTTP 428 Precondition Required\n    PreconditionRequired,\n    /// HTTP 429 Too Many Requests\n    TooManyRequests,\n    /// HTTP 431 Request Header Fields Too Large\n    RequestHeaderFieldsTooLarge,\n    /// HTTP 451 Unavailable For Legal Reasons\n    UnavailableForLegalReasons,\n    /// HTTP 500 Internal Server Error\n    InternalServerError,\n    /// HTTP 501 Not Implemented\n    NotImplemented,\n    /// HTTP 502 Bad Gateway\n    BadGateway,\n    /// HTTP 503 Service Unavailable\n    ServiceUnavailable,\n    /// HTTP 504 Gateway Timeout\n    GatewayTimeout,\n    /// HTTP 505 HTTP Version Not Supported\n    HTTPVersionNotSupported,\n    /// HTTP 506 Variant Also Negotiates\n    VariantAlsoNegotiates,\n    /// HTTP 507 Insufficient Storage (WebDAV)\n    InsufficientStorage,\n    /// HTTP 508 Loop Detected (WebDAV)\n    LoopDetected,\n    /// HTTP 510 Not Extended\n    NotExtended,\n    /// HTTP 511 Network Authentication Required\n    NetworkAuthenticationRequired,\n    /// HTTP Unknown status code\n    Unknown,\n}\n```\n\n<Bottom />", "file_size": 3896, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\context.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Context\ntitle: Context\nindex: true\nicon: fas fa-sitemap\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - ctx\norder: 11\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Context` 作为中间件和路由处理函数的唯一的参数类型，其内部保存了上下文数据，具体类型定义如下：\n\n```rust\n/// Represents the internal state of the application context.\n///\n/// This structure holds all the data associated with a single request-response cycle,\n/// including the stream, request, response, and any custom attributes.\n#[derive(Clone, Data, Default, CustomDebug, DisplayDebug)]\npub(crate) struct ContextInner {\n    /// A flag indicating whether the request handling has been aborted.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    aborted: bool,\n    /// A flag indicating whether the connection has been closed.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    closed: bool,\n    /// The underlying network stream for the connection.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    stream: OptionArcRwLockStream,\n    /// The incoming HTTP request.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    request: Request,\n    /// The outgoing HTTP response.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    response: Response,\n    /// Parameters extracted from the route path.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    route_params: RouteParams,\n    /// A collection of custom attributes for sharing data within the request lifecycle.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    attributes: HashMapArcAnySendSync,\n}\n\n/// The main application context, providing thread-safe access to request and response data.\n///\n/// This is a wrapper around `ContextInner` that uses an `Arc<RwLock<>>` to allow\n/// for shared, mutable access across asynchronous tasks.\n#[derive(Clone, Default, Getter, CustomDebug, DisplayDebug)]\npub struct Context(#[get(pub(super))] pub(super) ArcRwLock<ContextInner>);\n```\n\n<Bottom />", "file_size": 2111, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\speed\\request-time.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 响应时间测试\nindex: true\nicon: fas fa-stopwatch\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - speed\n  - request\n  - time\norder: 2\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/test-request)\n\n> [!tip]\n> 测试累计请求 `1w` 次\n\n| 场景      | http-request 平均耗时 | hyper 平均耗时 |\n| --------- | --------------------- | -------------- |\n| TCP 失败  | 39us                  | 78us           |\n| hyperlane | 100us                 | 150us          |\n| 阿帕奇    | 300us                 | 2500us         |\n\n<Bottom />", "file_size": 569, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\middleware\\cross.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 跨域中间件\nindex: true\nicon: fas fa-exchange-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - middleware\n  - multi-server\norder: 1\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持跨域中间件，用于处理跨域请求的情况。\n\n### 跨域中间件\n\n```rust\npub async fn cross_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_ORIGIN, ANY)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_METHODS, ALL_METHODS)\n        .await\n        .set_response_header(ACCESS_CONTROL_ALLOW_HEADERS, ANY)\n        .await;\n}\n\nasync fn index(ctx: Context) {\n    ctx.set_response_status_code(200)\n        .await\n        .set_response_body(\"Hello, world!\")\n        .await;\n}\n\nasync fn response_middleware(ctx: Context) {\n    ctx.send().await.unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    Server::new()\n        .request_middleware(cross_middleware)\n        .await\n        .response_middleware(response_middleware)\n        .await\n        .route(\"/\", index)\n        .await\n        .run()\n        .await\n        .unwrap();\n}\n```\n\n<Bottom />", "file_size": 1154, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\speed\\env.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 环境信息\nindex: true\nicon: fas fa-server\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - speed\norder: 1\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement)\n\n### 环境信息\n\n- 系统: `Ubuntu20.04.6 LTS`\n- CPU: `i9-14900KF`\n- 内存: `192GB 6400MT/S（实际运行 4000MT/S）`\n- 硬盘: `SKC3000D2048G * 2`\n- GPU: `AMD Radeon RX 6750 GRE 10GB`\n\n### 调优\n\n#### Linux 内核调优\n\n> 打开文件 `/etc/sysctl.conf`，增加以下设置。\n\n```sh\n#该参数设置系统的TIME_WAIT的数量，如果超过默认值则会被立即清除\nnet.ipv4.tcp_max_tw_buckets = 20000\n#定义了系统中每一个端口最大的监听队列的长度，这是个全局的参数\nnet.core.somaxconn = 65535\n#对于还未获得对方确认的连接请求，可保存在队列中的最大数目\nnet.ipv4.tcp_max_syn_backlog = 262144\n#在每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许送到队列的数据包的最大数目\nnet.core.netdev_max_backlog = 30000\n#此选项会导致处于NAT网络的客户端超时，建议为0。Linux从4.12内核开始移除了 tcp_tw_recycle 配置，如果报错\"No such file or directory\"请忽略\nnet.ipv4.tcp_tw_recycle = 0\n#系统所有进程一共可以打开的文件数量\nfs.file-max = 6815744\n#防火墙跟踪表的大小。注意：如果防火墙没开则会提示error: \"net.netfilter.nf_conntrack_max\" is an unknown key，忽略即可\nnet.netfilter.nf_conntrack_max = 2621440\nnet.ipv4.ip_local_port_range = 10240 65000\n```\n\n#### 控制台执行 `ulimit`\n\n```sh\nulimit -n 1024000\n```\n\n#### 打开文件数\n\n> 修改 `open files` 的数值重启后永久生效，修改配置文件：`/etc/security/limits.conf`。在这个文件后加上\n\n```sh\n* soft nofile 1024000\n* hard nofile 1024000\nroot soft nofile 1024000\nroot hard nofile 1024000\n```\n\n#### 运行命令\n\n```sh\nRUSTFLAGS=\"-C target-cpu=native -C link-arg=-fuse-ld=lld\" cargo run --release\n```\n\n<Bottom />", "file_size": 1465, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\project\\redis.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: Redis\nindex: true\nicon: fab fa-redhat\ncategory:\n  - clone\n  - web\n  - rust\n  - project\n  - redis\norder: 1\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/redis)\n\n> [!tip]\n>\n> 基于 `hyperlane` 框架，使用 `redis` 和 `server-manager` 开发的 `redis` 数据库 `demo`。\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### Redis 配置\n\n修改代码文件：[src/config/redis.rs](https://github.com/hyperlane-dev/hyperlane-quick-start/blob/redis/src/config/redis.rs)\n\n### 切换分支\n\n```sh\ngit checkout redis;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n<Bottom />", "file_size": 710, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\cookie.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Cookie\ntitle: Cookie\nindex: true\nicon: fas fa-cookie-bite\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - Cookie\norder: 12\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Cookie` 相关类型定义如下\n\n```rust\n/// Builder for constructing HTTP cookies.\n///\n/// Provides methods to set various cookie attributes like expiration,\n/// domain, path, and security flags before building the final cookie string.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct CookieBuilder {\n    /// Cookie name identifier.\n    pub(super) name: CookieKey,\n    /// Cookie value content.\n    pub(super) value: CookieValue,\n    /// Optional expiration date/time string.\n    pub(super) expires: OptionCookieExpires,\n    /// Optional maximum age in seconds.\n    pub(super) max_age: OptionCookieMaxAge,\n    /// Optional domain scope for the cookie.\n    pub(super) domain: OptionCookieDomain,\n    /// Optional path scope for the cookie.\n    pub(super) path: OptionCookiePath,\n    /// Flag indicating secure (HTTPS-only) transmission.\n    pub(super) secure: bool,\n    /// Flag preventing JavaScript access.\n    pub(super) http_only: bool,\n    /// Optional SameSite policy setting.\n    pub(super) same_site: OptionCookieSameSite,\n}\n\n/// Parser for HTTP Cookie headers.\n///\n/// Provides functionality to parse Cookie header strings into key-value pairs.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct Cookie;\n```", "file_size": 1460, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\speed\\open-keep-alive.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 开启Keep Alive\nindex: true\nicon: fas fa-toggle-on\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - speed\n  - open-keep-alive\norder: 4\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement/tree/master/open-keep-alive)\n\n### wrk\n\n#### 压测命令\n\n```sh\nwrk -c360 -d60s http://127.0.0.1:60000/\n```\n\n#### 压测结果\n\n> [!tip]\n> 测试 `360` 并发，持续 `60s` 请求。`QPS` 结果如下：\n>\n> - 1 `Tokio` ：340130.92\n> - 2 `Hyperlane框架` ：324323.71\n> - 3 `Rocket框架` ：298945.31\n> - 4 `Rust标准库` ：291218.96\n> - 5 `Gin框架` ：242570.16\n> - 6 `Go标准库` ：234178.93\n> - 7 `Node标准库` ：139412.13\n\n#### hyperlane 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.46ms    7.74ms 230.59ms   99.57%\n    Req/Sec   163.12k     9.54k  187.65k    67.75%\n  19476349 requests in 1.00m, 1.94GB read\nRequests/sec: 324323.71\nTransfer/sec:     33.10MB\n```\n\n#### Rust 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.64ms    8.62ms 238.68ms   99.48%\n    Req/Sec   146.49k    20.42k  190.38k    61.42%\n  17494266 requests in 1.00m, 1.52GB read\nRequests/sec: 291218.96\nTransfer/sec:     25.83MB\n```\n\n#### Tokio 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.22ms    5.96ms 230.76ms   99.76%\n    Req/Sec   171.05k     7.56k  192.19k    70.08%\n  20423683 requests in 1.00m, 1.77GB read\nRequests/sec: 340130.92\nTransfer/sec:     30.17MB\n```\n\n#### Rocket 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.42ms    6.67ms 228.04ms   99.67%\n    Req/Sec   150.37k     7.48k  172.42k    70.08%\n  17955815 requests in 1.00m, 4.00GB read\nRequests/sec: 298945.31\nTransfer/sec:     68.14MB\n```\n\n#### Gin 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.67ms    4.67ms 249.72ms   99.63%\n    Req/Sec   122.08k     4.39k  133.88k    69.58%\n  14577127 requests in 1.00m, 1.97GB read\nRequests/sec: 242570.16\nTransfer/sec:     33.54MB\n```\n\n#### Go 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     1.58ms    1.15ms  32.24ms   78.06%\n    Req/Sec   117.80k     4.43k  130.07k    70.67%\n  14064777 requests in 1.00m, 1.90GB read\nRequests/sec: 234178.93\nTransfer/sec:     32.38MB\n```\n\n#### Node 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     2.58ms  837.62us  45.39ms   89.66%\n    Req/Sec    70.11k     2.79k   74.29k    98.33%\n  8371733 requests in 1.00m, 1.16GB read\nRequests/sec: 139412.13\nTransfer/sec:     19.81MB\n```\n\n### ab\n\n#### 压测命令\n\n```sh\nab -n 1000000 -c 1000 -r -k http://127.0.0.1:60000/\n```\n\n#### 压测结果\n\n> [!tip]\n> 测试 `1000` 并发，一共 `100w` 请求。`QPS` 结果如下：\n>\n> - 1 `Tokio` ：308596.26\n> - 2 `Hyperlane框架` ：307568.90\n> - 3 `Rocket框架` ：267931.52\n> - 4 `Rust标准库` ：260514.56\n> - 5 `Go标准库` ：226550.34\n> - 6 `Gin框架` ：224296.16\n> - 7 `Node标准库` ：85357.18\n\n#### hyperlane 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.251 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      107000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    307568.90 [#/sec] (mean)\nTime per request:       3.251 [ms] (mean)\nTime per request:       0.003 [ms] (mean, across all concurrent requests)\nTransfer rate:          32138.55 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.3      0      11\nProcessing:     0    3   1.4      3      13\nWaiting:        0    3   1.4      3      13\nTotal:          0    3   1.4      3      16\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      7\n  99%      7\n 100%     16 (longest request)\n```\n\n#### Rust 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.839 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      93000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    260514.56 [#/sec] (mean)\nTime per request:       3.839 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          23660.01 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0  21.2      0    1069\nProcessing:     0    3   5.5      3     419\nWaiting:        0    3   5.5      3     419\nTotal:          0    4  23.4      3    1286\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      8\n  99%      8\n 100%   1286 (longest request)\n```\n\n#### Tokio 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.240 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      93000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    308596.26 [#/sec] (mean)\nTime per request:       3.240 [ms] (mean)\nTime per request:       0.003 [ms] (mean, across all concurrent requests)\nTransfer rate:          28026.81 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.3      0      11\nProcessing:     0    3   1.3      3      16\nWaiting:        0    3   1.3      3      16\nTotal:          0    3   1.4      3      16\n\nPercentage of the requests served within a certain time (ms)\n  50%      3\n  66%      4\n  75%      4\n  80%      4\n  90%      5\n  95%      6\n  98%      7\n  99%      7\n 100%     16 (longest request)\n```\n\n#### Rocket 框架\n\n```sh\nServer Software:        Rocket\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   3.732 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      271000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    267931.52 [#/sec] (mean)\nTime per request:       3.732 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          70907.66 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0      14\nProcessing:     0    4   1.4      4      17\nWaiting:        0    4   1.4      4      17\nTotal:          0    4   1.4      4      21\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      4\n  75%      5\n  80%      5\n  90%      6\n  95%      6\n  98%      7\n  99%      8\n 100%     21 (longest request)\n```\n\n#### Gin 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   4.458 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      145000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    224296.16 [#/sec] (mean)\nTime per request:       4.458 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          31760.69 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       7\nProcessing:     0    4   4.7      4     181\nWaiting:        0    4   4.7      4     181\nTotal:          0    4   4.8      4     184\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      5\n  75%      5\n  80%      6\n  90%      8\n  95%     10\n  98%     12\n  99%     13\n 100%    184 (longest request)\n```\n\n#### Go 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   4.414 seconds\nComplete requests:      1000000\nFailed requests:        0\nKeep-Alive requests:    1000000\nTotal transferred:      154000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    226550.34 [#/sec] (mean)\nTime per request:       4.414 [ms] (mean)\nTime per request:       0.004 [ms] (mean, across all concurrent requests)\nTransfer rate:          34071.05 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    0   0.2      0       7\nProcessing:     0    4   3.9      4     172\nWaiting:        0    4   3.9      4     172\nTotal:          0    4   4.0      4     176\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      4\n  75%      5\n  80%      5\n  90%      7\n  95%      8\n  98%      8\n  99%      9\n 100%    176 (longest request)\n```\n\n#### Node 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   11.715 seconds\nComplete requests:      1000000\nFailed requests:        811908\n   (Connect: 0, Receive: 14737, Length: 499810, Exceptions: 297361)\nKeep-Alive requests:    500200\nTotal transferred:      59523800 bytes\nHTML transferred:       6502600 bytes\nRequests per second:    85357.18 [#/sec] (mean)\nTime per request:       11.715 [ms] (mean)\nTime per request:       0.012 [ms] (mean, across all concurrent requests)\nTransfer rate:          4961.70 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    3  33.5      0    1082\nProcessing:     0    8   9.6      7     247\nWaiting:        0    7  10.5      3     247\nTotal:          0   12  35.3      9    1102\n\nPercentage of the requests served within a certain time (ms)\n  50%      9\n  66%     15\n  75%     17\n  80%     18\n  90%     21\n  95%     23\n  98%     27\n  99%     30\n 100%   1102 (longest request)\n```\n\n<Bottom />", "file_size": 10829, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\method.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Method\ntitle: Method\nindex: true\nicon: fas fa-hand-pointer\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - method\n  - type\norder: 3\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Method` 内部具体类型定义如下\n\n```rust\n/// Defines the `Method` enum, representing HTTP request methods.\n///\n/// This enum provides a comprehensive list of standard HTTP methods,\n/// such as GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT, and TRACE.\n/// It also includes an `UNKNOWN` variant for unrecognized methods.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Method {\n    /// Represents the HTTP `GET` method.\n    GET,\n    /// Represents the HTTP `POST` method.\n    POST,\n    /// Represents the HTTP `PUT` method.\n    PUT,\n    /// Represents the HTTP `DELETE` method.\n    DELETE,\n    /// Represents the HTTP `PATCH` method.\n    PATCH,\n    /// Represents the HTTP `HEAD` method.\n    HEAD,\n    /// Represents the HTTP `OPTIONS` method.\n    OPTIONS,\n    /// Represents the HTTP `CONNECT` method.\n    CONNECT,\n    /// Represents the HTTP `TRACE` method.\n    TRACE,\n    /// Unknown\n    UNKNOWN(String),\n}\n```\n\n<Bottom />", "file_size": 1159, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\speed\\close-keep-alive.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 关闭Keep Alive\nindex: true\nicon: fas fa-toggle-off\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - speed\n  - close-keep-alive\norder: 3\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/web-server-pressure-measurement/tree/master/close-keep-alive)\n\n### wrk\n\n#### 压测命令\n\n```sh\nwrk -c360 -d60s -H \"Connection: close\" http://127.0.0.1:60000/\n```\n\n#### 压测结果\n\n> [!tip]\n> 测试 `360` 并发，持续 `60s` 请求。`QPS` 结果如下：\n>\n> - 1 `Hyperlane框架` ：51031.27\n> - 2 `Tokio` ：49555.87\n> - 3 `Rocket框架` ：49345.76\n> - 4 `Gin框架` ：40149.75\n> - 5 `Go标准库` ：38364.06\n> - 6 `Rust标准库` ：30142.55\n> - 7 `Node标准库` ：28286.96\n\n#### hyperlane 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.51ms    2.12ms 254.29ms   74.68%\n    Req/Sec    25.69k     1.78k   42.56k    74.94%\n  3066756 requests in 1.00m, 298.32MB read\nRequests/sec:  51031.27\nTransfer/sec:      4.96MB\n```\n\n#### Rust 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency    13.39ms   39.09ms 938.33ms   93.24%\n    Req/Sec    15.17k     1.25k   19.88k    71.08%\n  1811006 requests in 1.00m, 151.99MB read\nRequests/sec:  30142.55\nTransfer/sec:      2.53MB\n```\n\n#### Tokio 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.64ms    2.97ms 331.60ms   89.67%\n    Req/Sec    24.93k     2.37k   31.57k    64.49%\n  2976845 requests in 1.00m, 249.83MB read\nRequests/sec:  49555.87\nTransfer/sec:      4.16MB\n```\n\n#### Rocket 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     3.70ms    3.23ms 246.75ms   92.68%\n    Req/Sec    24.83k     2.31k   47.87k    71.72%\n  2963056 requests in 1.00m, 729.05MB read\nRequests/sec:  49345.76\nTransfer/sec:     12.14MB\n```\n\n#### Gin 框架\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.69ms    2.66ms  37.49ms   68.89%\n    Req/Sec    20.22k     3.79k   28.13k    59.02%\n  2412349 requests in 1.00m, 322.08MB read\nRequests/sec:  40149.75\nTransfer/sec:      5.36MB\n```\n\n#### Go 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.96ms    3.17ms 248.63ms   75.61%\n    Req/Sec    19.33k     4.01k   28.20k    59.12%\n  2303964 requests in 1.00m, 307.61MB read\nRequests/sec:  38364.06\nTransfer/sec:      5.12MB\n```\n\n#### Node 标准库\n\n```sh\nRunning 1m test @ http://127.0.0.1:60000/\n  2 threads and 360 connections\n  Thread Stats   Avg      Stdev     Max   +/- Stdev\n    Latency     4.76ms    3.48ms  55.44ms   68.85%\n    Req/Sec    14.22k     2.88k   28.04k    83.54%\n  1699058 requests in 1.00m, 233.33MB read\n  Socket errors: connect 337, read 0, write 0, timeout 0\nRequests/sec:  28286.96\nTransfer/sec:      3.88MB\n```\n\n### ab\n\n#### 压测命令\n\n```sh\nab -n 1000000 -c 1000 -r http://127.0.0.1:60000/\n```\n\n#### 压测结果\n\n> [!tip]\n> 测试 `1000` 并发，一共 `100w` 请求。`QPS` 结果如下：\n>\n> - 1 `Tokio` ：51825.13\n> - 2 `Hyperlane框架` ：51554.47\n> - 3 `Rocket框架` ：49621.02\n> - 4 `Go标准库` ：47915.20\n> - 5 `Gin框架` ：47081.05\n> - 6 `Node标准库` ：44763.11\n> - 7 `Rust标准库` ：31511.00\n\n#### hyperlane 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   19.397 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      107000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    51554.47 [#/sec] (mean)\nTime per request:       19.397 [ms] (mean)\nTime per request:       0.019 [ms] (mean, across all concurrent requests)\nTransfer rate:          5387.04 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9   9.1      8    1069\nProcessing:     0   10   4.7     10     289\nWaiting:        0    9   4.5      9     286\nTotal:          1   19  11.1     19    1085\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     22\n  75%     24\n  80%     25\n  90%     29\n  95%     33\n  98%     37\n  99%     41\n 100%   1085 (longest request)\n```\n\n#### Rust 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   31.735 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      88000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    31511.00 [#/sec] (mean)\nTime per request:       31.735 [ms] (mean)\nTime per request:       0.032 [ms] (mean, across all concurrent requests)\nTransfer rate:          2707.98 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0   22 167.7      0    7232\nProcessing:     0    9  45.2      4    5771\nWaiting:        0    9  45.2      4    5771\nTotal:          0   31 178.6      4    7441\n\nPercentage of the requests served within a certain time (ms)\n  50%      4\n  66%      5\n  75%      5\n  80%      6\n  90%      7\n  95%      8\n  98%    426\n  99%   1050\n 100%   7441 (longest request)\n```\n\n#### Tokio 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   19.296 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      88000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    51825.13 [#/sec] (mean)\nTime per request:       19.296 [ms] (mean)\nTime per request:       0.019 [ms] (mean, across all concurrent requests)\nTransfer rate:          4453.72 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  19.4      8    1091\nProcessing:     0   10   5.4      9     284\nWaiting:        0    9   5.2      8     284\nTotal:          0   19  20.6     18    1107\n\nPercentage of the requests served within a certain time (ms)\n  50%     18\n  66%     21\n  75%     23\n  80%     25\n  90%     29\n  95%     33\n  98%     38\n  99%     42\n 100%   1107 (longest request)\n```\n\n#### Rocket 框架\n\n```sh\nServer Software:        Rocket\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   20.153 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      247000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    49621.02 [#/sec] (mean)\nTime per request:       20.153 [ms] (mean)\nTime per request:       0.020 [ms] (mean, across all concurrent requests)\nTransfer rate:          11969.13 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  11.2      9    1094\nProcessing:     0   11   5.4     10     305\nWaiting:        0   10   5.2      9     305\nTotal:          0   20  13.3     19    1107\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     22\n  75%     25\n  80%     26\n  90%     30\n  95%     34\n  98%     39\n  99%     43\n 100%   1107 (longest request)\n```\n\n#### Gin 框架\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        5 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   21.240 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      140000000 bytes\nHTML transferred:       5000000 bytes\nRequests per second:    47081.05 [#/sec] (mean)\nTime per request:       21.240 [ms] (mean)\nTime per request:       0.021 [ms] (mean, across all concurrent requests)\nTransfer rate:          6436.86 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0   10  13.0      9    1095\nProcessing:     0   12   6.0     11     288\nWaiting:        0   11   5.8     10     286\nTotal:          1   21  15.1     20    1114\n\nPercentage of the requests served within a certain time (ms)\n  50%     20\n  66%     23\n  75%     26\n  80%     27\n  90%     32\n  95%     35\n  98%     40\n  99%     44\n 100%   1114 (longest request)\n```\n\n#### Go 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   20.870 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      149000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    47915.20 [#/sec] (mean)\nTime per request:       20.870 [ms] (mean)\nTime per request:       0.021 [ms] (mean, across all concurrent requests)\nTransfer rate:          6972.04 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    9  21.1      8    1103\nProcessing:     0   11   6.5     11     323\nWaiting:        0   10   6.3     10     322\nTotal:          1   21  22.6     19    1120\n\nPercentage of the requests served within a certain time (ms)\n  50%     19\n  66%     23\n  75%     25\n  80%     27\n  90%     31\n  95%     35\n  98%     41\n  99%     46\n 100%   1120 (longest request)\n```\n\n#### Node 标准库\n\n```sh\nServer Hostname:        127.0.0.1\nServer Port:            60000\n\nDocument Path:          /\nDocument Length:        13 bytes\n\nConcurrency Level:      1000\nTime taken for tests:   22.340 seconds\nComplete requests:      1000000\nFailed requests:        0\nTotal transferred:      114000000 bytes\nHTML transferred:       13000000 bytes\nRequests per second:    44763.11 [#/sec] (mean)\nTime per request:       22.340 [ms] (mean)\nTime per request:       0.022 [ms] (mean, across all concurrent requests)\nTransfer rate:          4983.39 [Kbytes/sec] received\n\nConnection Times (ms)\n              min  mean[+/-sd] median   max\nConnect:        0    6  42.1      4    1086\nProcessing:     0   16  11.7     15     453\nWaiting:        0   13  11.2     12     452\nTotal:          1   22  43.7     20    1108\n\nPercentage of the requests served within a certain time (ms)\n  50%     20\n  66%     22\n  75%     23\n  80%     24\n  90%     27\n  95%     29\n  98%     33\n  99%     37\n 100%   1108 (longest request)\n```\n\n<Bottom />", "file_size": 10611, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\http-version.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: HttpVersion\ntitle: HttpVersion\nindex: true\nicon: fas fa-code-branch\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - http-version\n  - type\norder: 2\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `UpgradeType` 内部具体类型定义如下\n\n```rust\n/// Standard HTTP status codes.\n///\n/// Includes informational, success, redirection, client and server error codes.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpStatus {\n    /// HTTP 100 Continue\n    Continue,\n    /// HTTP 101 Switching Protocols\n    SwitchingProtocols,\n    /// HTTP 102 Processing (WebDAV)\n    Processing,\n    /// HTTP 103 Early Hints\n    EarlyHints,\n    /// HTTP 200 OK\n    Ok,\n    /// HTTP 201 Created\n    Created,\n    /// HTTP 202 Accepted\n    Accepted,\n    /// HTTP 203 Non-Authoritative Information\n    NonAuthoritativeInformation,\n    /// HTTP 204 No Content\n    NoContent,\n    /// HTTP 205 Reset Content\n    ResetContent,\n    /// HTTP 206 Partial Content\n    PartialContent,\n    /// HTTP 207 Multi-Status (WebDAV)\n    MultiStatus,\n    /// HTTP 208 Already Reported (WebDAV)\n    AlreadyReported,\n    /// HTTP 226 IM Used\n    IMUsed,\n    /// HTTP 300 Multiple Choices\n    MultipleChoices,\n    /// HTTP 301 Moved Permanently\n    MovedPermanently,\n    /// HTTP 302 Found\n    Found,\n    /// HTTP 303 See Other\n    SeeOther,\n    /// HTTP 304 Not Modified\n    NotModified,\n    /// HTTP 305 Use Proxy\n    UseProxy,\n    /// HTTP 307 Temporary Redirect\n    TemporaryRedirect,\n    /// HTTP 308 Permanent Redirect\n    PermanentRedirect,\n    /// HTTP 400 Bad Request\n    BadRequest,\n    /// HTTP 401 Unauthorized\n    Unauthorized,\n    /// HTTP 402 Payment Required\n    PaymentRequired,\n    /// HTTP 403 Forbidden\n    Forbidden,\n    /// HTTP 404 Not Found\n    NotFound,\n    /// HTTP 405 Method Not Allowed\n    MethodNotAllowed,\n    /// HTTP 406 Not Acceptable\n    NotAcceptable,\n    /// HTTP 407 Proxy Authentication Required\n    ProxyAuthenticationRequired,\n    /// HTTP 408 Request Timeout\n    RequestTimeout,\n    /// HTTP 409 Conflict\n    Conflict,\n    /// HTTP 410 Gone\n    Gone,\n    /// HTTP 411 Length Required\n    LengthRequired,\n    /// HTTP 412 Precondition Failed\n    PreconditionFailed,\n    /// HTTP 413 Payload Too Large\n    PayloadTooLarge,\n    /// HTTP 414 URI Too Long\n    URITooLong,\n    /// HTTP 415 Unsupported Media Type\n    UnsupportedMediaType,\n    /// HTTP 416 Range Not Satisfiable\n    RangeNotSatisfiable,\n    /// HTTP 417 Expectation Failed\n    ExpectationFailed,\n    /// HTTP 418 I'm a teapot\n    ImATeapot,\n    /// HTTP 421 Misdirected Request\n    MisdirectedRequest,\n    /// HTTP 422 Unprocessable Entity (WebDAV)\n    UnprocessableEntity,\n    /// HTTP 423 Locked (WebDAV)\n    Locked,\n    /// HTTP 424 Failed Dependency (WebDAV)\n    FailedDependency,\n    /// HTTP 425 Too Early\n    TooEarly,\n    /// HTTP 426 Upgrade Required\n    UpgradeRequired,\n    /// HTTP 428 Precondition Required\n    PreconditionRequired,\n    /// HTTP 429 Too Many Requests\n    TooManyRequests,\n    /// HTTP 431 Request Header Fields Too Large\n    RequestHeaderFieldsTooLarge,\n    /// HTTP 451 Unavailable For Legal Reasons\n    UnavailableForLegalReasons,\n    /// HTTP 500 Internal Server Error\n    InternalServerError,\n    /// HTTP 501 Not Implemented\n    NotImplemented,\n    /// HTTP 502 Bad Gateway\n    BadGateway,\n    /// HTTP 503 Service Unavailable\n    ServiceUnavailable,\n    /// HTTP 504 Gateway Timeout\n    GatewayTimeout,\n    /// HTTP 505 HTTP Version Not Supported\n    HTTPVersionNotSupported,\n    /// HTTP 506 Variant Also Negotiates\n    VariantAlsoNegotiates,\n    /// HTTP 507 Insufficient Storage (WebDAV)\n    InsufficientStorage,\n    /// HTTP 508 Loop Detected (WebDAV)\n    LoopDetected,\n    /// HTTP 510 Not Extended\n    NotExtended,\n    /// HTTP 511 Network Authentication Required\n    NetworkAuthenticationRequired,\n    /// HTTP Unknown status code\n    Unknown,\n}\n```\n\n<Bottom />", "file_size": 3905, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\project\\file-chunk.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: FileChunk\nindex: true\nicon: fas fa-file-archive\ncategory:\n  - clone\n  - web\n  - rust\n  - project\n  - file-chunk\norder: 3\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/crates-dev/hyperlane-quick-start/tree/playground)\n\n> [!tip]\n>\n> 基于 `hyperlane` 框架，使用 `chunkify`\n> （[官方文档](../../chunkify/README.md)） 开发的的文件分块项目\n\n### 克隆项目\n\n```sh\ngit clone git@github.com:hyperlane-dev/hyperlane-quick-start.git;\n```\n\n### 进入项目目录\n\n```sh\ncd ./hyperlane-quick-start;\n```\n\n### 切换分支\n\n```sh\ngit checkout playground;\n```\n\n### 运行\n\n```sh\ncargo run\n```\n\n### 浏览器访问\n\n```sh\nhttp://127.0.0.1:60006/upload\n```\n\n<Bottom />", "file_size": 661, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\async.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 异步运行时\nindex: true\nicon: fas fa-bolt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - async\norder: 1\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架在 `v3.0.0` 之前不对异步做任何处理，如果需要异步操作，可以引入第三方库\n>\n> `hyperlane` 框架在 `v3.0.0` 之后内置异步机制\n\n> [!tip]\n>\n> `hyperlane` 框架在 `v4.0.0` 之前支持同步和异步中间件/路由共存。\n> `hyperlane` 框架在 `v4.0.0` 之后为了性能移除了同步中间件和路由（ `all in async` ），在开启 `keep-alive` 情况下带来了效果 `QPS 10w+`的提升\n\n### 框架本身异步使用\n\n```rust\nserver.route(\"/\", move |_| async move {\n    println!(\"hello\");\n}).await;\n```\n\n### 下面是使用 `tokio` 库的异步运行时示例代码\n\n#### v4.0.0 之后版本的示例代码\n\n```rust\nuse hyperlane::*;\nuse runtime::Runtime;\n\nasync fn some_async_task() -> i32 {\n    println!(\"Starting the task...\");\n    // 模拟异步操作\n    tokio::time::sleep(std::time::Duration::from_secs(2)).await;\n    println!(\"Task completed!\");\n    0\n}\n\n#[tokio::main]\nasync fn main() {\n    let server: Server = Server::new().await;\n    server.route(\"/\", move |ctx: Context| {\n        some_async_task().await;\n    });\n    server.listen();\n}\n```\n\n### 异步闭包捕获外部变量\n\n#### 使用 async move\n\n```rust\nlet test_string: String = \"test\".to_owned();\nserver.route(\"/test/async\", move |_| {\n    let tmp_test_string = test_string.clone();\n    async move {\n        println!(\"{:?}\", tmp_test_string);\n    }\n}).await;\n```\n\n#### 使用 future_fn!\n\n```rust\nlet test_string: String = \"test\".to_owned();\nlet func = future_fn!(test_string, |_| {\n    println!(\"async_move => {:?}\", test_string);\n});\nserver.route(\"/test/async\", func).await;\n```\n\n<Bottom />", "file_size": 1545, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\server-config.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: ServerConfig\ntitle: ServerConfig\nindex: true\nicon: fas fa-cogs\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - server-config\norder: 12\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `ServerConfig` 相关类型定义如下\n\n```rust\n/// Represents the server configuration.\n///\n/// This structure holds all the settings for the HTTP and WebSocket server,\n/// including network parameters and buffer sizes.\n#[derive(Clone, Data, CustomDebug, DisplayDebug, PartialEq, Eq, Deserialize, Serialize)]\npub struct ServerConfig {\n    /// The host address the server will bind to.\n    pub(super) host: String,\n    /// The port number the server will listen on.\n    pub(super) port: usize,\n    /// The buffer size for WebSocket connections.\n    pub(super) ws_buffer: usize,\n    /// The buffer size for HTTP connections.\n    pub(super) http_buffer: usize,\n    /// The TCP_NODELAY option for sockets.\n    pub(super) nodelay: OptionBool,\n    /// The SO_LINGER option for sockets.\n    pub(super) linger: OptionDuration,\n    /// The IP_TTL option for sockets.\n    pub(super) ttl: OptionU32,\n}\n```\n\n<Bottom />", "file_size": 1144, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\stream.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Stream\ntitle: Stream\nindex: true\nicon: fas fa-water\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - stream\norder: 8\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Stream` 内部具体类型定义如下\n\n```rust\n/// A thread-safe reference-counted `TcpStream`.\npub type ArcStream = Arc<TcpStream>;\n/// An optional thread-safe reference-counted `TcpStream`.\npub type OptionArcTcpStream = Option<ArcStream>;\n/// An optional thread-safe read-write locked `TcpStream` wrapper.\npub type OptionArcRwLockStream = Option<ArcRwLockStream>;\n/// A read guard for a `RwLock<TcpStream>`.\npub type RwLockReadGuardTcpStream<'a> = RwLockReadGuard<'a, TcpStream>;\n/// A write guard for a `RwLock<TcpStream>`.\npub type RwLockWriteGuardTcpStream<'a> = RwLockWriteGuard<'a, TcpStream>;\n/// A thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type ArcRwLockWriteGuardTcpStream<'a> = Arc<RwLockWriteGuard<'a, TcpStream>>;\n/// An optional thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type OptionArcRwLockWriteGuardTcpStream<'a> = Option<ArcRwLockWriteGuardTcpStream<'a>>;\n/// A thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type ArcMutexGuardTcpStream<'a> = Arc<MutexGuard<'a, TcpStream>>;\n/// An optional thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type OptionArcMutexGuardTcpStream<'a> = Option<ArcMutexGuardTcpStream<'a>>;\n/// A socket host represented by an IP address.\npub type SocketHost = IpAddr;\n/// A socket port number.\npub type SocketPort = u16;\n/// An optional socket host.\npub type OptionSocketHost = Option<SocketHost>;\n/// An optional socket port.\npub type OptionSocketPort = Option<SocketPort>;\n/// An optional full socket address.\npub type OptionSocketAddr = Option<SocketAddr>;\n\n/// Thread-safe TCP stream wrapper.\n///\n/// Provides shared access to a TcpStream using Arc and RwLock.\n///\n/// # Fields\n///\n/// - `Arc<RwLock<TcpStream>>` - The protected TCP stream.\n#[derive(Clone, Debug, Getter)]\npub struct ArcRwLockStream(#[get(pub(super))] pub(super) ArcRwLock<TcpStream>);\n```\n\n<Bottom />", "file_size": 2112, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\send.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 发送响应\nindex: true\nicon: fas fa-paper-plane\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - send\norder: 14\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架提供了多种响应发送方法，支持完整 HTTP 响应发送、仅响应体发送，以及连接管理。\n\n## 发送完整 HTTP 响应\n\n### send 方法\n\n> [!tip]\n> 发送完整的 HTTP 响应，发送后 TCP 连接保留。\n\n```rust\nlet send_result: ResponseResult = ctx.send().await;\n```\n\n### send_once 方法\n\n> [!tip]\n> 发送完整的 HTTP 响应，发送后立即关闭 TCP 连接。\n\n```rust\nlet send_result: ResponseResult = ctx.send_once().await;\n```\n\n## 发送响应体\n\n### send_body 方法\n\n> [!tip]\n> 仅发送响应体内容，发送后 TCP 连接保留。适用于流式响应和 WebSocket。\n\n```rust\nlet send_result: ResponseResult = ctx.send_body().await;\n```\n\n### send_once_body 方法\n\n> [!tip]\n> 仅发送响应体内容，发送后立即关闭 TCP 连接。\n\n```rust\nlet send_result: ResponseResult = ctx.send_once_body().await;\n```\n\n## 刷新缓冲区\n\n### flush 方法\n\n> [!tip]\n> 强制刷新网络缓冲区，确保数据立即发送。\n\n```rust\nlet flush_result: ResponseResult = ctx.flush().await;\n```\n\n## 基本使用示例\n\n### 使用框架常量\n\n```rust\nctx.set_response_header(CONTENT_TYPE, APPLICATION_JSON).await\n   .set_response_body(r#\"{\"status\": \"ok\"}\"#).await\n   .send().await;\n```\n\n### 流式发送\n\n```rust\nctx.set_response_header(CONTENT_TYPE, TEXT_PLAIN).await;\nfor i in 1..=3 {\n    let _ = ctx.set_response_body(format!(\"chunk {}\\n\", i)).await.send_body().await;\n    ctx.flush().await;\n}\n```\n\n### WebSocket 发送\n\n```rust\nctx.upgrade_to_ws().await;\nlet _ = ctx.set_response_body(\"websocket message\").await.send_body().await;\n```\n\n<Bottom />", "file_size": 1477, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\cookie.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: Cookie 操作\nindex: true\nicon: fas fa-cookie-bite\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - cookie\norder: 13\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架提供了完整的 Cookie 处理功能，支持请求和响应中的 Cookie 操作。\n\n## 请求 Cookie 操作\n\n### 获取所有请求 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_request_cookies().await;\n```\n\n### 获取特定请求 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_request_cookie(\"session_id\").await;\n```\n\n> [!tip]\n>\n> Cookie 名称通常是自定义的，所以使用字符串字面量。但对于标准的请求头操作，建议使用框架常量。\n\n## 响应 Cookie 操作\n\n### 获取所有响应 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_response_cookies().await;\n```\n\n### 获取特定响应 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_response_cookie(\"user_token\").await;\n```\n\n### 设置响应 Cookie\n\n#### 使用字符串直接设置\n\n```rust\nctx.set_response_header(SET_COOKIE, \"session_id=abc123; Path=/; HttpOnly\").await;\n```\n\n#### 使用 CookieBuilder 构建\n\n```rust\nlet cookie_value: String = CookieBuilder::new(\"session_id\", \"abc123\")\n    .path(\"/\")\n    .http_only()\n    .build();\nctx.set_response_header(SET_COOKIE, cookie_value).await;\n```\n\n### 设置多个 Cookie\n\n```rust\nlet session_cookie: String = CookieBuilder::new(\"session_id\", \"abc123\")\n    .path(\"/\")\n    .http_only()\n    .secure()\n    .max_age(3600)\n    .build();\n\nlet pref_cookie: String = CookieBuilder::new(\"user_pref\", \"dark_mode\")\n    .path(\"/\")\n    .max_age(86400)\n    .build();\n\nctx.set_response_header(SET_COOKIE, session_cookie).await\n   .set_response_header(SET_COOKIE, pref_cookie).await;\n```\n\n## CookieBuilder 方法\n\n### 基本构建\n\n```rust\nlet cookie: String = CookieBuilder::new(\"name\", \"value\").build();\n```\n\n### 设置属性\n\n```rust\nlet cookie: String = CookieBuilder::new(\"session\", \"token123\")\n    .expires(\"Wed, 21 Oct 2025 07:28:00 GMT\")\n    .max_age(3600)\n    .domain(\"example.com\")\n    .path(\"/\")\n    .secure()\n    .http_only()\n    .same_site(\"Strict\")\n    .build();\n```\n\n### 解析现有 Cookie\n\n```rust\nlet cookie_builder: CookieBuilder = CookieBuilder::parse(\"name=value; Path=/; HttpOnly\");\nlet rebuilt_cookie: String = cookie_builder.build();\n```\n\n## 基本使用示例\n\n### 会话管理\n\n```rust\nlet session_cookie: String = CookieBuilder::new(\"session\", \"token123\")\n    .http_only()\n    .secure()\n    .max_age(3600)\n    .build();\nctx.set_response_header(SET_COOKIE, session_cookie).await;\n\nif let Some(session) = ctx.get_request_cookie(\"session\").await {}\n```\n\n### 清除 Cookie\n\n```rust\nlet clear_cookie: String = CookieBuilder::new(\"session\", \"\")\n    .max_age(0)\n    .build();\nctx.set_response_header(SET_COOKIE, clear_cookie).await;\n```\n\n<Bottom />", "file_size": 2579, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\response.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Response\ntitle: Response\nindex: true\nicon: fas fa-arrow-alt-circle-up\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - response\norder: 7\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Response` 内部具体类型定义如下\n\n```rust\n/// An alias for `Vec<u8>`, representing the binary body of the HTTP response.\npub type ResponseBody = Vec<u8>;\n/// An alias for `String`, representing the body of the HTTP response as a UTF-8 string.\npub type ResponseBodyString = String;\n/// An alias for `String`, representing the key type used in HTTP response headers.\npub type ResponseHeadersKey = String;\n/// An alias for `String`, representing a single value string for an HTTP response header.\npub type ResponseHeadersValueItem = String;\n/// An alias for `Option<ResponseHeadersValueItem>`, representing an optional value string for an HTTP response header.\npub type OptionResponseHeadersValueItem = Option<ResponseHeadersValueItem>;\n/// An alias for `VecDeque<ResponseHeadersValueItem>`, representing a collection of values for a single HTTP response header.\npub type ResponseHeadersValue = VecDeque<ResponseHeadersValueItem>;\n/// An alias for `HashMapXxHash3_64<ResponseHeadersKey, ResponseHeadersValue>`, representing a map of HTTP response headers.\npub type ResponseHeaders = HashMapXxHash3_64<ResponseHeadersKey, ResponseHeadersValue>;\n/// An alias for `HttpVersion`, representing the HTTP version of the response.\npub type ResponseVersion = HttpVersion;\n/// An alias for `usize`, representing the numeric status code of the HTTP response.\npub type ResponseStatusCode = usize;\n/// An alias for `String`, representing the reason phrase associated with the HTTP status code.\npub type ResponseReasonPhrase = String;\n/// An alias for `Result<(), ResponseError>`, representing the result type returned after writing an HTTP response.\npub type ResponseResult = Result<(), ResponseError>;\n/// An alias for `Vec<u8>`, representing the full serialized binary content of the HTTP response.\npub type ResponseData = Vec<u8>;\n/// An alias for `String`, representing the full serialized content of the HTTP response as a UTF-8 string.\npub type ResponseDataString = String;\n/// An alias for `RwLockReadGuard<'a, Response>`, representing a read guard to a shared `Response` value protected by `RwLock`.\npub type RwLockReadGuardResponse<'a> = RwLockReadGuard<'a, Response>;\n/// An alias for `RwLockWriteGuard<'a, Response>`, representing a write guard to a shared `Response` value protected by `RwLock`.\npub type RwLockWriteGuardResponse<'a> = RwLockWriteGuard<'a, Response>;\n/// An alias for `Option<ResponseHeadersValue>`, representing an optional collection of values for a response header.\npub type OptionResponseHeadersValue = Option<ResponseHeadersValue>;\n\n/// Represents a parsed HTTP response.\n#[derive(Debug, Clone, PartialEq, Eq, Data, DisplayDebug)]\npub struct Response {\n    /// The HTTP version used in the response.\n    pub(super) version: ResponseVersion,\n    /// The HTTP status code.\n    pub(super) status_code: ResponseStatusCode,\n    /// The reason phrase associated with the status code.\n    #[set(skip)]\n    pub(super) reason_phrase: ResponseReasonPhrase,\n    /// The response headers as key-value pairs.\n    #[set(skip)]\n    pub(super) headers: ResponseHeaders,\n    /// The binary body content of the response.\n    #[set(skip)]\n    pub(super) body: ResponseBody,\n}\n```\n\n<Bottom />", "file_size": 3432, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\request.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 请求\nindex: true\nicon: fas fa-arrow-alt-circle-down\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - request\norder: 5\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架对 `ctx` 额外封装了子字段的方法，可以直接调用大部分子字段的 `get` 和 `set` 方法名称。\n> 例如：调用 `request` 上的 `get_method` 方法，\n> 一般需要从 `ctx` 解出 `request`，再调用`request.get_method()`，\n> 可以简化成直接调用 `ctx.get_request_method().await`。\n>\n> **调用规律**\n>\n> - `request` 仅支持`get`，不支持`set`，框架保证请求信息不会被意外修改。\n> - 原 `request` 的 `get` 方法的 `get` 名称后加 `request` 名称，中间使用\\_拼接。\n\n## 获取请求信息\n\n#### 获取 `request`\n\n```rust\nlet request: Request = ctx.get_request().await;\n```\n\n#### 获取 `method`\n\n```rust\nlet method: RequestMethod = ctx.get_request_method().await;\n```\n\n#### 获取 `host`\n\n```rust\nlet host: RequestHost = ctx.get_request_host().await;\n```\n\n#### 获取 `path`\n\n```rust\nlet path: RequestPath = ctx.get_request_path().await;\n```\n\n#### 获取 `version`\n\n```rust\nlet version: RequestVersion = ctx.get_request_version().await;\n```\n\n#### 获取 `querys`\n\n```rust\nlet querys: RequestQuerys = ctx.get_request_querys().await;\n```\n\n#### 获取特定查询参数\n\n```rust\nlet query_value: OptionRequestQuerysValue = ctx.get_request_query(\"key\").await;\n```\n\n#### 获取 `header`\n\n> [!tip]\n>\n> `hyperlane` 框架请求头的 `key` 是经过全小写处理，建议使用框架定义的常量。\n\n```rust\nlet header: OptionRequestHeadersValue = ctx.get_request_header(CONTENT_TYPE).await;\n```\n\n#### 获取 `headers`\n\n```rust\nlet headers: RequestHeaders = ctx.get_request_headers().await;\n```\n\n#### 获取请求头的第一个值\n\n```rust\nlet header_value: OptionRequestHeadersValueItem = ctx.get_request_header_front(CONTENT_TYPE).await;\n```\n\n#### 获取请求头的最后一个值\n\n```rust\nlet header_value: OptionRequestHeadersValueItem = ctx.get_request_header_back(ACCEPT).await;\n```\n\n#### 获取请求头值的数量\n\n```rust\nlet header_count: usize = ctx.get_request_header_len(ACCEPT_ENCODING).await;\n```\n\n#### 获取所有请求头值的总数量\n\n```rust\nlet total_values: usize = ctx.get_request_headers_values_length().await;\n```\n\n#### 获取请求头的数量\n\n```rust\nlet headers_count: usize = ctx.get_request_headers_length().await;\n```\n\n#### 检查是否存在特定请求头\n\n```rust\nlet has_header: bool = ctx.has_request_header(CONTENT_TYPE).await;\n```\n\n#### 检查请求头是否包含特定值\n\n```rust\nlet has_value: bool = ctx.has_request_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 获取请求体\n\n```rust\nlet body: RequestBody = ctx.get_request_body().await;\n```\n\n#### 获取 `string` 格式的请求体\n\n```rust\nlet body: String = ctx.get_request_body_string().await;\n```\n\n#### 获取 `json` 格式的请求体\n\n```rust\nlet body: T = ctx.get_request_body_json::<T>().await;\n```\n\n#### 获取请求升级类型\n\n```rust\nlet upgrade_type: UpgradeType = ctx.get_request_upgrade_type().await;\n```\n\n## 执行闭包操作\n\n#### 使用请求执行异步闭包\n\n```rust\nlet result = ctx.with_request(|request| async move {\n    request.get_method()\n}).await;\n```\n\n## 转字符串\n\n#### 通过 `to_string`\n\n> [!tip]\n> 将获得完整的原始结构体字符串结构。\n\n```rust\nctx.get_request().await.to_string();\n```\n\n#### 通过 `get_string`\n\n> [!tip]\n> 将获得简化的结构体字符串结构。\n\n```rust\nctx.get_request().await.get_string();\n```\n\n#### 通过 `ctx.get_request_string`\n\n```rust\nlet request_string: String = ctx.get_request_string().await;\n```\n\n<Bottom />", "file_size": 3082, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\request.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Request\ntitle: Request\nindex: true\nicon: fas fa-arrow-alt-circle-down\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - request\norder: 5\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Request` 内部具体类型定义如下\n\n```rust\n/// An alias for `Method`, representing the HTTP request method.\npub type RequestMethod = Method;\n/// An alias for `String`, representing the host part of an HTTP request.\npub type RequestHost = String;\n/// An alias for `HttpVersion`, representing the HTTP version.\npub type RequestVersion = HttpVersion;\n/// An alias for `String`, representing the path portion of the request URL.\npub type RequestPath = String;\n/// An alias for `String`, representing the key type for request query parameters.\npub type RequestQuerysKey = String;\n/// An alias for `String`, representing the value type for request query parameters.\npub type RequestQuerysValue = String;\n/// An alias for `Option<RequestQuerysValue>`, representing an optional query parameter value.\npub type OptionRequestQuerysValue = Option<RequestQuerysValue>;\n/// An alias for `HashMapXxHash3_64<RequestQuerysKey, RequestQuerysValue>`, representing all query parameters parsed from the request URL.\npub type RequestQuerys = HashMapXxHash3_64<RequestQuerysKey, RequestQuerysValue>;\n/// An alias for `Vec<u8>`, representing the raw binary body of the request.\npub type RequestBody = Vec<u8>;\n/// An alias for `String`, representing the request body as a UTF-8 encoded string.\npub type RequestBodyString = String;\n/// An alias for `String`, representing the key type for request headers.\npub type RequestHeadersKey = String;\n/// An alias for `String`, representing a single value for an HTTP request header.\npub type RequestHeadersValueItem = String;\n/// An alias for `Option<RequestHeadersValueItem>`, representing an optional header value item.\npub type OptionRequestHeadersValueItem = Option<RequestHeadersValueItem>;\n/// An alias for `VecDeque<RequestHeadersValueItem>`, representing a collection of values for a single HTTP request header.\npub type RequestHeadersValue = VecDeque<RequestHeadersValueItem>;\n/// An alias for `Option<RequestHeadersValue>`, representing an optional collection of header values.\npub type OptionRequestHeadersValue = Option<RequestHeadersValue>;\n/// An alias for `HashMapXxHash3_64<RequestHeadersKey, RequestHeadersValue>`, representing all headers sent with the HTTP request.\npub type RequestHeaders = HashMapXxHash3_64<RequestHeadersKey, RequestHeadersValue>;\n/// An alias for `Result<Request, RequestError>`, representing the result type returned from a request reader handler.\npub type RequestReaderHandleResult = Result<Request, RequestError>;\n/// An alias for `RwLockReadGuard<'a, Request>`, representing a read guard for a `Request` wrapped in a `RwLock`.\npub type RwLockReadGuardRequest<'a> = RwLockReadGuard<'a, Request>;\n/// An alias for `RwLockWriteGuard<'a, Request>`, representing a write guard for a `Request` wrapped in a `RwLock`.\npub type RwLockWriteGuardRequest<'a> = RwLockWriteGuard<'a, Request>;\n\n/// HTTP request representation.\n///\n/// Contains all components of an HTTP request.\n#[derive(Debug, Clone, PartialEq, Eq, Getter, DisplayDebug)]\npub struct Request {\n    /// HTTP request method.\n    pub(super) method: RequestMethod,\n    /// Request host.\n    pub(super) host: RequestHost,\n    /// HTTP protocol version.\n    pub(super) version: RequestVersion,\n    /// Request path.\n    pub(super) path: RequestPath,\n    /// URL query parameters.\n    pub(super) querys: RequestQuerys,\n    /// HTTP headers collection.\n    pub(super) headers: RequestHeaders,\n    /// Request body content.\n    pub(super) body: RequestBody,\n}\n```\n\n<Bottom />", "file_size": 3723, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\attribute.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 属性\nindex: true\nicon: fas fa-tag\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - attribute\norder: 9\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持临时上下文属性以 `key-value` 形式存储，生命周期贯穿一个完整的请求和响应。\n> 存储的 `value` 支持实现了`Any + Send + Sync + Clone` 的 `trait` 的类型。\n\n### 设置某个临时上下文属性\n\n```rust\nctx.set_attribute(\"key\", &\"value\").await;\n```\n\n### 获取某个临时上下文属性\n\n```rust\nlet value: Option<String> = ctx.get_attribute::<String>(\"key\").await;\n```\n\n### 移除某个临时上下文属性\n\n```rust\nctx.remove_attribute(\"key\").await;\n```\n\n### 清空临时上下文属性\n\n```rust\nctx.clear_attribute().await;\n```\n\n### 额外示例\n\n#### 设置闭包\n\n> [!tip]\n> 闭包需要实现 `Send + Sync` 的 `trait`，否则无法跨线程调用。\n> 不推荐 `value` 存储函数，这里只是提供一个示例\n\n```rust\nlet func: &(dyn Fn(&str) + Send + Sync) = &|msg: &str| {\n    println_success!(\"hyperlane: \", msg);\n};\nctx.set_attribute(\"println_hyperlane\", func).await;\nlet println_hyperlane = ctx\n    .get_attribute::<&(dyn Fn(&str) + Send + Sync)>(\"println_hyperlane\")\n    .await\n    .unwrap();\nprintln_hyperlane(\"test\");\n```\n\n<Bottom />", "file_size": 1074, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\panic.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 恐慌\nindex: true\nicon: fas fa-exclamation-triangle\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - panic\norder: 10\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架对于用户线程 `panic` 会进行捕获并写入错误日志，`hook` 支持发送响应\n> 需注意对于一个请求如果在任一中间件环节触发 `panic` 当前请求的后续注册的路由处理函数将不会执行。\n\n### 代码示例\n\n```rust\nasync fn default_panic_hook(ctx: Context) {\nlet request_string: String = ctx.get_request_string().await;\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    let mut response_body: String = error.to_string();\n    let content_type: String = ContentType::format_content_type_with_charset(TEXT_PLAIN, UTF8);\n    if ctx.get_response().await != Response::default() {\n        response_body.push_str(BR);\n        response_body.push_str(&request_string);\n        response_body.push_str(BR);\n    }\n    eprintln!(\"{}\", response_body);\n    let _ = Write::flush(&mut io::stderr());\n    let _ = ctx\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(500)\n        .await\n        .clear_response_headers()\n        .await\n        .set_response_header(SERVER, HYPERLANE)\n        .await\n        .set_response_header(CONTENT_TYPE, content_type)\n        .await\n        .set_response_body(response_body)\n        .await\n        .send()\n        .await;\n}\n\n// 省略 server 创建\nserver.panic_hook(default_panic_hook);\n```\n\n<Bottom />", "file_size": 1435, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\multi-server.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 多服务\nindex: true\nicon: fas fa-server\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - config\n  - multi-server\norder: 11\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持多服务模式，仅需创建多个 `server` 实例并进行监听即可\n\n### 多服务\n\n> [!tip]\n> 启动多个服务，监听多个端口\n\n```rust\nlet app1 = spawn(async move {\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(80).await;\n    let server: Server = Server::from(config).await;\n    server.route(\"/\", |ctx: Context| async move {\n        let _ = ctx.send_status_body(200, \"hello world\").await;\n    }).await;\n    let _ = server.listen().await;\n});\nlet app2 = spawn(async move {\n    let config: ServerConfig = ServerConfig::new().await;\n    config.host(\"0.0.0.0\").await;\n    config.port(81).await;\n    let server: Server = Server::from(config).await;\n    server.route(\"/\", |ctx: Context| async move {\n        let _ = ctx.send_status_body(200, \"hello world\").await;\n    }).await;\n    let _ = server.listen().await;\n});\nlet _ = tokio::join!(app1, app2);\n```", "file_size": 1084, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\connection.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 连接管理\nindex: true\nicon: fas fa-link\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - connection\norder: 12\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架提供了完整的连接状态管理功能，包括连接的中止、关闭状态控制，以及 `Keep-Alive` 连接支持。\n\n## 连接状态管理\n\n### 获取连接状态\n\n```rust\n// 是否中止生命周期中的后续流程\nlet is_aborted: bool = ctx.get_aborted().await;\n// 连接是否断开\nlet is_closed: bool = ctx.get_closed().await;\n// 是否停止（等价于is_aborted || is_closed）\nlet is_terminated: bool = ctx.is_terminated().await;\n```\n\n### 设置连接状态\n\n```rust\nctx.set_aborted(true).await;\nctx.set_closed(true).await;\n```\n\n### 快捷方法\n\n```rust\n// 中止连接\nctx.aborted().await;\n// 关闭连接\nctx.closed().await;\n// 取消中止\nctx.cancel_aborted().await;\n// 取消关闭\nctx.cancel_closed().await;\n```\n\n## Keep-Alive 连接\n\n### 检查是否启用 Keep-Alive\n\n```rust\nlet keep_alive: bool = ctx.is_enable_keep_alive().await;\n```\n\n## 基本使用示例\n\n### 连接状态检查\n\n```rust\nif ctx.get_closed().await {\n    return;\n}\n```\n\n### 长连接处理\n\n```rust\nwhile !ctx.get_closed().await && !ctx.get_aborted().await {\n    let _ = ctx.http_from_stream(8192).await;\n    if !ctx.is_enable_keep_alive().await {\n        ctx.closed().await;\n        break;\n    }\n}\n```\n\n<Bottom />", "file_size": 1196, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\addr.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 客户端地址\nindex: true\nicon: fas fa-map-marker-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - file-extension\norder: 5\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架封装了获取客户端地址的方法\n\n### 使用\n\n#### 获取 `SocketAddr`\n\n```rust\nctx.get_socket_addr().await;\n```\n\n#### 获取 `SocketAddr` 如果失败使用默认值\n\n```rust\nctx.get_socket_addr_or_default().await;\n```\n\n#### 获取 `SocketAddr` 字符串\n\n```rust\nctx.get_socket_addr_string().await;\n```\n\n#### 获取 `SocketAddr` 字符串，如果失败使用默认值\n\n```rust\nctx.get_socket_addr_or_default_string().await;\n```\n\n#### 获取 `SocketHost`\n\n```rust\nctx.get_socket_host().await;\n```\n\n#### 获取 `SocketPort`\n\n```rust\nctx.get_socket_port().await;\n```\n\n<Bottom />", "file_size": 735, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\sse.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: SSE\nindex: true\nicon: fas fa-broadcast-tower\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - sse\norder: 7\n---\n\n<Share colorful />\n\n[GITHUB 地址](https://github.com/hyperlane-dev/hyperlane-quick-start/tree/sse)\n\n> [!tip]\n>\n> `hyperlane` 框架支持 `sse`，服务端主动推送，下面是每隔 `1s` 完成一次推送，并在 `10` 次后关闭连接。\n\n> [!tip]\n>\n> `sse` 规范: 服务器使用 `\"content-type: text/event-stream\"` 表示响应是一个 `sse` 事件流。\n> 接着使用 `\"data\"` 字段来发送事件数据，每个事件以 `\"data:\"` 开头，后面跟着事件的内容和一个空行。\n> 客户端收到这样的响应后，就可以解析其中的事件数据并进行相应的处理。\n> 如果开发者非首次响应尝试调用 `send` 会正常发送响应，但是会包含整个 `http` 协议内容，所以对于 `sse`，\n> 非首次响应请统一使用 `send_body` 方法。\n\n### 服务端代码\n\n```rust\nuse crate::{tokio::time::sleep, *};\nuse std::time::Duration;\n\npub async fn root(ctx: Context) {\n    let _ = ctx\n        .set_response_header(CONTENT_TYPE, TEXT_EVENT_STREAM)\n        .await\n        .set_response_status_code(200)\n        .await\n        .send()\n        .await\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await;\n    for i in 0..10 {\n        let _ = ctx\n            .set_response_body(format!(\"data:{}{}\", i, HTTP_DOUBLE_BR))\n            .await\n            .send_body()\n            .await;\n        sleep(Duration::from_secs(1)).await;\n    }\n    let _ = ctx.closed().await;\n}\n```\n\n### 客户端代码\n\n## 客户端代码\n\n#### 断线重连\n\n```js\nconst eventSource = new EventSource('http://127.0.0.1:60000');\n\neventSource.onopen = function (event) {\n  console.log('Connection opened.');\n};\n\neventSource.onmessage = function (event) {\n  const eventData = JSON.parse(event.data);\n  console.log('Received event data:', eventData);\n};\n\neventSource.onerror = function (event) {\n  if (event.eventPhase === EventSource.CLOSED) {\n    console.log('Connection was closed.');\n  } else {\n    console.error('Error occurred:', event);\n  }\n};\n```\n\n#### 取消断线重连\n\n```js\nconst eventSource = new EventSource('http://127.0.0.1:60000');\n\neventSource.onopen = function (event) {\n  console.log('Connection opened.');\n};\n\neventSource.onmessage = function (event) {\n  const eventData = JSON.parse(event.data);\n  console.log('Received event data:', eventData);\n};\n\neventSource.onerror = function (event) {\n  if (event.eventPhase === EventSource.CLOSED) {\n    console.log('Connection was closed.');\n    // 关闭连接，防止自动重连\n    eventSource.close();\n  } else {\n    console.error('Error occurred:', event);\n  }\n};\n```", "file_size": 2348, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\file-extension.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: FileExtension\ntitle: FileExtension\nindex: true\nicon: fas fa-file-code\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - type\n  - file-extension\norder: 10\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `FileExtension` 内部具体类型定义参考 [FileExtension](https://docs.rs/http-type/latest/http_type/enum.FileExtension.html)。\n\n<Bottom />", "file_size": 383, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\protocol.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: Protocol\ntitle: Protocol\nindex: true\nicon: fas fa-shield-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - protocol\n  - type\norder: 1\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `Protocol` 内部具体类型定义如下\n\n```rust\n/// Represents HTTP-related protocols.\n///\n/// This enum defines the different protocols that can be used in HTTP communication.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Protocol {\n    /// Represents the HTTP protocol.\n    ///\n    /// This is the standard protocol for unencrypted communication over the web.\n    HTTP,\n    /// Represents the HTTPS protocol.\n    ///\n    /// This is the secure version of HTTP, using encryption for communication.\n    HTTPS,\n    /// Represents an unknown or custom protocol.\n    ///\n    /// This variant is used for protocols that are not explicitly defined as HTTP or HTTPS,\n    /// or when the protocol string is not recognized.\n    Unknown(String),\n}\n```\n\n<Bottom />", "file_size": 983, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\utils\\recommend-utils.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 推荐工具\nindex: true\nicon: fas fa-thumbs-up\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - utils\n  - recommend-utils\norder: 2\n---\n\n<Share colorful />\n\n## hyperlane-utils\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `hyperlane-utils` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-utils/README.md)。\n\n## lombok\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `lombok` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../lombok-macros/README.md)。\n\n## clonelicious\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `clonelicious` 库，内部提供变量捕获和克隆（需额外安装和导入），\n> 使用参考 [官方文档](../../clonelicious/README.md)。\n\n## future-fn\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `future-fn` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../future-fn/README.md)。\n\n## std-macro-extensions\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `std-macro-extensions` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../std-macro-extensions/README.md)。\n\n## color-output\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `color-output` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../color-output/README.md)。\n\n## bin-encode-decode\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `bin-encode-decode` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../bin-encode-decode/README.md)。\n\n## file-operation\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `file-operation` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../file-operation/README.md)。\n\n## compare-version\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `compare-version` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../compare-version/README.md)。\n\n## hyperlane-log\n\n> [!tip]\n>\n> `hyperlane` 框架使用 `hyperlane-log` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-log/README.md)。\n\n## hyperlane-time\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `hyperlane-time` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-time/README.md)。\n\n## recoverable-spawn\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `recoverable-spawn` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../recoverable-spawn/README.md)。\n\n## recoverable-thread-pool\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `recoverable-thread-pool` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../recoverable-thread-pool/README.md)。\n\n## http-request\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `http-request` 库，支持 `http` 和 `https`（需额外安装和导入），\n> 使用参考 [官方文档](../../http-request/README.md)。\n\n## hyperlane-broadcast\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `hyperlane-broadcast` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-broadcast/README.md)。\n\n## hyperlane-plugin-websocket\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `hyperlane-plugin-websocket` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../hyperlane-plugin-websocket/README.md)。\n\n## urlencoding\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `urlencoding` 库（需额外安装和导入），可以实现 `url` 编解码。\n\n## server-manager\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `server-manager` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../server-manager/README.md)。\n\n## chunkify\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `chunkify` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../chunkify/README.md)。\n\n## china_identification_card\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `china_identification_card` 库（需额外安装和导入），\n> 使用参考 [官方文档](../../china-identification-card/README.md)。\n\n## utoipa\n\n> [!tip]\n>\n> `hyperlane` 框架推荐使用 `utoipa` 库实现 `openapi`，下面是一段简单的示例代码\n\n```rust\nuse hyperlane::*;\nuse serde::Serialize;\nuse serde_json;\nuse utoipa::{OpenApi, ToSchema};\nuse utoipa_rapidoc::RapiDoc;\nuse utoipa_swagger_ui::SwaggerUi;\n\n#[derive(Serialize, ToSchema)]\nstruct User {\n    name: String,\n    age: usize,\n}\n\n#[derive(OpenApi)]\n#[openapi(\n    components(schemas(User)),\n    info(title = \"Hyperlane\", version = \"1.0.0\"),\n    paths(index, user, openapi_json, swagger)\n)]\nstruct ApiDoc;\n\nasync fn request_middleware(ctx: Context) {\n    ctx.set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(200).await;\n}\n\n#[utoipa::path(\n    get,\n    path = \"/openapi.json\",\n    responses(\n        (status = 200, description = \"Openapi docs\", body = String)\n    )\n)]\nasync fn openapi_json(ctx: Context) {\n    ctx.set_response_body(ApiDoc::openapi().to_json().unwrap())\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/{file}\",\n    responses(\n        (status = 200, description = \"Openapi json\", body = String)\n    )\n)]\nasync fn swagger(ctx: Context) {\n    SwaggerUi::new(\"/{file}\").url(\"/openapi.json\", ApiDoc::openapi());\n    let res: String = RapiDoc::with_openapi(\"/openapi.json\", ApiDoc::openapi()).to_html();\n    ctx.set_response_header(CONTENT_TYPE, TEXT_HTML)\n        .await\n        .set_response_body(res)\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/\",\n    responses(\n        (status = 302, description = \"Redirect to index.html\")\n    )\n)]\nasync fn index(ctx: Context) {\n    ctx.set_response_header(LOCATION, \"/index.html\")\n        .await\n        .set_response_body(vec![])\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[utoipa::path(\n    get,\n    path = \"/user/{name}\",\n    responses(\n        (status = 200, description = \"User\", body = User)\n    )\n)]\nasync fn user(ctx: Context) {\n    let name: String = ctx.get_route_param(\"name\").await.unwrap();\n    let user: User = User { name, age: 0 };\n    ctx.set_response_body(serde_json::to_vec(&user).unwrap())\n        .await\n        .send()\n        .await\n        .unwrap();\n}\n\n#[tokio::main]\nasync fn main() {\n    let server: Server = Server::new().await;\n    server.request_middleware(request_middleware).await;\n    server.route(\"/\", index).await;\n    server.route(\"/user/{name}\", user).await;\n    server.route(\"/openapi.json\", openapi_json).await;\n    server.route(\"/{file}\", swagger).await;\n    server.run().await.unwrap();\n}\n```\n\n<Bottom />", "file_size": 5440, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\speed\\flamegraph.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 火焰图\nindex: true\nicon: fas fa-fire-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - speed\n  - flamegraph\norder: 5\n---\n\n<Share colorful />\n\n## plaintext\n\n![](../markdown-images/flamegraph_plaintext.svg)\n\n## query db\n\n![](../markdown-images/flamegraph_db.svg)\n\n## sleep 100ms\n\n![](../markdown-images/flamegraph_sleep100.svg)", "file_size": 385, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\utils\\inner-utils.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 框架内置工具\nindex: true\nicon: fas fa-tools\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - utils\n  - internal-utils\norder: 1\n---\n\n<Share colorful />\n\n## http-constant\n\n> [!tip]\n>\n> `hyperlane` 框架使用了 `http-constant` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-constant/README.md)。\n\n## http-compress\n\n> [!tip]\n>\n> `hyperlane` 框架使用了 `http-compress` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-compress/README.md)。\n\n## http-type\n\n> [!tip]\n>\n> `hyperlane` 框架使用了 `http-type` 库（框架已内置，无需额外安装和导入），\n> 使用参考 [官方文档](../../http-type/README.md)。\n\n<Bottom />", "file_size": 600, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\type\\upgrade-type.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content: UpgradeType\ntitle: UpgradeType\nindex: true\nicon: fas fa-level-up-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - upgrade-type\n  - type\norder: 4\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架的 `UpgradeType` 内部具体类型定义如下\n\n```rust\n/// Represents different upgrade types.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum UpgradeType {\n    /// Represents an upgrade to the WebSocket protocol.\n    WebSocket,\n    /// Represents an upgrade to HTTP/2 cleartext (h2c).\n    H2c,\n    /// Represents a TLS upgrade, which is rare and experimental. It includes the specific TLS protocol string.\n    Tls(String),\n    /// Represents other custom or unknown upgrade protocols, including the protocol string.\n    Unknown(String),\n}\n```\n\n<Bottom />", "file_size": 790, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\styles\\index.scss", "language": "scss", "content": "* {\n  -webkit-touch-callout: none !important;\n  -webkit-user-select: none !important;\n  -khtml-user-select: none !important;\n  -moz-user-select: none !important;\n  -ms-user-select: none !important;\n  user-select: none !important;\n  --vp-sidebar-line-height: 2;\n  --vp-sidebar-padding-top-bottom: 4px;\n  --vp-catalog-title-line-height: 2.68;\n  --vp-sidebar-group-padding-inline-start: 1.38rem;\n  --vp-sidebar-link-padding-inline-start: 1.88rem;\n  --ltpp-top-scroll-color: var(--vp-c-accent-bg);\n  --ltpp-top-scroll-height: 0.1rem;\n  ::-webkit-resizer,\n  ::-webkit-scrollbar,\n  ::-webkit-scrollbar-button,\n  ::-webkit-scrollbar-thumb,\n  ::-webkit-scrollbar-track,\n  ::-webkit-scrollbar-corner {\n    width: 0px !important;\n    height: 0px !important;\n    border-radius: 0px !important;\n  }\n  scrollbar-width: none !important;\n  --search-input-width: 10rem;\n}\n\n.animate {\n  -webkit-transition: all 0.666s ease !important;\n  -moz-transition: all 0.666s ease !important;\n  -o-transition: all 0.666s ease !important;\n  -ms-transition: all 0.666s ease !important;\n  transition: all 0.666s ease !important;\n}\n\n.ltpp-link {\n  text-decoration: none;\n  font-size: 0.88rem;\n  color: var(--vp-c-text-mute);\n  font-weight: bold;\n  transition: color 0.36s ease;\n}\n\n.ltpp-link:hover,\n.ltpp-link:active {\n  color: var(--vp-c-accent-bg);\n}\n\nh1,\nh2,\nh3,\nh4,\nh5 {\n  font-weight: bold;\n  span {\n    font-weight: bold;\n  }\n}\n\n.title,\n.vp-sidebar-title,\n.nav-screen-links,\n.route-link,\n.nav-link,\n.vp-sidebar-link,\n.vp-sidebar-page {\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n\n.title,\n.vp-sidebar-title,\n.nav-screen-links,\n.vp-sidebar-link,\n.vp-sidebar-page {\n  line-height: var(--vp-sidebar-line-height);\n  padding-top: var(--vp-sidebar-padding-top-bottom);\n  padding-bottom: var(--vp-sidebar-padding-top-bottom);\n}\n\n.vp-sidebar-group .vp-sidebar-group {\n  padding-inline-start: var(--vp-sidebar-group-padding-inline-start);\n}\n\n.vp-sidebar-group .vp-sidebar-link {\n  padding-inline-start: var(--vp-sidebar-link-padding-inline-start);\n}\n\n.vp-catalog-title {\n  line-height: var(--vp-catalog-title-line-height);\n}\n\n.p,\nul,\nol,\nli {\n  line-height: 1.88;\n}\n\n.nav-dropdown a.nav-link {\n  line-height: var(--vp-catalog-title-line-height) !important;\n}\n\n.vp-sidebar-header,\n.vp-sidebar,\n.vp-sidebar-links,\n.vp-sidebar-link,\n.vp-sidebar > .vp-sidebar-links > li > .vp-sidebar-link {\n  font-size: 0.98em;\n  font-weight: 500;\n}\n\n.icp-img {\n  height: 18.4px;\n  width: auto;\n  position: absolute;\n  left: -22px;\n  top: 0px;\n}\n\n.relative {\n  position: relative;\n}\n\nh1 {\n  font-size: 2rem !important;\n}\n\nh2 {\n  font-size: 1.5rem !important;\n}\n\nh3 {\n  font-size: 1.17rem !important;\n}\n\nh4 {\n  font-size: 1rem !important;\n}\n\nh5 {\n  font-size: 0.83rem !important;\n}\n\nh6 {\n  font-size: 0.75rem !important;\n}\n\n.vp-hero-action {\n  padding: 0.36em 1.36rem;\n}\n\n#main-title {\n  font-size: 3.36rem !important;\n}\n\n#main-description {\n  font-size: 1.36rem !important;\n}\n\n@media (max-width: 419px) {\n  #main-title {\n    font-size: 2rem !important;\n  }\n  #main-description {\n    font-size: 1.2rem !important;\n  }\n}\n\n@media (max-width: 719px) {\n  #main-title {\n    font-size: 2.25rem !important;\n  }\n  #main-description {\n    font-size: 1.2rem !important;\n  }\n}\n\n@media (max-width: 959px) {\n  #main-title {\n    font-size: 2.5rem !important;\n  }\n  #main-description {\n    font-size: 1.2rem !important;\n  }\n}\n\ncode,\ncode * {\n  -webkit-touch-callout: unset !important;\n  /* iOS Safari */\n  -webkit-user-select: unset !important;\n  /* Chrome/Safari/Opera */\n  -khtml-user-select: unset !important;\n  /* Konqueror */\n  -moz-user-select: unset !important;\n  /* Firefox */\n  -ms-user-select: unset !important;\n  /* Internet Explorer/Edge */\n  user-select: text !important;\n}\n\n.vp-page-nav .auto-link {\n  border: 0px solid transparent;\n}\n\n.external-link-icon .external-link:not(.no-external-link-icon)::after,\n.external-link-icon [vp-content] a[href*=\"://\"]:not(.no-external-link-icon)::after, .external-link-icon [vp-content] a[target=_blank]:not(.no-external-link-icon)::after\n{\n  background: transparent !important;\n  width: 0px !important;\n  height: 0px !important;\n}\n\n.vp-footer-wrapper,\n.vp-page-nav {\n  border: 0px solid transparent !important;\n}\n\n.vp-sidebar-header,\n.vp-sidebar,\n.vp-sidebar-links,\n.vp-sidebar-link,\n.vp-sidebar > .vp-sidebar-links > li > .vp-sidebar-link {\n  font-weight: 400 !important;\n}\n\n.vp-navbar-center .vp-nav-item {\n  padding: 0rem 1.68rem;\n}\n\n.labelBkg {\n  border-radius: 6px;\n}\n\n.edgeLabel p {\n  padding: 0.36rem;\n  border-radius: 6px;\n}\n\n.vp-breadcrumb li {\n  line-height: 0px;\n}\n\n.center {\n  text-align: center;\n}\n\nsvg {\n  max-width: 100% !important;\n}\n\n#mermaid-123 .labelBkg {\n  background-color: #ffb500 !important;\n}", "file_size": 4727, "extension": ".scss"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\response.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 响应\nindex: true\nicon: fas fa-arrow-alt-circle-up\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - response\norder: 6\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架没有发送响应前通过 `ctx` 中 `get_response` 获取的只是响应的初始化实例，里面其实没有数据，\n> 只有当用户发送响应时才会构建出完整 `http` 响应，此后再次 `get_response` 才能获取到响应内容。\n\n> [!tip]\n>\n> `hyperlane` 框架对 `ctx` 额外封装了子字段的方法，可以直接调用大部分子字段的 `get` 和 `set` 方法名称，\n> 例如：调用 `response` 上的 `get_status_code` 方法。\n>\n> **调用规律**\n>\n> - 原 `response` 的 `get` 方法的 `get` 名称后加 `response` 名称，中间使用\\_拼接。\n> - 原 `response` 的 `set` 方法的 `set` 名称后加 `response` 名称，中间使用\\_拼接。\n\n### 获取响应\n\n#### 获取 `response`\n\n```rust\nlet response: Response = ctx.get_response().await;\n```\n\n#### 获取响应版本\n\n```rust\nlet version: ResponseVersion = ctx.get_response_version().await;\n```\n\n#### 获取响应状态码\n\n```rust\nlet status_code: ResponseStatusCode = ctx.get_response_status_code().await;\n```\n\n#### 获取响应原因短语\n\n```rust\nlet reason_phrase: ResponseReasonPhrase = ctx.get_response_reason_phrase().await;\n```\n\n#### 获取完整响应头\n\n```rust\nlet headers: ResponseHeaders = ctx.get_response_headers().await;\n```\n\n#### 获取某个响应头\n\n```rust\nlet value: OptionResponseHeadersValue = ctx.get_response_header(CONTENT_TYPE).await;\n```\n\n#### 获取响应头的第一个值\n\n```rust\nlet header_value: OptionResponseHeadersValueItem = ctx.get_response_header_front(CONTENT_TYPE).await;\n```\n\n#### 获取响应头的最后一个值\n\n```rust\nlet header_value: OptionResponseHeadersValueItem = ctx.get_response_header_back(CONTENT_TYPE).await;\n```\n\n#### 检查是否存在特定响应头\n\n```rust\nlet has_header: bool = ctx.get_response_has_header(CONTENT_TYPE).await;\n```\n\n#### 检查响应头是否包含特定值\n\n```rust\nlet has_value: bool = ctx.has_response_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 获取响应头数量\n\n```rust\nlet headers_count: usize = ctx.get_response_headers_length().await;\n```\n\n#### 获取响应头值的数量\n\n```rust\nlet header_count: usize = ctx.get_response_header_len(CONTENT_TYPE).await;\n```\n\n#### 获取所有响应头值的总数量\n\n```rust\nlet total_values: usize = ctx.get_response_headers_values_length().await;\n```\n\n#### 获取响应体\n\n```rust\nlet body: ResponseBody = ctx.get_response_body().await;\n```\n\n#### 获取 `string` 格式的响应体\n\n```rust\nlet body: String = ctx.get_response_body_string().await;\n```\n\n#### 获取 `json` 格式的响应体\n\n```rust\nlet body: T = ctx.get_response_body_json::<T>().await;\n```\n\n#### 获取响应 Cookie\n\n```rust\nlet cookies: Cookies = ctx.get_response_cookies().await;\n```\n\n#### 获取特定响应 Cookie\n\n```rust\nlet cookie_value: OptionCookiesValue = ctx.get_response_cookie(\"session_id\").await;\n```\n\n### 设置响应\n\n#### 设置 `response`\n\n```rust\nctx.set_response(Response::default()).await;\n```\n\n#### 设置响应版本\n\n> [!warning]\n>\n> 特别注意的是需要设置响应版本，框架默认的版本是空字符串，客户端处理会异常。\n\n```rust\nctx.set_response_version(HttpVersion::HTTP1_1).await;\n```\n\n#### 设置响应状态码\n\n```rust\nctx.set_response_status_code(200).await;\n```\n\n#### 设置响应原因短语\n\n```rust\nctx.set_response_reason_phrase(\"OK\").await;\n```\n\n#### 设置响应体\n\n```rust\nctx.set_response_body(\"Hello World\").await;\n```\n\n#### 设置（添加）响应头\n\n> [!tip]\n>\n> `hyperlane` 框架对响应头的 `key` 是不做大小写处理的，建议使用框架定义的常量。\n\n```rust\nctx.add_response_header(SERVER, \"hyperlane\").await;\n```\n\n#### 设置（替换）响应头\n\n```rust\nctx.set_response_header(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 移除响应头\n\n```rust\nctx.remove_response_header(CONTENT_TYPE).await;\n```\n\n#### 移除响应头的特定值\n\n```rust\nctx.remove_response_header_value(CONTENT_TYPE, APPLICATION_JSON).await;\n```\n\n#### 清空所有响应头\n\n```rust\nctx.clear_response_headers().await;\n```\n\n### 执行闭包操作\n\n#### 使用响应执行异步闭包\n\n```rust\nlet result = ctx.with_response(|response| async move {\n    response.get_status_code()\n}).await;\n```\n\n### 转字符串\n\n#### 通过 `to_string`\n\n> [!tip]\n> 将获得完整的原始结构体字符串结构。\n\n```rust\nctx.get_response().await.to_string();\n```\n\n#### 通过 `get_string`\n\n> [!tip]\n> 将获得简化的结构体字符串结构。\n\n```rust\nctx.get_response().await.get_string();\n```\n\n#### 通过 `ctx.get_response_string`\n\n```rust\nlet response_string: String = ctx.get_response_string().await;\n```\n\n<Bottom />", "file_size": 3886, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\route.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 路由\nindex: true\nicon: fas fa-route\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - request\norder: 4\n---\n\n<Share colorful />\n\n## 静态路由\n\n> [!tip]\n>\n> `hyperlane` 框架支持静态路由（如果重复注册相同的静态路由，框架会抛出异常，程序退出运行），使用方法如下：\n\n### 注册\n\n```rust\nserver.route(\"/test\", |ctx: Context| {}).await;\n```\n\n## 动态路由\n\n> [!tip]\n>\n> `hyperlane` 框架支持动态路由（如果重复注册相同模式的动态路由，框架会抛出异常，程序退出运行），具体使用方法如下：\n\n### 注册\n\n> [!tip]\n> 动态路由使用 `{}` 包裹，有两种写法\n>\n> - `{key}`内直接些字符串，则将匹配的 `value` 存入 `key` 对应的 `value` 中。\n> - `{key:regex}` 则将正则表达式匹配的 `value` 存入 `key` 对应的 `value` 中，如果路径的最后是正则动态路由，则匹配后续所有路径，例如 `/test/{file:^.*$}` 匹配 `/test/a/b/c/d` 会成功，`file` 的 `value` 为 `a/b/c/d`。如果路径的最后不是正则动态路由，则仅使用正则匹配当前段的路由，例如 `/test/{file:^.*$}/b` 匹配 `/test/a/b` 会成功，`file` 的 `value` 为 `a`。\n\n### 朴素动态路由\n\n```rust\nserver.route(\"/test/{text}\", |ctx: Context| {}).await;\n```\n\n### 正则表达式动态路由\n\n```rust\nserver.route(\"/test/{number:\\\\d+}\", |ctx: Context| {}).await;\n```\n\n### 获取全部动态路由参数\n\n```rust\nctx.get_route_params().await;\n```\n\n### 获取某个动态路由参数\n\n```rust\nctx.get_route_param(\"text\").await;\n```\n\n<Bottom />", "file_size": 1107, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\stream.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: 流\nindex: true\nicon: fas fa-water\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - stream\norder: 2\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架接收请求和发送响应均依赖 `stream`，类型是 [`ArcRwLockStream`](../type/stream.md) 需要注意框架提供的 `stream` 仅可读，使用方式如下：\n\n### 获取 `stream`\n\n```rust\nlet stream_lock: ArcRwLockStream = ctx.get_stream().await.clone().unwrap();\n```\n\n### 获取客户端地址\n\n> [!tip]\n>\n> 完整接口参阅[官方文档](./addr.md)，此处只介绍通过 `stream` 解析使用。\n\n```rust\nlet socket_addr: String = ctx\n    .get_stream()\n    .await\n    .unwrap()\n    .read()\n    .await\n    .peer_addr()\n    .and_then(|host| Ok(host.to_string()))\n    .unwrap_or(\"Unknown\".to_owned());\n```\n\n### 关闭连接\n\n> [!tip]\n> 此方法会关闭 `TCP` 连接，不会终止当前的生命周期（当前声明周期结束不会进入下一次生命周期循环，需要重新建立 `TCP` 连接），当前声明周期内的代码正常执行，但是不会再发送响应。\n\n```rust\nctx.closed().await;\n```\n\n<Bottom />", "file_size": 875, "extension": ".md"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-quick-start\"\nversion = \"3.7.2\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A lightweight rust http server with middleware, websocket, sse, and tcp support, built on tokio for cross-platform async networking, hyperlane simplifies modern web service development.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"cross-platform\"]\nrepository = \"https://github.com/hyperlane-dev/hyperlane-quick-start.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \".github\",\n    \"tmp\",\n    \"**/*.pid\",\n    \"**/*.log\"\n]\n\n[workspace]\nmembers = [\n    \"app\",\n    \"config\",\n    \"init\",\n    \"plugin\"\n]\n\n[workspace.dependencies]\nhyperlane_app = { path = \"app\", version = \"0.1.0\" }\nhyperlane_config = { path = \"config\", version = \"0.1.0\" }\nhyperlane_init = { path = \"init\", version = \"0.1.0\" }\nhyperlane_plugin = { path = \"plugin\", version = \"0.1.0\" }\n\nhyperlane = \"7.8.0\"\nhyperlane-utils = \"7.2.0\"\n\n[dependencies]\nhyperlane_init = { workspace = true }\n\n[patch.crates-io]\nhyperlane_app = { path = \"app\" }\nhyperlane_config = { path = \"config\" }\nhyperlane_init = { path = \"init\" }\nhyperlane_plugin = { path = \"plugin\" }\n\n[profile.dev]\nincremental = true\nopt-level = 1\nlto = false\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"none\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1495, "extension": ".toml"}
{"file_path": "training_sources\\ltpp-docs\\src\\hyperlane\\usage-introduction\\websocket.md", "language": "markdown", "content": "---\nhead:\n  - - meta\n    - name: keywords\n      content:\ntitle: WebSocket\nindex: true\nicon: fas fa-exchange-alt\ncategory:\n  - hyperlane\n  - web\n  - rust\n  - usage-introduction\n  - websocket\norder: 8\n---\n\n<Share colorful />\n\n> [!tip]\n>\n> `hyperlane` 框架支持 `websocket` 协议，服务端自动处理协议升级，支持请求中间件，路由处理，响应中间件。\n\n### 服务端代码\n\n> [!tip]\n>\n> `hyperlane` 框架发送 `websocket` 响应使用`send_body`，与 `sse` 相同。\n> 由于 `websocket`协议基于`http`，所以可以像使用 `http` 一样处理请求。\n> 如果开发者尝试调用 `send` 会导致客户端处理错误，\n> （服务端发送响应前需要处理成符合`websocket` 规范的响应，客户端才能正确解析）。所以对于 `websocket`，\n> 请统一使用 `send_body` 方法。\n\n#### 单点发送\n\n```rust\npub async fn handle(ctx: Context) {\n    let request_body: Vec<u8> = ctx.get_request_body().await;\n    let _ = ctx.set_response_body(request_body).await.send_body().await;\n}\n```\n\n#### 广播发送\n\n> [!tip]\n>\n> 需要阻塞住当前处理函数，将后续所有请求在处理函数中处理。\n> 这里使用 `tokio` 的 `select` 来处理多个请求，使用 [`hyperlane-broadcast`](../../hyperlane-broadcast/README.md) 来实现广播。\n> 需要特别注意，如果 `server` 没有配置 [`disable_ws_hook`](../config/ws-handle.md) ，群发消息必须要求客户端连接后主动向服务端发送一条消息（空消息即可），否则不会接收到广播的信息，\n> 因为服务端在框架内部会先完成握手，然后等待读取一次客户端请求，才会执行到用户代码。\n> 如果配置了则连接后即可接收到广播的信息。\n\n> [!tip]\n>\n> 完整代码参考 [`GroupChat`](../project/group-chat.md) 。\n\n### 客户端代码\n\n```js\nconst ws = new WebSocket('ws://localhost:60000/websocket');\n\nws.onopen = () => {\n  console.log('WebSocket opened');\n  setInterval(() => {\n    ws.send(`Now time: ${new Date().toISOString()}`);\n  }, 1000);\n};\n\nws.onmessage = (event) => {\n  console.log('Receive: ', event.data);\n};\n\nws.onerror = (error) => {\n  console.error('WebSocket error: ', error);\n};\n\nws.onclose = () => {\n  console.log('WebSocket closed');\n};\n```", "file_size": 1593, "extension": ".md"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\styles\\palette.scss", "language": "scss", "content": ":root {\n  --content-width: max(61vw, 740px);\n  --home-page-width: max(78vw, 740px);\n}\n\n$sidebar-width: 16rem;\n$content-width: var(--content-width);\n$home-page-width: var(78vw);\n$navbar-height: 3.26rem;\n\n$font-family: 'Microsoft Yahei, SimSun, -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, \"Helvetica Neue\", Arial, \"Noto Sans\", STHeiti, \"Microsoft YaHei\", SimSun, sans-serif, \"Apple Color Emoji\", \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\"' !default;\n$font-family-heading: $font-family !default;\n$font-family-mono: 'Consolas, Monaco, \"Andale Mono\", \"Ubuntu Mono\", monospace' !default;", "file_size": 605, "extension": ".scss"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\plugin\\lib.rs", "language": "rust", "content": "pub mod log;\npub mod server_manager;\n\nuse hyperlane_utils::*;", "file_size": 61, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane\"\nversion = \"7.9.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A lightweight, high-performance, and cross-platform Rust HTTP server library built on Tokio. It simplifies modern web service development by providing built-in support for middleware, WebSocket, Server-Sent Events (SSE), and raw TCP communication. With a unified and ergonomic API across Windows, Linux, and MacOS, it enables developers to build robust, scalable, and event-driven network applications with minimal overhead and maximum flexibility.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"cross-platform\"]\nrepository = \"https://github.com/hyperlane-dev/hyperlane.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"img\",\n    \"**/*.log\"\n]\n\n[dependencies]\nhttp-type = \"4.58.2\"\nlombok-macros = \"1.13.11\"\nserde_json = \"1.0.143\"\nserde = { version = \"1.0.219\", features = [\"derive\"] }\nregex = \"1.11.1\"\ninventory = \"0.3.21\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1333, "extension": ".toml"}
{"file_path": "training_sources\\ltpp-docs\\src\\.vuepress\\styles\\config.scss", "language": "scss", "content": "$colors: #c0392b, #d35400, #f39c12, #27ae60, #16a085, #2980b9, #8e44ad, #2c3e50,\n  #7f8c8d !default;", "file_size": 100, "extension": ".scss"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\lib.rs", "language": "rust", "content": "pub mod business;\npub mod framework;\npub mod server_manager;\n\nuse hyperlane::*;", "file_size": 79, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\LICENSE", "language": "unknown", "content": "MIT License\n\nCopyright (c) 2024 尤雨东\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.", "file_size": 1059, "extension": ""}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\lib.rs", "language": "rust", "content": "pub mod aspect;\npub mod controller;\npub mod exception;\npub mod filter;\npub mod mapper;\npub mod middleware;\npub mod model;\npub mod service;\npub mod utils;\npub mod view;\n\nuse hyperlane::*;\nuse hyperlane_utils::*;\n\nuse hyperlane_plugin::log::*;", "file_size": 241, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\init\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane_init\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[lib]\npath = \"lib.rs\"\n\n[dependencies]\nhyperlane_app = { workspace = true }\nhyperlane_config = { workspace = true }\nhyperlane_plugin = { workspace = true }\n\nhyperlane = { workspace = true }\nhyperlane-utils = { workspace = true }", "file_size": 297, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane_app\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[lib]\npath = \"lib.rs\"\n\n[dependencies]\nhyperlane_config = { workspace = true }\nhyperlane_plugin = { workspace = true }\n\nhyperlane = { workspace = true }\nhyperlane-utils = { workspace = true }", "file_size": 259, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\plugin\\server_manager\\fn.rs", "language": "rust", "content": "use super::*;\n\npub async fn create<F, Fut>(server_hook: F)\nwhere\n    F: Fn() -> Fut + Send + Sync + 'static,\n    Fut: Future<Output = ()> + Send + 'static,\n{\n    let args: Vec<String> = args().collect();\n    let mut manager: ServerManager = ServerManager::new();\n    manager\n        .set_pid_file(PID_FILE_PATH)\n        .set_server_hook(server_hook);\n    let is_daemon: bool = args.len() >= 3 && args[2].to_lowercase() == \"-d\";\n    let start_server = || async {\n        if is_daemon {\n            match manager.start_daemon().await {\n                Ok(_) => println_success!(\"Server started in background successfully\"),\n                Err(e) => println_error!(format!(\"Error starting server in background: {e}\")),\n            };\n        } else {\n            println_success!(\"Server started successfully\");\n            manager.start().await;\n        }\n    };\n    let stop_server = || async {\n        match manager.stop().await {\n            Ok(_) => println_success!(\"Server stopped successfully\"),\n            Err(e) => println_error!(format!(\"Error stopping server: {e}\")),\n        };\n    };\n    let hot_restart_server = || async {\n        match manager\n            .watch_detached(&[\"--clear\", \"--skip-local-deps\", \"-q\", \"-x\", \"run\"])\n            .await\n        {\n            Ok(_) => println_success!(\"Server started successfully\"),\n            Err(e) => println_error!(format!(\"Error starting server in background: {e}\")),\n        }\n    };\n    let restart_server = || async {\n        stop_server().await;\n        start_server().await;\n    };\n    if args.len() < 2 {\n        start_server().await;\n        return;\n    }\n    let command: String = args[1].to_lowercase();\n    match command.as_str() {\n        \"start\" => start_server().await,\n        \"stop\" => stop_server().await,\n        \"restart\" => restart_server().await,\n        \"hot\" => hot_restart_server().await,\n        _ => {\n            println_error!(format!(\"Invalid command: {command}\"));\n        }\n    }\n}", "file_size": 1974, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\src\\main.rs", "language": "rust", "content": "use hyperlane_init;\n\nfn main() {\n    hyperlane_init::framework::run();\n}", "file_size": 72, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\framework\\const.rs", "language": "rust", "content": "use super::*;\n\npub const SERVER_PORT: usize = 60000;\npub const SERVER_HOST: &str = \"0.0.0.0\";\npub const SERVER_WS_BUFFER: usize = 4096;\npub const SERVER_HTTP_BUFFER: usize = 4096;\npub const SERVER_LOG_SIZE: usize = 100_024_000;\npub const SERVER_LOG_DIR: &str = \"./tmp/logs\";\npub const SERVER_INNER_PRINT: bool = true;\npub const SERVER_INNER_LOG: bool = true;\npub const SERVER_NODELAY: bool = true;\npub const SERVER_LINGER: Duration = Duration::ZERO;\npub const SERVER_TTI: u32 = 128;", "file_size": 482, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane_config\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[lib]\npath = \"lib.rs\"\n\n[dependencies]\nhyperlane = { workspace = true }\nhyperlane-utils = { workspace = true }", "file_size": 181, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\init\\framework\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[hyperlane(config: ServerConfig)]\nasync fn configure_config(server: &Server) {\n    config.host(SERVER_HOST).await;\n    config.port(SERVER_PORT).await;\n    config.ttl(SERVER_TTI).await;\n    config.linger(SERVER_LINGER).await;\n    config.nodelay(SERVER_NODELAY).await;\n    config.http_buffer(SERVER_HTTP_BUFFER).await;\n    config.ws_buffer(SERVER_WS_BUFFER).await;\n    server.config(config).await;\n}\n\nasync fn configure_panic_hook(server: &Server) {\n    server.panic_hook(exception::framework::panic_hook).await;\n}\n\nasync fn configure_request_middleware(server: &Server) {\n    server\n        .request_middleware(middleware::request::cross::cross)\n        .await\n        .request_middleware(middleware::request::response::response_header)\n        .await\n        .request_middleware(middleware::request::response::response_status_code)\n        .await\n        .request_middleware(middleware::request::response::response_body)\n        .await;\n}\n\nasync fn configure_response_middleware(server: &Server) {\n    server\n        .response_middleware(middleware::response::send::send)\n        .await\n        .response_middleware(middleware::response::log::log)\n        .await;\n}\n\nasync fn configure_routes(server: &Server) {\n    server\n        .route(format!(\"/hello/{{{NAME_KEY}}}\"), controller::hello::handle)\n        .await;\n}\n\nfn runtime() -> Runtime {\n    Builder::new_multi_thread()\n        .worker_threads(num_cpus::get_physical() << 1)\n        .thread_stack_size(1_048_576)\n        .max_blocking_threads(2_048)\n        .max_io_events_per_tick(1_024)\n        .enable_all()\n        .build()\n        .unwrap()\n}\n\n#[hyperlane(server: Server)]\nasync fn create_server() {\n    configure_config(&server).await;\n    configure_panic_hook(&server).await;\n    configure_request_middleware(&server).await;\n    configure_routes(&server).await;\n    configure_response_middleware(&server).await;\n    println_success!(\"Server initialization successful\");\n    let server_result: ServerResult<ServerHook> = server.run().await;\n    match server_result {\n        Ok(server_hook) => {\n            let host_port: String = format!(\"{SERVER_HOST}:{SERVER_PORT}\");\n            println_success!(\"Server listen in: \", host_port);\n            let shutdown: ArcFnPinBoxFutureSend<()> = server_hook.get_shutdown_hook().clone();\n            set_shutdown(shutdown);\n            server_hook.wait().await;\n        }\n        Err(server_error) => println_error!(\"Server run error: \", server_error),\n    }\n}\n\npub fn run() {\n    runtime().block_on(server_manager::create(create_server));\n}", "file_size": 2561, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\plugin\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane_plugin\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[lib]\npath = \"lib.rs\"\n\n[dependencies]\nhyperlane_config = { workspace = true }\n\nhyperlane = { workspace = true }\nhyperlane-utils = { workspace = true }", "file_size": 222, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\init\\business\\mod.rs", "language": "rust", "content": "mod root;", "file_size": 9, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\plugin\\server_manager\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_config::server_manager::*;\n\nuse std::{env::args, future::Future};", "file_size": 122, "extension": ".rs"}
{"file_path": "training_sources\\ltpp-docs\\component\\mixins\\no-click-mixin.js", "language": "javascript", "content": "/**\n * No-Click Mixin\n * 为组件提供禁用点击功能的混入\n * 使用方法：在组件中添加 mixins: [NoClickMixin]\n */\nconst NoClickMixin = {\n  mounted() {\n    // 自动为所有带有 no-click 类的元素添加事件监听器\n    this.$nextTick(() => {\n      this.setupNoClickElements();\n    });\n  },\n\n  updated() {\n    // 组件更新后重新设置\n    this.$nextTick(() => {\n      this.setupNoClickElements();\n    });\n  },\n\n  methods: {\n    /**\n     * 阻止点击事件\n     * @param {Event} event - 事件对象\n     * @returns {boolean} - 返回 false\n     */\n    preventClick(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      return false;\n    },\n\n    /**\n     * 阻止右键菜单\n     * @param {Event} event - 事件对象\n     * @returns {boolean} - 返回 false\n     */\n    preventContextMenu(event) {\n      event.preventDefault();\n      return false;\n    },\n\n    /**\n     * 阻止拖拽\n     * @param {Event} event - 事件对象\n     * @returns {boolean} - 返回 false\n     */\n    preventDrag(event) {\n      event.preventDefault();\n      return false;\n    },\n\n    /**\n     * 设置 no-click 元素的事件监听器\n     */\n    setupNoClickElements() {\n      if (!this.$el) return;\n\n      const noClickElements = this.$el.querySelectorAll('.no-click');\n      noClickElements.forEach((element) => {\n        // 检查是否已经添加过事件监听器\n        if (!element._noClickSetup) {\n          element.addEventListener('click', this.preventClick, {\n            passive: false,\n          });\n          element.addEventListener('contextmenu', this.preventContextMenu, {\n            passive: false,\n          });\n          element.addEventListener('dragstart', this.preventDrag, {\n            passive: false,\n          });\n          element.addEventListener('selectstart', this.preventClick, {\n            passive: false,\n          });\n\n          // 标记已设置\n          element._noClickSetup = true;\n        }\n      });\n    },\n\n    /**\n     * 清理事件监听器\n     */\n    cleanupNoClickElements() {\n      if (this.$el) {\n        const noClickElements = this.$el.querySelectorAll('.no-click');\n        noClickElements.forEach((element) => {\n          if (element._noClickSetup) {\n            element.removeEventListener('click', this.preventClick);\n            element.removeEventListener('contextmenu', this.preventContextMenu);\n            element.removeEventListener('dragstart', this.preventDrag);\n            element.removeEventListener('selectstart', this.preventClick);\n\n            delete element._noClickSetup;\n          }\n        });\n      }\n    },\n  },\n\n  beforeDestroy() {\n    // Vue 2 生命周期钩子\n    this.cleanupNoClickElements();\n  },\n\n  beforeUnmount() {\n    // Vue 3 生命周期钩子\n    this.cleanupNoClickElements();\n  },\n};\n\nexport { NoClickMixin };\nexport default NoClickMixin;", "file_size": 2607, "extension": ".js"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\not_found\\mod.rs", "language": "rust", "content": "mod r#const;\n\npub use r#const::*;", "file_size": 33, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\resources\\static\\html\\404.html", "language": "html", "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>404 Not Found</title>\n    <style>\n      .center-text {\n        text-align: center;\n      }\n      a {\n        color: #1e90ff;\n        text-decoration: none;\n        transition: color 0.3s, border-bottom-color 0.3s;\n      }\n      a:hover,\n      a:focus {\n        color: pink;\n        border-bottom-color: pink;\n        outline: none;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <h1 class=\"center-text\">404 Not Found</h1>\n    <hr />\n    <p class=\"center-text\">\n      Server:\n      <a href=\"https://github.com/hyperlane-dev/hyperlane\" target=\"_blank\"\n        >Hyperlane</a\n      >\n    </p>\n  </body>\n</html>", "file_size": 787, "extension": ".html"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\init\\lib.rs", "language": "rust", "content": "pub mod business;\npub mod framework;\n\nuse hyperlane::*;\nuse hyperlane_utils::*;", "file_size": 79, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\README.ZH-CN.md", "language": "markdown", "content": "<center>\n\n## hyperlane-quick-start\n\n[English](README.md) | [简体中文](README.ZH-CN.md)\n\n<img src=\"https://docs.ltpp.vip/img/hyperlane.png\" alt=\"\" height=\"160\">\n\n[![](https://img.shields.io/crates/v/hyperlane.svg)](https://crates.io/crates/hyperlane)\n[![](https://img.shields.io/crates/d/hyperlane.svg)](https://img.shields.io/crates/d/hyperlane.svg)\n[![](https://docs.rs/hyperlane/badge.svg)](https://docs.rs/hyperlane)\n[![](https://github.com/hyperlane-dev/hyperlane/workflows/Rust/badge.svg)](https://github.com/hyperlane-dev/hyperlane/actions?query=workflow:Rust)\n[![](https://img.shields.io/crates/l/hyperlane.svg)](./license)\n\n</center>\n\n> 这是一个轻量级、高性能且跨平台的 Rust HTTP 服务器库，基于 Tokio 构建。它通过提供中间件、WebSocket、服务器推送事件(SSE)和原始 TCP 通信的内置支持，简化了现代 Web 服务的开发。凭借在 Windows、Linux 和 macOS 上统一且符合人体工程学的 API，它使开发者能够以最小的开销和最大的灵活性构建强大、可扩展且事件驱动的网络应用程序。\n\n## API 文档\n\n- [API 文档](https://docs.rs/hyperlane/latest/hyperlane/)\n\n## 官方文档\n\n- [官方文档](https://docs.ltpp.vip/hyperlane/)\n\n## 运行\n\n### 运行\n\n```sh\ncargo run\n```\n\n### 在后台运行\n\n```sh\ncargo run -- -d\n```\n\n### 停止\n\n```sh\ncargo run stop\n```\n\n### 重启\n\n```sh\ncargo run restart\n```\n\n### 重启在后台运行\n\n```sh\ncargo run restart -d\n```\n\n## 性能测试\n\n- [性能测试](https://docs.ltpp.vip/hyperlane/speed)\n\n## 赞赏\n\n> 如果你觉得 `hyperlane` 对你有所帮助，欢迎捐赠\n\n### 微信支付\n\n<img src=\"https://docs.ltpp.vip/img/wechat-pay.png\" width=\"200\">\n\n### 支付宝支付\n\n<img src=\"https://docs.ltpp.vip/img/alipay-pay.jpg\" width=\"200\">\n\n## 许可证\n\n此项目基于 MIT 许可证授权。详细信息请查看 [license](license) 文件。\n\n## 贡献\n\n欢迎贡献！请提交 issue 或创建 pull request。\n\n## 联系方式\n\n如有任何疑问，请联系作者：[root@ltpp.vip](mailto:root@ltpp.vip)。", "file_size": 1553, "extension": ".md"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\mod.rs", "language": "rust", "content": "pub mod hello;\npub mod logo_img;\npub mod not_found;\npub mod templates;", "file_size": 70, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\resources\\templates\\html\\index.html", "language": "html", "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Hyperlane</title>\n    <style>\n      .center-text {\n        text-align: center;\n      }\n      a {\n        color: #1e90ff;\n        text-decoration: none;\n        transition: color 0.3s, border-bottom-color 0.3s;\n      }\n      a:hover,\n      a:focus {\n        color: pink;\n        border-bottom-color: pink;\n        outline: none;\n        cursor: pointer;\n      }\n    </style>\n  </head>\n  <body>\n    <h1 class=\"center-text\">Hello hyperlane: {{ time }}</h1>\n    <hr />\n    <p class=\"center-text\">\n      Server:\n      <a href=\"https://github.com/hyperlane-dev/hyperlane\" target=\"_blank\"\n        >Hyperlane</a\n      >\n    </p>\n  </body>\n</html>", "file_size": 797, "extension": ".html"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\framework\\static.rs", "language": "rust", "content": "use super::*;\n\npub(super) static SHUTDOWN: OnceLock<ArcFnPinBoxFutureSend<()>> = OnceLock::new();", "file_size": 97, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\init\\framework\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_app::{controller, exception, middleware};\nuse hyperlane_config::{business::hello::*, framework::*};\nuse hyperlane_plugin::server_manager;\n\nuse tokio::runtime::{Builder, Runtime};", "file_size": 235, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\framework\\mod.rs", "language": "rust", "content": "mod r#const;\nmod r#fn;\nmod r#static;\n\npub use r#const::*;\npub use r#fn::*;\n\nuse super::*;\nuse r#static::*;\n\nuse std::{\n    sync::{Arc, OnceLock},\n    time::Duration,\n};", "file_size": 168, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\framework\\fn.rs", "language": "rust", "content": "use super::*;\n\npub fn set_shutdown(shutdown: ArcFnPinBoxFutureSend<()>) {\n    if SHUTDOWN.get().is_some() {\n        return;\n    }\n    let _ = SHUTDOWN.set(shutdown);\n}\n\npub fn shutdown() -> ArcFnPinBoxFutureSend<()> {\n    SHUTDOWN\n        .get_or_init(|| Arc::new(|| Box::pin(async {})))\n        .clone()\n}", "file_size": 306, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\model\\mod.rs", "language": "rust", "content": "pub mod application;\npub mod bean;\npub mod business;\npub mod data;\npub mod data_access;\npub mod data_transfer;\npub mod domain;\npub mod param;\npub mod persistent;\npub mod view;", "file_size": 175, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\server_manager\\const.rs", "language": "rust", "content": "pub const PID_FILE_PATH: &str = \"./tmp/process/hyperlane.pid\";", "file_size": 62, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\not_found\\const.rs", "language": "rust", "content": "pub const NOT_FOUND_HTML: &'static str = include_str!(\"../../../resources/static/html/404.html\");", "file_size": 97, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\hello\\const.rs", "language": "rust", "content": "pub const NAME_KEY: &str = \"name\";", "file_size": 34, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\logo_img\\const.rs", "language": "rust", "content": "pub const LOGO_IMG_URL: &str = \"https://docs.ltpp.vip/img/hyperlane.png\";", "file_size": 73, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\mod.rs", "language": "rust", "content": "pub mod favicon_ico;\npub mod hello;\npub mod root;\npub mod ws;\n\nuse super::*;", "file_size": 76, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\config\\business\\templates\\const.rs", "language": "rust", "content": "pub const INDEX_HTML: &'static str = include_str!(\"../../../resources/templates/html/index.html\");", "file_size": 98, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\request\\mod.rs", "language": "rust", "content": "pub mod cross;\npub mod response;\n\nuse super::*;", "file_size": 47, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\mod.rs", "language": "rust", "content": "pub mod request;\npub mod response;\n\nuse super::*;", "file_size": 49, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\exception\\framework\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;", "file_size": 42, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\favicon_ico\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_config::business::logo_img::*;", "file_size": 87, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\request\\cross\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[response_header(ACCESS_CONTROL_ALLOW_ORIGIN => WILDCARD_ANY)]\n#[response_header(ACCESS_CONTROL_ALLOW_METHODS => ALL_METHODS)]\n#[response_header(ACCESS_CONTROL_ALLOW_HEADERS => WILDCARD_ANY)]\npub async fn cross(ctx: Context) {}", "file_size": 243, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\response\\mod.rs", "language": "rust", "content": "pub mod log;\npub mod send;\n\nuse super::*;", "file_size": 41, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\exception\\mod.rs", "language": "rust", "content": "pub mod framework;\n\nuse super::*;", "file_size": 33, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\hello\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[post]\n#[response_status_code(200)]\n#[response_body(format!(\"Hello {}\", name_opt.unwrap_or_default()))]\n#[route_param(NAME_KEY => name_opt)]\npub async fn handle(ctx: Context) {}", "file_size": 193, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\favicon_ico\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[get]\n#[route(\"/favicon.ico\")]\n#[response_status_code(301)]\n#[response_header(LOCATION => LOGO_IMG_URL)]\npub async fn handle(ctx: Context) {}", "file_size": 157, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\hello\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_config::business::hello::*;", "file_size": 84, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\ws\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[ws]\n#[get]\n#[route(\"/websocket\")]\npub async fn handle(ctx: Context) {\n    let request_body: Vec<u8> = ctx.get_request_body().await;\n    let _ = ctx.set_response_body(request_body).await.send_body().await;\n}", "file_size": 223, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\request\\response\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[response_status_code(404)]\npub async fn response_status_code(ctx: Context) {}\n\n#[response_header(DATE => gmt())]\n#[response_header(SERVER => HYPERLANE)]\n#[response_header(CONNECTION => KEEP_ALIVE)]\n#[response_header(CONTENT_TYPE => TEXT_HTML)]\n#[response_version(HttpVersion::HTTP1_1)]\npub async fn response_header(ctx: Context) {\n    let socket_addr_string: String = ctx.get_socket_addr_or_default_string().await;\n    let content_type: String = ContentType::format_content_type_with_charset(TEXT_HTML, UTF8);\n    ctx.set_response_header(CONTENT_TYPE, content_type)\n        .await\n        .set_response_header(\"SocketAddr\", socket_addr_string)\n        .await;\n}\n\n#[response_body(NOT_FOUND_HTML)]\npub async fn response_body(ctx: Context) {}", "file_size": 756, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\response\\send\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[send]\n#[http]\n#[flush]\npub async fn send(ctx: Context) {\n    if ctx.get_request_upgrade_type().await.is_ws() {\n        return;\n    }\n}", "file_size": 151, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\config\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#struct::*;\npub use r#type::*;", "file_size": 111, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\middleware\\request\\response\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_config::business::not_found::*;", "file_size": 88, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\root\\fn.rs", "language": "rust", "content": "use super::*;\n\n#[route(\"/\")]\n#[methods(get, post)]\n#[response_status_code(200)]\npub async fn handle(ctx: Context) {\n    let html: String = INDEX_HTML.replace(\"{{ time }}\", &time());\n    let _ = ctx.set_response_body(html).await;\n}", "file_size": 230, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\controller\\root\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub use r#fn::*;\n\nuse super::*;\nuse hyperlane_config::business::templates::*;", "file_size": 88, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\attribute\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#type;\n\npub use r#type::*;\n\npub(crate) use r#enum::*;", "file_size": 115, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane-quick-start\\app\\exception\\framework\\fn.rs", "language": "rust", "content": "use super::*;\n\npub async fn panic_hook(ctx: Context) {\n    let error: Panic = ctx.get_panic().await.unwrap_or_default();\n    let response_body: String = error.to_string();\n    println_error!(response_body);\n    log_error(response_body.clone()).await;\n    let content_type: String = ContentType::format_content_type_with_charset(TEXT_PLAIN, UTF8);\n    let _ = ctx\n        .set_response_version(HttpVersion::HTTP1_1)\n        .await\n        .set_response_status_code(500)\n        .await\n        .clear_response_headers()\n        .await\n        .set_response_header(SERVER, HYPERLANE)\n        .await\n        .set_response_header(CONTENT_TYPE, content_type)\n        .await\n        .set_response_body(response_body)\n        .await\n        .send()\n        .await;\n}", "file_size": 758, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\context\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of methods for `Context` structure.\nimpl Context {\n    /// Creates a new `Context` from an internal context instance.\n    ///\n    /// # Arguments\n    ///\n    /// - `ContextInner` - The wrapped context data.\n    ///\n    /// # Returns\n    ///\n    /// - `Context` - The newly created context instance.\n    pub(crate) fn from_internal_context(ctx: ContextInner) -> Self {\n        Self(arc_rwlock(ctx))\n    }\n\n    /// Creates a new `Context` for a given stream and request.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ArcRwLockStream` - The network stream.\n    /// - `&Request` - The HTTP request.\n    ///\n    /// # Returns\n    ///\n    /// - `Context` - The newly created context.\n    pub(crate) fn create_context(stream: &ArcRwLockStream, request: &Request) -> Context {\n        Context::from_internal_context({\n            let mut internal_ctx: ContextInner = ContextInner::default();\n            internal_ctx\n                .set_stream(Some(stream.clone()))\n                .set_request(request.clone());\n            internal_ctx\n        })\n    }\n\n    /// Acquires a read lock on the inner context data.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadContextInner` - The read guard for the inner context.\n    async fn read(&self) -> RwLockReadContextInner {\n        self.get_0().read().await\n    }\n\n    /// Acquires a write lock on the inner context data.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteContextInner` - The write guard for the inner context.\n    async fn write(&self) -> RwLockWriteContextInner {\n        self.get_0().write().await\n    }\n\n    /// Checks if the context has been marked as aborted.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the context is aborted, otherwise false.\n    pub async fn get_aborted(&self) -> bool {\n        *self.read().await.get_aborted()\n    }\n\n    /// Sets the aborted flag for the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `bool` - The aborted state to set.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn set_aborted(&self, aborted: bool) -> &Self {\n        self.write().await.set_aborted(aborted);\n        self\n    }\n\n    /// Marks the context as aborted.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn aborted(&self) -> &Self {\n        self.set_aborted(true).await;\n        self\n    }\n\n    /// Cancels the aborted state of the context.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn cancel_aborted(&self) -> &Self {\n        self.set_aborted(false).await;\n        self\n    }\n\n    /// Checks if the connection is marked as closed.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the connection is closed, otherwise false.\n    pub async fn get_closed(&self) -> bool {\n        *self.read().await.get_closed()\n    }\n\n    /// Sets the closed flag for the connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `bool` - The new value for the closed flag.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_closed(&self, closed: bool) -> &Self {\n        self.write().await.set_closed(closed);\n        self\n    }\n\n    /// Marks the connection as closed.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn closed(&self) -> &Self {\n        self.set_closed(true).await;\n        self\n    }\n\n    /// Cancels the closed state of the connection.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn cancel_closed(&self) -> &Self {\n        self.set_closed(false).await;\n        self\n    }\n\n    /// Retrieves the underlying network stream, if available.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionArcRwLockStream` - The thread-safe, shareable network stream if it exists.\n    pub async fn get_stream(&self) -> OptionArcRwLockStream {\n        self.read().await.get_stream().clone()\n    }\n\n    /// Retrieves the remote socket address of the connection.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketAddr` - The socket address of the remote peer if available.\n    pub async fn get_socket_addr(&self) -> OptionSocketAddr {\n        let stream_result: OptionArcRwLockStream = self.get_stream().await;\n        if stream_result.is_none() {\n            return None;\n        }\n        stream_result.unwrap().read().await.peer_addr().ok()\n    }\n\n    /// Retrieves the remote socket address or a default value if unavailable.\n    ///\n    /// # Returns\n    ///\n    /// - `SocketAddr` - The socket address of the remote peer, or default if unavailable.\n    pub async fn get_socket_addr_or_default(&self) -> SocketAddr {\n        let stream_result: OptionArcRwLockStream = self.get_stream().await;\n        if stream_result.is_none() {\n            return DEFAULT_SOCKET_ADDR;\n        }\n        stream_result\n            .unwrap()\n            .read()\n            .await\n            .peer_addr()\n            .unwrap_or(DEFAULT_SOCKET_ADDR)\n    }\n\n    /// Retrieves the remote socket address as a string.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionString` - The string representation of the socket address if available.\n    pub async fn get_socket_addr_string(&self) -> OptionString {\n        self.get_socket_addr().await.map(|data| data.to_string())\n    }\n\n    /// Retrieves the remote socket address as a string, or a default value if unavailable.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The string representation of the socket address, or default if unavailable.\n    pub async fn get_socket_addr_or_default_string(&self) -> String {\n        self.get_socket_addr_or_default().await.to_string()\n    }\n\n    /// Retrieves the IP address part of the remote socket address.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketHost` - The IP address of the remote peer if available.\n    pub async fn get_socket_host(&self) -> OptionSocketHost {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.ip())\n    }\n\n    /// Retrieves the port number part of the remote socket address.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketPort` - The port number of the remote peer if available.\n    pub async fn get_socket_port(&self) -> OptionSocketPort {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.port())\n    }\n\n    /// Retrieves the current HTTP request.\n    ///\n    /// # Returns\n    ///\n    /// - `Request` - A clone of the current request.\n    pub async fn get_request(&self) -> Request {\n        self.read().await.get_request().clone()\n    }\n\n    /// Sets the current HTTP request for the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Request` - The request to set in the context.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub(crate) async fn set_request(&self, request_data: &Request) -> &Self {\n        self.write().await.set_request(request_data.clone());\n        self\n    }\n\n    /// Executes an asynchronous closure with the current request.\n    ///\n    /// This method provides temporary access to the request data without needing to clone it.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - A closure that takes the `Request` and returns a future.\n    ///\n    /// # Returns\n    ///\n    /// - `R` - The result of the provided closure's future.\n    pub async fn with_request<F, Fut, R>(&self, func: F) -> R\n    where\n        F: Fn(Request) -> Fut,\n        Fut: FutureSendStatic<R>,\n    {\n        func(self.read().await.get_request().clone()).await\n    }\n\n    /// Retrieves the string representation of the current request.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The full request as a string.\n    pub async fn get_request_string(&self) -> String {\n        self.read().await.get_request().get_string()\n    }\n\n    /// Retrieves the HTTP version of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestVersion` - The HTTP version of the request.\n    pub async fn get_request_version(&self) -> RequestVersion {\n        self.read().await.get_request().get_version().clone()\n    }\n\n    /// Retrieves the HTTP method of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestMethod` - The HTTP method of the request.\n    pub async fn get_request_method(&self) -> RequestMethod {\n        self.read().await.get_request().get_method().clone()\n    }\n\n    /// Retrieves the host from the request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestHost` - The host part of the request's URI.\n    pub async fn get_request_host(&self) -> RequestHost {\n        self.read().await.get_request().get_host().clone()\n    }\n\n    /// Retrieves the path of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestPath` - The path part of the request's URI.\n    pub async fn get_request_path(&self) -> RequestPath {\n        self.read().await.get_request().get_path().clone()\n    }\n\n    /// Retrieves the query parameters of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestQuerys` - A map containing the query parameters.\n    pub async fn get_request_querys(&self) -> RequestQuerys {\n        self.read().await.get_request().get_querys().clone()\n    }\n\n    /// Retrieves a specific query parameter by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The query parameter key.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestQuerysValue` - The query parameter value if exists.\n    pub async fn get_request_query<K>(&self, key: K) -> OptionRequestQuerysValue\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().get_query(key)\n    }\n\n    /// Retrieves the body of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBody` - A clone of the request's body.\n    pub async fn get_request_body(&self) -> RequestBody {\n        self.read().await.get_request().get_body().clone()\n    }\n\n    /// Retrieves the request body as a string.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The request body converted to a string.\n    pub async fn get_request_body_string(&self) -> String {\n        self.read().await.get_request().get_body_string()\n    }\n\n    /// Deserializes the request body from JSON into a specified type.\n    ///\n    /// # Returns\n    ///\n    /// - `ResultJsonError<J>` - The deserialized type `J` or a JSON error.\n    pub async fn get_request_body_json<J>(&self) -> ResultJsonError<J>\n    where\n        J: DeserializeOwned,\n    {\n        self.read().await.get_request().get_body_json()\n    }\n\n    /// Retrieves a specific request header by its key.\n    ///\n    /// Gets a request header by key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValue` - The header values if exists.\n    pub async fn get_request_header<K>(&self, key: K) -> OptionRequestHeadersValue\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().get_header(key)\n    }\n\n    /// Retrieves all request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestHeaders` - A clone of the request's header map.\n    pub async fn get_request_headers(&self) -> RequestHeaders {\n        self.read().await.get_request().get_headers().clone()\n    }\n\n    /// Retrieves the first value of a specific request header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValueItem` - The first value of the header if it exists.\n    pub async fn get_request_header_front<K>(&self, key: K) -> OptionRequestHeadersValueItem\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().get_header_front(key)\n    }\n\n    /// Retrieves the last value of a specific request header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValueItem` - The last value of the header if it exists.\n    pub async fn get_request_header_back<K>(&self, key: K) -> OptionRequestHeadersValueItem\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().get_header_back(key)\n    }\n\n    /// Retrieves the number of values for a specific request header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The number of values for the specified header.\n    pub async fn get_request_header_len<K>(&self, key: K) -> usize\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().get_header_length(key)\n    }\n\n    /// Retrieves the total number of values across all request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total count of all values in all headers.\n    pub async fn get_request_headers_values_length(&self) -> usize {\n        self.read().await.get_request().get_headers_values_length()\n    }\n\n    /// Retrieves the total number of request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total number of headers in the request.\n    pub async fn get_request_headers_length(&self) -> usize {\n        self.read().await.get_request().get_headers_length()\n    }\n\n    /// Checks if a specific request header exists.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header to check.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the header exists, otherwise false.\n    pub async fn has_request_header<K>(&self, key: K) -> bool\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.read().await.get_request().has_header(key)\n    }\n\n    /// Checks if a request header has a specific value.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key.\n    /// - `V` - The value to check.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if header contains the value.\n    pub async fn has_request_header_value<K, V>(&self, key: K, value: V) -> bool\n    where\n        K: Into<RequestHeadersKey>,\n        V: Into<RequestHeadersValueItem>,\n    {\n        self.read().await.get_request().has_header_value(key, value)\n    }\n\n    /// Parses and retrieves all cookies from the request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `Cookies` - A map of cookies parsed from the request's Cookie header.\n    pub async fn get_request_cookies(&self) -> Cookies {\n        self.get_request_header_back(COOKIE)\n            .await\n            .map(|data| Cookie::parse(&data))\n            .unwrap_or_default()\n    }\n\n    /// Retrieves a specific cookie by its name from the request.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The cookie name.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionCookiesValue` - The cookie value if exists.\n    pub async fn get_request_cookie<K>(&self, key: K) -> OptionCookiesValue\n    where\n        K: Into<CookieKey>,\n    {\n        self.get_request_cookies().await.get(&key.into()).cloned()\n    }\n\n    /// Retrieves the upgrade type of the request.\n    ///\n    /// # Returns\n    ///\n    /// - `UpgradeType` - Indicates if the request is for a WebSocket connection.\n    pub async fn get_request_upgrade_type(&self) -> UpgradeType {\n        self.read().await.get_request().get_upgrade_type()\n    }\n\n    /// Retrieves the current HTTP response.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - A clone of the current response.\n    pub async fn get_response(&self) -> Response {\n        self.read().await.get_response().clone()\n    }\n\n    /// Sets the HTTP response for the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `Response` - The response to set in the context.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_response(&self, response: Response) -> &Self {\n        self.write().await.set_response(response);\n        self\n    }\n\n    /// Executes an asynchronous closure with the current response.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - A closure that takes the `Response` and returns a future.\n    ///\n    /// # Returns\n    ///\n    /// - `R` - The result of the provided closure's future.\n    pub async fn with_response<F, Fut, R>(&self, func: F) -> R\n    where\n        F: Fn(Response) -> Fut,\n        Fut: FutureSendStatic<R>,\n    {\n        func(self.read().await.get_response().clone()).await\n    }\n\n    /// Retrieves the string representation of the current response.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The full response as a string.\n    pub async fn get_response_string(&self) -> String {\n        self.read().await.get_response().get_string()\n    }\n\n    /// Retrieves the HTTP version of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseVersion` - The HTTP version of the response.\n    pub async fn get_response_version(&self) -> ResponseVersion {\n        self.read().await.get_response().get_version().clone()\n    }\n\n    /// Sets the HTTP version for the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `ResponseVersion` - The HTTP version to set for the response.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_response_version(&self, version: ResponseVersion) -> &Self {\n        self.write().await.get_mut_response().set_version(version);\n        self\n    }\n\n    /// Retrieves all response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseHeaders` - A clone of the response's header map.\n    pub async fn get_response_headers(&self) -> ResponseHeaders {\n        self.read().await.get_response().get_headers().clone()\n    }\n\n    /// Retrieves a specific response header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header to retrieve.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValue` - The header values if the header exists.\n    pub async fn get_response_header<K>(&self, key: K) -> OptionResponseHeadersValue\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.read().await.get_response().get_header(key)\n    }\n\n    /// Sets a response header with a new value, removing any existing values.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header to set.\n    /// - `V` - The new value for the header.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_response_header<K, V>(&self, key: K, value: V) -> &Self\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<String>,\n    {\n        self.write().await.get_mut_response().set_header(key, value);\n        self\n    }\n\n    /// Retrieves the first value of a specific response header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValueItem` - The first value of the header if it exists.\n    pub async fn get_response_header_front<K>(&self, key: K) -> OptionResponseHeadersValueItem\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.read().await.get_response().get_header_front(key)\n    }\n\n    /// Retrieves the last value of a specific response header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValueItem` - The last value of the header if it exists.\n    pub async fn get_response_header_back<K>(&self, key: K) -> OptionResponseHeadersValueItem\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.read().await.get_response().get_header_back(key)\n    }\n\n    /// Checks if a specific response header exists.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header to check.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the header exists, otherwise false.\n    pub async fn get_response_has_header<K>(&self, key: K) -> bool\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.read().await.get_response().has_header(key)\n    }\n\n    /// Checks if a response header has a specific value.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    /// - `V` - The value to check for.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the header contains the specified value, otherwise false.\n    pub async fn has_response_header_value<K, V>(&self, key: K, value: V) -> bool\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<ResponseHeadersValueItem>,\n    {\n        self.read()\n            .await\n            .get_response()\n            .has_header_value(key, value)\n    }\n\n    /// Retrieves the total number of response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total number of headers in the response.\n    pub async fn get_response_headers_length(&self) -> usize {\n        self.read().await.get_response().get_headers_length()\n    }\n\n    /// Retrieves the number of values for a specific response header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The number of values for the specified header.\n    pub async fn get_response_header_len<K>(&self, key: K) -> usize\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.read().await.get_response().get_header_length(key)\n    }\n\n    /// Retrieves the total number of values across all response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total count of all values in all headers.\n    pub async fn get_response_headers_values_length(&self) -> usize {\n        self.read().await.get_response().get_headers_values_length()\n    }\n\n    /// Adds a response header, adding it if it doesn't exist or appending to it if it does.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key.\n    /// - `V` - The header value.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn add_response_header<K, V>(&self, key: K, value: V) -> &Self\n    where\n        K: Into<String>,\n        V: Into<String>,\n    {\n        self.write().await.get_mut_response().add_header(key, value);\n        self\n    }\n\n    /// Removes a response header and all its values.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The key of the header to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn remove_response_header<K>(&self, key: K) -> &Self\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.write().await.get_mut_response().remove_header(key);\n        self\n    }\n\n    /// Removes a specific value from a response header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key.\n    /// - `V` - The value to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn remove_response_header_value<K, V>(&self, key: K, value: V) -> &Self\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<String>,\n    {\n        self.write()\n            .await\n            .get_mut_response()\n            .remove_header_value(key, value);\n        self\n    }\n\n    /// Clears all headers from the response.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn clear_response_headers(&self) -> &Self {\n        self.write().await.get_mut_response().clear_headers();\n        self\n    }\n\n    /// Parses and retrieves all cookies from the response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `Cookies` - A map of cookies parsed from the response's Cookie header.\n    pub async fn get_response_cookies(&self) -> Cookies {\n        self.get_response_header_back(COOKIE)\n            .await\n            .map(|data| Cookie::parse(&data))\n            .unwrap_or_default()\n    }\n\n    /// Retrieves a specific cookie by its name from the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The name of the cookie to retrieve.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionCookiesValue` - The cookie's value if it exists.\n    pub async fn get_response_cookie<K>(&self, key: K) -> OptionCookiesValue\n    where\n        K: Into<CookieKey>,\n    {\n        self.get_response_cookies().await.get(&key.into()).cloned()\n    }\n\n    /// Retrieves the body of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseBody` - A clone of the response's body.\n    pub async fn get_response_body(&self) -> ResponseBody {\n        self.read().await.get_response().get_body().clone()\n    }\n\n    /// Sets the body of the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `B` - The body to set for the response.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_response_body<B>(&self, body: B) -> &Self\n    where\n        B: Into<ResponseBody>,\n    {\n        self.write().await.get_mut_response().set_body(body);\n        self\n    }\n\n    /// Retrieves the response body as a string.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The response body converted to a string.\n    pub async fn get_response_body_string(&self) -> String {\n        self.read().await.get_response().get_body_string()\n    }\n\n    /// Deserializes the response body from JSON into a specified type.\n    ///\n    /// # Returns\n    ///\n    /// - `ResultJsonError<J>` - The deserialized type `J` or a JSON error.\n    pub async fn get_response_body_json<J>(&self) -> ResultJsonError<J>\n    where\n        J: DeserializeOwned,\n    {\n        self.read().await.get_response().get_body_json()\n    }\n\n    /// Retrieves the reason phrase of the response's status code.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseReasonPhrase` - The reason phrase associated with the response's status code.\n    pub async fn get_response_reason_phrase(&self) -> ResponseReasonPhrase {\n        self.read().await.get_response().get_reason_phrase().clone()\n    }\n\n    /// Sets the reason phrase for the response's status code.\n    ///\n    /// # Arguments\n    ///\n    /// - `P` - The reason phrase to set.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to the modified context.\n    pub async fn set_response_reason_phrase<P>(&self, reason_phrase: P) -> &Self\n    where\n        P: Into<ResponseReasonPhrase>,\n    {\n        self.write()\n            .await\n            .get_mut_response()\n            .set_reason_phrase(reason_phrase);\n        self\n    }\n\n    /// Retrieves the status code of the response.\n    ///\n    /// # Returns\n    ///\n    /// The status code of the response.\n    pub async fn get_response_status_code(&self) -> ResponseStatusCode {\n        self.read().await.get_response().get_status_code().clone()\n    }\n\n    /// Sets the status code for the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `ResponseStatusCode` - The status code to set for the response.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    pub async fn set_response_status_code(&self, status_code: ResponseStatusCode) -> &Self {\n        self.write()\n            .await\n            .get_mut_response()\n            .set_status_code(status_code);\n        self\n    }\n\n    /// Retrieves the parameters extracted from the route path.\n    ///\n    /// # Returns\n    ///\n    /// - `RouteParams` - A map containing the route parameters.\n    pub async fn get_route_params(&self) -> RouteParams {\n        self.read().await.get_route_params().clone()\n    }\n\n    /// Sets the route parameters for the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `RouteParams` - The route parameters to set.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified `Context`.\n    pub(crate) async fn set_route_params(&self, params: RouteParams) -> &Self {\n        self.write().await.set_route_params(params);\n        self\n    }\n\n    /// Retrieves a specific route parameter by its name.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The name of the route parameter to retrieve.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionString` - The value of the route parameter if it exists.\n    pub async fn get_route_param(&self, name: &str) -> OptionString {\n        self.read().await.get_route_params().get(name).cloned()\n    }\n\n    /// Retrieves all attributes stored in the context.\n    ///\n    /// # Returns\n    ///\n    /// - `HashMapArcAnySendSync` - A map containing all attributes.\n    pub async fn get_attributes(&self) -> HashMapArcAnySendSync {\n        self.read().await.get_attributes().clone()\n    }\n\n    /// Retrieves a specific attribute by its key, casting it to the specified type.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The key of the attribute to retrieve.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<V>` - The attribute's value if it exists and can be cast to the specified type.\n    pub async fn get_attribute<V>(&self, key: &str) -> Option<V>\n    where\n        V: AnySendSyncClone,\n    {\n        self.read()\n            .await\n            .get_attributes()\n            .get(&AttributeKey::External(key.to_owned()).to_string())\n            .and_then(|arc| arc.downcast_ref::<V>())\n            .cloned()\n    }\n\n    /// Sets an attribute in the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The key of the attribute to set.\n    /// - `V` - The value of the attribute.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    pub async fn set_attribute<V>(&self, key: &str, value: V) -> &Self\n    where\n        V: AnySendSyncClone,\n    {\n        self.write().await.get_mut_attributes().insert(\n            AttributeKey::External(key.to_owned()).to_string(),\n            Arc::new(value),\n        );\n        self\n    }\n\n    /// Removes an attribute from the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The key of the attribute to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    pub async fn remove_attribute(&self, key: &str) -> &Self {\n        self.write()\n            .await\n            .get_mut_attributes()\n            .remove(&AttributeKey::External(key.to_owned()).to_string());\n        self\n    }\n\n    /// Clears all attributes from the context.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    pub async fn clear_attribute(&self) -> &Self {\n        self.write().await.get_mut_attributes().clear();\n        self\n    }\n\n    /// Retrieves an internal framework attribute.\n    ///\n    /// # Arguments\n    ///\n    /// - `InternalAttributeKey` - The internal attribute key to retrieve.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<V>` - The attribute's value if it exists and can be cast to the specified type.\n    async fn get_internal_attribute<V>(&self, key: InternalAttributeKey) -> Option<V>\n    where\n        V: AnySendSyncClone,\n    {\n        self.read()\n            .await\n            .get_attributes()\n            .get(&AttributeKey::Internal(key).to_string())\n            .and_then(|arc| arc.downcast_ref::<V>())\n            .cloned()\n    }\n\n    /// Sets an internal framework attribute.\n    ///\n    /// # Arguments\n    ///\n    /// - `InternalAttributeKey` - The internal attribute key to set.\n    /// - `V` - The value of the attribute.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    async fn set_internal_attribute<V>(&self, key: InternalAttributeKey, value: V) -> &Self\n    where\n        V: AnySendSyncClone,\n    {\n        self.write()\n            .await\n            .get_mut_attributes()\n            .insert(AttributeKey::Internal(key).to_string(), Arc::new(value));\n        self\n    }\n\n    /// Retrieves panic information if a panic has occurred during handling.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionPanic` - The panic information if a panic was caught.\n    pub async fn get_panic(&self) -> OptionPanic {\n        self.get_internal_attribute(InternalAttributeKey::Panic)\n            .await\n    }\n\n    /// Sets the panic information for the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `Panic` - The panic information to store.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the modified context.\n    pub(crate) async fn set_panic(&self, panic: Panic) -> &Self {\n        self.set_internal_attribute(InternalAttributeKey::Panic, panic)\n            .await\n    }\n\n    /// Checks if the connection has been terminated (aborted and closed).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the connection is both aborted and closed, otherwise false.\n    pub async fn is_terminated(&self) -> bool {\n        self.get_aborted().await || self.get_closed().await\n    }\n\n    /// Checks if the connection should be kept alive based on request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the Connection header suggests keeping the connection alive, otherwise false.\n    pub async fn is_enable_keep_alive(&self) -> bool {\n        self.get_request().await.is_enable_keep_alive()\n    }\n\n    /// Handles the WebSocket upgrade handshake and sends the appropriate response.\n    ///\n    /// This method constructs and sends the WebSocket handshake response if the\n    /// request is a valid upgrade request.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the handshake operation.\n    pub async fn upgrade_to_ws(&self) -> ResponseResult {\n        if let Some(key) = &self.get_request_header_back(SEC_WEBSOCKET_KEY).await {\n            let accept_key: String = WebSocketFrame::generate_accept_key(key);\n            let result: ResponseResult = self\n                .set_response_version(HttpVersion::HTTP1_1)\n                .await\n                .set_response_status_code(101)\n                .await\n                .set_response_header(UPGRADE, WEBSOCKET)\n                .await\n                .set_response_header(CONNECTION, UPGRADE)\n                .await\n                .set_response_header(SEC_WEBSOCKET_ACCEPT, accept_key)\n                .await\n                .send()\n                .await;\n            return result;\n        }\n        Err(ResponseError::WebSocketHandShake(format!(\n            \"missing {} header\",\n            SEC_WEBSOCKET_KEY\n        )))\n    }\n\n    /// Reads an HTTP request from the underlying stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The read buffer size.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestReaderHandleResult` - The parsed request or error.\n    pub async fn http_from_stream(&self, buffer: usize) -> RequestReaderHandleResult {\n        if self.get_aborted().await {\n            return Err(RequestError::RequestAborted);\n        }\n        if let Some(stream) = self.get_stream().await.as_ref() {\n            let request_res: RequestReaderHandleResult =\n                Request::http_from_stream(stream, buffer).await;\n            if let Ok(request) = request_res.as_ref() {\n                self.set_request(request).await;\n            }\n            return request_res;\n        };\n        Err(RequestError::GetTcpStream)\n    }\n\n    /// Reads a WebSocket frame from the underlying stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The read buffer size.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestReaderHandleResult` - The parsed frame or error.\n    pub async fn ws_from_stream(&self, buffer: usize) -> RequestReaderHandleResult {\n        if self.get_aborted().await {\n            return Err(RequestError::RequestAborted);\n        }\n        if let Some(stream) = self.get_stream().await.as_ref() {\n            let mut last_request: Request = self.get_request().await;\n            let request_res: RequestReaderHandleResult =\n                Request::ws_from_stream(stream, buffer, &mut last_request).await;\n            match request_res.as_ref() {\n                Ok(request) => {\n                    self.set_request(&request).await;\n                }\n                Err(_) => {\n                    self.set_request(&last_request).await;\n                }\n            }\n            return request_res;\n        };\n        Err(RequestError::GetTcpStream)\n    }\n\n    /// Updates the lifecycle status based on the current context state.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut Lifecycle` - The lifecycle to update.\n    pub(crate) async fn update_lifecycle_status(&self, lifecycle: &mut Lifecycle) {\n        let keep_alive: bool = !self.get_closed().await && lifecycle.is_keep_alive();\n        let aborted: bool = self.get_aborted().await;\n        lifecycle.update_status(aborted, keep_alive);\n    }\n\n    /// Sends the response headers and body to the client.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the send operation.\n    pub async fn send(&self) -> ResponseResult {\n        if self.is_terminated().await {\n            return Err(ResponseError::Terminated);\n        }\n        if let Some(stream) = self.get_stream().await {\n            let response_res: ResponseData = self.write().await.get_mut_response().build();\n            return stream.send(&response_res).await;\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n\n    /// Sends the response and then closes the connection.\n    ///\n    /// After sending, the connection will be marked as closed.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the send operation.\n    pub async fn send_once(&self) -> ResponseResult {\n        let res: ResponseResult = self.send().await;\n        self.closed().await;\n        res\n    }\n\n    /// Sends only the response body to the client.\n    ///\n    /// This is useful for streaming data or for responses where headers have already been sent.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the send operation.\n    pub async fn send_body(&self) -> ResponseResult {\n        if self.is_terminated().await {\n            return Err(ResponseError::Terminated);\n        }\n        if let Some(stream) = self.get_stream().await {\n            let is_ws: bool = self.get_request_upgrade_type().await.is_ws();\n            let response_body: ResponseBody = self.get_response_body().await;\n            return stream.send_body_conditional(&response_body, is_ws).await;\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n\n    /// Sends only the response body and then closes the connection.\n    ///\n    /// After sending the body, the connection will be marked as closed.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the send operation.\n    pub async fn send_once_body(&self) -> ResponseResult {\n        let res: ResponseResult = self.send_body().await;\n        self.closed().await;\n        res\n    }\n\n    /// Flushes the underlying network stream, ensuring all buffered data is sent.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - The outcome of the flush operation.\n    pub async fn flush(&self) -> ResponseResult {\n        if let Some(stream) = self.get_stream().await {\n            stream.flush().await;\n            return Ok(());\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n}", "file_size": 39329, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the inner, mutable server configuration.\n///\n/// This structure holds all the settings for the HTTP and WebSocket server,\n/// including network parameters and buffer sizes. It is not intended to be used directly\n/// by end-users, but rather through the `ServerConfig` wrapper.\n#[derive(Clone, Data, CustomDebug, DisplayDebug, PartialEq, Eq, Deserialize, Serialize)]\npub(crate) struct ServerConfigInner {\n    /// The host address the server will bind to.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) host: String,\n    /// The port number the server will listen on.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) port: usize,\n    /// The buffer size for WebSocket connections.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) ws_buffer: usize,\n    /// The buffer size for HTTP connections.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) http_buffer: usize,\n    /// The `TCP_NODELAY` option for sockets.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) nodelay: OptionBool,\n    /// The `SO_LINGER` option for sockets.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) linger: OptionDuration,\n    /// The `IP_TTL` option for sockets.\n    #[get(pub(crate))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) ttl: OptionU32,\n}\n\n/// Represents the thread-safe, shareable server configuration.\n///\n/// This structure wraps `ServerConfigInner` in an `Arc<RwLock<ServerConfigInner>>`\n/// to allow for safe concurrent access and modification of the server settings.\n#[derive(Clone, Getter, CustomDebug, DisplayDebug)]\npub struct ServerConfig(#[get(pub(super))] pub(super) ArcRwLockServerConfigInner);", "file_size": 1875, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\config\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a `Result<ServerConfig, serde_json::Error>`.\n///\n/// This is used for operations that can fail during `ServerConfig` deserialization.\npub type ServerConfigResult = Result<ServerConfig, serde_json::Error>;\n\n/// A type alias for `RwLockReadGuard<'a, ServerConfigInner>`.\n///\n/// This provides read-only access to the `ServerConfigInner` wrapped in a `RwLock`.\npub(crate) type RwLockReadGuardServerConfigInner<'a> = RwLockReadGuard<'a, ServerConfigInner>;\n\n/// A type alias for `RwLockWriteGuard<'a, ServerConfigInner>`.\n///\n/// This provides mutable access to the `ServerConfigInner` wrapped in a `RwLock`.\npub(crate) type RwLockWriteGuardServerConfigInner<'a> = RwLockWriteGuard<'a, ServerConfigInner>;", "file_size": 737, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\context\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#struct::*;\n\npub(crate) use r#type::*;", "file_size": 119, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\lib.rs", "language": "rust", "content": "//! hyperlane\n//!\n//! A lightweight, high-performance, and cross-platform\n//! Rust HTTP server library built on Tokio. It simplifies\n//! modern web service development by providing built-in\n//! support for middleware, WebSocket, Server-Sent Events (SSE),\n//! and raw TCP communication. With a unified and ergonomic API\n//! across Windows, Linux, and MacOS, it enables developers to\n//! build robust, scalable, and event-driven network\n//! applications with minimal overhead and maximum flexibility.\n\nmod attribute;\nmod config;\nmod context;\nmod error;\nmod hook;\nmod lifecycle;\nmod panic;\nmod route;\nmod server;\nmod tests;\n\npub use attribute::*;\npub use config::*;\npub use context::*;\npub use error::*;\npub use hook::*;\npub use panic::*;\npub use route::*;\npub use server::*;\n\npub use http_type::*;\n\npub(crate) use lifecycle::*;\n\npub(crate) use std::{\n    any::Any,\n    cmp::Ordering,\n    collections::{BTreeSet, HashMap},\n    future::Future,\n    net::SocketAddr,\n    panic::Location,\n    pin::Pin,\n    sync::Arc,\n    time::Duration,\n};\n\npub(crate) use inventory::collect;\npub(crate) use lombok_macros::*;\npub(crate) use regex::Regex;\npub(crate) use serde::{Deserialize, Serialize, de::DeserializeOwned};\npub(crate) use tokio::{\n    net::{TcpListener, TcpStream},\n    spawn,\n    sync::{\n        RwLockReadGuard, RwLockWriteGuard,\n        watch::{Receiver, Sender, channel},\n    },\n    task::{JoinError, JoinHandle},\n};", "file_size": 1415, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\context\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a write guard on the inner context data.\n///\n/// This provides exclusive, mutable access to the `ContextInner` data.\npub(crate) type RwLockWriteContextInner<'a> = RwLockWriteGuard<'a, ContextInner>;\n\n/// A type alias for a read guard on the inner context data.\n///\n/// This provides shared, immutable access to the `ContextInner` data.\npub(crate) type RwLockReadContextInner<'a> = RwLockReadGuard<'a, ContextInner>;", "file_size": 451, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\enum.rs", "language": "rust", "content": "/// Enum to identify different kinds of hooks.\n///\n/// Each variant represents a specific type of hook that can be registered\n/// and triggered during the server lifecycle.\n#[derive(Clone, Debug, PartialEq, Eq, Copy)]\npub enum HookType {\n    /// Hook representing a panic hook, triggered when a panic occurs.\n    PanicHook,\n    /// Hook representing a directive to disable the default HTTP handler\n    /// for a given route.\n    ///\n    /// - `&'static str`: The route path for which the default HTTP handler is disabled.\n    DisableHttpHook(&'static str),\n    /// Hook representing a directive to disable the default WebSocket handler\n    /// for a given route.\n    ///\n    /// - `&'static str`: The route path for which the default WebSocket handler is disabled.\n    DisableWsHook(&'static str),\n    /// Hook representing a connected hook, triggered when a client\n    /// successfully establishes a connection.\n    ConnectedHook,\n    /// Hook representing a pre-upgrade hook, triggered before a protocol upgrade\n    /// such as upgrading from HTTP to WebSocket.\n    PreUpgradeHook,\n    /// Hook representing a request middleware, executed before a request\n    /// reaches its designated route handler.\n    RequestMiddleware,\n    /// Hook representing a route handler for a specific path.\n    ///\n    /// - `&'static str`: The route path handled by this hook.\n    Route(&'static str),\n    /// Hook representing a response middleware, executed after a route handler\n    /// but before the response is sent back to the client.\n    ResponseMiddleware,\n}", "file_size": 1551, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the hooks for managing the server's lifecycle, specifically for waiting and shutting down.\n///\n/// This struct is returned by the `run` method and provides two key hooks:\n/// - `wait_hook`: A future that resolves when the server has stopped accepting new connections.\n/// - `shutdown_hook`: A function that can be called to gracefully shut down the server.\n#[derive(Clone, CustomDebug, DisplayDebug, Getter, Setter)]\npub struct ServerHook {\n    /// A hook that returns a future, which completes when the server's main task finishes.\n    /// This is typically used to wait for the server to stop accepting connections before\n    /// the application exits.\n    #[debug(skip)]\n    #[get(pub)]\n    #[set(pub(crate))]\n    pub(super) wait_hook: ArcFnPinBoxFutureSend<()>,\n    /// A hook that, when called, initiates a graceful shutdown of the server.\n    /// This will stop the server from accepting new connections and allow existing ones\n    /// to complete.\n    #[debug(skip)]\n    #[get(pub)]\n    #[set(pub(crate))]\n    pub(super) shutdown_hook: ArcFnPinBoxFutureSend<()>,\n}\n\n/// Represents a route definition created by a macro.\n///\n/// This struct encapsulates the necessary information to register a new hook.\n#[derive(Getter, Setter, Clone, Debug, PartialEq, Eq)]\npub struct HookMacro {\n    /// Represents the asynchronous handler function that is executed when\n    /// the associated hook is triggered.\n    pub handler: fn(Context) -> PinBoxFutureSend<()>,\n    /// Represents the type of the hook that determines when the handler\n    /// should be executed.\n    pub hook_type: HookType,\n}", "file_size": 1620, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `ServerConfigInner`.\n///\n/// This provides a default configuration for the server with predefined values.\nimpl Default for ServerConfigInner {\n    /// Creates a default `ServerConfigInner`.\n    ///\n    /// # Returns\n    ///\n    /// A `ServerConfigInner` instance with default settings.\n    fn default() -> Self {\n        Self {\n            host: DEFAULT_HOST.to_owned(),\n            port: DEFAULT_WEB_PORT,\n            ws_buffer: DEFAULT_BUFFER_SIZE,\n            http_buffer: DEFAULT_BUFFER_SIZE,\n            nodelay: DEFAULT_NODELAY,\n            linger: DEFAULT_LINGER,\n            ttl: DEFAULT_TTI,\n        }\n    }\n}\n\n/// Implements the `Default` trait for `ServerConfig`.\n///\n/// This wraps the default `ServerConfigInner` in an `Arc<RwLock>`.\nimpl Default for ServerConfig {\n    /// Creates a default `ServerConfig`.\n    ///\n    /// # Returns\n    ///\n    /// A `ServerConfig` instance with default settings.\n    fn default() -> Self {\n        Self(arc_rwlock(ServerConfigInner::default()))\n    }\n}\n\n/// Implements the `PartialEq` trait for `ServerConfig`.\n///\n/// This allows for comparing two `ServerConfig` instances for equality.\nimpl PartialEq for ServerConfig {\n    /// Checks if two `ServerConfig` instances are equal.\n    ///\n    /// It first checks for pointer equality for performance. If the pointers are not equal,\n    /// it compares the inner `ServerConfigInner` values.\n    ///\n    /// # Parameters\n    ///\n    /// - `&Self`: The other `ServerConfig` to compare against.\n    ///\n    /// # Returns\n    ///\n    /// A `bool` indicating whether the configurations are equal.\n    fn eq(&self, other: &Self) -> bool {\n        if Arc::ptr_eq(self.get_0(), other.get_0()) {\n            return true;\n        }\n        if let (Ok(s), Ok(o)) = (self.get_0().try_read(), other.get_0().try_read()) {\n            *s == *o\n        } else {\n            false\n        }\n    }\n}\n\n/// Implements the `Eq` trait for `ServerConfig`.\n///\n/// This indicates that `ServerConfig` has a total equality relation.\nimpl Eq for ServerConfig {}\n\n/// Implementation block for `ServerConfig`.\nimpl ServerConfig {\n    /// Creates a new `ServerConfig` with default values.\n    ///\n    /// # Returns\n    ///\n    /// A new `ServerConfig` instance.\n    pub async fn new() -> Self {\n        Self::default()\n    }\n\n    /// Acquires a read lock on the server configuration.\n    ///\n    /// # Returns\n    ///\n    /// A `RwLockReadGuardServerConfigInner` for the inner configuration.\n    async fn read(&self) -> RwLockReadGuardServerConfigInner {\n        self.get_0().read().await\n    }\n\n    /// Acquires a write lock on the server configuration.\n    ///\n    /// # Returns\n    ///\n    /// A `RwLockWriteGuardServerConfigInner` for the inner configuration.\n    async fn write(&self) -> RwLockWriteGuardServerConfigInner {\n        self.get_0().write().await\n    }\n\n    /// Retrieves a clone of the inner server configuration.\n    ///\n    /// This function provides a snapshot of the current configuration by acquiring a read lock\n    /// and cloning the inner `ServerConfigInner`.\n    ///\n    /// # Returns\n    ///\n    /// A `ServerConfigInner` instance containing the current server configuration.\n    pub(crate) async fn get_inner(&self) -> ServerConfigInner {\n        self.read().await.clone()\n    }\n\n    /// Sets the host address for the server.\n    ///\n    /// # Parameters\n    ///\n    /// - `H`: The host address to set.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn host<H: ToString>(&self, host: H) -> &Self {\n        self.write().await.set_host(host.to_string());\n        self\n    }\n\n    /// Sets the port for the server.\n    ///\n    /// # Parameters\n    ///\n    /// - `usize`: The port number to set.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn port(&self, port: usize) -> &Self {\n        self.write().await.set_port(port);\n        self\n    }\n\n    /// Sets the WebSocket buffer size.\n    ///\n    /// # Parameters\n    ///\n    /// - `usize`: The WebSocket buffer size to set.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn ws_buffer(&self, ws_buffer: usize) -> &Self {\n        self.write().await.set_ws_buffer(ws_buffer);\n        self\n    }\n\n    /// Sets the HTTP buffer size.\n    ///\n    /// # Parameters\n    ///\n    /// - `usize`: The HTTP buffer size to set.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn http_buffer(&self, http_buffer: usize) -> &Self {\n        self.write().await.set_http_buffer(http_buffer);\n        self\n    }\n\n    /// Sets the `TCP_NODELAY` option.\n    ///\n    /// # Parameters\n    ///\n    /// - `bool`: The `bool` value for `TCP_NODELAY`.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn nodelay(&self, nodelay: bool) -> &Self {\n        self.write().await.set_nodelay(Some(nodelay));\n        self\n    }\n\n    /// Enables the `TCP_NODELAY` option.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn enable_nodelay(&self) -> &Self {\n        self.nodelay(true).await\n    }\n\n    /// Disables the `TCP_NODELAY` option.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn disable_nodelay(&self) -> &Self {\n        self.nodelay(false).await\n    }\n\n    /// Sets the `SO_LINGER` option.\n    ///\n    /// # Parameters\n    ///\n    /// - `Duration`: The `Duration` value for `SO_LINGER`.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn linger(&self, linger: Duration) -> &Self {\n        self.write().await.set_linger(Some(linger));\n        self\n    }\n\n    /// Sets the `IP_TTL` option.\n    ///\n    /// # Parameters\n    ///\n    /// - `u32`: The `u32` value for `IP_TTL`.\n    ///\n    /// # Returns\n    ///\n    /// A reference to `Self` for method chaining.\n    pub async fn ttl(&self, ttl: u32) -> &Self {\n        self.write().await.set_ttl(Some(ttl));\n        self\n    }\n\n    /// Creates a `ServerConfig` from a JSON string.\n    ///\n    /// # Parameters\n    ///\n    /// - `&str`: The JSON string to parse.\n    ///\n    /// # Returns\n    ///\n    /// A `ServerConfigResult` which is a `Result` containing either the `ServerConfig` or a `serde_json::Error`.\n    pub fn from_str(config_str: &str) -> ServerConfigResult {\n        serde_json::from_str(config_str).map(|config: ServerConfigInner| Self(arc_rwlock(config)))\n    }\n}", "file_size": 6601, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\attribute\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the key for an attribute.\n///\n/// Attributes can be either external, defined by a user-provided string,\n/// or internal, representing framework-specific functionality.\n#[derive(CustomDebug, Clone, PartialEq, Eq, Hash, DisplayDebug)]\npub(crate) enum AttributeKey {\n    /// An external attribute identified by a string.\n    External(String),\n    /// An internal attribute with a predefined key.\n    Internal(InternalAttributeKey),\n}\n\n/// Defines keys for internal attributes used by the framework.\n///\n/// These keys correspond to specific, built-in functionalities.\n#[derive(CustomDebug, Clone, PartialEq, Eq, Hash, DisplayDebug)]\npub(crate) enum InternalAttributeKey {\n    /// The attribute key for panic handling.\n    Panic,\n}", "file_size": 757, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\attribute\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a HashMap storing string keys and thread-safe, shareable values.\n///\n/// This type is used for storing attributes that can be safely shared across threads.\npub type HashMapArcAnySendSync = HashMap<String, ArcAnySendSync>;", "file_size": 257, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// A blanket implementation for any function that takes a `Context` and returns a value.\n///\n/// This implementation makes it easy to use any compatible function as a `FnContextSendSync`,\n/// promoting a flexible and functional programming style.\nimpl<F, R> FnContextSendSync<R> for F where F: Fn(Context) -> R + Send + Sync {}\n\n/// A blanket implementation for functions that return a pinned, boxed, sendable future.\n///\n/// This trait is a common pattern for asynchronous handlers in Rust, enabling type\n/// erasure and dynamic dispatch for futures. It is essential for storing different\n/// async functions in a collection.\nimpl<F, T> FnContextPinBoxSendSync<T> for F where F: FnContextSendSync<PinBoxFutureSend<T>> {}\n\n/// A blanket implementation for static, sendable, synchronous functions that return a future.\n///\n/// This trait is used for handlers that are known at compile time, ensuring they\n/// are safe to be sent across threads and have a static lifetime. This is crucial\n/// for handlers that are part of the application's long-lived state.\nimpl<F, Fut, T> FnContextSendSyncStatic<Fut, T> for F\nwhere\n    F: FnContextSendSync<Fut> + 'static,\n    Fut: Future<Output = T> + Send,\n{\n}\n\n/// A blanket implementation for any future that is sendable and has a static lifetime.\n///\n/// This is a convenient trait for working with futures in an asynchronous context,\n/// ensuring that they can be safely managed by the async runtime across different\n/// threads.\nimpl<T, R> FutureSendStatic<R> for T where T: Future<Output = R> + Send + 'static {}\n\n/// Blanket implementation of `FutureSend` for any type that satisfies the bounds.\nimpl<T, O> FutureSend<O> for T where T: Future<Output = O> + Send {}\n\n/// Blanket implementation of `FnPinBoxFutureSend` for any type that satisfies the bounds.\nimpl<T, O> FnPinBoxFutureSend<O> for T where T: Fn() -> PinBoxFutureSend<O> + Send + Sync {}\n\n/// Provides a default implementation for `ServerHook`.\nimpl Default for ServerHook {\n    /// Creates a new `ServerHook` instance with default no-op hooks.\n    ///\n    /// The default `wait_hook` and `shutdown_hook` do nothing, allowing the server\n    /// to run without specific shutdown or wait logic unless configured otherwise.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `ServerHook` instance with default hooks.\n    fn default() -> Self {\n        Self {\n            wait_hook: Arc::new(|| Box::pin(async {})),\n            shutdown_hook: Arc::new(|| Box::pin(async {})),\n        }\n    }\n}\n\n/// Manages server lifecycle hooks, including waiting and shutdown procedures.\n///\n/// This struct holds closures that are executed during specific server lifecycle events.\nimpl ServerHook {\n    /// Waits for the server's shutdown signal or completion.\n    ///\n    /// This method asynchronously waits until the server's `wait_hook` is triggered,\n    /// typically indicating that the server has finished its operations or is ready to shut down.\n    pub async fn wait(&self) {\n        self.get_wait_hook()().await;\n    }\n\n    /// Initiates the server shutdown process.\n    ///\n    /// This method asynchronously calls the `shutdown_hook`, which is responsible for\n    /// performing any necessary cleanup or graceful shutdown procedures.\n    pub async fn shutdown(&self) {\n        self.get_shutdown_hook()().await;\n    }\n}", "file_size": 3343, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a thread-safe, shareable, pinned, boxed, sendable, synchronous function.\n///\n/// This type is used for storing handlers in a shared context, allowing multiple\n/// parts of the application to safely access and execute the same handler.\npub type ArcFnContextPinBoxSendSync<T> = Arc<dyn FnContextPinBoxSendSync<T>>;\n\n/// An optional, thread-safe, shareable handler function.\n///\n/// This is used when a handler may or may not be present, such as for optional\n/// middleware or hooks.\npub type OptionArcFnContextPinBoxSendSync<T> = Option<ArcFnContextPinBoxSendSync<T>>;\n\n/// A vector of thread-safe, shareable handler functions.\n///\n/// This type is used to represent a chain of middleware or hooks that can be\n/// executed sequentially.\npub type VecArcFnContextPinBoxSendSync<T> = Vec<ArcFnContextPinBoxSendSync<T>>;\n\n/// A type alias for a pinned, boxed, sendable, static future.\n///\n/// This is a common return type for asynchronous handlers, providing a type-erased\n/// future that can be easily managed by the async runtime.\npub type PinBoxFutureSendStatic = Pin<Box<(dyn Future<Output = ()> + Send + 'static)>>;\n\n/// A type alias for a pinned, boxed, `Send`-able future with a generic output.\n///\n/// This is often used to represent an asynchronous task that can be sent across threads.\npub type PinBoxFutureSend<T> = Pin<Box<dyn Future<Output = T> + Send>>;\n\n/// A type alias for a thread-safe, reference-counted closure that produces a `FnPinBoxFutureSend`.\n///\n/// This is useful for creating and sharing asynchronous task factories.\npub type ArcFnPinBoxFutureSend<T> = Arc<dyn FnPinBoxFutureSend<T>>;", "file_size": 1643, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\attribute\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of `From` trait for `AttributeKey`.\nimpl From<&str> for AttributeKey {\n    /// Converts a string slice into an `AttributeKey`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The string slice to convert.\n    ///\n    /// # Returns\n    ///\n    /// - `AttributeKey` - The converted attribute key.\n    fn from(key: &str) -> Self {\n        AttributeKey::External(key.to_string())\n    }\n}\n\n/// Implementation of `From` trait for `AttributeKey`.\nimpl From<String> for AttributeKey {\n    /// Converts a `String` into an `AttributeKey`.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The string to convert.\n    ///\n    /// # Returns\n    ///\n    /// - `AttributeKey` - The converted attribute key.\n    fn from(key: String) -> Self {\n        AttributeKey::External(key)\n    }\n}\n\n/// Implementation of `From` trait for `AttributeKey`.\nimpl From<InternalAttributeKey> for AttributeKey {\n    /// Converts an `InternalAttributeKey` into an `AttributeKey`.\n    ///\n    /// # Arguments\n    ///\n    /// - `InternalAttributeKey` - The internal attribute key to convert.\n    ///\n    /// # Returns\n    ///\n    /// - `AttributeKey` - The converted attribute key.\n    fn from(key: InternalAttributeKey) -> Self {\n        AttributeKey::Internal(key)\n    }\n}", "file_size": 1284, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// A generic trait for functions that take a `Context` and return a value.\n///\n/// This trait encapsulates the common behavior of being a sendable, synchronous\n/// function that accepts a `Context`. It is used as a base for other, more\n/// specific function traits.\npub trait FnContextSendSync<R>: Fn(Context) -> R + Send + Sync {}\n\n/// A trait for functions that return a pinned, boxed, sendable future.\n///\n/// This trait is essential for creating type-erased async function pointers,\n/// which is a common pattern for storing and dynamically dispatching different\n/// asynchronous handlers in a collection.\npub trait FnContextPinBoxSendSync<T>: FnContextSendSync<PinBoxFutureSend<T>> {}\n\n/// A trait for static, sendable, synchronous functions that return a future.\n///\n/// This trait ensures that a handler function is safe to be sent across threads\n/// and has a static lifetime, making it suitable for use in long-lived components\n/// of the application, such as the main router.\npub trait FnContextSendSyncStatic<Fut, T>: FnContextSendSync<Fut> + 'static\nwhere\n    Fut: Future<Output = T> + Send,\n{\n}\n\n/// A trait for futures that are sendable and have a static lifetime.\n///\n/// This marker trait simplifies generic bounds for asynchronous operations, ensuring\n/// that futures can be safely managed by the async runtime without lifetime issues.\npub trait FutureSendStatic<T>: Future<Output = T> + Send + 'static {}\n\n/// A trait for `Send`-able futures with a generic output.\npub trait FutureSend<T>: Future<Output = T> + Send {}\n\n/// A trait for thread-safe, reference-counted closures that produce a `PinBoxFutureSend`.\npub trait FnPinBoxFutureSend<T>: Fn() -> PinBoxFutureSend<T> + Send + Sync {}", "file_size": 1723, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\hook\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use r#enum::*;\npub use r#struct::*;\npub use r#trait::*;\npub use r#type::*;", "file_size": 197, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\panic\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of methods for the `Panic` struct.\nimpl Panic {\n    /// Creates a new `Panic` instance from its constituent parts.\n    ///\n    /// # Arguments\n    ///\n    /// - `OptionString` - The panic message.\n    /// - `OptionString` - The source code location of the panic.\n    /// - `OptionString` - The panic payload.\n    ///\n    /// # Returns\n    ///\n    /// - `Panic` - A new panic instance.\n    pub(crate) fn new(\n        message: OptionString,\n        location: OptionString,\n        payload: OptionString,\n    ) -> Self {\n        Self {\n            message,\n            location,\n            payload,\n        }\n    }\n\n    /// Attempts to extract a string from a dynamic `&dyn Any` panic payload.\n    ///\n    /// This function handles payloads that are either `&str` or `String`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&dyn Any` - The payload from a `PanicInfo` object.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionString` - The extracted message, or None if the payload is not a string type.\n    fn extract_panic_message_from_any(panic_payload: &dyn Any) -> OptionString {\n        if let Some(s) = panic_payload.downcast_ref::<&str>() {\n            Some(s.to_string())\n        } else if let Some(s) = panic_payload.downcast_ref::<String>() {\n            Some(s.clone())\n        } else {\n            None\n        }\n    }\n\n    /// Creates a `Panic` instance from a `tokio::task::JoinError`.\n    ///\n    /// This is used to handle panics that occur within spawned asynchronous tasks,\n    /// extracting the panic message from the `JoinError`.\n    ///\n    /// # Arguments\n    ///\n    /// - `JoinError` - The error from a panicked task.\n    ///\n    /// # Returns\n    ///\n    /// - `Panic` - A new panic instance with message from error.\n    pub(crate) fn from_join_error(join_error: JoinError) -> Self {\n        let default_message: String = join_error.to_string();\n        let mut message: OptionString = if let Ok(panic_join_error) = join_error.try_into_panic() {\n            Self::extract_panic_message_from_any(&panic_join_error)\n        } else {\n            None\n        };\n        if (message.is_none() || message.clone().unwrap_or_default().is_empty())\n            && !default_message.is_empty()\n        {\n            message = Some(default_message);\n        }\n        let panic: Panic = Panic::new(message, None, None);\n        panic\n    }\n}", "file_size": 2388, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\error\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\n\npub use r#enum::*;", "file_size": 42, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\context\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the internal state of the application context.\n///\n/// This structure holds all the data associated with a single request-response cycle,\n/// including the stream, request, response, and any custom attributes.\n#[derive(Clone, Data, Default, CustomDebug, DisplayDebug)]\npub(crate) struct ContextInner {\n    /// A flag indicating whether the request handling has been aborted.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    aborted: bool,\n    /// A flag indicating whether the connection has been closed.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    closed: bool,\n    /// The underlying network stream for the connection.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    stream: OptionArcRwLockStream,\n    /// The incoming HTTP request.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    request: Request,\n    /// The outgoing HTTP response.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    response: Response,\n    /// Parameters extracted from the route path.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    route_params: RouteParams,\n    /// A collection of custom attributes for sharing data within the request lifecycle.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    attributes: HashMapArcAnySendSync,\n}\n\n/// The main application context, providing thread-safe access to request and response data.\n///\n/// This is a wrapper around `ContextInner` that uses an `Arc<RwLock<>>` to allow\n/// for shared, mutable access across asynchronous tasks.\n#[derive(Clone, Default, Getter, CustomDebug, DisplayDebug)]\npub struct Context(#[get(pub(super))] pub(super) ArcRwLock<ContextInner>);", "file_size": 1813, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\panic\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents detailed information about a panic that has occurred within the server.\n///\n/// This struct captures essential details about a panic, such as the message,\n/// source code location, and payload. It is used by the server's panic handling\n/// mechanism and passed to the configured panic hook for custom processing.\n#[derive(CustomDebug, Default, PartialEq, Eq, Clone, Getter, DisplayDebug)]\npub struct Panic {\n    /// The message associated with the panic.\n    /// This is `None` if the panic payload is not a string.\n    #[get(pub)]\n    pub(super) message: OptionString,\n    /// The source code location where the panic occurred.\n    #[get(pub)]\n    pub(super) location: OptionString,\n    /// The payload of the panic, often a string literal.\n    /// The handler attempts to downcast it to a `&str` or `String`.\n    #[get(pub)]\n    pub(super) payload: OptionString,\n}", "file_size": 896, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\error\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents errors that can occur at the server level.\n#[derive(CustomDebug, DisplayDebug, PartialEq, Eq, Clone)]\npub enum ServerError {\n    /// An error occurred while trying to bind to a TCP socket.\n    TcpBind(String),\n    /// An unknown or unexpected error occurred.\n    Unknown(String),\n    /// An error occurred while reading an HTTP request.\n    HttpRead(String),\n    /// The received HTTP request was invalid or malformed.\n    InvalidHttpRequest(Request),\n    /// Other error.\n    Other(String),\n}\n\n/// Represents errors related to route definitions and matching.\n#[derive(CustomDebug, DisplayDebug, PartialEq, Eq, Clone)]\npub(crate) enum RouteError {\n    /// The route pattern cannot be empty.\n    EmptyPattern,\n    /// A route with the same pattern has already been defined.\n    DuplicatePattern(String),\n    /// The provided route pattern is not a valid regular expression.\n    InvalidRegexPattern(String),\n}", "file_size": 937, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\lifecycle\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\n\npub(crate) use r#enum::*;", "file_size": 72, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\lifecycle\\impl.rs", "language": "rust", "content": "use super::*;\n\n/// Implementation of methods for the `Lifecycle` enum.\nimpl Lifecycle {\n    /// Creates a new Lifecycle instance with default continue and keep-alive state.\n    ///\n    /// # Returns\n    ///\n    /// - `Lifecycle` - A new Lifecycle::Continue(true) instance.\n    pub(crate) fn new() -> Self {\n        Self::Continue(true)\n    }\n\n    /// Creates a new Lifecycle instance with Continue state.\n    ///\n    /// # Arguments\n    ///\n    /// - `bool` - Whether the connection should be kept alive.\n    ///\n    /// # Returns\n    ///\n    /// - `Lifecycle` - A new Lifecycle::Continue instance.\n    pub(crate) fn new_continue(keep_alive: bool) -> Self {\n        Self::Continue(keep_alive)\n    }\n\n    /// Updates the lifecycle status based on abort and keep-alive flags.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut self` - A mutable reference to the `Lifecycle` instance.\n    /// - `bool` - Whether the request processing has been aborted.\n    /// - `bool` - Whether the connection should be kept alive.\n    pub(crate) fn update_status(&mut self, aborted: bool, keep_alive: bool) {\n        *self = if aborted {\n            Lifecycle::Abort(keep_alive)\n        } else {\n            Lifecycle::Continue(keep_alive)\n        };\n    }\n\n    /// Checks if the lifecycle state is Abort.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if in Abort state, false otherwise.\n    pub(crate) fn is_abort(&self) -> bool {\n        matches!(self, Lifecycle::Abort(_))\n    }\n\n    /// Checks if the connection should be kept alive.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if keep-alive flag is set, false otherwise.\n    pub(crate) fn is_keep_alive(&self) -> bool {\n        matches!(self, Lifecycle::Continue(true) | Lifecycle::Abort(true))\n    }\n\n    /// Returns the keep-alive status of the connection.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - The keep-alive flag value.\n    pub(crate) fn keep_alive(&self) -> bool {\n        match self {\n            Lifecycle::Continue(res) | Lifecycle::Abort(res) => *res,\n        }\n    }\n}", "file_size": 2058, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\lifecycle\\enum.rs", "language": "rust", "content": "/// Represents the control flow state of a request's lifecycle.\n///\n/// This enum is used internally to manage whether the request processing pipeline\n/// should proceed to the next stage or be terminated prematurely. It also tracks\n/// whether the underlying connection should be kept alive for subsequent requests.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum Lifecycle {\n    /// Indicates that the request processing should be aborted.\n    /// The boolean value specifies whether the connection should be kept alive (`true`) or closed (`false`).\n    Abort(bool),\n    /// Indicates that the request processing should continue to the next stage.\n    /// The boolean value specifies whether the connection should be kept alive (`true`) or closed (`false`).\n    Continue(bool),\n}", "file_size": 788, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\server\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a `Result` that returns a `ServerError` on failure.\n///\n/// This is commonly used throughout the server's public-facing API.\npub type ServerResult<T> = Result<T, ServerError>;\n\n/// A type alias for a `Result` that returns a `JoinError` on failure.\n///\n/// This is used when waiting for asynchronous tasks to complete.\npub type ResultJoinError<T> = Result<T, JoinError>;\n\n/// A type alias for a thread-safe, reference-counted read-write lock over `ServerInner`.\n///\n/// This is the core mechanism for sharing server state across threads.\npub(crate) type ArcRwLockServerInner = ArcRwLock<ServerInner>;\n\n/// A type alias for a thread-safe, reference-counted read-write lock over `ServerConfigInner`.\n///\n/// This is the core mechanism for sharing server config state across threads.\npub(crate) type ArcRwLockServerConfigInner = ArcRwLock<ServerConfigInner>;\n\n/// A type alias for a read guard on the `ServerInner`'s `RwLock`.\n///\n/// This provides read-only access to the server's internal state.\npub(crate) type RwLockReadGuardServerInner<'a> = RwLockReadGuard<'a, ServerInner>;\n\n/// A type alias for a write guard on the `ServerInner`'s `RwLock`.\n///\n/// This provides mutable access to the server's internal state.\npub(crate) type RwLockWriteGuardServerInner<'a> = RwLockWriteGuard<'a, ServerInner>;", "file_size": 1335, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\clonelicious\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"clonelicious\"\nversion = \"2.2.4\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust macro library that simplifies cloning and closure execution. The `clone!` macro automatically clones variables and immediately executes the closure with the cloned values, streamlining common patterns in Rust programming.\"\"\"\nkeywords = [\"standard\", \"macro\", \"extensions\", \"structures\", \"simplifying\"]\nrepository = \"https://github.com/crates-dev/clonelicious\"\ncategories = [\"data-structures\", \"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dev-dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 972, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a hash map that stores captured route parameters.\n///\n/// The key is the parameter name and the value is the captured string.\npub type RouteParams = HashMapXxHash3_64<String, String>;\n\n/// A type alias for a vector of `RouteSegment`s.\n///\n/// This is used to represent a parsed route.\npub(crate) type VecRouteSegment = Vec<RouteSegment>;\n\n/// A type alias for a vector of string slices.\n///\n/// This is often used for path components.\npub(crate) type VecStrRef<'a> = Vec<&'a str>;\n\n/// A type alias for a vector containing tuples of a `RoutePattern` and its associated handler function.\n///\n/// This is used for storing dynamic and regex routes.\npub(crate) type VecRoutePatternArcFnPinBoxSendSync<T = ()> =\n    Vec<(RoutePattern, ArcFnContextPinBoxSendSync<T>)>;\n\n/// A type alias for a hash map that stores static routes and their handlers.\n///\n/// The key is the exact path string.\npub(crate) type HashMapStringArcFnPinBoxSendSyncXxHash3_64 =\n    HashMapXxHash3_64<String, ArcFnContextPinBoxSendSync<()>>;\n\n/// A type alias for a `Result` returned when adding a new route.\n///\n/// This indicates success or a `RouteError`.\npub(crate) type ResultAddRoute = Result<(), RouteError>;\n\n/// A type alias for a `Result` from parsing a route string.\n///\n/// This yields a vector of `RouteSegment`s or a `RouteError`.\npub(crate) type ResultVecRouteSegmentRouteError = Result<VecRouteSegment, RouteError>;\n\n/// A type alias for a `Result` from creating a `RoutePattern`.\n///\n/// This can fail with a `RouteError`.\npub(crate) type ResultRoutePatternRouteError = Result<RoutePattern, RouteError>;\n\n/// A type alias for an optional `RouteParams` map.\n///\n/// It is `Some` if a dynamic or regex route matches and captures parameters, and `None` otherwise.\npub(crate) type OptionRouteParams = Option<RouteParams>;", "file_size": 1836, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"china_identification_card\"\nversion = \"1.1.10\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"A Rust library for validating Chinese identification card numbers based on official rules and checksums.\"\nkeywords = [\"china\", \"id\", \"identification\", \"card\", \"validation\"]\nrepository = \"https://github.com/crates-dev/china_identification_card\"\ncategories = [\"authentication\", \"data-structures\", \"development-tools\"]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 738, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\server\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default implementation for ServerInner.\nimpl Default for ServerInner {\n    /// Creates a new ServerInner instance with default values.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new instance with default configuration.\n    fn default() -> Self {\n        Self {\n            config: ServerConfigInner::default(),\n            route: RouteMatcher::new(),\n            request_middleware: vec![],\n            response_middleware: vec![],\n            pre_upgrade_hook: vec![],\n            connected_hook: vec![],\n            disable_http_hook: RouteMatcher::new(),\n            disable_ws_hook: RouteMatcher::new(),\n            panic_hook: vec![],\n        }\n    }\n}\n\n/// Implements the `PartialEq` trait for `ServerInner`.\n///\n/// This allows for comparing two `ServerInner` instances for equality.\nimpl PartialEq for ServerInner {\n    /// Checks if two `ServerInner` instances are equal.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `ServerInner` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool`: `true` if the instances are equal, `false` otherwise.\n    fn eq(&self, other: &Self) -> bool {\n        self.config == other.config\n            && self.route == other.route\n            && self.disable_http_hook == other.disable_http_hook\n            && self.disable_ws_hook == other.disable_ws_hook\n            && self.request_middleware.len() == other.request_middleware.len()\n            && self.response_middleware.len() == other.response_middleware.len()\n            && self.panic_hook.len() == other.panic_hook.len()\n            && self.connected_hook.len() == other.connected_hook.len()\n            && self.pre_upgrade_hook.len() == other.pre_upgrade_hook.len()\n            && self\n                .request_middleware\n                .iter()\n                .zip(other.request_middleware.iter())\n                .all(|(a, b)| Arc::ptr_eq(a, b))\n            && self\n                .response_middleware\n                .iter()\n                .zip(other.response_middleware.iter())\n                .all(|(a, b)| Arc::ptr_eq(a, b))\n            && self\n                .pre_upgrade_hook\n                .iter()\n                .zip(other.pre_upgrade_hook.iter())\n                .all(|(a, b)| Arc::ptr_eq(a, b))\n            && self\n                .connected_hook\n                .iter()\n                .zip(other.connected_hook.iter())\n                .all(|(a, b)| Arc::ptr_eq(a, b))\n            && self\n                .panic_hook\n                .iter()\n                .zip(other.panic_hook.iter())\n                .all(|(a, b)| Arc::ptr_eq(a, b))\n    }\n}\n\n/// Implements the `Eq` trait for `ServerInner`.\n///\n/// This indicates that `ServerInner` has a total equality relation.\nimpl Eq for ServerInner {}\n\n/// Implements the `PartialEq` trait for `Server`.\n///\n/// This allows for comparing two `Server` instances for equality.\nimpl PartialEq for Server {\n    /// Checks if two `Server` instances are equal.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `Server` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool`: `true` if the instances are equal, `false` otherwise.\n    fn eq(&self, other: &Self) -> bool {\n        if Arc::ptr_eq(&self.get_0(), &other.get_0()) {\n            return true;\n        }\n        if let (Ok(s), Ok(o)) = (self.get_0().try_read(), other.get_0().try_read()) {\n            *s == *o\n        } else {\n            false\n        }\n    }\n}\n\n/// Implements the `Eq` trait for `Server`.\n///\n/// This indicates that `Server` has a total equality relation.\nimpl Eq for Server {}\n\n/// Manages the state for handling a single connection, including the stream and context.\n///\n/// This struct provides a convenient way to pass around the necessary components\n/// for processing a request or WebSocket frame.\nimpl<'a> HandlerState<'a> {\n    /// Creates a new HandlerState instance.\n    ///\n    /// # Arguments\n    ///\n    /// - `&'a ArcRwLockStream` - The network stream.\n    /// - `&'a Context` - The request context.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - The newly created handler state.\n    pub(super) fn new(stream: &'a ArcRwLockStream, ctx: &'a Context) -> Self {\n        Self { stream, ctx }\n    }\n}\n\n/// Represents the server, providing methods to configure and run it.\n///\n/// This struct wraps the `ServerInner` configuration and routing logic,\n/// offering a high-level API for setting up the HTTP and WebSocket server.\nimpl Server {\n    /// Creates a new Server instance with default settings.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new Server instance.\n    pub async fn new() -> Self {\n        let server: ServerInner = ServerInner::default();\n        Self(arc_rwlock(server))\n    }\n\n    /// Creates a new Server instance from a configuration.\n    ///\n    /// # Arguments\n    ///\n    /// - `ServerConfig` - The server configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new Server instance.\n    pub async fn from(config: ServerConfig) -> Self {\n        let server: Self = Self::new().await;\n        server.config(config).await;\n        server\n    }\n\n    /// Acquires a read lock on the inner server data.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadGuardServerInner` - The read guard for ServerInner.\n    async fn read(&self) -> RwLockReadGuardServerInner {\n        self.get_0().read().await\n    }\n\n    /// Acquires a write lock on the inner server data.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteGuardServerInner` - The write guard for ServerInner.\n    async fn write(&self) -> RwLockWriteGuardServerInner {\n        self.get_0().write().await\n    }\n\n    /// Sets the server configuration from a string.\n    ///\n    /// # Arguments\n    ///\n    /// - `C: ToString` - The configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn config_str<C: ToString>(&self, config_str: C) -> &Self {\n        let config: ServerConfig = ServerConfig::from_str(&config_str.to_string()).unwrap();\n        self.write().await.set_config(config.get_inner().await);\n        self\n    }\n\n    /// Sets the server configuration.\n    ///\n    /// # Arguments\n    ///\n    /// - `ServerConfig` - The server configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn config(&self, config: ServerConfig) -> &Self {\n        self.write().await.set_config(config.get_inner().await);\n        self\n    }\n\n    /// Sets a custom panic hook for request processing.\n    ///\n    /// # Arguments\n    ///\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The panic handler function.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the panic handler.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn panic_hook<F, Fut>(&self, func: F) -> &Self\n    where\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        self.write()\n            .await\n            .get_mut_panic_hook()\n            .push(Arc::new(move |ctx: Context| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Adds a route handler for a specific path.\n    ///\n    /// # Arguments\n    ///\n    /// - `R: ToString` - The route path pattern.\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The handler function for the route.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the handler.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn route<R, F, Fut>(&self, route: R, func: F) -> &Self\n    where\n        R: ToString,\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        let route_str: String = route.to_string();\n        self.write()\n            .await\n            .get_mut_route()\n            .add(\n                &route_str,\n                Arc::new(move |ctx: Context| Box::pin(func(ctx))),\n            )\n            .unwrap_or_else(|err| panic!(\"{}\", err));\n        self\n    }\n\n    /// Adds request middleware to the processing pipeline.\n    ///\n    /// # Arguments\n    ///\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The middleware function.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the middleware.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn request_middleware<F, Fut>(&self, func: F) -> &Self\n    where\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        self.write()\n            .await\n            .get_mut_request_middleware()\n            .push(Arc::new(move |ctx: Context| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Adds response middleware to the processing pipeline.\n    ///\n    /// # Arguments\n    ///\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The middleware function.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the middleware.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn response_middleware<F, Fut>(&self, func: F) -> &Self\n    where\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        self.write()\n            .await\n            .get_mut_response_middleware()\n            .push(Arc::new(move |ctx: Context| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Adds a hook executed before WebSocket connection upgrade.\n    ///\n    /// # Arguments\n    ///\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The hook function.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the hook.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn pre_upgrade_hook<F, Fut>(&self, func: F) -> &Self\n    where\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        self.write()\n            .await\n            .get_mut_pre_upgrade_hook()\n            .push(Arc::new(move |ctx: Context| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Adds a hook executed after new client connection is established.\n    ///\n    /// # Arguments\n    ///\n    /// - `F: FnContextSendSyncStatic<Fut, ()>` - The hook function.\n    /// - `Fut: FutureSendStatic<()>` - The future returned by the hook.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn connected_hook<F, Fut>(&self, func: F) -> &Self\n    where\n        F: FnContextSendSyncStatic<Fut, ()>,\n        Fut: FutureSendStatic<()>,\n    {\n        self.write()\n            .await\n            .get_mut_connected_hook()\n            .push(Arc::new(move |ctx: Context| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Re-enables default HTTP handling for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `R: ToString` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn enable_http_hook<R: ToString>(&self, route: R) -> &Self {\n        let route_string: String = route.to_string();\n        self.write()\n            .await\n            .get_mut_disable_http_hook()\n            .remove(&route_string);\n        self\n    }\n\n    /// Disables default HTTP handling for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `R: ToString` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn disable_http_hook<R: ToString>(&self, route: R) -> &Self {\n        let route_string: String = route.to_string();\n        let _ = self\n            .write()\n            .await\n            .get_mut_disable_http_hook()\n            .add(&route_string, Arc::new(|_: Context| Box::pin(async {})));\n        self\n    }\n\n    /// Re-enables default WebSocket handling for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `R: ToString` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn enable_ws_hook<R: ToString>(&self, route: R) -> &Self {\n        let route_string: String = route.to_string();\n        self.write()\n            .await\n            .get_mut_disable_ws_hook()\n            .remove(&route_string);\n        self\n    }\n\n    /// Disables default WebSocket handling for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `R: ToString` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn disable_ws_hook<R: ToString>(&self, route: R) -> &Self {\n        let route_string: String = route.to_string();\n        let _ = self\n            .write()\n            .await\n            .get_mut_disable_ws_hook()\n            .add(&route_string, Arc::new(|_: Context| Box::pin(async {})));\n        self\n    }\n\n    /// Checks if default HTTP handling is disabled for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if HTTP handling is disabled.\n    async fn contains_disable_http_hook(&self, route: &str) -> bool {\n        self.read().await.get_disable_http_hook().match_route(route)\n    }\n\n    /// Checks if default WebSocket handling is disabled for a route.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The route path.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if WebSocket handling is disabled.\n    async fn contains_disable_ws_hook(&self, route: &str) -> bool {\n        self.read().await.get_disable_ws_hook().match_route(route)\n    }\n\n    /// Formats the host and port into a bindable address string.\n    ///\n    /// # Arguments\n    ///\n    /// - `H: ToString` - The host address.\n    /// - `usize` - The port number.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The formatted address string.\n    pub fn format_host_port<H: ToString>(host: H, port: usize) -> String {\n        format!(\"{}{}{}\", host.to_string(), COLON_SPACE_SYMBOL, port)\n    }\n\n    /// Handles a panic that has been captured and associated with a specific request `Context`.\n    ///\n    /// This function is invoked when a panic occurs within a task that has access to the request\n    /// context, such as a route handler or middleware. It ensures that the panic information is\n    /// recorded in the `Context` and then passed to the server's configured panic hook for\n    /// processing.\n    ///\n    /// By associating the panic with the context, the handler can access request-specific details\n    /// to provide more meaningful error logging and responses.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The context of the request during which the panic occurred.\n    /// - `&Panic` - The captured panic information.\n    async fn handle_panic_with_context(&self, ctx: &Context, panic: &Panic) {\n        let panic_clone: Panic = panic.clone();\n        ctx.cancel_aborted().await.set_panic(panic_clone).await;\n        for func in self.read().await.get_panic_hook().iter() {\n            func(ctx.clone()).await;\n            if ctx.get_aborted().await {\n                return;\n            }\n        }\n    }\n\n    /// Handles a panic that occurred within a spawned Tokio task.\n    ///\n    /// It extracts the panic information from the `JoinError` and processes it.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The context associated with the task.\n    /// - `JoinError` - The `JoinError` returned from the panicked task.\n    async fn handle_task_panic(&self, ctx: &Context, join_error: JoinError) {\n        let panic: Panic = Panic::from_join_error(join_error);\n        self.handle_panic_with_context(&ctx, &panic).await;\n    }\n\n    /// Executes a given hook function within a spawned task and manages the request lifecycle.\n    ///\n    /// This function also handles panics that may occur within the hook's execution.\n    ///\n    /// # Arguments\n    ///\n    /// - `ctx: &Context` - The request context.\n    /// - `lifecycle: &mut Lifecycle` - A mutable reference to the current `Lifecycle` state.\n    /// - `F: Fn(Context) -> PinBoxFutureSendStatic` - The hook function to execute.\n    async fn run_hook_with_lifecycle<F>(\n        &self,\n        ctx: &Context,\n        lifecycle: &mut Lifecycle,\n        hook_func: F,\n    ) where\n        F: Fn(Context) -> PinBoxFutureSendStatic,\n    {\n        let result: ResultJoinError<()> = spawn(hook_func(ctx.clone())).await;\n        ctx.update_lifecycle_status(lifecycle).await;\n        if let Err(join_error) = result {\n            if join_error.is_panic() {\n                self.handle_task_panic(&ctx, join_error).await;\n            }\n        }\n    }\n\n    /// Creates and binds a `TcpListener` based on the server's configuration.\n    ///\n    /// # Returns\n    ///\n    /// Returns a `ServerResult` containing the bound `TcpListener` on success,\n    /// or a `ServerError` on failure.\n    async fn create_tcp_listener(&self) -> ServerResult<TcpListener> {\n        let config: ServerConfigInner = self.read().await.get_config().clone();\n        let host: String = config.get_host().clone();\n        let port: usize = *config.get_port();\n        let addr: String = Self::format_host_port(host, port);\n        TcpListener::bind(&addr)\n            .await\n            .map_err(|err| ServerError::TcpBind(err.to_string()))\n    }\n\n    /// Enters a loop to accept incoming TCP connections and spawn handlers for them.\n    ///\n    /// # Arguments\n    ///\n    /// - `&TcpListener` - A reference to the `TcpListener` to accept connections from.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerResult<()>` - A `ServerResult` which is typically `Ok(())` unless an unrecoverable\n    /// error occurs.\n    async fn accept_connections(&self, tcp_listener: &TcpListener) -> ServerResult<()> {\n        while let Ok((stream, _socket_addr)) = tcp_listener.accept().await {\n            self.configure_stream(&stream).await;\n            let stream: ArcRwLockStream = ArcRwLockStream::from_stream(stream);\n            self.spawn_connection_handler(stream).await;\n        }\n        Ok(())\n    }\n\n    /// Configures socket options for a newly accepted `TcpStream`.\n    ///\n    /// This applies settings like `SO_LINGER`, `TCP_NODELAY`, and `IP_TTL` from the server's configuration.\n    ///\n    /// # Arguments\n    ///\n    /// - `&TcpStream` - A reference to the `TcpStream` to configure.\n    async fn configure_stream(&self, stream: &TcpStream) {\n        let config: ServerConfigInner = self.read().await.get_config().clone();\n        let nodelay_opt: OptionBool = *config.get_nodelay();\n        let linger_opt: OptionDuration = *config.get_linger();\n        let ttl_opt: OptionU32 = *config.get_ttl();\n        let _ = stream.set_linger(linger_opt);\n        if let Some(nodelay) = nodelay_opt {\n            let _ = stream.set_nodelay(nodelay);\n        }\n        if let Some(ttl) = ttl_opt {\n            let _ = stream.set_ttl(ttl);\n        }\n    }\n\n    /// Spawns a new asynchronous task to handle a single client connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `ArcRwLockStream` - The thread-safe stream representing the client connection.\n    async fn spawn_connection_handler(&self, stream: ArcRwLockStream) {\n        let server: Server = self.clone();\n        let http_buffer: usize = *self.read().await.get_config().get_http_buffer();\n        spawn(async move {\n            server.handle_connection(stream, http_buffer).await;\n        });\n    }\n\n    /// Handles a single client connection, determining whether it's an HTTP or WebSocket request.\n    ///\n    /// It reads the initial request from the stream and dispatches it to the appropriate handler.\n    ///\n    /// # Arguments\n    ///\n    /// - `ArcRwLockStream` - The stream for the client connection.\n    /// - `usize` - The buffer size to use for reading the initial HTTP request.\n    async fn handle_connection(&self, stream: ArcRwLockStream, http_buffer: usize) {\n        if let Ok(mut request) = Request::http_from_stream(&stream, http_buffer).await {\n            let ctx: Context = Context::create_context(&stream, &request);\n            let handler: HandlerState = HandlerState::new(&stream, &ctx);\n            if request.is_ws() {\n                self.ws_hook(&handler, &mut request).await;\n            } else {\n                self.http_hook(&handler, &request).await;\n            }\n        }\n    }\n\n    /// Executes all registered pre-upgrade hooks for a WebSocket connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&mut Lifecycle` - A mutable reference to the request lifecycle state.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - `true` if the lifecycle was aborted, `false` otherwise.\n    async fn run_pre_upgrade_hook(&self, ctx: &Context, lifecycle: &mut Lifecycle) -> bool {\n        for func in self.read().await.get_pre_upgrade_hook().iter() {\n            self.run_hook_with_lifecycle(ctx, lifecycle, move |ctx: Context| func(ctx))\n                .await;\n            if lifecycle.is_abort() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Executes all registered `connected` hooks.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&mut Lifecycle` - A mutable reference to the request lifecycle state.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - `true` if the lifecycle was aborted, `false` otherwise.\n    async fn run_connected_hook(&self, ctx: &Context, lifecycle: &mut Lifecycle) -> bool {\n        for func in self.read().await.get_connected_hook().iter() {\n            self.run_hook_with_lifecycle(ctx, lifecycle, move |ctx: Context| func(ctx))\n                .await;\n            if lifecycle.is_abort() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Executes all registered request middleware in sequence.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&mut Lifecycle` - A mutable reference to the request lifecycle state.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - `true` if the lifecycle was aborted, `false` otherwise.\n    async fn run_request_middleware(&self, ctx: &Context, lifecycle: &mut Lifecycle) -> bool {\n        for func in self.read().await.get_request_middleware().iter() {\n            self.run_hook_with_lifecycle(ctx, lifecycle, move |ctx: Context| func(ctx))\n                .await;\n            if lifecycle.is_abort() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Executes the matched route handler.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&OptionArcFnContextPinBoxSendSync` - An `Option` containing the handler function if a route was matched.\n    /// - `&mut Lifecycle` - A mutable reference to the request lifecycle state.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - `true` if the lifecycle was aborted, `false` otherwise.\n    async fn run_route_hook(\n        &self,\n        ctx: &Context,\n        handler: &OptionArcFnContextPinBoxSendSync<()>,\n        lifecycle: &mut Lifecycle,\n    ) -> bool {\n        if let Some(func) = handler {\n            self.run_hook_with_lifecycle(ctx, lifecycle, move |ctx: Context| func(ctx))\n                .await;\n        }\n        lifecycle.is_abort()\n    }\n\n    /// Executes all registered response middleware in sequence.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&mut Lifecycle` - A mutable reference to the request lifecycle state.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - `true` if the lifecycle was aborted, `false` otherwise.\n    async fn run_response_middleware(&self, ctx: &Context, lifecycle: &mut Lifecycle) -> bool {\n        for func in self.read().await.get_response_middleware().iter() {\n            self.run_hook_with_lifecycle(ctx, lifecycle, move |ctx: Context| func(ctx))\n                .await;\n            if lifecycle.is_abort() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// The core request handling pipeline.\n    ///\n    /// This function orchestrates the execution of request middleware, the route handler,\n    /// and response middleware.\n    ///\n    /// # Arguments\n    ///\n    /// - `&HandlerState<'a>` - The `HandlerState` for the current connection.\n    /// - `&Request` - The incoming request to be processed.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - A boolean indicating whether the connection should be kept alive.\n    async fn request_hook<'a>(&self, state: &HandlerState<'a>, request: &Request) -> bool {\n        let route: &str = request.get_path();\n        let ctx: &Context = state.ctx;\n        ctx.set_request(request).await;\n        let mut lifecycle: Lifecycle = Lifecycle::new_continue(request.is_enable_keep_alive());\n        let route_hook: OptionArcFnContextPinBoxSendSync<()> = self\n            .read()\n            .await\n            .get_route()\n            .resolve_route(ctx, route)\n            .await;\n        if self.run_request_middleware(ctx, &mut lifecycle).await {\n            return lifecycle.keep_alive();\n        }\n        if self.run_route_hook(ctx, &route_hook, &mut lifecycle).await {\n            return lifecycle.keep_alive();\n        }\n        self.run_response_middleware(ctx, &mut lifecycle).await;\n        lifecycle.keep_alive()\n    }\n\n    /// Handles subsequent HTTP requests on a persistent (keep-alive) connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `&HandlerState<'a>` - The `HandlerState` for the current connection.\n    /// - `&Request` - The initial request that established the keep-alive connection.\n    async fn handle_http_requests<'a>(&self, state: &HandlerState<'a>, request: &Request) {\n        let route: &str = request.get_path();\n        let contains_disable_http_hook: bool = self.contains_disable_http_hook(route).await;\n        let buffer: usize = *self.read().await.get_config().get_http_buffer();\n        if contains_disable_http_hook {\n            while self.request_hook(state, request).await {}\n            return;\n        }\n        while let Ok(new_request) = &Request::http_from_stream(state.stream, buffer).await {\n            if !self.request_hook(state, new_request).await {\n                return;\n            }\n        }\n    }\n\n    /// The main entry point for handling an HTTP connection.\n    ///\n    /// It runs connected hooks and then enters the request handling loop.\n    ///\n    /// # Arguments\n    ///\n    /// - `&HandlerState<'a>` - The `HandlerState` for the current connection.\n    /// - `&Request` - The initial HTTP request from the client.\n    async fn http_hook<'a>(&self, state: &HandlerState<'a>, request: &Request) {\n        let ctx: &Context = state.ctx;\n        let mut lifecycle: Lifecycle = Lifecycle::new();\n        if self.run_connected_hook(ctx, &mut lifecycle).await {\n            return;\n        }\n        if !self.request_hook(state, request).await {\n            return;\n        }\n        self.handle_http_requests(state, request).await;\n    }\n\n    /// Handles the stream of incoming WebSocket frames after a connection is established.\n    ///\n    /// # Arguments\n    ///\n    /// - `&HandlerState<'a>` - The `HandlerState` for the current connection.\n    /// - `&mut Request` - The mutable request object, which will be updated with each new frame.\n    /// - `&str` - The route path that the WebSocket connection was established on.\n    async fn handle_ws_requests<'a>(\n        &self,\n        state: &HandlerState<'a>,\n        request: &mut Request,\n        route: &str,\n    ) {\n        let disable_ws_hook_contains: bool = self.contains_disable_ws_hook(route).await;\n        let buffer: usize = *self.read().await.get_config().get_ws_buffer();\n        if disable_ws_hook_contains {\n            while self.request_hook(state, request).await {}\n            return;\n        }\n        while let Ok(new_request) = &Request::ws_from_stream(state.stream, buffer, request).await {\n            let _ = self.request_hook(state, new_request).await;\n        }\n    }\n\n    /// The main entry point for handling a WebSocket connection.\n    ///\n    /// This function manages the upgrade process, runs pre-upgrade and connected hooks,\n    /// and then enters the WebSocket frame handling loop.\n    ///\n    /// # Arguments\n    ///\n    /// - `&HandlerState<'a>` - The `HandlerState` for the current connection.\n    /// - `&mut Request` - The mutable HTTP request that initiated the WebSocket upgrade.\n    async fn ws_hook<'a>(&self, state: &HandlerState<'a>, request: &mut Request) {\n        let route: String = request.get_path().clone();\n        let ctx: &Context = state.ctx;\n        let mut lifecycle: Lifecycle = Lifecycle::new();\n        self.read()\n            .await\n            .get_route()\n            .resolve_route(ctx, &route)\n            .await;\n        if self.run_pre_upgrade_hook(ctx, &mut lifecycle).await {\n            return;\n        }\n        if ctx.upgrade_to_ws().await.is_err() {\n            return;\n        }\n        if self.run_connected_hook(ctx, &mut lifecycle).await {\n            return;\n        }\n        self.handle_ws_requests(state, request, &route).await;\n    }\n\n    /// Starts the server, binds to the configured address, and begins listening for connections.\n    ///\n    /// This is the main entry point to launch the server. It will initialize the panic hook,\n    /// create a TCP listener, and then enter the connection acceptance loop in a background task.\n    ///\n    /// # Returns\n    ///\n    /// Returns a `ServerResult` containing a shutdown function on success.\n    /// Calling this function will shut down the server by aborting its main task.\n    /// Returns an error if the server fails to start.\n    pub async fn run(&self) -> ServerResult<ServerHook> {\n        let tcp_listener: TcpListener = self.create_tcp_listener().await?;\n        let server: Server = self.clone();\n        let (wait_sender, wait_receiver) = channel(());\n        let (shutdown_sender, mut shutdown_receiver) = channel(());\n        let accept_connections: JoinHandle<()> = spawn(async move {\n            let _ = server.accept_connections(&tcp_listener).await;\n            let _ = wait_sender.send(());\n        });\n        let wait_hook: ArcFnPinBoxFutureSend<()> = Arc::new(move || {\n            let mut wait_receiver_clone: Receiver<()> = wait_receiver.clone();\n            Box::pin(async move {\n                let _ = wait_receiver_clone.changed().await;\n            })\n        });\n        let shutdown_hook: ArcFnPinBoxFutureSend<()> = Arc::new(move || {\n            let shutdown_sender_clone: Sender<()> = shutdown_sender.clone();\n            Box::pin(async move {\n                let _ = shutdown_sender_clone.send(());\n            })\n        });\n        spawn(async move {\n            let _ = shutdown_receiver.changed().await;\n            accept_connections.abort();\n        });\n        let mut server_hook: ServerHook = ServerHook::default();\n        server_hook.set_shutdown_hook(shutdown_hook);\n        server_hook.set_wait_hook(wait_hook);\n        Ok(server_hook)\n    }\n}", "file_size": 31146, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"bin-encode-decode\"\nversion = \"1.1.21\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"A high-performance binary encode and decode library that supports customizable character sets beyond Base64.\"\nkeywords = [\"binaryencode\", \"decode\", \"customcharset\", \"highperformance\", \"base64alternative\"]\nrepository = \"https://github.com/crates-dev/bin-encode-decode\"\ncategories = [\"encoding\"]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 708, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a parsed and structured route pattern.\n///\n/// This struct wraps a vector of `RouteSegment`s, which are the individual components\n/// of a URL path. It is used internally by the `RouteMatcher` to perform efficient\n/// route matching against incoming requests.\n#[derive(Debug, Clone, Getter, DisplayDebug)]\npub(crate) struct RoutePattern(\n    /// The collection of segments that make up the route pattern.\n    #[get(pub(super))]\n    pub(super) VecRouteSegment,\n);\n\n/// The core routing engine responsible for matching request paths to their corresponding handlers.\n///\n/// The matcher categorizes routes into three types for optimized performance:\n/// 1.  `static_routes`: For exact path matches, offering the fastest lookups.\n/// 2.  `dynamic_routes`: For paths with variable segments.\n/// 3.  `regex_routes`: For complex matching based on regular expressions.\n///\n/// When a request comes in, the matcher checks these categories in order to find the appropriate handler.\n#[derive(Clone, CustomDebug, Getter, GetterMut, DisplayDebug)]\npub(crate) struct RouteMatcher {\n    /// A hash map for storing and quickly retrieving handlers for static routes.\n    /// These are routes without any variable path segments.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    pub(super) static_routes: HashMapStringArcFnPinBoxSendSyncXxHash3_64,\n    /// A vector of routes that contain dynamic segments.\n    /// These are evaluated sequentially if no static route matches.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    pub(super) dynamic_routes: VecRoutePatternArcFnPinBoxSendSync,\n    /// A vector of routes that use regular expressions for matching.\n    /// These provide the most flexibility but are evaluated last due to their performance overhead.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    pub(super) regex_routes: VecRoutePatternArcFnPinBoxSendSync,\n}", "file_size": 1953, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\panic\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for an `Option` that may contain a `Panic` struct.\n///\n/// This is used in contexts where a panic might not have occurred, allowing for\n/// graceful handling of both panic and non-panic scenarios.\npub type OptionPanic = Option<Panic>;\n\n/// A type alias for an optional reference to a `Location`.\n///\n/// The lifetimes `'a` and `'b` are tied to the `PanicHookInfo` from which the\n/// location information is sourced. This ensures that the reference does not\n/// outlive the panic information itself, preventing dangling pointers.\npub type OptionLocationRef<'a, 'b> = Option<&'a Location<'b>>;", "file_size": 623, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the different types of segments that can make up a route path.\n///\n/// A route path is parsed into a sequence of these segments. For example, the path\n/// `/users/:id/posts` would be broken down into `Static(\"users\")`, `Dynamic(\"id\")`,\n/// and `Static(\"posts\")`.\n#[derive(CustomDebug, Clone)]\npub(crate) enum RouteSegment {\n    /// A static, literal segment of a path.\n    /// This must be an exact match. For example, in `/users/active`, \"users\" and \"active\"\n    /// are both static segments.\n    Static(String),\n    /// A dynamic segment that captures a value from the path.\n    /// It is denoted by a colon prefix. The captured value\n    /// is stored as a parameter in the request context.\n    Dynamic(String),\n    /// A segment that is matched against a regular expression.\n    /// This allows for more complex and flexible routing logic. The first element is the parameter\n    /// name, and the second is the compiled `Regex` object.\n    Regex(String, Regex),\n}", "file_size": 997, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\impl.rs", "language": "rust", "content": "use crate::*;\n\n// Collects route macro definitions for the inventory system.\ncollect!(HookMacro);\n\n/// Provides a default implementation for RouteMatcher.\nimpl Default for RouteMatcher {\n    /// Creates a new, empty RouteMatcher.\n    ///\n    /// # Returns\n    ///\n    /// - `RouteMatcher` - A new RouteMatcher with empty storage for static, dynamic, and regex routes.\n    fn default() -> Self {\n        Self {\n            static_routes: hash_map_xx_hash3_64(),\n            dynamic_routes: Vec::new(),\n            regex_routes: Vec::new(),\n        }\n    }\n}\n\n/// Implements the `PartialEq` trait for `RoutePattern`.\n///\n/// This allows for comparing two `RoutePattern` instances for equality.\nimpl PartialEq for RoutePattern {\n    /// Checks if two `RoutePattern` instances are equal.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RoutePattern` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool`: `true` if the instances are equal, `false` otherwise.\n    fn eq(&self, other: &Self) -> bool {\n        self.get_0() == other.get_0()\n    }\n}\n\n/// Implements the `Eq` trait for `RoutePattern`.\n///\n/// This indicates that `RoutePattern` has a total equality relation.\nimpl Eq for RoutePattern {}\n\n/// Implements the `PartialOrd` trait for `RoutePattern`.\n///\n/// This allows for partial ordering of `RoutePattern` instances.\nimpl PartialOrd for RoutePattern {\n    /// Partially compares two `RoutePattern` instances.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RoutePattern` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<std::cmp::Ordering>`: The ordering of the two instances.\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// Implements the `Ord` trait for `RoutePattern`.\n///\n/// This allows for total ordering of `RoutePattern` instances.\nimpl Ord for RoutePattern {\n    /// Compares two `RoutePattern` instances.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RoutePattern` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `std::cmp::Ordering`: The ordering of the two instances.\n    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n        self.get_0().cmp(&other.get_0())\n    }\n}\n\n/// Implements the `PartialEq` trait for `RouteMatcher`.\n///\n/// This allows for comparing two `RouteMatcher` instances for equality.\nimpl PartialEq for RouteMatcher {\n    /// Checks if two `RouteMatcher` instances are equal.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RouteMatcher` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool`: `true` if the instances are equal, `false` otherwise.\n    fn eq(&self, other: &Self) -> bool {\n        let self_static_keys: BTreeSet<_> = self.static_routes.keys().collect();\n        let other_static_keys: BTreeSet<_> = other.static_routes.keys().collect();\n        if self_static_keys != other_static_keys {\n            return false;\n        }\n        let self_dynamic_patterns: BTreeSet<_> =\n            self.dynamic_routes.iter().map(|(p, _)| p).collect();\n        let other_dynamic_patterns: BTreeSet<_> =\n            other.dynamic_routes.iter().map(|(p, _)| p).collect();\n        if self_dynamic_patterns != other_dynamic_patterns {\n            return false;\n        }\n        let self_regex_patterns: BTreeSet<_> = self.regex_routes.iter().map(|(p, _)| p).collect();\n        let other_regex_patterns: BTreeSet<_> = other.regex_routes.iter().map(|(p, _)| p).collect();\n        if self_regex_patterns != other_regex_patterns {\n            return false;\n        }\n        true\n    }\n}\n\n/// Implements the `Eq` trait for `RouteMatcher`.\n///\n/// This indicates that `RouteMatcher` has a total equality relation.\nimpl Eq for RouteMatcher {}\n\n/// Implements the `Eq` trait for `RouteSegment`.\n///\n/// This indicates that `RouteSegment` has a total equality relation.\nimpl Eq for RouteSegment {}\n\n/// Implements the `PartialOrd` trait for `RouteSegment`.\n///\n/// This allows for partial ordering of `RouteSegment` instances.\nimpl PartialOrd for RouteSegment {\n    /// Partially compares two `RouteSegment` instances.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RouteSegment` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<Ordering>`: The ordering of the two instances.\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\n/// Implements the `Ord` trait for `RouteSegment`.\n///\n/// This allows for total ordering of `RouteSegment` instances.\nimpl Ord for RouteSegment {\n    /// Compares two `RouteSegment` instances.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RouteSegment` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `Ordering`: The ordering of the two instances.\n    fn cmp(&self, other: &Self) -> Ordering {\n        match (self, other) {\n            (Self::Static(s1), Self::Static(s2)) => s1.cmp(s2),\n            (Self::Dynamic(d1), Self::Dynamic(d2)) => d1.cmp(d2),\n            (Self::Regex(n1, r1), Self::Regex(n2, r2)) => {\n                n1.cmp(n2).then_with(|| r1.as_str().cmp(r2.as_str()))\n            }\n            (Self::Static(_), _) => Ordering::Less,\n            (_, Self::Static(_)) => Ordering::Greater,\n            (Self::Dynamic(_), _) => Ordering::Less,\n            (_, Self::Dynamic(_)) => Ordering::Greater,\n        }\n    }\n}\n\n/// Implements the `PartialEq` trait for `RouteSegment`.\n///\n/// This allows for comparing two `RouteSegment` instances for equality.\nimpl PartialEq for RouteSegment {\n    /// Checks if two `RouteSegment` instances are equal.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self`: The other `RouteSegment` instance to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool`: `true` if the instances are equal, `false` otherwise.\n    fn eq(&self, other: &Self) -> bool {\n        match (self, other) {\n            (Self::Static(l0), Self::Static(r0)) => l0 == r0,\n            (Self::Dynamic(l0), Self::Dynamic(r0)) => l0 == r0,\n            (Self::Regex(l0, l1), Self::Regex(r0, r1)) => l0 == r0 && l1.as_str() == r1.as_str(),\n            _ => false,\n        }\n    }\n}\n\n/// Manages route patterns, including parsing and matching.\n///\n/// This struct is responsible for defining and validating route structures,\n/// supporting static, dynamic, and regex-based path matching.\nimpl RoutePattern {\n    /// Creates a new RoutePattern by parsing a route string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The raw route string to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<RoutePattern, RouteError>` - The parsed RoutePattern on success, or RouteError on failure.\n    pub(crate) fn new(route: &str) -> ResultRoutePatternRouteError {\n        Ok(Self(Self::parse_route(route)?))\n    }\n\n    /// Parses a raw route string into RouteSegments.\n    ///\n    /// This is the core logic for interpreting the route syntax.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The raw route string.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Vec<RouteSegment>, RouteError>` - Vector of RouteSegments on success, or RouteError on failure.\n    fn parse_route(route: &str) -> ResultVecRouteSegmentRouteError {\n        if route.is_empty() {\n            return Err(RouteError::EmptyPattern);\n        }\n        let route: &str = route.trim_start_matches(DEFAULT_HTTP_PATH);\n        if route.is_empty() {\n            return Ok(Vec::new());\n        }\n        let estimated_segments: usize = route.matches(DEFAULT_HTTP_PATH).count() + 1;\n        let mut segments: VecRouteSegment = Vec::with_capacity(estimated_segments);\n        for segment in route.split(DEFAULT_HTTP_PATH) {\n            if segment.starts_with(DYNAMIC_ROUTE_LEFT_BRACKET)\n                && segment.ends_with(DYNAMIC_ROUTE_RIGHT_BRACKET)\n            {\n                let content: &str = &segment[1..segment.len() - 1];\n                if let Some((name, pattern)) = content.split_once(':') {\n                    match Regex::new(pattern) {\n                        Ok(regex) => {\n                            segments.push(RouteSegment::Regex(name.to_owned(), regex));\n                        }\n                        Err(err) => {\n                            return Err(RouteError::InvalidRegexPattern(format!(\n                                \"Invalid regex pattern '{}{}{}\",\n                                pattern, COLON_SPACE, err\n                            )));\n                        }\n                    }\n                } else {\n                    segments.push(RouteSegment::Dynamic(content.to_owned()));\n                }\n            } else {\n                segments.push(RouteSegment::Static(segment.to_owned()));\n            }\n        }\n        Ok(segments)\n    }\n\n    /// Matches this route pattern against a request path.\n    ///\n    /// If the pattern matches, extracts any dynamic or regex parameters.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The request path to match against.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<RouteParams>` - Some with parameters if matched, None otherwise.\n    pub(crate) fn match_path(&self, path: &str) -> OptionRouteParams {\n        let path: &str = path.trim_start_matches(DEFAULT_HTTP_PATH);\n        let route_segments_len: usize = self.get_0().len();\n        let is_tail_regex: bool = matches!(self.get_0().last(), Some(RouteSegment::Regex(_, _)));\n        if path.is_empty() {\n            if route_segments_len == 0 {\n                return Some(hash_map_xx_hash3_64());\n            }\n            return None;\n        }\n        let mut path_segments: VecStrRef = Vec::with_capacity(route_segments_len);\n        let mut segment_start: usize = 0;\n        let path_bytes: &[u8] = path.as_bytes();\n        let path_separator_byte: u8 = b'/';\n        for i in 0..path_bytes.len() {\n            if path_bytes[i] == path_separator_byte {\n                if segment_start < i {\n                    path_segments.push(&path[segment_start..i]);\n                }\n                segment_start = i + 1;\n            }\n        }\n        if segment_start < path.len() {\n            path_segments.push(&path[segment_start..]);\n        }\n        let path_segments_len: usize = path_segments.len();\n        if (!is_tail_regex && path_segments_len != route_segments_len)\n            || (is_tail_regex && path_segments_len < route_segments_len - 1)\n        {\n            return None;\n        }\n        let mut params: RouteParams = hash_map_xx_hash3_64();\n        for (idx, segment) in self.get_0().iter().enumerate() {\n            match segment {\n                RouteSegment::Static(expected_path) => {\n                    if path_segments.get(idx).copied() != Some(expected_path.as_str()) {\n                        return None;\n                    }\n                }\n                RouteSegment::Dynamic(param_name) => {\n                    let Some(value) = path_segments.get(idx) else {\n                        return None;\n                    };\n                    params.insert(param_name.clone(), value.to_string());\n                }\n                RouteSegment::Regex(param_name, regex) => {\n                    let segment_value: String = if idx == route_segments_len - 1 {\n                        path_segments[idx..].join(DEFAULT_HTTP_PATH)\n                    } else {\n                        match path_segments.get(idx) {\n                            Some(val) => val.to_string(),\n                            None => return None,\n                        }\n                    };\n                    if let Some(mat) = regex.find(&segment_value) {\n                        if mat.start() != 0 || mat.end() != segment_value.len() {\n                            return None;\n                        }\n                    } else {\n                        return None;\n                    }\n                    params.insert(param_name.clone(), segment_value);\n                    if idx == route_segments_len - 1 {\n                        break;\n                    }\n                }\n            }\n        }\n        Some(params)\n    }\n\n    /// Checks if the route pattern is static.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if the pattern is static, false otherwise.\n    pub(crate) fn is_static(&self) -> bool {\n        self.get_0()\n            .iter()\n            .all(|seg| matches!(seg, RouteSegment::Static(_)))\n    }\n\n    /// Checks if the route pattern is dynamic.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if the pattern is dynamic, false otherwise.\n    pub(crate) fn is_dynamic(&self) -> bool {\n        self.get_0()\n            .iter()\n            .any(|seg| matches!(seg, RouteSegment::Dynamic(_)))\n            && self\n                .get_0()\n                .iter()\n                .all(|seg| !matches!(seg, RouteSegment::Regex(_, _)))\n    }\n}\n\n/// Manages a collection of routes, enabling efficient lookup and dispatch.\n///\n/// This struct stores routes categorized by type (static, dynamic, regex)\n/// to quickly find the appropriate handler for incoming requests.\nimpl RouteMatcher {\n    /// Creates a new, empty RouteMatcher.\n    ///\n    /// # Returns\n    ///\n    /// - `RouteMatcher` - A new RouteMatcher instance with empty route stores.\n    pub(crate) fn new() -> Self {\n        Self {\n            static_routes: hash_map_xx_hash3_64(),\n            dynamic_routes: Vec::new(),\n            regex_routes: Vec::new(),\n        }\n    }\n\n    /// Adds a new route and its handler to the matcher.\n    ///\n    /// The route is categorized as static, dynamic, or regex based on its pattern.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The route pattern string.\n    /// - `ArcFnContextPinBoxSendSync` - The handler function for this route.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<(), RouteError>` - Ok on success, or RouteError if pattern is duplicate.\n    pub(crate) fn add(\n        &mut self,\n        pattern: &str,\n        handler: ArcFnContextPinBoxSendSync<()>,\n    ) -> ResultAddRoute {\n        let route_pattern: RoutePattern = RoutePattern::new(pattern)?;\n        if route_pattern.is_static() {\n            if self.get_static_routes().contains_key(pattern) {\n                return Err(RouteError::DuplicatePattern(pattern.to_owned()));\n            }\n            self.get_mut_static_routes()\n                .insert(pattern.to_string(), handler);\n            return Ok(());\n        }\n        let target_vec: &mut VecRoutePatternArcFnPinBoxSendSync = if route_pattern.is_dynamic() {\n            self.get_mut_dynamic_routes()\n        } else {\n            self.get_mut_regex_routes()\n        };\n        let has_same_pattern: bool = target_vec\n            .iter()\n            .any(|(tmp_pattern, _)| tmp_pattern == &route_pattern);\n        if has_same_pattern {\n            return Err(RouteError::DuplicatePattern(pattern.to_owned()));\n        }\n        target_vec.push((route_pattern, handler));\n        Ok(())\n    }\n\n    /// Removes a route from the matcher based on its pattern.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The pattern of the route to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if route was removed, false otherwise.\n    pub(crate) fn remove(&mut self, pattern: &str) -> bool {\n        if let Ok(route_pattern) = RoutePattern::new(pattern) {\n            if route_pattern.is_static() {\n                return self.get_mut_static_routes().remove(pattern).is_some();\n            }\n            let target_vec: &mut VecRoutePatternArcFnPinBoxSendSync = if route_pattern.is_dynamic()\n            {\n                self.get_mut_dynamic_routes()\n            } else {\n                self.get_mut_regex_routes()\n            };\n            if let Some(pos) = target_vec\n                .iter()\n                .position(|(tmp_pattern, _)| tmp_pattern == &route_pattern)\n            {\n                target_vec.remove(pos);\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Checks if a path matches any registered routes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The request path to check.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - true if matching route found, false otherwise.\n    pub(crate) fn match_route(&self, path: &str) -> bool {\n        if self.get_static_routes().contains_key(path) {\n            return true;\n        }\n        for (pattern, _) in self.get_dynamic_routes().iter() {\n            if pattern.match_path(path).is_some() {\n                return true;\n            }\n        }\n        for (pattern, _) in self.get_regex_routes().iter() {\n            if pattern.match_path(path).is_some() {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Finds the handler for a path by matching against registered routes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Context` - The request context.\n    /// - `&str` - The request path to resolve.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<ArcFnContextPinBoxSendSync>` - Some handler if match found, None otherwise.\n    pub(crate) async fn resolve_route(\n        &self,\n        ctx: &Context,\n        path: &str,\n    ) -> OptionArcFnContextPinBoxSendSync<()> {\n        if let Some(handler) = self.get_static_routes().get(path) {\n            ctx.set_route_params(RouteParams::default()).await;\n            return Some(handler.clone());\n        }\n        for (pattern, handler) in self.get_dynamic_routes().iter() {\n            if let Some(params) = pattern.match_path(path) {\n                ctx.set_route_params(params).await;\n                return Some(handler.clone());\n            }\n        }\n        for (pattern, handler) in self.get_regex_routes().iter() {\n            if let Some(params) = pattern.match_path(path) {\n                ctx.set_route_params(params).await;\n                return Some(handler.clone());\n            }\n        }\n        None\n    }\n}", "file_size": 17991, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\server\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the state associated with a single connection handler.\n///\n/// This struct encapsulates the necessary context for processing a connection,\n/// including a reference to the network stream and the request context. It is created\n/// for each connection and passed to the relevant handlers.\n#[derive(Clone, CustomDebug, DisplayDebug)]\npub(crate) struct HandlerState<'a> {\n    /// A reference to the underlying network stream for the connection.\n    /// This provides access to the raw TCP stream for reading and writing data.\n    pub(super) stream: &'a ArcRwLockStream,\n    /// A reference to the context of the current request.\n    /// This contains request-specific information, such as headers, method, and URI.\n    pub(super) ctx: &'a Context,\n}\n\n/// Represents the internal, mutable state of the web server.\n///\n/// This struct consolidates all the core components required for the server to operate,\n/// including configuration, routing, middleware, and various hooks for extending functionality.\n/// It is not intended to be used directly by end-users, but rather wrapped within the `Server` struct\n/// for thread-safe access.\n#[derive(Data, Clone, CustomDebug, DisplayDebug)]\npub(crate) struct ServerInner {\n    /// Stores the server's configuration settings, such as address, port, and timeouts.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) config: ServerConfigInner,\n    /// The routing component responsible for matching incoming requests to their registered handlers.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) route: RouteMatcher,\n    /// A collection of middleware functions that are executed for every incoming request\n    /// before it is passed to the corresponding route handler.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) request_middleware: VecArcFnContextPinBoxSendSync<()>,\n    /// A collection of middleware functions that are executed for every outgoing response\n    /// before it is sent back to the client.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) response_middleware: VecArcFnContextPinBoxSendSync<()>,\n    /// A collection of hooks that are executed before a connection is upgraded to WebSocket.\n    /// This allows for custom logic, such as authentication, to be performed.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) pre_upgrade_hook: VecArcFnContextPinBoxSendSync<()>,\n    /// A collection of hooks that are executed immediately after a new client connection is established.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) connected_hook: VecArcFnContextPinBoxSendSync<()>,\n    /// A route matcher used to specify routes for which the default HTTP hook should be disabled.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) disable_http_hook: RouteMatcher,\n    /// A route matcher used to specify routes for which the default WebSocket hook should be disabled.\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) disable_ws_hook: RouteMatcher,\n    /// A custom error handler that is invoked when a panic occurs during request processing.\n    /// This allows for graceful error recovery and customized error responses.\n    #[debug(skip)]\n    #[get(pub(super))]\n    #[get_mut(pub(super))]\n    #[set(pub(super))]\n    pub(super) panic_hook: VecArcFnContextPinBoxSendSync<()>,\n}\n\n/// The primary server structure that provides a thread-safe interface to the server's state.\n///\n/// This struct acts as a public-facing wrapper around an `Arc<RwLock<ServerInner>>`.\n/// It allows multiple parts of the application to safely share and modify the server's\n/// configuration and state across different threads and asynchronous tasks.\n#[derive(Clone, Getter, CustomDebug, DisplayDebug, Default)]\npub struct Server(#[get(pub(super))] pub(super) ArcRwLockServerInner);", "file_size": 4125, "extension": ".rs"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#type::*;\n\npub(crate) use r#const::*;\npub(crate) use r#enum::*;\npub(crate) use r#struct::*;", "file_size": 219, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"color-output\"\nversion = \"7.2.7\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"An atomic output library based on Rust that supports output functionalities through functions, builders, and other methods. It allows customization of text and background colors.\"\"\"\nkeywords = [\"output\", \"console\", \"log\", \"print\", \"color\"]\nrepository = \"https://github.com/crates-dev/color-output\"\ncategories = [\"command-line-interface\", \"development-tools\", \"visualization\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nhyperlane-time = \"0.7.7\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 897, "extension": ".toml"}
{"file_path": "training_sources\\hyperlane-dev\\hyperlane\\src\\route\\const.rs", "language": "rust", "content": "/// The character used to denote the beginning of a dynamic route segment.\npub(crate) const DYNAMIC_ROUTE_LEFT_BRACKET: &str = \"{\";\n/// The character used to denote the end of a dynamic route segment.\npub(crate) const DYNAMIC_ROUTE_RIGHT_BRACKET: &str = \"}\";", "file_size": 258, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"chunkify\"\nversion = \"0.6.36\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A simple and efficient chunking library for Rust.\"\"\"\nkeywords = [\"http\", \"file\", \"chunk\", \"upload\", \"web\"]\nrepository = \"https://github.com/crates-dev/chunkify.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"uploads\",\n    \"**/*.log\",\n]\n\n[dependencies]\nfile-operation = \"0.8.4\"\nonce_cell = \"1.21.3\"\ndashmap = \"6.1.0\"\ntokio = { version = \"1.47.1\", features = [\"full\"] }\ntwox-hash = \"2.1.1\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 894, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\compare-version\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"compare_version\"\nversion = \"1.2.3\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"A Rust library for comparing semantic versioning strings and checking version compatibility.\"\nkeywords = [\"version\", \"comparison\", \"semver\", \"rust\"]\nrepository = \"https://github.com/crates-dev/compare-version\"\ncategories = [\"algorithms\", \"development-tools\", \"rust-patterns\"]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 687, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\gtl\\README.ZH-CN.md", "language": "markdown", "content": "<center>\n\n## gtl\n\n[English](README.md) | [简体中文](README.ZH-CN.md)\n\n[![](https://img.shields.io/crates/v/gtl.svg)](https://crates.io/crates/gtl)\n[![](https://img.shields.io/crates/d/gtl.svg)](https://img.shields.io/crates/d/gtl.svg)\n[![](https://img.shields.io/crates/l/gtl.svg)](./license)\n\n</center>\n\n> `gtl` 是一个基于 Git 的工具，旨在简化多远程仓库的管理。它扩展了 Git 的功能，提供了一键初始化和推送到多个远程仓库的功能，特别适合需要同时维护多个远程仓库的开发者。\n\n## 特性\n\n- **多远程仓库管理**：支持为一个本地仓库配置多个远程仓库。\n- **一键初始化远程仓库**：通过简单的命令，一次性初始化并配置多个远程仓库。\n- **一键推送到多个远程仓库**：可以通过一条命令将代码推送到所有已配置的远程仓库，节省时间和精力。\n- **Git 命令扩展**：为 Git 提供了更多便捷的操作，提升工作效率。\n\n## 安装\n\n通过 `cargo` 安装 `gtl`：\n\n```bash\ncargo install gtl\n```\n\n## 使用\n\n### 配置文件\n\n> 路径: /home/.git_helper/config.json\n\n```json\n{\n  \"D:\\\\code\\\\gtl\": [\n    { \"name\": \"gitee\", \"url\": \"git@gitee.com:eastspire/gtl.git\" },\n    { \"name\": \"origin\", \"url\": \"git@github.com:eastspire/gtl.git\" }\n  ]\n}\n```\n\n### 初始化多个远程仓库\n\n假设你已经有一个本地 Git 仓库，并希望将其与多个远程仓库关联，使用以下命令：\n\n```bash\ngtl init\n```\n\n### 一键推送到所有远程仓库\n\n配置好多个远程仓库后，使用以下命令将代码推送到所有已配置的远程仓库：\n\n```bash\ngtl push\n```\n\n### Git 添加 & 提交 & 推送\n\n```bash\ngtl acp\n```\n\n### 发布到 Crates.io & Git 添加 & 提交 & 推送\n\n```bash\ngtl pacp\n```\n\n### 版本\n\n```bash\ngtl -v\ngtl version\ngtl --version\n```\n\n### 帮助\n\n```bash\ngtl help\n```\n\n## 赞赏\n\n**如果你觉得 `hyperlane` 对你有所帮助，欢迎捐赠。**\n\n<img src=\"https://docs.ltpp.vip/img/wechat-pay.png\" width=\"200\">  \n<img src=\"https://docs.ltpp.vip/img/alipay-pay.jpg\" width=\"200\">\n\n## 许可证\n\n此项目基于 MIT 许可证授权。详细信息请查看 [license](license) 文件。\n\n## 贡献\n\n欢迎贡献！请提交 issue 或创建 pull request。\n\n## 联系方式\n\n如有任何疑问，请联系作者：[root@ltpp.vip](mailto:root@ltpp.vip)。", "file_size": 1533, "extension": ".md"}
{"file_path": "training_sources\\crates-dev\\file-operation\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"file-operation\"\nversion = \"0.8.4\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust library providing comprehensive utilities for file operations with both sync/async support. Includes operations for copy, delete, move, read and write files. Simplifies file handling in Rust projects with safe and efficient methods for file manipulation and metadata querying.\"\"\"\nkeywords = [\"time\", \"hyperlane\", \"day\", \"format\", \"lang\"]\nrepository = \"https://github.com/crates-dev/file-operation.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1015, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-broadcast\"\nversion = \"0.7.5\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"hyperlane-broadcast is a lightweight and ergonomic wrapper over Tokio’s broadcast channel designed for easy-to-use publish-subscribe messaging in async Rust applications. It simplifies the native Tokio broadcast API by providing a straightforward interface for broadcasting messages to multiple subscribers with minimal boilerplate.\"\"\"\nkeywords = [\"time\", \"hyperlane\", \"broadcast\", \"tokio\", \"hyperlane\"]\nrepository = \"https://github.com/crates-dev/hyperlane-broadcast.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\ndashmap = \"6.1.0\"\ntokio = { version = \"1.47.1\", features = [\"full\"] }\ntwox-hash = \"2.1.1\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1122, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hot-restart\"\nversion = \"0.6.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust library for hot restarting applications without downtime. Provides seamless process replacement for servers and long-running services, enabling zero-downtime updates and configuration reloads.\"\"\"\nkeywords = [\"hot\", \"restart\", \"cargo\", \"watch\", \"file\"]\nrepository = \"https://github.com/crates-dev/hot-restart.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dev-dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 927, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\http-compress\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"http-compress\"\nversion = \"2.16.6\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A high-performance async library for HTTP compression/decompression, supporting Brotli, Deflate, and Gzip algorithms. Provides both compression and decompression capabilities with optimized memory usage, ideal for HTTP clients/servers and network programming.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/http-compress.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nbrotli = \"8.0.2\"\nflate2 = \"1.1.2\"\ntwox-hash = \"2.1.1\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 996, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\http-request\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"http-request\"\nversion = \"8.91.14\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"http-request is a lightweight, efficient library for building, sending, and handling HTTP/HTTPS requests in Rust applications. It provides a simple and intuitive API, allowing developers to easily interact with web services, whether they use the \"HTTP\" or \"HTTPS\" protocol. The library supports various HTTP methods, custom headers, request bodies, timeout, automatic handling of redirects (including detecting redirect loops), and enhanced response body decoding (both automatic and manual), enabling fast and secure communication. Whether working with secure \"HTTPS\" connections or standard \"HTTP\" requests, the library is optimized for performance, minimal resource usage, and easy integration into Rust projects.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/http-request.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nhttp-type = \"4.58.2\"\nrustls = \"0.23.31\"\nserde = \"1.0.219\"\nserde_json = \"1.0.143\"\nwebpki-roots = \"1.0.2\"\ntokio-rustls = \"0.26.2\"\nfutures = \"0.3.31\"\ntokio-tungstenite = \"0.27.0\"\ntungstenite = \"0.27.0\"\n\n[profile.dev]\nincremental = true\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false", "file_size": 1520, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\future-fn\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"future-fn\"\nversion = \"0.3.4\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust library providing macros to simplify the creation of asynchronous closures with external state captured by move. Useful for structuring asynchronous code with ease and clarity.\"\"\"\nkeywords = [\"standard\", \"macro\", \"extensions\", \"structures\", \"simplifying\"]\nrepository = \"https://github.com/crates-dev/future-fn\"\ncategories = [\"data-structures\", \"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dev-dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 921, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\http-constant\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"http-constant\"\nversion = \"1.63.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A comprehensive library providing common HTTP constants for header names, versions, MIME types, and protocol identifiers.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/http-constant.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 788, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-log\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-log\"\nversion = \"1.18.6\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust logging library that supports both asynchronous and synchronous logging. It provides multiple log levels, such as error, info, and debug. Users can define custom log handling methods and configure log file paths. The library supports log rotation, automatically creating a new log file when the current file reaches the specified size limit. It allows flexible logging configurations, making it suitable for both high-performance asynchronous applications and traditional synchronous logging scenarios. The asynchronous mode utilizes Tokio's async channels for efficient log buffering, while the synchronous mode writes logs directly to the file system.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/hyperlane-log.git\"\ncategories = [\"network-programming\", \"web-programming\",\"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"**/*.log\"\n]\n\n[dependencies]\nfile-operation = \"0.8.4\"\nhyperlane-time = \"0.7.7\"\n\n[dev-dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1513, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-utils\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-utils\"\nversion = \"7.2.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A library providing utils for hyperlane.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/hyperlane-utils.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nhex = \"0.4.3\"\nlombok-macros = \"1.13.11\"\nserde = \"1.0.219\"\nserde-xml-rs = \"0.8.1\"\nserde_json = \"1.0.143\"\nserde_urlencoded = \"0.7.1\"\nurl = \"2.5.6\"\nonce_cell = \"1.21.3\"\nsimd-json = \"0.15.1\"\nfutures = \"0.3.31\"\nnum_cpus = \"1.17.0\"\nahash = \"0.8.12\"\nurlencoding = \"2.1.3\"\ntwox-hash = \"2.1.1\"\nchunkify = \"0.6.36\"\nfuture-fn = \"0.3.4\"\ncolor-output = \"7.2.7\"\nclonelicious = \"2.2.4\"\nhyperlane-log = \"1.18.6\"\nserver-manager = \"5.0.0\"\nfile-operation = \"0.8.4\"\ncompare_version = \"1.2.3\"\nbin-encode-decode = \"1.1.21\"\nrecoverable-spawn = \"3.9.4\"\nhyperlane-broadcast = \"0.7.5\"\nrecoverable-thread-pool = \"2.4.4\"\nlog = \"0.4.27\"\nstd-macro-extensions = \"0.26.5\"\nhot-restart = \"0.6.0\"\nutoipa = { version = \"5.4.0\", features = [\"openapi_extensions\"] }\nutoipa-swagger-ui = { version = \"9.0.2\", features = [\"debug-embed\", \"vendored\", \"actix-web\"] }\nutoipa-rapidoc = { version = \"6.0.0\", features = [\"actix-web\"] }\nhyperlane-macros = \"4.1.1\"\nhyperlane-plugin-websocket = \"2.2.33\"\ninventory = \"0.3.21\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1700, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-macros\"\nversion = \"4.0.2\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A comprehensive collection of procedural macros for building HTTP servers with enhanced functionality. This crate provides attribute macros that simplify HTTP request handling, protocol validation, response management, and request data extraction.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"cross-platform\"]\nrepository = \"https://github.com/crates-dev/hyperlane-macros.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"img\",\n    \"**/*.log\",\n    \"debug\"\n]\n\n[lib]\nproc-macro = true\n\n[dependencies]\nsyn = { version = \"2.0.106\", features = [\"full\"] }\nquote = \"1.0.40\"\nproc-macro2 = \"1.0.101\"\n\n[dev-dependencies]\nhyperlane = \"7.6.1\"\nserde = { version = \"1.0.219\", features = [\"derive\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1205, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\http-type\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"http-type\"\nversion = \"4.58.2\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A comprehensive Rust library providing essential types for HTTP operations. Includes core HTTP abstractions (request/response, methods, status codes, versions), content types, cookies, WebSocket support, and thread-safe concurrent types (ArcMutex, ArcRwLock). Also provides convenient Option-wrapped primitive types for flexible HTTP handling.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/http-type.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nhex = \"0.4.3\"\nhttp-constant = \"1.63.0\"\nlombok-macros = \"1.13.11\"\nserde = \"1.0.219\"\nserde_json = \"1.0.143\"\nserde-xml-rs = \"0.8.1\"\nserde_urlencoded = \"0.7.1\"\nurl = \"2.5.6\"\ntokio = { version = \"1.47.1\", features = [\"full\"] }\nhttp-compress = \"2.16.6\"\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1265, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\gtl\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"gtl\"\nversion = \"0.5.6\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"gtl is a Git-based tool designed to simplify the management of multiple remote repositories. It extends Git's functionality by providing one-click initialization and pushing to multiple remote repositories, making it especially useful for developers who need to maintain multiple remote repositories simultaneously.\"\"\"\nkeywords = [\"git\", \"helper\", \"remote\", \"tool\", \"repositories\"]\nrepository = \"https://github.com/crates-dev/gtl.git\"\ncategories = [\"data-structures\", \"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nserde = { version = \"1.0.219\", features = [\"derive\"] }\nserde_json = \"1.0.142\"\ntoml = \"0.9.4\"\nchrono = \"0.4\"", "file_size": 822, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\server-manager\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"server-manager\"\nversion = \"5.0.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"server-manager is a rust library for managing server processes. It encapsulates service startup, shutdown, and background daemon mode. Users can specify the PID file, log file paths, and other configurations through custom settings, while also passing in their own asynchronous server function for execution. The library supports both synchronous and asynchronous operations. On Unix and Windows platforms, it enables background daemon processes.\"\"\"\nkeywords = [\"manager\", \"processes\", \"libc\", \"linux\", \"unix\"]\nrepository = \"https://github.com/crates-dev/server-manager.git\"\ncategories = [\"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"**/*.pid\",\n    \"**/*.log\"\n]\n\n[dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1192, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-plugin-websocket\"\nversion = \"2.2.33\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A WebSocket plugin for the Hyperlane framework, providing robust WebSocket communication capabilities and integrating with hyperlane-broadcast for efficient message dissemination.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/hyperlane-plugin-websocket.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nhyperlane = \"7.8.0\"\nhyperlane-broadcast = \"0.7.5\"\n\n[profile.dev]\nincremental = true\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false", "file_size": 861, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"hyperlane-time\"\nversion = \"0.7.7\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A library for fetching the current time based on the system's locale settings.\"\"\"\nkeywords = [\"time\", \"hyperlane\", \"day\", \"format\", \"lang\"]\nrepository = \"https://github.com/crates-dev/hyperlane-time.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 742, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"recoverable-spawn\"\nversion = \"3.9.4\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A thread that supports automatic recovery from panics, allowing threads to restart after a panic. Useful for resilient and fault-tolerant concurrency in network and web programming.\"\"\"\nkeywords = [\"time\", \"hyperlane\", \"day\", \"format\", \"lang\"]\nrepository = \"https://github.com/crates-dev/recoverable-spawn.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nonce_cell = \"1.21.3\"\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 940, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"lombok-macros\"\nversion = \"1.13.11\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust procedural macro collection providing Lombok-like functionality. Automatically generates getters/setters with field-level visibility control, custom Debug implementations with field skipping, and Display trait implementations. Supports structs, enums, generics and lifetimes.\"\"\"\nkeywords = [\"proc-macro\", \"get-set\", \"macros\", \"lombok\", \"code-generation\"]\nrepository = \"https://github.com/crates-dev/lombok-macros.git\"\ncategories = [\"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"debug\"\n]\n\n[dependencies]\nproc-macro2 = \"1.0.95\"\nquote = \"1.0.40\"\nsyn = \"2.0.104\"\n\n[lib]\nproc-macro = true\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1053, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"recoverable-thread-pool\"\nversion = \"2.4.4\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A thread pool that supports automatic recovery from panics, allowing threads to restart after a panic. Useful for resilient and fault-tolerant concurrency in network and web programming.\"\"\"\nkeywords = [\"time\", \"hyperlane\", \"day\", \"format\", \"lang\"]\nrepository = \"https://github.com/crates-dev/recoverable-thread-pool.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dependencies]\nrecoverable-spawn = \"3.9.4\"\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 964, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"std-macro-extensions\"\nversion = \"0.26.5\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A collection of macro extensions for Rust's standard library data structures, simplifying the creation and manipulation of common collections such as HashMap, Vec, and more.\"\"\"\nkeywords = [\"standard\", \"macro\", \"extensions\", \"structures\", \"simplifying\"]\nrepository = \"https://github.com/crates-dev/std-macro-extensions\"\ncategories = [\"data-structures\", \"development-tools\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[dev-dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 934, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"tcp-request\"\nversion = \"2.3.2\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A Rust library for sending raw TCP requests, with features for handling responses, managing redirects, and working with compressed data over TCP connections.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/tcp-request.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 819, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\cfg.rs", "language": "rust", "content": "use crate::*;\nuse std::{\n    sync::Mutex,\n    thread::{JoinHandle, spawn},\n    time::Instant,\n};\n\n#[test]\nfn test_readme_text() {\n    let mut request_builder = RequestBuilder::new().host(\"127.0.0.1\").port(60000).build();\n    request_builder\n        .send(\"udp send\".as_bytes())\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n    let mut request_builder = RequestBuilder::new().host(\"127.0.0.1\").port(60000).build();\n    request_builder\n        .send(\"udp send\".as_bytes())\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n}\n\n#[test]\nfn test_readme_binary() {\n    let mut request_builder = RequestBuilder::new().host(\"127.0.0.1\").port(60000).build();\n    request_builder\n        .send(\"udp send\".as_bytes())\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.binary());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n}\n\n#[test]\nfn test_thread_request() {\n    let num_threads: i32 = 10;\n    let mut handles: Vec<JoinHandle<()>> = Vec::new();\n    let request_builder: Arc<Mutex<BoxRequestTrait>> = Arc::new(Mutex::new(\n        RequestBuilder::new()\n            .host(\"127.0.0.1\")\n            .port(60000)\n            .timeout(10)\n            .buffer(1_024_000)\n            .build(),\n    ));\n    for _ in 0..num_threads {\n        let request_builder: Arc<\n            Mutex<\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<dyn ResponseTrait<OutputText = String, OutputBinary = Vec<u8>>>,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            >,\n        > = Arc::clone(&request_builder);\n        let handle: JoinHandle<()> = spawn(move || {\n            let mut request_builder = request_builder.lock().unwrap();\n            let start_time: Instant = Instant::now();\n            match request_builder.send(\"test\".as_bytes()) {\n                Ok(response) => {\n                    let duration: std::time::Duration = start_time.elapsed();\n                    println!(\"{:?}\", duration);\n                    let response_text = response.text();\n                    println!(\"ResponseTrait => {}\", response_text);\n                }\n                Err(e) => {\n                    let duration: std::time::Duration = start_time.elapsed();\n                    println!(\"{:?}\", duration);\n                    println!(\"Error => {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}", "file_size": 2883, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"tcplane\"\nversion = \"5.0.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"tcplane is a lightweight and high-performance Rust TCP server library designed to simplify network service development. It supports TCP communication, data stream management, and connection handling, focusing on providing efficient low-level network connections and data transmission capabilities, making it ideal for building modern network services.\"\"\"\nkeywords = [\"http\", \"request\", \"response\", \"tcp\", \"redirect\"]\nrepository = \"https://github.com/crates-dev/tcplane.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"**/*.log\"\n]\n\n[dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 1101, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\udp-request\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"udp-request\"\nversion = \"0.3.3\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"\"\"A simple UDP request library for sending and receiving UDP packets, designed to handle network communication in Rust applications.\"\"\"\nkeywords = [\"udp\", \"net\", \"response\", \"request\", \"tool\"]\nrepository = \"https://github.com/crates-dev/udp-request.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\"\n]\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 787, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\udp\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"udp\"\nversion = \"2.0.0\"\nreadme = \"README.md\"\nedition = \"2024\"\nauthors = [\"root@ltpp.vip\"]\nlicense = \"MIT\"\ndescription = \"A lightweight and efficient Rust library for building UDP servers with request-response handling.\"\nkeywords = [\"udp\", \"request\", \"response\", \"server\", \"network\"]\nrepository = \"https://github.com/crates-dev/udp.git\"\ncategories = [\"network-programming\", \"web-programming\"]\nexclude = [\n    \"target\",\n    \"Cargo.lock\",\n    \"sh\",\n    \".github\",\n    \"logs\",\n    \"**/*.log\"\n]\n\n[dependencies]\ntokio = { version = \"1.47.1\", features = [\"full\"] }\n\n[profile.dev]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"\n\n[profile.release]\nincremental = false\nopt-level = 3\nlto = true\npanic = \"unwind\"\ndebug = false\ncodegen-units = 1\nstrip = \"debuginfo\"", "file_size": 836, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\response_binary\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `ResponseTrait` for `UdpResponseBinary`.\nimpl ResponseTrait for UdpResponseBinary {\n    type OutputText = UdpResponseText;\n    type OutputBinary = UdpResponseBinary;\n\n    /// Creates a `UdpResponseBinary` instance from a byte slice.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The byte slice containing the response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `UdpResponseBinary` instance.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized,\n    {\n        response.to_vec()\n    }\n\n    /// Returns the binary representation of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputBinary` - The binary data of the response.\n    fn binary(&self) -> Self::OutputBinary {\n        self.clone()\n    }\n\n    /// Converts the binary response to a text representation.\n    ///\n    /// # Returns\n    ///\n    /// - `UdpResponseText` - The text representation of the response, with invalid UTF-8 sequences replaced.\n    fn text(&self) -> UdpResponseText {\n        let data: String = String::from_utf8_lossy(&self).to_string();\n        data\n    }\n}", "file_size": 1134, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\common\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#type;\n\npub(crate) use r#const::*;\npub(crate) use r#type::*;", "file_size": 100, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\common\\const.rs", "language": "rust", "content": "/// An empty string slice.\n///\n/// Used as a default value for various string fields.\npub const EMPTY_STR: &str = \"\";\n\n/// The default port for web connections.\n///\n/// This is the standard port for HTTP.\npub const DEFAULT_WEB_PORT: usize = 80;\n\n/// The default buffer size for I/O operations.\n///\n/// Set to 512 KB.\npub const DEFAULT_BUFFER_SIZE: usize = 512_000;\n\n/// The default timeout value for network operations.\n///\n/// Set to the maximum value of `u64`.\npub const DEFAULT_TIMEOUT: u64 = u64::MAX;", "file_size": 505, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\lib.rs", "language": "rust", "content": "//! udp-request\n//!\n//! A simple UDP request library for sending and receiving UDP packets,\n//! designed to handle network communication in Rust applications.\n\n#[cfg(test)]\nmod cfg;\npub(crate) mod common;\npub(crate) mod request;\npub(crate) mod response;\n\npub use request::*;\npub use response::*;\n\npub(crate) use common::*;\n\npub(crate) use std::{\n    error::Error as StdError,\n    fmt::Debug,\n    fmt::{self, Display},\n    net::UdpSocket,\n    sync::{Arc, RwLock},\n    time::Duration,\n};", "file_size": 485, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\mod.rs", "language": "rust", "content": "pub(crate) mod config;\npub(crate) mod error;\npub(crate) mod request;\npub(crate) mod request_builder;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use error::r#enum::*;\npub use request_builder::r#struct::*;\npub use r#trait::*;\npub use r#type::*;\n\npub(crate) use config::r#struct::*;\npub(crate) use request::r#struct::*;", "file_size": 325, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// A trait for sending UDP requests.\n///\n/// This trait defines the core functionality for sending data over UDP.\n/// It requires the `Send` and `Debug` traits.\npub trait RequestTrait: Send + Debug {\n    /// The result type for the request operation.\n    ///\n    /// This associated type must be `Sized`.\n    type RequestResult: Sized;\n\n    /// Sends data through the UDP socket.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to be sent as a byte slice.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::RequestResult` - The result of the send operation, as defined by the implementor.\n    fn send(&mut self, data: &[u8]) -> Self::RequestResult;\n}", "file_size": 683, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\response_text\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `ResponseTrait` for `UdpResponseText`.\nimpl ResponseTrait for UdpResponseText {\n    type OutputText = UdpResponseText;\n    type OutputBinary = UdpResponseBinary;\n\n    /// Creates a `UdpResponseText` from a byte slice.\n    ///\n    /// This method first converts the byte slice to `UdpResponseBinary`\n    /// and then to `UdpResponseText`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The byte slice containing the response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text representation of the response.\n    fn from(response: &[u8]) -> Self::OutputText\n    where\n        Self: Sized,\n    {\n        <UdpResponseBinary as ResponseTrait>::from(response).text()\n    }\n\n    /// Returns the text representation of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text data of the response.\n    fn text(&self) -> Self::OutputText {\n        self.clone()\n    }\n\n    /// Converts the text response to its binary representation.\n    ///\n    /// # Returns\n    ///\n    /// - `UdpResponseBinary` - The binary representation of the response.\n    fn binary(&self) -> UdpResponseBinary {\n        self.clone().into_bytes()\n    }\n}", "file_size": 1221, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\response_binary\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#type;", "file_size": 45, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// A trait for handling UDP responses.\n///\n/// This trait defines the common operations for processing UDP responses,\n/// including converting them to text or binary formats.\npub trait ResponseTrait: Send + Debug {\n    /// The associated type for the text representation of the response.\n    type OutputText: Clone + Sized;\n    /// The associated type for the binary representation of the response.\n    type OutputBinary: Clone + Sized;\n\n    /// Converts the response to its text format.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text representation of the response.\n    fn text(&self) -> Self::OutputText;\n\n    /// Returns the binary representation of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputBinary` - The binary representation of the response.\n    fn binary(&self) -> Self::OutputBinary;\n\n    /// Creates a response instance from a byte slice.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The byte slice containing the response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new instance of the response type.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized;\n}", "file_size": 1180, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\response_binary\\type.rs", "language": "rust", "content": "/// A type alias for a binary UDP response.\npub type UdpResponseBinary = Vec<u8>;", "file_size": 81, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for the result of a UDP request.\npub type RequestResult = Result<BoxResponseTrait, RequestError>;\n\n/// A type alias for a boxed `RequestTrait` object.\npub type BoxRequestTrait = Box<dyn RequestTrait<RequestResult = RequestResult>>;", "file_size": 263, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Configuration for a UDP request.\n///\n/// This structure holds all the necessary configuration for making a UDP request,\n/// including network settings and timeout values.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Config {\n    /// The remote host address to which the UDP request will be sent.\n    pub(crate) host: String,\n    /// The remote port number to which the UDP request will be sent.\n    pub(crate) port: usize,\n    /// The request timeout in milliseconds.\n    pub(crate) timeout: u64,\n    /// The buffer size for receiving data from the remote host.\n    pub(crate) buffer_size: usize,\n}", "file_size": 622, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\error\\enum.rs", "language": "rust", "content": "/// An enumeration of possible errors that can occur during a UDP request.\n///\n/// This enum covers a range of potential issues, from socket creation to network timeouts.\n#[derive(Debug)]\npub enum RequestError {\n    /// An error indicating that the provided URL is invalid.\n    InvalidUrl,\n    /// An error indicating that the UDP socket could not be created.\n    UdpSocketCreateError,\n    /// An error indicating that the UDP socket could not connect to the specified address.\n    UdpSocketConnectError,\n    /// A general request error, used for unspecified issues.\n    RequestError,\n    /// An error indicating that reading from the connection failed.\n    ReadConnectionError,\n    /// An error indicating that setting the read timeout for the socket failed.\n    SetReadTimeoutError,\n    /// An error indicating that setting the write timeout for the socket failed.\n    SetWriteTimeoutError,\n    /// An error indicating that reading the response from the socket failed.\n    ReadResponseError,\n    /// An error indicating that sending the request failed, with a descriptive message.\n    SendResponseError(String),\n}", "file_size": 1115, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\common\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for an `Arc<RwLock<T>>`.\npub type ArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 96, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for the `Config` struct.\nimpl Default for Config {\n    /// Creates a default `Config` instance.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A `Config` instance with default values: an empty host, default web port, maximum timeout, and default buffer size.\n    fn default() -> Self {\n        Self {\n            timeout: DEFAULT_TIMEOUT,\n            buffer_size: DEFAULT_BUFFER_SIZE,\n            host: EMPTY_STR.to_owned(),\n            port: DEFAULT_WEB_PORT,\n        }\n    }\n}", "file_size": 534, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\response_text\\type.rs", "language": "rust", "content": "/// A type alias for a text UDP response.\npub type UdpResponseText = String;", "file_size": 76, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\mod.rs", "language": "rust", "content": "pub(crate) mod response_binary;\npub(crate) mod response_text;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use response_binary::r#type::*;\npub use response_text::r#type::*;\npub use r#trait::*;\npub use r#type::*;", "file_size": 218, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a boxed `ResponseTrait` object.\npub type BoxResponseTrait =\n    Box<dyn ResponseTrait<OutputText = UdpResponseText, OutputBinary = UdpResponseBinary>>;", "file_size": 187, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\request_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `RequestBuilder`.\nimpl Default for RequestBuilder {\n    /// Creates a default `RequestBuilder` instance.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `RequestBuilder` with default values.\n    fn default() -> Self {\n        Self {\n            udp_request: UdpRequest::default(),\n            builder: UdpRequest::default(),\n        }\n    }\n}\n\n/// Implementation of `RequestBuilder`.\nimpl RequestBuilder {\n    /// Creates a new `RequestBuilder`.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `RequestBuilder` instance.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the host for the UDP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The host address, which can be any type that implements `Into<String>`.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to the `RequestBuilder` for method chaining.\n    pub fn host<T>(&mut self, host: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        let _ = self.udp_request.config.write().and_then(|mut data| {\n            data.host = host.into();\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the port for the UDP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The port number.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to the `RequestBuilder` for method chaining.\n    pub fn port(&mut self, port: usize) -> &mut Self {\n        let _ = self.udp_request.config.write().and_then(|mut data| {\n            data.port = port;\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the buffer size for the UDP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The buffer size in bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to the `RequestBuilder` for method chaining.\n    pub fn buffer(&mut self, buffer_size: usize) -> &mut Self {\n        let _ = self.udp_request.config.write().and_then(|mut data| {\n            data.buffer_size = buffer_size;\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the timeout for the UDP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `u64` - The timeout in milliseconds.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to the `RequestBuilder` for method chaining.\n    pub fn timeout(&mut self, timeout: u64) -> &mut Self {\n        let _ = self.udp_request.config.write().and_then(|mut data| {\n            data.timeout = timeout;\n            Ok(())\n        });\n        self\n    }\n\n    /// Builds the `UdpRequest` and returns a boxed trait object.\n    ///\n    /// # Returns\n    ///\n    /// - `BoxRequestTrait` - A boxed `RequestTrait` object that can be used to send the request.\n    pub fn build(&mut self) -> BoxRequestTrait {\n        self.builder = self.udp_request.clone();\n        self.udp_request = UdpRequest::default();\n        Box::new(self.builder.clone())\n    }\n}", "file_size": 2985, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\request\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `UdpRequest`.\nimpl Default for UdpRequest {\n    /// Creates a default `UdpRequest` instance.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `UdpRequest` with default configuration and an empty response.\n    fn default() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(Config::default())),\n            response: Arc::new(RwLock::new(UdpResponseBinary::default())),\n        }\n    }\n}\n\n/// Implementation of `UdpRequest`.\nimpl UdpRequest {\n    /// Sends a UDP request and reads the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut UdpSocket` - The UDP socket to use for sending and receiving data.\n    /// - `&[u8]` - The data to send in the request.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - A `Result` containing the response as a boxed trait object or a `RequestError`.\n    fn send_request(\n        &mut self,\n        socket: &mut UdpSocket,\n        data: &[u8],\n    ) -> Result<BoxResponseTrait, RequestError> {\n        socket\n            .send(data)\n            .map_err(|err| RequestError::SendResponseError(err.to_string()))?;\n        self.read_response(socket)\n    }\n\n    /// Reads the response from the UDP socket.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut UdpSocket` - The UDP socket to read the response from.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - A `Result` containing the response as a boxed trait object or a `RequestError`.\n    fn read_response(&mut self, socket: &mut UdpSocket) -> Result<BoxResponseTrait, RequestError> {\n        let cfg_buffer_size: usize = self\n            .config\n            .read()\n            .map_or(DEFAULT_BUFFER_SIZE, |data| data.buffer_size);\n        let mut tmp_buf: Vec<u8> = vec![0u8; cfg_buffer_size];\n        let mut response_bytes: Vec<u8> = Vec::with_capacity(cfg_buffer_size);\n        if let Ok(n) = socket.recv(&mut tmp_buf) {\n            response_bytes.extend_from_slice(&tmp_buf[..n]);\n        }\n        self.response = Arc::new(RwLock::new(<UdpResponseBinary as ResponseTrait>::from(\n            &response_bytes,\n        )));\n        return Ok(Box::new(\n            self.response.read().map_or(Vec::new(), |data| data.clone()),\n        ));\n    }\n\n    /// Creates and configures a UDP socket for the connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The host address to connect to.\n    /// - `usize` - The port number to connect to.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<UdpSocket, RequestError>` - A `Result` containing the configured `UdpSocket` or a `RequestError`.\n    fn get_connection_socket(&self, host: String, port: usize) -> Result<UdpSocket, RequestError> {\n        let host_port: String = format!(\"{}:{}\", host.clone(), port);\n        let cfg_timeout: u64 = self\n            .config\n            .read()\n            .map_or(DEFAULT_TIMEOUT, |data| data.timeout);\n        let timeout: Duration = Duration::from_millis(cfg_timeout);\n        let socket: UdpSocket =\n            UdpSocket::bind(\"0.0.0.0:0\").map_err(|_| RequestError::UdpSocketCreateError)?;\n        socket\n            .connect(host_port)\n            .map_err(|_| RequestError::UdpSocketConnectError)?;\n        socket\n            .set_read_timeout(Some(timeout))\n            .map_err(|_| RequestError::SetReadTimeoutError)?;\n        socket\n            .set_write_timeout(Some(timeout))\n            .map_err(|_| RequestError::SetWriteTimeoutError)?;\n        let socket_result: Result<UdpSocket, RequestError> = Ok(socket);\n        socket_result\n    }\n}\n\n/// Implements the `RequestTrait` for `UdpRequest`.\nimpl RequestTrait for UdpRequest {\n    type RequestResult = RequestResult;\n\n    /// Sends a UDP request with the given data.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to send in the request.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::RequestResult` - The result of the request, containing either the response or an error.\n    fn send(&mut self, data: &[u8]) -> Self::RequestResult {\n        let cfg_timeout: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |data| data.clone());\n        let host: String = cfg_timeout.host.clone();\n        let port: usize = cfg_timeout.port.clone();\n        let mut socket: UdpSocket = self.get_connection_socket(host, port)?;\n        let res: Result<BoxResponseTrait, RequestError> = self.send_request(&mut socket, data);\n        res\n    }\n}", "file_size": 4516, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\common\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#type;\n\npub use r#const::*;\npub use r#type::*;", "file_size": 86, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\common\\const.rs", "language": "rust", "content": "use crate::*;\n\n/// Default socket address (0.0.0.0:0).\npub const DEFAULT_SOCKET_ADDR: SocketAddr =\n    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0));", "file_size": 167, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\config\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;", "file_size": 47, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\request\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a UDP request.\n///\n/// This struct holds the configuration and response for a UDP request.\n#[derive(Debug, Clone)]\npub struct UdpRequest {\n    /// The configuration for the UDP request, wrapped in an `Arc<RwLock<>>`.\n    pub(crate) config: ArcRwLock<Config>,\n    /// The response of the UDP request, wrapped in an `Arc<RwLock<>>`.\n    pub(crate) response: ArcRwLock<UdpResponseBinary>,\n}", "file_size": 417, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `StdError` trait for `RequestError`.\nimpl StdError for RequestError {}\n\n/// Implements the `Display` trait for `RequestError`.\nimpl Display for RequestError {\n    /// Formats the `RequestError` for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter<'_>` - The formatter to write the output to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - The result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::InvalidUrl => write!(f, \"Invalid url\"),\n            Self::UdpSocketCreateError => write!(f, \"Udp socket create error\"),\n            Self::UdpSocketConnectError => write!(f, \"Udp socket connection error\"),\n            Self::RequestError => write!(f, \"Request error\"),\n            Self::ReadConnectionError => write!(f, \"Connection read error\"),\n            Self::SetReadTimeoutError => write!(f, \"Failed to set read timeout\"),\n            Self::SetWriteTimeoutError => write!(f, \"Failed to set write timeout\"),\n            Self::ReadResponseError => write!(f, \"Read response error\"),\n            Self::SendResponseError(err) => write!(f, \"Send response error: {}\", err),\n        }\n    }\n}", "file_size": 1242, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\error\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;", "file_size": 45, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\common\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe reference-counted read-write lock wrapper.\npub type ArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 113, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Server configuration settings.\n///\n/// Contains all necessary parameters to configure a UDP server.\n#[derive(Clone)]\npub struct ServerConfig {\n    /// Server host address.\n    pub(crate) host: String,\n    /// Server port number.\n    pub(crate) port: usize,\n    /// Maximum buffer size for incoming packets.\n    pub(crate) buffer_size: usize,\n    /// Error handling callback function.\n    pub(crate) error_handle: ArcErrorHandle,\n}", "file_size": 449, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\config\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#const::*;\npub(crate) use r#struct::*;\npub(crate) use r#type::*;", "file_size": 169, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\context\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of InnerContext methods.\nimpl InnerContext {\n    /// Creates a new InnerContext with default values.\n    ///\n    /// # Returns\n    ///\n    /// - `InnerContext` - New context instance.\n    pub fn new() -> Self {\n        InnerContext {\n            socket: None,\n            request: Request::new(),\n            response: Response::default(),\n            socket_addr: None,\n            data: HashMap::default(),\n        }\n    }\n}\n\n/// Implementation of Context methods.\n///\n/// Provides thread-safe operations on the UDP context.\nimpl Context {\n    /// Creates a Context from an InnerContext.\n    ///\n    /// # Arguments\n    ///\n    /// - `InnerContext` - The inner context to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `Context` - New thread-safe context wrapper.\n    pub(crate) fn from_inner_context(ctx: InnerContext) -> Self {\n        Self(Arc::new(RwLock::new(ctx)))\n    }\n\n    /// Acquires a read lock on the inner context.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadContext` - Read guard for the inner context.\n    pub async fn get_read_lock(&self) -> RwLockReadContext {\n        self.0.read().await\n    }\n\n    /// Acquires a write lock on the inner context.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteContext` - Write guard for the inner context.\n    pub async fn get_write_lock(&self) -> RwLockWriteContext {\n        self.0.write().await\n    }\n\n    /// Gets a clone of the inner context.\n    ///\n    /// # Returns\n    ///\n    /// - `InnerContext` - Clone of the inner context.\n    pub async fn get(&self) -> InnerContext {\n        self.get_read_lock().await.clone()\n    }\n\n    /// Gets the request data from the context.\n    ///\n    /// # Returns\n    ///\n    /// - `Request` - Clone of the request data.\n    pub async fn get_request(&self) -> Request {\n        self.get().await.request.clone()\n    }\n\n    /// Gets the response data from the context.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - Clone of the response data.\n    pub async fn get_response(&self) -> Response {\n        self.get().await.response.clone()\n    }\n\n    /// Gets the UDP socket from the context.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionArcRwLockUdpSocket` - Clone of the socket if present.\n    pub async fn get_socket(&self) -> OptionArcRwLockUdpSocket {\n        self.get().await.socket.clone()\n    }\n\n    /// Gets the socket address from the context.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketAddr` - Clone of the socket address if present.\n    pub async fn get_socket_addr(&self) -> OptionSocketAddr {\n        self.get().await.socket_addr.clone()\n    }\n\n    /// Gets the socket address or default if not present.\n    ///\n    /// # Returns\n    ///\n    /// - `SocketAddr` - Socket address or default (0.0.0.0:0).\n    pub async fn get_socket_addr_or_default(&self) -> SocketAddr {\n        let socket_result: OptionArcRwLockUdpSocket = self.get_socket().await;\n        if socket_result.is_none() {\n            return DEFAULT_SOCKET_ADDR;\n        }\n        let socket_addr: SocketAddr = socket_result\n            .unwrap()\n            .get_read_lock()\n            .await\n            .peer_addr()\n            .unwrap_or(DEFAULT_SOCKET_ADDR);\n        socket_addr\n    }\n\n    /// Gets the socket address as a string.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<String>` - Socket address string if present.\n    pub async fn get_socket_addr_string(&self) -> Option<String> {\n        self.get_socket_addr().await.map(|data| data.to_string())\n    }\n\n    /// Gets the socket address or default as a string.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Socket address string or default.\n    pub async fn get_socket_addr_or_default_string(&self) -> String {\n        self.get_socket_addr_or_default().await.to_string()\n    }\n\n    /// Gets the socket host IP address.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketHost` - Host IP address if present.\n    pub async fn get_socket_host(&self) -> OptionSocketHost {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.ip())\n    }\n\n    /// Gets the socket port number.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketPort` - Port number if present.\n    pub async fn get_socket_port(&self) -> OptionSocketPort {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.port())\n    }\n\n    /// Sets the response data in the context.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Data convertible to ResponseData.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for chaining.\n    pub(super) async fn set_response<T: Into<ResponseData>>(&self, data: T) -> &Self {\n        self.get_write_lock().await.response = Response::from(data);\n        self\n    }\n\n    /// Sends response data through the socket.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Data convertible to ResponseData.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result of the send operation.\n    pub async fn send<T: Into<ResponseData>>(&self, data: T) -> ResponseResult {\n        let response_result: ResponseResult = self\n            .set_response(data)\n            .await\n            .get_response()\n            .await\n            .send(&self.get_socket().await, &self.get_socket_addr().await)\n            .await;\n        return response_result;\n    }\n\n    /// Sets a value in the context data storage.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Key for the value.\n    /// - `&T` - Value to store (must be Any + Send + Sync + Clone).\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for chaining.\n    pub async fn set_data_value<T: Any + Send + Sync + Clone>(\n        &self,\n        key: &str,\n        value: &T,\n    ) -> &Self {\n        self.get_write_lock()\n            .await\n            .data\n            .insert(key.to_owned(), Arc::new(value.clone()));\n        self\n    }\n\n    /// Gets a value from the context data storage.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Key for the value.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<T>` - Retrieved value if present and of correct type.\n    pub async fn get_data_value<T: Any + Send + Sync + Clone>(&self, key: &str) -> Option<T> {\n        self.get_read_lock()\n            .await\n            .data\n            .get(key)\n            .and_then(|arc| arc.downcast_ref::<T>())\n            .cloned()\n    }\n\n    /// Removes a value from the context data storage.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Key for the value to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for chaining.\n    pub async fn remove_data_value(&self, key: &str) -> &Self {\n        self.get_write_lock().await.data.remove(key);\n        self\n    }\n\n    /// Clears all data from the context data storage.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for chaining.\n    pub async fn clear_data(&self) -> &Self {\n        self.get_write_lock().await.data.clear();\n        self\n    }\n}", "file_size": 7098, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\context\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type RwLockWriteContext<'a> = RwLockWriteGuard<'a, InnerContext>;\npub type RwLockReadContext<'a> = RwLockReadGuard<'a, InnerContext>;\npub type ArcAnySendSync = Arc<dyn Any + Send + Sync>;\npub type HashMapArcAnySendSync = HashMap<String, ArcAnySendSync>;", "file_size": 272, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\context\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Inner context containing all UDP communication components.\n///\n/// Stores the socket, request/response data and additional context information.\n#[derive(Clone)]\npub struct InnerContext {\n    /// UDP socket wrapper with read-write lock.\n    pub(crate) socket: OptionArcRwLockUdpSocket,\n    /// Incoming request data.\n    pub(crate) request: Request,\n    /// Outgoing response data.\n    pub(crate) response: Response,\n    /// Remote socket address.\n    pub(crate) socket_addr: OptionSocketAddr,\n    /// Additional context data storage.\n    pub(crate) data: HashMapArcAnySendSync,\n}\n\n/// Thread-safe context wrapper for UDP operations.\n///\n/// Provides synchronized access to the inner context.\n#[derive(Clone)]\npub struct Context(\n    /// Thread-safe reference to inner context.\n    pub(super) ArcRwLock<InnerContext>,\n);", "file_size": 838, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\handler\\fn.rs", "language": "rust", "content": "/// Default error handler that prints errors to stderr.\n///\n/// # Arguments\n///\n/// - `String` - The error message to be printed.\n///\n/// # Returns\n///\n/// - `()` - This function does not return any value.\npub(crate) fn print_error_handle(error: String) {\n    eprintln!(\"{}\", error);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}", "file_size": 344, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\config\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe read-write locked server configuration.\npub type ArcRwLockServerConfig = ArcRwLock<ServerConfig>;", "file_size": 128, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for ServerConfig.\nimpl Default for ServerConfig {\n    /// Creates a default server configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerConfig` - New config with default values.\n    fn default() -> Self {\n        Self {\n            host: DEFAULT_HOST.to_owned(),\n            port: DEFAULT_LISTEN_PORT,\n            buffer_size: DEFAULT_BUFFER_SIZE,\n            error_handle: Arc::new(print_error_handle),\n        }\n    }\n}", "file_size": 476, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Response.\nimpl Default for Response {\n    /// Creates a default empty response.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - New response with empty data.\n    fn default() -> Self {\n        Self(Vec::new())\n    }\n}\n\n/// Implementation of Response methods.\n///\n/// Provides conversion and sending capabilities for UDP responses.\nimpl Response {\n    /// Creates a Response from convertible data.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Data convertible to ResponseData.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - New response containing the data.\n    pub fn from<T: Into<ResponseData>>(data: T) -> Self {\n        Self(data.into())\n    }\n\n    /// Gets the underlying response data.\n    ///\n    /// # Returns\n    ///\n    /// - `&ResponseData` - Reference to the response data.\n    pub fn get_response_data(&self) -> &ResponseData {\n        &self.0\n    }\n\n    /// Sends the response through the specified socket.\n    ///\n    /// # Arguments\n    ///\n    /// - `&OptionArcRwLockUdpSocket` - Optional socket reference.\n    /// - `&OptionSocketAddr` - Optional target address.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result of the send operation.\n    pub async fn send(\n        &self,\n        socket_opt: &OptionArcRwLockUdpSocket,\n        addr_opt: &OptionSocketAddr,\n    ) -> ResponseResult {\n        if let Some(socket_lock) = socket_opt {\n            let socket = socket_lock.get_read_lock().await;\n            if let Some(addr) = addr_opt {\n                let response_data: &ResponseData = self.get_response_data();\n                socket\n                    .send_to(response_data, &addr)\n                    .await\n                    .map_err(|e| response::error::ResponseError::ResponseError(e.to_string()))?;\n                return Ok(());\n            }\n        }\n        Err(response::error::ResponseError::Unknown)\n    }\n}", "file_size": 1934, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\handler\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Boxed handler function with Send bound.\npub(crate) type FuncBox = Box<dyn Func + Send + 'static>;\n\n/// Thread-safe vector of handler functions.\npub(crate) type ArcRwLockVecFuncBox = ArcRwLock<Vec<FuncBox>>;\n\n/// Thread-safe error handler with Send+Sync bounds.\npub(crate) type ArcErrorHandle = Arc<dyn ErrorHandle + Send + Sync + 'static>;", "file_size": 358, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\lib.rs", "language": "rust", "content": "//! udp\n//!\n//! A lightweight and efficient Rust library for\n//! building UDP servers with request-response handling.\n\npub(crate) mod cfg;\npub(crate) mod common;\npub(crate) mod config;\npub(crate) mod context;\npub(crate) mod handler;\npub(crate) mod request;\npub(crate) mod response;\npub(crate) mod server;\npub(crate) mod socket;\npub(crate) mod utils;\n\npub use config::*;\npub use context::*;\npub use request::*;\npub use response::*;\npub use server::*;\npub use socket::*;\npub use utils::*;\n\npub use tokio;\n\npub(crate) use common::*;\npub(crate) use handler::*;\n\npub(crate) use std::{\n    any::Any,\n    collections::HashMap,\n    error::Error as StdError,\n    fmt::{self, Display},\n    future::Future,\n    net::{IpAddr, Ipv4Addr, SocketAddr, SocketAddrV4},\n    panic::set_hook,\n    pin::Pin,\n    sync::Arc,\n};\npub(crate) use tokio::{\n    net::UdpSocket,\n    sync::{MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard},\n};", "file_size": 917, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp-request\\src\\request\\request_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// A builder for creating and configuring a `UdpRequest`.\n///\n/// This struct provides a fluent interface for building a `UdpRequest`.\n#[derive(Debug, Clone)]\npub struct RequestBuilder {\n    /// The `UdpRequest` instance being built.\n    pub(crate) udp_request: UdpRequest,\n    /// A mutable `UdpRequest` instance used for configuration.\n    pub(crate) builder: UdpRequest,\n}", "file_size": 391, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\mod.rs", "language": "rust", "content": "pub(crate) mod error;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use error::*;\npub use r#struct::*;\npub use r#type::*;", "file_size": 151, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\handler\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Trait for error handling functions.\npub trait ErrorHandle: Fn(String) {}\n\n/// Trait for async handler functions without Pin requirement.\n///\n/// # Generic Parameters\n///\n/// - `Fut` - Future type returned by the function.\npub trait AsyncFuncWithoutPin<Fut>: Fn(Context) -> Fut + Send + Sync + 'static\nwhere\n    Fut: Future<Output = ()> + Send + 'static,\n{\n}\n\n/// Trait for general handler functions.\n///\n/// Wraps async functions in Pin<Box<dyn Future>>.\npub trait Func:\n    Fn(Context) -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + Sync + 'static\n{\n}", "file_size": 587, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\handler\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\npub(crate) mod r#impl;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub(crate) use r#fn::*;\npub(crate) use r#trait::*;\npub(crate) use r#type::*;", "file_size": 168, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\handler\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl<T> ErrorHandle for T where T: Fn(String) {}\n\nimpl<F> Func for F where\n    F: Fn(Context) -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + Sync + 'static\n{\n}\n\nimpl<F, Fut> AsyncFuncWithoutPin<Fut> for F\nwhere\n    F: Fn(Context) -> Fut + Send + Sync + 'static,\n    Fut: Future<Output = ()> + Send + Sync + 'static,\n{\n}", "file_size": 350, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\request\\mod.rs", "language": "rust", "content": "pub(crate) mod r#type;\n\npub use r#type::*;", "file_size": 42, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\config\\const.rs", "language": "rust", "content": "pub const DEFAULT_INNER_PRINT: bool = true;\npub const DEFAULT_INNER_LOG: bool = true;\npub const COLON_SPACE: &str = \": \";\npub const COLON_SPACE_SYMBOL: &str = \":\";\npub const DEFAULT_HOST: &str = \"0.0.0.0\";\npub const DEFAULT_LISTEN_PORT: usize = 60000;\npub const DEFAULT_BUFFER_SIZE: usize = 512_000;", "file_size": 299, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// UDP response wrapper containing response data.\n///\n/// Provides thread-safe access to response content.\n#[derive(Clone, Debug)]\npub struct Response(\n    /// The underlying response data.\n    pub(super) ResponseData,\n);", "file_size": 237, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn test_server_basic_usage() {\n    use crate::*;\n\n    async fn test_func(ctx: Context) {\n        ctx.send(\"udp: 1\").await.unwrap();\n    }\n\n    fn error_handle(error: String) {\n        eprintln!(\"{}\", error);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn main() {\n        let mut server: Server = Server::new().await;\n        server.host(\"0.0.0.0\").await;\n        server.port(60000).await;\n        server.buffer(100_024_000).await;\n        server.error_handle(error_handle).await;\n        server.func(test_func).await;\n        server\n            .func(|ctx: Context| async move {\n                ctx.send(\"udp: 2\").await.unwrap();\n            })\n            .await;\n        server.run().await;\n    }\n\n    let _ = tokio::time::timeout(std::time::Duration::from_secs(60), main()).await;\n}", "file_size": 843, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\server\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Server.\nimpl Default for Server {\n    /// Creates a default server instance with empty configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Server` - New server instance with default values.\n    fn default() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(ServerConfig::default())),\n            func_list: Arc::new(RwLock::new(vec![])),\n        }\n    }\n}\n\n/// Implementation of Server methods.\n///\n/// Provides server configuration and runtime operations.\nimpl Server {\n    /// Creates a new server instance.\n    ///\n    /// # Returns\n    ///\n    /// - `Server` - New server instance.\n    pub async fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the server host address.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Host address convertible to String.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for chaining.\n    pub async fn host<T>(&mut self, host: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.config.write().await.host = host.into();\n        self\n    }\n\n    /// Sets the server port number.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - Port number.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for chaining.\n    pub async fn port(&mut self, port: usize) -> &mut Self {\n        self.config.write().await.port = port;\n        self\n    }\n\n    /// Sets the buffer size for incoming packets.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - Buffer size in bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for chaining.\n    pub async fn buffer(&mut self, buffer_size: usize) -> &mut Self {\n        self.config.write().await.buffer_size = buffer_size;\n        self\n    }\n\n    /// Sets the error handler function.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - Error handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for chaining.\n    pub async fn error_handle<F>(&self, func: F) -> &Self\n    where\n        F: ErrorHandle + Send + Sync + 'static,\n    {\n        self.config.write().await.error_handle = Arc::new(func);\n        self\n    }\n\n    /// Registers a handler function.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - Async handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for chaining.\n    pub async fn func<F, Fut>(&mut self, func: F) -> &mut Self\n    where\n        F: AsyncFuncWithoutPin<Fut>,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.func_list\n            .write()\n            .await\n            .push(Box::new(move |ctx| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Starts the server and begins processing requests.\n    pub async fn run(&mut self) {\n        self.init().await;\n        let config: ServerConfig = self.config.read().await.clone();\n        let host: String = config.host.clone();\n        let port: usize = config.port;\n        let addr: String = format!(\"{}{}{}\", host, COLON_SPACE_SYMBOL, port);\n        let socket: UdpSocket = UdpSocket::bind(&addr)\n            .await\n            .map_err(|e| ServerError::TcpBindError(e.to_string()))\n            .unwrap();\n        let socket_arc_lock: ArcRwLockUdpSocket = ArcRwLockUdpSocket::from_socket(socket);\n        loop {\n            let mut buf: Vec<u8> = vec![0u8; config.buffer_size];\n            let socket_arc_lock: ArcRwLockUdpSocket = socket_arc_lock.clone();\n            let socket_lock: RwLockReadGuardUdpSocket = socket_arc_lock.get_read_lock().await;\n            let (data_len, client_addr) = socket_lock.recv_from(&mut buf).await.unwrap();\n            let func_list_arc_lock: ArcRwLockVecFuncBox = Arc::clone(&self.func_list);\n            let socket_clone: ArcRwLockUdpSocket = socket_arc_lock.clone();\n            let handle_request = move || async move {\n                let request: Vec<u8> = buf[..data_len].to_vec();\n                let mut ctx: InnerContext = InnerContext::new();\n                ctx.socket = Some(socket_clone);\n                ctx.socket_addr = Some(client_addr);\n                ctx.request = request;\n                let ctx: Context = Context::from_inner_context(ctx);\n                for func in func_list_arc_lock.read().await.iter() {\n                    func(ctx.clone()).await;\n                }\n            };\n            tokio::spawn(handle_request());\n        }\n    }\n\n    /// Initializes the panic hook with error handler.\n    async fn init_panic_hook(&self) {\n        let error_handle: ArcErrorHandle = self.config.read().await.error_handle.clone();\n        set_hook(Box::new(move |err| {\n            let data: String = err.to_string();\n            error_handle(data);\n        }));\n    }\n\n    /// Initializes server components.\n    async fn init(&self) {\n        self.init_panic_hook().await;\n    }\n}", "file_size": 4911, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\socket\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe wrapper for UDP socket with read-write lock.\n///\n/// Provides synchronized access to UDP socket operations.\n#[derive(Clone, Debug)]\npub struct ArcRwLockUdpSocket(\n    /// Underlying UDP socket with read-write lock.\n    pub(super) ArcRwLock<UdpSocket>,\n);", "file_size": 285, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\socket\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of ArcRwLockUdpSocket methods.\n///\n/// Provides construction and access methods for thread-safe UDP socket.\nimpl ArcRwLockUdpSocket {\n    /// Creates a new instance from existing ArcRwLock<UdpSocket>.\n    ///\n    /// # Arguments\n    ///\n    /// - `ArcRwLock<UdpSocket>` - Existing socket with read-write lock.\n    ///\n    /// # Returns\n    ///\n    /// - `ArcRwLockUdpSocket` - New wrapper instance.\n    pub fn from(arc_rw_lock_socket: ArcRwLock<UdpSocket>) -> Self {\n        Self(arc_rw_lock_socket)\n    }\n\n    /// Creates a new instance from raw UdpSocket.\n    ///\n    /// # Arguments\n    ///\n    /// - `UdpSocket` - Raw UDP socket.\n    ///\n    /// # Returns\n    ///\n    /// - `ArcRwLockUdpSocket` - New wrapper instance.\n    pub fn from_socket(socket: UdpSocket) -> Self {\n        Self(Arc::new(RwLock::new(socket)))\n    }\n\n    /// Acquires a read lock on the socket.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadGuardUdpSocket` - Read guard for the socket.\n    pub async fn get_read_lock(&self) -> RwLockReadGuardUdpSocket {\n        self.0.read().await\n    }\n\n    /// Acquires a write lock on the socket.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteGuardUdpSocket` - Write guard for the socket.\n    pub async fn get_write_lock(&self) -> RwLockWriteGuardUdpSocket {\n        self.0.write().await\n    }\n}", "file_size": 1360, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\socket\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe reference-counted UDP socket.\npub type ArcUdpSocket = Arc<UdpSocket>;\n\n/// Optional thread-safe reference-counted UDP socket.\npub type OptionArcUdpSocket = Option<ArcUdpSocket>;\n\n/// Optional thread-safe read-write locked UDP socket.\npub type OptionArcRwLockUdpSocket = Option<ArcRwLockUdpSocket>;\n\n/// Read guard for read-write locked UDP socket.\npub type RwLockReadGuardUdpSocket<'a> = RwLockReadGuard<'a, UdpSocket>;\n\n/// Write guard for read-write locked UDP socket.\npub type RwLockWriteGuardUdpSocket<'a> = RwLockWriteGuard<'a, UdpSocket>;\n\n/// Thread-safe reference-counted write guard for UDP socket.\npub type ArcRwLockWriteGuardUdpSocket<'a> = Arc<RwLockWriteGuard<'a, UdpSocket>>;\n\n/// Optional thread-safe reference-counted write guard for UDP socket.\npub type OptionArcRwLockWriteGuardUdpSocket<'a> = Option<ArcRwLockWriteGuardUdpSocket<'a>>;\n\n/// Thread-safe reference-counted mutex guard for UDP socket.\npub type ArcMutexGuardUdpSocket<'a> = Arc<MutexGuard<'a, UdpSocket>>;\n\n/// Optional thread-safe reference-counted mutex guard for UDP socket.\npub type OptionArcMutexGuardUdpSocket<'a> = Option<ArcMutexGuardUdpSocket<'a>>;\n\n/// Optional socket host IP address.\npub type OptionSocketHost = Option<IpAddr>;\n\n/// Optional socket port number.\npub type OptionSocketPort = Option<u16>;\n\n/// Optional socket address (IP + port).\npub type OptionSocketAddr = Option<SocketAddr>;", "file_size": 1416, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Type alias for raw response data (byte vector).\npub type ResponseData = Vec<u8>;\n\n/// Result type for response operations.\npub type ResponseResult = Result<(), ResponseError>;", "file_size": 194, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\utils\\thread\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\n\npub use r#fn::*;", "file_size": 38, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\error\\enum.rs", "language": "rust", "content": "/// Error types for response operations.\n#[derive(Debug)]\npub enum ResponseError {\n    /// Represents a response error with message.\n    ResponseError(String),\n    /// Unknown response error.\n    Unknown,\n}", "file_size": 206, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\request\\type.rs", "language": "rust", "content": "pub type Request = Vec<u8>;", "file_size": 27, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\server\\error\\enum.rs", "language": "rust", "content": "/// Error types for server operations.\n#[derive(Debug)]\npub enum ServerError {\n    /// Represents a TCP bind error with message.\n    TcpBindError(String),\n    /// Unknown server error.\n    Unknown,\n}", "file_size": 199, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\server\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// UDP server instance containing configuration and handler functions.\n///\n/// Provides thread-safe access to server state and operations.\n#[derive(Clone)]\npub struct Server {\n    /// Server configuration settings.\n    pub(super) config: ArcRwLockServerConfig,\n    /// List of registered handler functions.\n    pub(super) func_list: ArcRwLockVecFuncBox,\n}", "file_size": 371, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\server\\mod.rs", "language": "rust", "content": "pub(crate) mod error;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub use error::*;\npub use r#struct::*;", "file_size": 109, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\error\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\n\npub use r#enum::*;", "file_size": 65, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\utils\\thread\\fn.rs", "language": "rust", "content": "/// Gets the number of available threads for parallel processing.\n///\n/// # Returns\n///\n/// - `usize` - Number of available threads, defaults to 1 if detection fails.\npub fn get_thread_count() -> usize {\n    match std::thread::available_parallelism() {\n        Ok(count) => count.get(),\n        Err(_) => 1,\n    }\n}", "file_size": 315, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\common\\const.rs", "language": "rust", "content": "use crate::*;\n\npub const DEFAULT_SOCKET_ADDR: SocketAddr =\n    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0));", "file_size": 127, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\lib.rs", "language": "rust", "content": "//! tcplane\n//!\n//! tcplane is a lightweight and high-performance Rust TCP server\n//! library designed to simplify network service development.\n//! It supports TCP communication, data stream management,\n//! and connection handling, focusing on providing efficient\n//! low-level network connections and data transmission capabilities,\n//! making it ideal for building modern network services.\n\npub(crate) mod cfg;\npub(crate) mod common;\npub(crate) mod config;\npub(crate) mod context;\npub(crate) mod handler;\npub(crate) mod middleware;\npub(crate) mod request;\npub(crate) mod response;\npub(crate) mod server;\npub(crate) mod stream;\npub(crate) mod utils;\n\npub use config::*;\npub use context::*;\npub use request::*;\npub use response::*;\npub use server::*;\npub use stream::*;\npub use utils::*;\n\npub use tokio;\n\npub(crate) use common::*;\npub(crate) use handler::*;\npub(crate) use middleware::*;\n\npub(crate) use std::{\n    any::Any,\n    collections::HashMap,\n    error::Error as StdError,\n    fmt::{self, Display},\n    future::Future,\n    net::{IpAddr, Ipv4Addr, SocketAddr, SocketAddrV4},\n    panic::set_hook,\n    pin::Pin,\n    sync::Arc,\n};\npub(crate) use tokio::{\n    io::{AsyncReadExt, AsyncWriteExt},\n    net::{TcpListener, TcpStream},\n    sync::{MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard},\n};", "file_size": 1302, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\utils\\list\\fn.rs", "language": "rust", "content": "/// Removes trailing zeros from a byte vector.\n///\n/// # Arguments\n///\n/// - `&mut Vec<u8>` - Mutable reference to the byte vector.\n///\n/// # Returns\n///\n/// - `Vec<u8>` - New vector with trailing zeros removed.\npub fn remove_trailing_zeros(data: &mut Vec<u8>) -> Vec<u8> {\n    if let Some(last_non_zero_pos) = data.iter().rposition(|&x| x != 0) {\n        data.truncate(last_non_zero_pos + 1);\n    } else {\n        data.clear();\n    }\n    data.clone()\n}", "file_size": 453, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements default values for `ServerConfig`.\n///\n/// Provides a default server configuration with default host address, port, buffer size, and error handling function.\nimpl Default for ServerConfig {\n    fn default() -> Self {\n        Self {\n            host: DEFAULT_HOST.to_owned(),\n            port: DEFAULT_LISTEN_PORT,\n            buffer_size: DEFAULT_BUFFER_SIZE,\n            error_handle: Arc::new(print_error_handle),\n        }\n    }\n}", "file_size": 463, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn test_server_basic_usage() {\n    use crate::*;\n\n    async fn test_func(ctx: Context) {\n        ctx.send(\"tcplane: 1\").await.unwrap();\n    }\n\n    fn error_handle(error: String) {\n        eprintln!(\"{}\", error);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn main() {\n        let mut server: Server = Server::new().await;\n        server.host(\"0.0.0.0\").await;\n        server.port(60000).await;\n        server.buffer(100_024_000).await;\n        server.error_handle(error_handle).await;\n        server.func(test_func).await;\n        server\n            .func(|ctx: Context| async move {\n                ctx.send(\"tcplane: 2\").await.unwrap();\n            })\n            .await;\n        server.run().await;\n    }\n\n    let _ = tokio::time::timeout(std::time::Duration::from_secs(60), main()).await;\n}", "file_size": 851, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\context\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Internal context structure.\n///\n/// Stores core data during request processing, including stream, request, response, and data.\n#[derive(Clone)]\npub struct InnerContext {\n    /// The stream object for network communication.\n    pub(crate) stream: OptionArcRwLockStream,\n    /// The request object containing client-sent request information.\n    pub(crate) request: Request,\n    /// The response object for building and sending responses to clients.\n    pub(crate) response: Response,\n    /// Data storage for holding arbitrary type data during request processing.\n    pub(crate) data: HashMapArcAnySendSync,\n}\n\n/// Context structure.\n///\n/// Wraps `InnerContext` providing thread-safe shared access.\n#[derive(Clone)]\npub struct Context(\n    /// The inner context, wrapped in an ArcRwLock for thread-safe access.\n    pub(super) ArcRwLock<InnerContext>,\n);", "file_size": 872, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\config\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `Arc<RwLock<ServerConfig>>`.\npub type ArcRwLockServerConfig = ArcRwLock<ServerConfig>;", "file_size": 122, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\middleware\\mod.rs", "language": "rust", "content": "pub(crate) mod r#type;\n\npub(crate) use r#type::*;", "file_size": 49, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\utils\\mod.rs", "language": "rust", "content": "pub(crate) mod list;\npub(crate) mod thread;\n\npub use list::*;\npub use thread::*;", "file_size": 80, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Server configuration parameters.\n///\n/// Contains all settings required for server initialization and operation.\n#[derive(Clone)]\npub struct ServerConfig {\n    /// The server host address.\n    pub(crate) host: String,\n    /// The server listening port.\n    pub(crate) port: usize,\n    /// Network buffer size in bytes.\n    pub(crate) buffer_size: usize,\n    /// Error handling function for server operations.\n    pub(crate) error_handle: ArcErrorHandle,\n}", "file_size": 474, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\response\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Standard error implementation for ResponseError.\nimpl StdError for ResponseError {}\n\n/// Display implementation for ResponseError.\nimpl Display for ResponseError {\n    /// Formats the error for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&fmt::Formatter` - Formatter for the output.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::ResponseError(data) => write!(f, \"Response Error{}{}\", COLON_SPACE, data),\n            Self::Unknown => write!(f, \"{}\", \"Unknown\"),\n        }\n    }\n}", "file_size": 657, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\udp\\src\\server\\error\\impl.rs", "language": "rust", "content": "use super::r#enum::ServerError;\nuse crate::*;\n\n/// Standard error implementation for ServerError.\nimpl StdError for ServerError {}\n\n/// Display implementation for ServerError.\nimpl Display for ServerError {\n    /// Formats the error for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&fmt::Formatter` - Formatter for the output.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::TcpBindError(data) => write!(f, \"Tcp bind error{}{}\", COLON_SPACE, data),\n            Self::Unknown => write!(f, \"Unknown\"),\n        }\n    }\n}", "file_size": 674, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\context\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Manages the internal state of the context.\nimpl InnerContext {\n    /// Creates a new `InnerContext` with default values.\n    ///\n    /// # Returns\n    ///\n    /// - `InnerContext` - A new instance of `InnerContext`.\n    pub fn new() -> Self {\n        InnerContext {\n            stream: None,\n            request: Request::new(),\n            response: Response::default(),\n            data: HashMap::default(),\n        }\n    }\n}\n\n/// Provides thread-safe access and manipulation of the context.\nimpl Context {\n    /// Creates a `Context` from an `InnerContext`.\n    ///\n    /// # Arguments\n    ///\n    /// - `InnerContext` - The inner context to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new `Context` instance.\n    pub(crate) fn from_inner_context(ctx: InnerContext) -> Self {\n        Self(Arc::new(RwLock::new(ctx)))\n    }\n\n    /// Gets a read lock for the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadContext` - A read guard for the inner context.\n    pub async fn get_read_lock(&self) -> RwLockReadContext {\n        self.0.read().await\n    }\n\n    /// Gets a write lock for the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteContext` - A write guard for the inner context.\n    pub async fn get_write_lock(&self) -> RwLockWriteContext {\n        self.0.write().await\n    }\n\n    /// Gets a clone of the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `InnerContext` - A cloned inner context.\n    pub async fn get(&self) -> InnerContext {\n        self.get_read_lock().await.clone()\n    }\n\n    /// Gets the stream from the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionArcRwLockStream` - The optional stream.\n    pub async fn get_stream(&self) -> OptionArcRwLockStream {\n        self.get().await.stream.clone()\n    }\n\n    /// Gets the request from the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `Request` - The request object.\n    pub async fn get_request(&self) -> Request {\n        self.get().await.request.clone()\n    }\n\n    /// Gets the response from the inner context.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - The response object.\n    pub async fn get_response(&self) -> Response {\n        self.get().await.response.clone()\n    }\n\n    /// Sets response data.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    /// - `data` - The data to set, which can be converted into `ResponseData`.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the `Context`.\n    pub(super) async fn set_response_data<T: Into<ResponseData>>(&self, data: T) -> &Self {\n        self.get_write_lock().await.response.set_response_data(data);\n        self\n    }\n\n    /// Gets the socket address from the stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketAddr` - The optional socket address.\n    pub async fn get_socket_addr(&self) -> OptionSocketAddr {\n        let stream_result: OptionArcRwLockStream = self.get_stream().await;\n        if stream_result.is_none() {\n            return None;\n        }\n        let socket_addr_opt: OptionSocketAddr = stream_result\n            .unwrap()\n            .get_read_lock()\n            .await\n            .peer_addr()\n            .ok();\n        socket_addr_opt\n    }\n\n    /// Gets the socket address or a default if none is available.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `SocketAddr` - The socket address or the default socket address.\n    pub async fn get_socket_addr_or_default(&self) -> SocketAddr {\n        let stream_result: OptionArcRwLockStream = self.get_stream().await;\n        if stream_result.is_none() {\n            return DEFAULT_SOCKET_ADDR;\n        }\n        let socket_addr: SocketAddr = stream_result\n            .unwrap()\n            .get_read_lock()\n            .await\n            .peer_addr()\n            .unwrap_or(DEFAULT_SOCKET_ADDR);\n        socket_addr\n    }\n\n    /// Gets the socket address as a string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<String>` - The socket address as a string, if available.\n    pub async fn get_socket_addr_string(&self) -> Option<String> {\n        self.get_socket_addr().await.map(|data| data.to_string())\n    }\n\n    /// Gets the socket address as a string, or a default string if none is available.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The socket address as a string, or the default socket address string.\n    pub async fn get_socket_addr_or_default_string(&self) -> String {\n        self.get_socket_addr_or_default().await.to_string()\n    }\n\n    /// Gets the socket host from the socket address.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketHost` - The optional socket host.\n    pub async fn get_socket_host(&self) -> OptionSocketHost {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.ip())\n    }\n\n    /// Gets the socket port from the socket address.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `OptionSocketPort` - The optional socket port.\n    pub async fn get_socket_port(&self) -> OptionSocketPort {\n        self.get_socket_addr()\n            .await\n            .map(|socket_addr: SocketAddr| socket_addr.port())\n    }\n\n    /// Sends data through the stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    /// - `data` - The data to send, which can be converted into `ResponseData`.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Ok(()) on success, or an error if the stream is not found or sending fails.\n    pub async fn send<T: Into<ResponseData>>(&self, data: T) -> ResponseResult {\n        if let Some(stream) = self.get_stream().await {\n            self.set_response_data(data)\n                .await\n                .get_response()\n                .await\n                .send(&stream)\n                .await?;\n            return Ok(());\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n\n    /// Closes the stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Ok(()) on success, or an error if the stream is not found or closing fails.\n    pub async fn close(&self) -> ResponseResult {\n        if let Some(stream) = self.get_stream().await {\n            self.get_response().await.close(&stream).await?;\n            return Ok(());\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n\n    /// Flushes the stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Ok(()) on success, or an error if the stream is not found or flushing fails.\n    pub async fn flush(&self) -> ResponseResult {\n        if let Some(stream) = self.get_stream().await {\n            self.get_response().await.flush(&stream).await?;\n            return Ok(());\n        }\n        Err(ResponseError::NotFoundStream)\n    }\n\n    /// Sets a data value in the context's data map.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    /// - `key` - The key for the data.\n    /// - `value` - The value to set, which must be cloneable and thread-safe.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the `Context`.\n    pub async fn set_data_value<T: Any + Send + Sync + Clone>(\n        &self,\n        key: &str,\n        value: &T,\n    ) -> &Self {\n        self.get_write_lock()\n            .await\n            .data\n            .insert(key.to_owned(), Arc::new(value.clone()));\n        self\n    }\n\n    /// Gets a data value from the context's data map.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    /// - `key` - The key for the data.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<T>` - The data value if found and successfully downcasted, otherwise `None`.\n    pub async fn get_data_value<T: Any + Send + Sync + Clone>(&self, key: &str) -> Option<T> {\n        self.get_read_lock()\n            .await\n            .data\n            .get(key)\n            .and_then(|arc| arc.downcast_ref::<T>())\n            .cloned()\n    }\n\n    /// Removes a data value from the context's data map.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    /// - `key` - The key of the data to remove.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the `Context`.\n    pub async fn remove_data_value(&self, key: &str) -> &Self {\n        self.get_write_lock().await.data.remove(key);\n        self\n    }\n\n    /// Clears all data from the context's data map.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - A reference to the `Context`.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - A reference to the `Context`.\n    pub async fn clear_data(&self) -> &Self {\n        self.get_write_lock().await.data.clear();\n        self\n    }\n}", "file_size": 9966, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\common\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `Arc<RwLock<T>>`.\n///\n/// This type alias simplifies the use of `Arc<RwLock<T>>`, providing thread-safe shared ownership with read-write access.\npub type ArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 220, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Binary data for HTTP response.\npub type ResponseData = Vec<u8>;\n\n/// Result type for response operations.\npub type ResponseResult = Result<(), ResponseError>;", "file_size": 177, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\config\\const.rs", "language": "rust", "content": "/// Default inner print setting.\npub const DEFAULT_INNER_PRINT: bool = true;\n\n/// Default inner log setting.\npub const DEFAULT_INNER_LOG: bool = true;\n\n/// Colon space separator string.\npub const COLON_SPACE: &str = \": \";\n\n/// Colon space symbol string.\npub const COLON_SPACE_SYMBOL: &str = \":\";\n\n/// Default host address.\npub const DEFAULT_HOST: &str = \"0.0.0.0\";\n\n/// Default listen port number.\npub const DEFAULT_LISTEN_PORT: usize = 60000;\n\n/// Request split marker string.\npub const SPLIT_REQUEST: &str = \"\\r\\n\\r\\n\";\n\n/// Request split marker bytes.\npub const SPLIT_REQUEST_BYTES: &[u8] = SPLIT_REQUEST.as_bytes();\n\n/// Default buffer size for requests.\npub const DEFAULT_BUFFER_SIZE: usize = 512_000;", "file_size": 706, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Server.\nimpl Default for Server {\n    fn default() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(ServerConfig::default())),\n            func_list: Arc::new(RwLock::new(vec![])),\n        }\n    }\n}\n\n/// Server implementation containing all server operations.\nimpl Server {\n    /// Creates a new Server instance with default configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Server` - New server instance with default settings.\n    pub async fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the server host address.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Type that can be converted into String (host address)\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for method chaining.\n    pub async fn host<T>(&mut self, host: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.config.write().await.host = host.into();\n        self\n    }\n\n    /// Sets the server listening port.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - Port number to listen on\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for method chaining.\n    pub async fn port(&mut self, port: usize) -> &mut Self {\n        self.config.write().await.port = port;\n        self\n    }\n\n    /// Sets the network buffer size for the server.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - Buffer size in bytes\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for method chaining.\n    pub async fn buffer(&mut self, buffer_size: usize) -> &mut Self {\n        self.config.write().await.buffer_size = buffer_size;\n        self\n    }\n\n    /// Sets the error handler for the server.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - Error handler function implementing ErrorHandle trait\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Immutable reference to self for method chaining.\n    pub async fn error_handle<F>(&self, func: F) -> &Self\n    where\n        F: ErrorHandle + Send + Sync + 'static,\n    {\n        self.config.write().await.error_handle = Arc::new(func);\n        self\n    }\n\n    /// Adds an async function to the server's handler list.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - Async function type implementing AsyncFuncWithoutPin trait\n    /// - `Fut` - Future type returned by the async function\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for method chaining.\n    pub async fn func<F, Fut>(&mut self, func: F) -> &mut Self\n    where\n        F: AsyncFuncWithoutPin<Fut>,\n        Fut: Future<Output = ()> + Send + Sync + 'static,\n    {\n        self.func_list\n            .write()\n            .await\n            .push(Box::new(move |ctx| Box::pin(func(ctx))));\n        self\n    }\n\n    /// Handles incoming TCP stream and reads data into buffer.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ServerConfig` - Server configuration reference\n    /// - `ArcRwLockStream` - Thread-safe TCP stream wrapper\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - Byte buffer containing the received data\n    pub(super) async fn handle_stream(\n        config: &ServerConfig,\n        stream_lock: ArcRwLockStream,\n    ) -> Vec<u8> {\n        let buffer_size: usize = config.buffer_size.max(SPLIT_REQUEST_BYTES.len());\n        let mut buffer: Vec<u8> = Vec::new();\n        let mut tmp_buf: Vec<u8> = vec![0u8; buffer_size];\n        let mut stream: RwLockWriteGuard<'_, TcpStream> = stream_lock.get_write_lock().await;\n        loop {\n            match stream.read(&mut tmp_buf).await {\n                Ok(n) => {\n                    let old_len: usize = tmp_buf.len();\n                    tmp_buf = remove_trailing_zeros(&mut tmp_buf);\n                    let new_len: usize = tmp_buf.len();\n                    if n == 0 {\n                        break;\n                    }\n                    if old_len != new_len || tmp_buf.ends_with(SPLIT_REQUEST_BYTES) {\n                        buffer.extend_from_slice(&tmp_buf[..n - SPLIT_REQUEST_BYTES.len()]);\n                        break;\n                    }\n                    buffer.extend_from_slice(&tmp_buf[..n]);\n                }\n                _ => {\n                    break;\n                }\n            }\n        }\n        buffer\n    }\n\n    /// Starts the server and begins accepting connections.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - Mutable reference to self for method chaining.\n    pub async fn run(&mut self) -> &mut Self {\n        self.init().await;\n        let config: ServerConfig = self.config.read().await.clone();\n        let host: String = config.host.to_owned();\n        let port: usize = config.port;\n        let addr: String = format!(\"{}{}{}\", host, COLON_SPACE_SYMBOL, port);\n        let tcp_listener: TcpListener = TcpListener::bind(&addr)\n            .await\n            .map_err(|e| ServerError::TcpBindError(e.to_string()))\n            .unwrap();\n        while let Ok((stream, _)) = tcp_listener.accept().await {\n            let stream_lock: ArcRwLockStream = ArcRwLockStream::from_stream(stream);\n            let func_list_arc_lock: ArcRwlockVecBoxFunc = Arc::clone(&self.func_list);\n            let config_arc_lock: ArcRwLockServerConfig = Arc::clone(&self.config);\n            let handle_request = move || async move {\n                let config: ServerConfig = config_arc_lock.read().await.clone();\n                let request: Vec<u8> = Self::handle_stream(&config, stream_lock.clone()).await;\n                let mut ctx: InnerContext = InnerContext::new();\n                ctx.stream = Some(stream_lock.clone());\n                ctx.request = request;\n                let ctx: Context = Context::from_inner_context(ctx);\n                for func in func_list_arc_lock.read().await.iter() {\n                    func(ctx.clone()).await;\n                }\n            };\n            tokio::spawn(handle_request());\n        }\n        self\n    }\n\n    /// Initializes the panic hook to use the configured error handler.\n    ///\n    /// # Returns\n    ///\n    /// - `()` - This function does not return any meaningful value.\n    async fn init_panic_hook(&self) {\n        let error_handle: ArcErrorHandle = self.config.read().await.error_handle.clone();\n        set_hook(Box::new(move |err| {\n            let data: String = err.to_string();\n            error_handle(data);\n        }));\n    }\n\n    /// Initializes server components including panic hook.\n    ///\n    /// # Returns\n    ///\n    /// - `()` - This function does not return any meaningful value.\n    async fn init(&self) {\n        self.init_panic_hook().await;\n    }\n}", "file_size": 6685, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\middleware\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type FuncListArcLock = AsyncArcRwLock<Vec<BoxFunc>>;", "file_size": 71, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\response\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Default for Response {\n    fn default() -> Self {\n        Self(Vec::new())\n    }\n}\n\nimpl Response {\n    pub fn from<T: Into<ResponseData>>(data: T) -> Self {\n        Self(data.into())\n    }\n\n    pub fn get_response_data(&self) -> &ResponseData {\n        &self.0\n    }\n\n    pub fn set_response_data<T: Into<ResponseData>>(&mut self, data: T) -> &mut Self {\n        self.0 = data.into();\n        self\n    }\n\n    pub async fn send(&mut self, stream_lock: &ArcRwLockStream) -> ResponseResult {\n        let mut stream: RwLockWriteGuardTcpStream = stream_lock.get_write_lock().await;\n        stream\n            .write_all(&self.get_response_data())\n            .await\n            .map_err(|err| ResponseError::ResponseError(err.to_string()))?;\n        Ok(())\n    }\n\n    pub async fn close(&mut self, stream_lock: &ArcRwLockStream) -> ResponseResult {\n        let mut stream: RwLockWriteGuardTcpStream = stream_lock.get_write_lock().await;\n        stream\n            .shutdown()\n            .await\n            .map_err(|err| ResponseError::CloseError(err.to_string()))?;\n        Ok(())\n    }\n\n    pub async fn flush(&mut self, stream_lock: &ArcRwLockStream) -> ResponseResult {\n        let mut stream: RwLockWriteGuardTcpStream = stream_lock.get_write_lock().await;\n        stream\n            .flush()\n            .await\n            .map_err(|err| ResponseError::ResponseError(err.to_string()))?;\n        Ok(())\n    }\n}", "file_size": 1432, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\handler\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Error handling trait.\n///\n/// Defines the interface for error handling functions.\npub trait ErrorHandle: Fn(String) {}\n\n/// Async function trait (without Pin).\n///\n/// Defines the interface for async functions handling context.\npub trait AsyncFuncWithoutPin<Fut>: Fn(Context) -> Fut + Send + Sync + 'static\nwhere\n    Fut: Future<Output = ()> + Send + 'static,\n{\n}\n\n/// Function trait.\n///\n/// Defines the interface for functions handling context.\npub trait Func:\n    Fn(Context) -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + Sync + 'static\n{\n}", "file_size": 579, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type AsyncArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 59, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\stream\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl ArcRwLockStream {\n    pub fn from(arc_rw_lock_stream: ArcRwLock<TcpStream>) -> Self {\n        Self(arc_rw_lock_stream)\n    }\n\n    pub fn from_stream(stream: TcpStream) -> Self {\n        Self(Arc::new(RwLock::new(stream)))\n    }\n\n    pub async fn get_read_lock(&self) -> RwLockReadGuardTcpStream {\n        self.0.read().await\n    }\n\n    pub async fn get_write_lock(&self) -> RwLockWriteGuardTcpStream {\n        self.0.write().await\n    }\n}", "file_size": 458, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\handler\\type.rs", "language": "rust", "content": "use crate::*;\n\npub(crate) type BoxFunc = Box<dyn Func + Send + 'static>;\npub(crate) type ArcRwlockVecBoxFunc = ArcRwLock<Vec<BoxFunc>>;\npub(crate) type ArcErrorHandle = Arc<dyn ErrorHandle + Send + Sync + 'static>;", "file_size": 214, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\handler\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of the `ErrorHandle` trait.\n///\n/// Provides error handling functionality for function types.\nimpl<T> ErrorHandle for T where T: Fn(String) {}\n\n/// Implementation of the `Func` trait.\n///\n/// Provides context handling functionality for function types.\nimpl<F> Func for F where\n    F: Fn(Context) -> Pin<Box<dyn Future<Output = ()> + Send + 'static>> + Send + Sync + 'static\n{\n}\n\n/// Implementation of the `AsyncFuncWithoutPin` trait.\n///\n/// Provides context handling functionality for async function types.\nimpl<F, Fut> AsyncFuncWithoutPin<Fut> for F\nwhere\n    F: Fn(Context) -> Fut + Send + Sync + 'static,\n    Fut: Future<Output = ()> + Send + 'static,\n{\n}", "file_size": 693, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\stream\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type ArcStream = Arc<TcpStream>;\npub type OptionArcTcpStream = Option<ArcStream>;\npub type OptionArcRwLockStream = Option<ArcRwLockStream>;\npub type RwLockReadGuardTcpStream<'a> = RwLockReadGuard<'a, TcpStream>;\npub type RwLockWriteGuardTcpStream<'a> = RwLockWriteGuard<'a, TcpStream>;\npub type ArcRwLockWriteGuardTcpStream<'a> = Arc<RwLockWriteGuard<'a, TcpStream>>;\npub type OptionArcRwLockWriteGuardTcpStream<'a> = Option<ArcRwLockWriteGuardTcpStream<'a>>;\npub type ArcMutexGuardTcpStream<'a> = Arc<MutexGuard<'a, TcpStream>>;\npub type OptionArcMutexGuardTcpStream<'a> = Option<ArcMutexGuardTcpStream<'a>>;\npub type OptionSocketHost = Option<IpAddr>;\npub type OptionSocketPort = Option<u16>;\npub type OptionSocketAddr = Option<SocketAddr>;", "file_size": 761, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\handler\\fn.rs", "language": "rust", "content": "/// Prints error message to stderr and flushes the buffer.\n///\n/// # Arguments\n///\n/// - `String` - Error message to be printed.\n///\n/// # Returns\n///\n/// - `()` - This function does not return any meaningful value.\npub(crate) fn print_error_handle(error: String) {\n    eprintln!(\"{}\", error);\n    let _ = std::io::Write::flush(&mut std::io::stderr());\n}", "file_size": 354, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl StdError for ServerError {}\n\nimpl Display for ServerError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::TcpBindError(data) => write!(f, \"Tcp bind error{}{}\", COLON_SPACE, data),\n            Self::Unknown => write!(f, \"Unknown\"),\n        }\n    }\n}", "file_size": 324, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\context\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A write guard for the `InnerContext`.\npub type RwLockWriteContext<'a> = RwLockWriteGuard<'a, InnerContext>;\n/// A read guard for the `InnerContext`.\npub type RwLockReadContext<'a> = RwLockReadGuard<'a, InnerContext>;\n/// An `Arc` pointer to a type that is `Any`, `Send`, and `Sync`.\npub type ArcAnySendSync = Arc<dyn Any + Send + Sync>;\n/// A hash map storing `ArcAnySendSync` values, keyed by `String`.\npub type HashMapArcAnySendSync = HashMap<String, ArcAnySendSync>;", "file_size": 488, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\response\\struct.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Clone, Debug)]\npub struct Response(pub(super) ResponseData);", "file_size": 84, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\stream\\struct.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Clone, Debug)]\npub struct ArcRwLockStream(pub(super) ArcRwLock<TcpStream>);", "file_size": 99, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Server structure.\n///\n/// Contains the core configuration and function list of the server.\n#[derive(Clone)]\npub struct Server {\n    /// Server configuration containing all necessary settings.\n    pub(crate) config: ArcRwLockServerConfig,\n    /// Function list containing all supported processing functions.\n    pub(crate) func_list: FuncListArcLock,\n}", "file_size": 370, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\common\\const.rs", "language": "rust", "content": "/// Empty string constant.\npub const EMPTY_STR: &str = \"\";\n\n/// Default web port number.\npub const DEFAULT_WEB_PORT: usize = 80;\n\n/// Request split marker string.\npub const SPLIT_REQUEST: &str = \"\\r\\n\\r\\n\";\n\n/// Request split marker bytes.\npub const SPLIT_REQUEST_BYTES: &[u8] = SPLIT_REQUEST.as_bytes();\n\n/// Default buffer size for requests.\npub const DEFAULT_BUFFER_SIZE: usize = 512_000;\n\n/// Default timeout value (maximum possible u64 value).\npub const DEFAULT_TIMEOUT: u64 = u64::MAX;", "file_size": 491, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\lib.rs", "language": "rust", "content": "//! tcp-request\n//!\n//! A Rust library for sending raw TCP requests, with features\n//! for handling responses, managing redirects, and working\n//! with compressed data over TCP connections.\n\n#[cfg(test)]\nmod cfg;\npub(crate) mod common;\npub(crate) mod request;\npub(crate) mod response;\n\npub use request::*;\npub use response::*;\n\npub(crate) use common::*;\n\npub(crate) use std::{\n    error::Error as StdError,\n    fmt::Debug,\n    fmt::{self, Display},\n    io::{Read, Write},\n    net::TcpStream,\n    sync::{Arc, RwLock},\n    time::Duration,\n};", "file_size": 539, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\error\\type.rs", "language": "rust", "content": "#[derive(Debug)]\npub enum ServerError {\n    TcpBindError(String),\n    Unknown,\n}", "file_size": 80, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\server\\error\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#type;\n\npub use r#type::*;", "file_size": 65, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\response\\error\\enum.rs", "language": "rust", "content": "#[derive(Debug)]\npub enum ResponseError {\n    ResponseError(String),\n    CloseError(String),\n    NotFoundStream,\n    Unknown,\n}", "file_size": 127, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Trait defining the interface for response operations.\npub trait ResponseTrait: Send + Debug {\n    type OutputText: Clone + Sized;\n    type OutputBinary: Clone + Sized;\n\n    /// Gets the response as text.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The response text content.\n    fn text(&self) -> Self::OutputText;\n\n    /// Gets the response as binary data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputBinary` - The response binary content.\n    fn binary(&self) -> Self::OutputBinary;\n\n    /// Creates a response from raw bytes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new response instance.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized;\n}", "file_size": 808, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\utils\\list\\fn.rs", "language": "rust", "content": "pub fn remove_trailing_zeros(data: &mut Vec<u8>) -> Vec<u8> {\n    if let Some(last_non_zero_pos) = data.iter().rposition(|&x| x != 0) {\n        data.truncate(last_non_zero_pos + 1);\n    } else {\n        data.clear();\n    }\n    data.clone()\n}", "file_size": 241, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\utils\\thread\\fn.rs", "language": "rust", "content": "pub fn get_thread_count() -> usize {\n    match std::thread::available_parallelism() {\n        Ok(count) => count.get(),\n        Err(_) => 1,\n    }\n}", "file_size": 148, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\cfg.rs", "language": "rust", "content": "use crate::*;\nuse std::{\n    sync::Mutex,\n    thread::{JoinHandle, spawn},\n    time::Instant,\n};\n\n#[test]\nfn test_readme_text() {\n    let mut request_builder = RequestBuilder::new().host(\"127.0.0.1\").port(60000).build();\n    request_builder\n        .send(\"tcp send\".as_bytes())\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n}\n\n#[test]\nfn test_readme_binary() {\n    let mut request_builder = RequestBuilder::new().host(\"127.0.0.1\").port(60000).build();\n    request_builder\n        .send(\"tcp send\".as_bytes())\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.binary());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {:?}\", e));\n}\n\n#[test]\nfn test_thread_request() {\n    let num_threads: i32 = 10;\n    let mut handles: Vec<JoinHandle<()>> = Vec::new();\n    let request_builder: Arc<Mutex<BoxRequestTrait>> = Arc::new(Mutex::new(\n        RequestBuilder::new()\n            .host(\"127.0.0.1\")\n            .port(60000)\n            .timeout(10)\n            .buffer(1_024_000)\n            .build(),\n    ));\n    for _ in 0..num_threads {\n        let request_builder: Arc<\n            Mutex<\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<dyn ResponseTrait<OutputText = String, OutputBinary = Vec<u8>>>,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            >,\n        > = Arc::clone(&request_builder);\n        let handle: JoinHandle<()> = spawn(move || {\n            let mut request_builder = request_builder.lock().unwrap();\n            let start_time: Instant = Instant::now();\n            match request_builder.send(\"tcp send\".as_bytes()) {\n                Ok(response) => {\n                    let duration: std::time::Duration = start_time.elapsed();\n                    println!(\"{:?}\", duration);\n                    let response_text = response.text();\n                    println!(\"ResponseTrait => {}\", response_text);\n                }\n                Err(e) => {\n                    let duration: std::time::Duration = start_time.elapsed();\n                    println!(\"{:?}\", duration);\n                    println!(\"Error => {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}", "file_size": 2555, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\response_text\\type.rs", "language": "rust", "content": "/// Text response type for TCP requests (String).\npub type TcpResponseText = String;", "file_size": 84, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Trait defining the interface for request operations.\npub trait RequestTrait: Send + Debug {\n    type RequestResult: Sized;\n\n    /// Sends data through the request.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to be sent.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::RequestResult` - The result of the send operation.\n    fn send(&mut self, data: &[u8]) -> Self::RequestResult;\n}", "file_size": 423, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\response_binary\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// ResponseTrait implementation for binary TCP responses.\nimpl ResponseTrait for TcpResponseBinary {\n    type OutputText = TcpResponseText;\n    type OutputBinary = TcpResponseBinary;\n\n    /// Creates a binary response from raw bytes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - A new binary response instance.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized,\n    {\n        response.to_vec()\n    }\n\n    /// Gets the binary representation of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputBinary` - The binary response data.\n    fn binary(&self) -> Self::OutputBinary {\n        self.clone()\n    }\n\n    /// Converts the binary response to text representation.\n    ///\n    /// # Returns\n    ///\n    /// - `TcpResponseText` - The text representation of the response.\n    fn text(&self) -> TcpResponseText {\n        let data: String = String::from_utf8_lossy(&self).to_string();\n        data\n    }\n}", "file_size": 1040, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\response_text\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// ResponseTrait implementation for text TCP responses.\nimpl ResponseTrait for TcpResponseText {\n    type OutputText = TcpResponseText;\n    type OutputBinary = TcpResponseBinary;\n\n    /// Creates a text response from raw bytes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw response data.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text response instance.\n    fn from(response: &[u8]) -> Self::OutputText\n    where\n        Self: Sized,\n    {\n        <TcpResponseBinary as ResponseTrait>::from(response).text()\n    }\n\n    /// Gets the text representation of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text response data.\n    fn text(&self) -> Self::OutputText {\n        self.clone()\n    }\n\n    /// Converts the text response to binary representation.\n    ///\n    /// # Returns\n    ///\n    /// - `TcpResponseBinary` - The binary representation of the response.\n    fn binary(&self) -> TcpResponseBinary {\n        self.clone().into_bytes()\n    }\n}", "file_size": 1044, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Result type for request operations containing either a boxed response trait or request error.\npub type RequestResult = Result<BoxResponseTrait, RequestError>;\n\n/// Boxed trait object for request operations.\npub type BoxRequestTrait = Box<dyn RequestTrait<RequestResult = RequestResult>>;", "file_size": 306, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Boxed trait object for response operations with text and binary output types.\npub type BoxResponseTrait =\n    Box<dyn ResponseTrait<OutputText = TcpResponseText, OutputBinary = TcpResponseBinary>>;", "file_size": 216, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcplane\\src\\response\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl StdError for ResponseError {}\n\nimpl Display for ResponseError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::ResponseError(data) => write!(f, \"Response Error{}{}\", COLON_SPACE, data),\n            Self::CloseError(data) => write!(f, \"Close Error{}{}\", COLON_SPACE, data),\n            Self::NotFoundStream => {\n                write!(f, \"Not found stream\")\n            }\n            Self::Unknown => write!(f, \"{}\", \"Unknown\"),\n        }\n    }\n}", "file_size": 520, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\error\\enum.rs", "language": "rust", "content": "/// Error types for request operations.\n#[derive(Debug)]\npub enum RequestError {\n    /// Invalid URL provided.\n    InvalidUrl,\n    /// Failed to establish TCP connection.\n    TcpStreamConnectError,\n    /// General request error.\n    RequestError,\n    /// Error reading from connection.\n    ReadConnectionError,\n    /// Failed to set read timeout.\n    SetReadTimeoutError,\n    /// Failed to set write timeout.\n    SetWriteTimeoutError,\n    /// Error reading response.\n    ReadResponseError,\n}", "file_size": 491, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Standard error implementation for RequestError.\nimpl StdError for RequestError {}\n\n/// Display formatting implementation for RequestError.\nimpl Display for RequestError {\n    /// Formats the error for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter<'_>` - The formatter to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - The result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::InvalidUrl => write!(f, \"Invalid URL\"),\n            Self::TcpStreamConnectError => write!(f, \"TCP Stream Connection Error\"),\n            Self::RequestError => write!(f, \"Request Error\"),\n            Self::ReadConnectionError => write!(f, \"Connection Read Error\"),\n            Self::SetReadTimeoutError => write!(f, \"Failed to Set Read Timeout\"),\n            Self::SetWriteTimeoutError => write!(f, \"Failed to Set Write Timeout\"),\n            Self::ReadResponseError => write!(f, \"Read response error\"),\n        }\n    }\n}", "file_size": 1052, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\arc\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_arc_num() {\n    use crate::*;\n    const NUM: i32 = 1;\n    let num_arc: Arc<i32> = arc!(NUM);\n    let num: i32 = num_arc.as_ref().clone();\n    assert_eq!(num_arc, Arc::new(NUM));\n    assert_eq!(num, NUM)\n}\n\n#[test]\nfn test_arc_str() {\n    use crate::*;\n    const STR: &str = \"test\";\n    let str_arc: Arc<&str> = arc!(STR);\n    let tmp_str: &str = str_arc.as_ref();\n    assert_eq!(str_arc, Arc::new(STR));\n    assert_eq!(tmp_str, STR)\n}\n\n#[test]\nfn test_arc_string() {\n    use crate::*;\n    const STR: &str = \"test\";\n    let string_from_str: String = STR.to_string();\n    let string_arc: Arc<String> = arc!(string_from_str.clone());\n    let string: String = string_arc.as_ref().clone();\n    assert_eq!(string_arc, Arc::new(string_from_str.clone()));\n    assert_eq!(string, string_from_str.clone())\n}", "file_size": 813, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\arc\\macro.rs", "language": "rust", "content": "/// Creates a new atomic reference counted pointer.\n///\n/// # Arguments\n///\n/// - `expr` - The value to be reference counted.\n///\n/// # Returns\n///\n/// - `Arc<T>` - A thread-safe reference-counting pointer.\n#[macro_export]\nmacro_rules! arc {\n    ($val:expr) => {\n        std::sync::Arc::new($val)\n    };\n}", "file_size": 305, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Configuration for TCP request settings.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) struct Config {\n    /// Target host address.\n    pub(crate) host: String,\n    /// Target port number.\n    pub(crate) port: usize,\n    /// Request timeout in seconds.\n    pub(crate) timeout: u64,\n    /// Buffer size for data transfer.\n    pub(crate) buffer_size: usize,\n}", "file_size": 379, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\boxed\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_box() {\n    use crate::*;\n    let boxed_value: Box<i32> = boxed!(10);\n    assert_eq!(boxed_value, Box::new(10));\n}", "file_size": 130, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\request\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of TCP request operations.\nimpl TcpRequest {\n    /// Sends data through the TCP connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut TcpStream` - The TCP stream to send data through.\n    /// - `&[u8]` - The data to be sent.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - The response or error.\n    fn send_request(\n        &mut self,\n        stream: &mut TcpStream,\n        data: &[u8],\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let mut data_vec: Vec<u8> = data.into();\n        data_vec.extend_from_slice(SPLIT_REQUEST_BYTES);\n        stream\n            .write_all(&data_vec)\n            .and_then(|_| stream.flush())\n            .unwrap();\n        self.read_response(stream)\n    }\n\n    /// Reads response from the TCP connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut TcpStream` - The TCP stream to read from.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - The response or error.\n    fn read_response(&mut self, stream: &mut TcpStream) -> Result<BoxResponseTrait, RequestError> {\n        let cfg_buffer_size: usize = self\n            .config\n            .read()\n            .map_or(DEFAULT_BUFFER_SIZE, |data| data.buffer_size);\n        let mut tmp_buf: Vec<u8> = vec![0u8; cfg_buffer_size];\n        let mut response_bytes: Vec<u8> = Vec::with_capacity(cfg_buffer_size);\n        while let Ok(n) = stream.read(&mut tmp_buf) {\n            if n == 0 {\n                break;\n            }\n            response_bytes.extend_from_slice(&tmp_buf[..n]);\n        }\n        self.response = Arc::new(RwLock::new(<TcpResponseBinary as ResponseTrait>::from(\n            &response_bytes,\n        )));\n        return Ok(Box::new(\n            self.response.read().map_or(Vec::new(), |data| data.clone()),\n        ));\n    }\n\n    /// Establishes a TCP connection to the specified host and port.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The host address to connect to.\n    /// - `usize` - The port number to connect to.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<TcpStream, RequestError>` - The TCP stream or error.\n    fn get_connection_stream(&self, host: String, port: usize) -> Result<TcpStream, RequestError> {\n        let host_port: (String, u16) = (host.clone(), port as u16);\n        let cfg_timeout: u64 = self\n            .config\n            .read()\n            .map_or(DEFAULT_TIMEOUT, |data| data.timeout);\n        let timeout: Duration = Duration::from_millis(cfg_timeout);\n        let tcp_stream: TcpStream = TcpStream::connect(host_port.clone())\n            .map_err(|_| RequestError::TcpStreamConnectError)?;\n        tcp_stream\n            .set_read_timeout(Some(timeout))\n            .map_err(|_| RequestError::SetReadTimeoutError)?;\n        tcp_stream\n            .set_write_timeout(Some(timeout))\n            .map_err(|_| RequestError::SetWriteTimeoutError)?;\n        let stream: Result<TcpStream, RequestError> = Ok(tcp_stream);\n        stream\n    }\n}\n\n/// RequestTrait implementation for TcpRequest.\nimpl RequestTrait for TcpRequest {\n    type RequestResult = RequestResult;\n\n    /// Sends data through the TCP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to be sent.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestResult` - The result of the send operation.\n    fn send(&mut self, data: &[u8]) -> Self::RequestResult {\n        let cfg_timeout: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |data| data.clone());\n        let host: String = cfg_timeout.host.clone();\n        let port: usize = cfg_timeout.port.clone();\n        let mut stream: TcpStream = self\n            .get_connection_stream(host, port)\n            .map_err(|_| RequestError::TcpStreamConnectError)?;\n        let res: Result<BoxResponseTrait, RequestError> = self.send_request(&mut stream, data);\n        res\n    }\n}\n\n/// Default implementation for TcpRequest.\nimpl Default for TcpRequest {\n    /// Creates a default TcpRequest instance.\n    ///\n    /// # Returns\n    ///\n    /// - `TcpRequest` - A new TcpRequest instance with default configuration.\n    fn default() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(Config::default())),\n            response: Arc::new(RwLock::new(TcpResponseBinary::default())),\n        }\n    }\n}", "file_size": 4381, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Config.\nimpl Default for Config {\n    /// Creates a default configuration instance.\n    ///\n    /// # Returns\n    ///\n    /// - `Config` - A new Config instance with default values.\n    fn default() -> Self {\n        Self {\n            timeout: DEFAULT_TIMEOUT,\n            buffer_size: DEFAULT_BUFFER_SIZE,\n            host: EMPTY_STR.to_owned(),\n            port: DEFAULT_WEB_PORT,\n        }\n    }\n}", "file_size": 447, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\binary_heap\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_empty_binary_heap() {\n    use crate::*;\n    let heap: BinaryHeap<i32> = binary_heap!();\n    assert!(heap.is_empty());\n}\n\n#[test]\nfn test_binary_heap_with_elements() {\n    use crate::*;\n    let heap: BinaryHeap<i32> = binary_heap!(5, 3, 8, 1);\n    let vec: Vec<i32> = heap.into_sorted_vec();\n    assert_eq!(vec, vec![1, 3, 5, 8]);\n}", "file_size": 347, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\lib.rs", "language": "rust", "content": "//! std-macro-extensions\n//!\n//! A collection of macro extensions for Rust's standard library\n//! data structures, simplifying the creation and manipulation of\n//! common collections such as HashMap, Vec, and more.\n\npub(crate) mod r#arc;\npub(crate) mod b_tree_map;\npub(crate) mod b_tree_set;\npub(crate) mod binary_heap;\npub(crate) mod boxed;\npub(crate) mod r#cell;\npub(crate) mod cin;\npub(crate) mod cout;\npub(crate) mod execute;\npub(crate) mod hash_map;\npub(crate) mod hash_set;\npub(crate) mod linked_list;\npub(crate) mod mutex;\npub(crate) mod path;\npub(crate) mod r#rc;\npub(crate) mod ref_cell;\npub(crate) mod rw_lock;\npub(crate) mod string;\npub(crate) mod vector;\npub(crate) mod vector_deque;\n\n#[cfg(test)]\npub(crate) use std::{\n    boxed::Box,\n    cell::{Cell, RefCell},\n    collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, LinkedList, VecDeque},\n    path::PathBuf,\n    rc::Rc,\n    sync::Arc,\n    sync::{Mutex, MutexGuard, RwLock},\n};", "file_size": 953, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\boxed\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#macro;", "file_size": 43, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\request_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for RequestBuilder.\nimpl Default for RequestBuilder {\n    /// Creates a default RequestBuilder instance.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBuilder` - A new RequestBuilder with default configuration.\n    fn default() -> Self {\n        Self {\n            tcp_request: TcpRequest::default(),\n            builder: TcpRequest::default(),\n        }\n    }\n}\n\n/// Implementation for RequestBuilder methods.\nimpl RequestBuilder {\n    /// Creates a new RequestBuilder instance.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBuilder` - A new RequestBuilder with default configuration.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the target host for the request.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The host address (any type that implements Into<String>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining.\n    pub fn host<T>(&mut self, host: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        let _ = self.tcp_request.config.write().and_then(|mut data| {\n            data.host = host.into();\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the target port for the request.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The port number.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining.\n    pub fn port(&mut self, port: usize) -> &mut Self {\n        let _ = self.tcp_request.config.write().and_then(|mut data| {\n            data.port = port;\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the buffer size for the request.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The buffer size in bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining.\n    pub fn buffer(&mut self, buffer_size: usize) -> &mut Self {\n        let _ = self.tcp_request.config.write().and_then(|mut data| {\n            data.buffer_size = buffer_size;\n            Ok(())\n        });\n        self\n    }\n\n    /// Sets the timeout for the request in milliseconds.\n    ///\n    /// # Arguments\n    ///\n    /// - `u64` - The timeout duration in milliseconds.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining.\n    pub fn timeout(&mut self, timeout: u64) -> &mut Self {\n        let _ = self.tcp_request.config.write().and_then(|mut data| {\n            data.timeout = timeout;\n            Ok(())\n        });\n        self\n    }\n\n    /// Builds and returns the configured request.\n    ///\n    /// # Returns\n    ///\n    /// - `BoxRequestTrait` - A boxed request trait object ready for use.\n    pub fn build(&mut self) -> BoxRequestTrait {\n        self.builder = self.tcp_request.clone();\n        self.tcp_request = TcpRequest::default();\n        Box::new(self.builder.clone())\n    }\n}", "file_size": 2870, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\request_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Builder for creating and configuring TCP requests.\n#[derive(Debug, Clone)]\npub struct RequestBuilder {\n    /// The TCP request being configured.\n    pub(crate) tcp_request: TcpRequest,\n    /// The built TCP request instance.\n    pub(crate) builder: TcpRequest,\n}", "file_size": 281, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cin\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_cin_parse() {\n    use crate::*;\n    let input: &str = \"1 2 3\";\n    let numbers: Vec<i32> = cin_parse!(input, Vec<i32>);\n    assert_eq!(numbers, vec![1, 2, 3]);\n    let single_input: &str = \"12\";\n    let number: i32 = cin_parse!(single_input, i32);\n    assert_eq!(number, 12);\n}", "file_size": 293, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\b_tree_map\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_b_tree_map() {\n    use crate::*;\n    let _empty_map: BTreeMap<i32, i32> = b_tree_map!();\n    let b_tree_map_a: BTreeMap<&str, &str> = b_tree_map!(\n        \"a\" => \"a\",\n        \"b\" => \"b\"\n    );\n    let b_tree_map_b: BTreeMap<&str, &str> = b_tree_map!(\n        \"a\" => \"a\",\n        \"b\" => \"b\"\n    );\n    assert_eq!(b_tree_map_a, b_tree_map_b);\n}", "file_size": 358, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\response\\response_binary\\type.rs", "language": "rust", "content": "/// Binary response type for TCP requests (Vec<u8>).\npub type TcpResponseBinary = Vec<u8>;", "file_size": 90, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\b_tree_set\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_b_tree_set() {\n    use crate::*;\n    let mut b_tree_set_b: BTreeSet<&str> = b_tree_set!();\n    let b_tree_set_a: BTreeSet<&str> = b_tree_set!(\"a\", \"b\");\n    b_tree_set_b.insert(\"a\");\n    b_tree_set_b.insert(\"b\");\n    assert_eq!(b_tree_set_a, b_tree_set_b);\n}", "file_size": 274, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\b_tree_set\\macro.rs", "language": "rust", "content": "/// Creates a new BTreeSet instance.\n///\n/// # Arguments\n///\n/// - `expr` - The elements to initialize the BTreeSet.\n///\n/// # Returns\n///\n/// - `BTreeSet<T>` - A new BTreeSet containing the given elements.\n#[macro_export]\nmacro_rules! b_tree_set {\n    () => {\n        std::collections::BTreeSet::new()\n    };\n    ($($elem:expr),*) => {{\n        let mut set = std::collections::BTreeSet::new();\n        $( set.insert($elem); )*\n        set\n    }};\n}", "file_size": 449, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\tcp-request\\src\\request\\request\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// TCP request structure containing configuration and response data.\n#[derive(Debug, Clone)]\npub struct TcpRequest {\n    /// Thread-safe configuration for the request.\n    pub(crate) config: ArcRwLock<Config>,\n    /// Thread-safe binary response storage.\n    pub(crate) response: ArcRwLock<TcpResponseBinary>,\n}", "file_size": 327, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\b_tree_map\\macro.rs", "language": "rust", "content": "/// Creates a new BTreeMap instance.\n///\n/// # Arguments\n///\n/// - `expr` - The key-value pairs to initialize the BTreeMap.\n///\n/// # Returns\n///\n/// - `BTreeMap<K, V>` - A new BTreeMap containing the given key-value pairs.\n#[macro_export]\nmacro_rules! b_tree_map {\n    () => {\n        std::collections::BTreeMap::new()\n    };\n    ($($key:expr => $val:expr),*) => {{\n        let mut map = std::collections::BTreeMap::new();\n        $( map.insert($key, $val); )*\n        map\n    }};\n}", "file_size": 483, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cell\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_cell() {\n    use crate::*;\n    let cell_value: Cell<i32> = cell!(5);\n    assert_eq!(cell_value.get(), 5);\n    cell_value.set(10);\n    assert_eq!(cell_value.get(), 10);\n}", "file_size": 185, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cell\\macro.rs", "language": "rust", "content": "/// Creates a new `Cell` instance.\n///\n/// This macro takes an expression and wraps it in a `Cell`, providing interior mutability for the given value.\n/// The `Cell` type allows for mutation of its contents even when shared among multiple references.\n#[macro_export]\nmacro_rules! cell {\n    ($val:expr) => {\n        std::cell::Cell::new($val)\n    };\n}", "file_size": 351, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\boxed\\macro.rs", "language": "rust", "content": "/// Creates a new `Box` instance.\n///\n/// This macro takes an expression and wraps it in a `Box`. It offers a more concise syntax compared to the standard `Box::new` function.\n#[macro_export]\nmacro_rules! boxed {\n    ($val:expr) => {\n        std::boxed::Box::new($val)\n    };\n}", "file_size": 277, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\hash_map\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_hash_map() {\n    use crate::*;\n    let my_map: HashMap<&str, i32> = hash_map!(\"a\" => 1, \"b\" => 2);\n    assert_eq!(my_map[\"a\"], 1);\n    assert_eq!(my_map[\"b\"], 2);\n}", "file_size": 180, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\binary_heap\\macro.rs", "language": "rust", "content": "/// Creates a new `BinaryHeap<T>`.\n///\n/// This macro provides two ways to initialize a `BinaryHeap`:\n///\n/// 1. **Empty Heap**:\n///    - Calling `binary_heap!()` creates an empty `BinaryHeap`.\n///\n/// 2. **With Elements**:\n///    - You can initialize a `BinaryHeap` with elements by providing a comma-separated list of values.\n///    - This will create a `BinaryHeap` containing the specified elements.\n#[macro_export]\nmacro_rules! binary_heap {\n    () => {\n        std::collections::BinaryHeap::new()\n    };\n    ($($elem:expr),*) => {\n        std::collections::BinaryHeap::from(vec![$($elem),*])\n    };\n}", "file_size": 606, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cout\\macro.rs", "language": "rust", "content": "/// Print formatted output to standard output using `print!`.\n///\n/// # Parameters\n/// - `args`: A format string followed by optional expressions, just like in `print!`.\n///\n/// # Returns\n/// - Nothing. This macro prints directly to standard output.\n#[macro_export]\nmacro_rules! cout {\n    ($($args: tt)*) => {\n        ::std::print!($($args)*);\n        let _ = ::std::io::Write::flush(&mut ::std::io::stdout());\n    };\n}\n\n/// Print a newline character and flush the standard output buffer.\n///\n/// # Parameters\n/// - (none): This macro takes no arguments.\n///\n/// # Returns\n/// - Nothing. This macro prints `\\n` and flushes the output.\n#[macro_export]\nmacro_rules! endl {\n    () => {{\n        $crate::cout!(\"\\n\");\n    }};\n}\n\n/// Print formatted output with a newline and flush the standard output buffer.\n///\n/// # Parameters\n/// - `args`: A format string followed by optional expressions, just like in `println!`.\n///\n/// # Returns\n/// - Nothing. This macro prints to standard output and flushes the buffer.\n#[macro_export]\nmacro_rules! cout_endl {\n    ($($args:tt)*) => {\n        $crate::cout!($($args)*);\n        $crate::endl!();\n    };\n}", "file_size": 1141, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\hash_set\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_hash_set() {\n    use crate::*;\n    let my_set: HashSet<i32> = hash_set!();\n    assert!(my_set.is_empty());\n    let my_set: HashSet<i32> = hash_set!(1, 2, 3);\n    assert!(my_set.contains(&1));\n    assert!(my_set.contains(&2));\n    assert!(my_set.contains(&3));\n}", "file_size": 277, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cin\\macro.rs", "language": "rust", "content": "/// Read a line from standard input as a `String`.\n///\n/// # Returns\n/// - A `String` containing the input line (including trailing newline if present).\n#[macro_export]\nmacro_rules! cin {\n    () => {{\n        use std::io::{self};\n        let mut input: String = String::new();\n        let _ = io::stdin().read_line(&mut input);\n        input\n    }};\n}\n\n/// Parse input string into a value or a vector of values of a specified type.\n///\n/// # Parameters\n/// - `input`: The input `&str` to be parsed.\n/// - `type`: The target type to parse into.\n///\n/// # Returns\n/// - A single value of the specified type if used in scalar mode.\n/// - A `Vec` of values if used in vector mode.\n#[macro_export]\nmacro_rules! cin_parse {\n    ($input: expr, Vec<$type: ty>) => {{\n        let mut res: Vec<$type> = Vec::<$type>::new();\n        for token in $input.trim().split_whitespace() {\n            if let Ok(num) = token.parse::<$type>() {\n                res.push(num);\n            }\n        }\n        res\n    }};\n    ($input: expr, $type: ty) => {{\n        let mut res: $type = Default::default();\n        if let Ok(parse_res) = $input.parse::<$type>() {\n            res = parse_res;\n        }\n        res\n    }};\n}", "file_size": 1201, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\cout\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_cout() {\n    use crate::*;\n    let name: &str = \"Alice\";\n    let age: i32 = 30;\n    cout!(\"Name: {}, Age: {}\\n\", name, age);\n}\n\n#[test]\nfn test_endl() {\n    use crate::*;\n    endl!();\n}\n\n#[test]\nfn test_cout_endl() {\n    use crate::*;\n    let name: &str = \"Alice\";\n    let age: i32 = 30;\n    cout_endl!(\"Name: {}, Age: {}\\n\", name, age);\n}", "file_size": 355, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\execute\\macro.rs", "language": "rust", "content": "/// Execute a synchronous function with given arguments.\n///\n/// # Parameters\n/// - `$path`: The function path.\n/// - `$array`: The primary argument.\n/// - `$arg`...: Optional trailing arguments.\n///\n/// # Returns\n/// - The result of the function call.\n#[macro_export]\nmacro_rules! execute {\n    ($path: path, $array: expr) => {\n        $path($array)\n    };\n    ($path: path, $array: expr, $($arg: expr), *) => {\n        $path($array, $($arg), *)\n    };\n}\n\n/// Execute an asynchronous function and return a future.\n///\n/// # Parameters\n/// - `$path`: The async function path.\n/// - `$array`: The primary argument.\n/// - `$arg`...: Optional trailing arguments.\n///\n/// # Returns\n/// - A future that must be `.await`ed.\n#[macro_export]\nmacro_rules! execute_async {\n    ($path: path, $array: expr) => {\n        async {\n            $path($array).await\n        }\n    };\n    ($path: path, $array: expr, $($arg: expr),*) => {\n        async {\n            $path($array, $($arg),*).await\n        }\n    };\n}", "file_size": 996, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\hash_set\\macro.rs", "language": "rust", "content": "/// Creates a new `HashSet` instance.\n///\n/// This macro can be used in two forms:\n/// - Without arguments, it creates an empty `HashSet`.\n/// - With elements, it creates a `HashSet` and inserts the provided elements into it.\n#[macro_export]\nmacro_rules! hash_set {\n    () => {\n        std::collections::HashSet::new()\n    };\n    ($($elem:expr),*) => {{\n        let mut set = std::collections::HashSet::new();\n        $( set.insert($elem); )*\n        set\n    }};\n}", "file_size": 464, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\linked_list\\macro.rs", "language": "rust", "content": "/// Creates a new `LinkedList` instance.\n///\n/// This macro can be used in two forms:\n/// - Without arguments, it creates an empty `LinkedList`.\n/// - With elements, it creates a `LinkedList` and appends the provided elements to the back of the list.\n#[macro_export]\nmacro_rules! linked_list {\n    () => {\n        std::collections::LinkedList::new()\n    };\n    ($($elem:expr),*) => {{\n        let mut list = std::collections::LinkedList::new();\n        $( list.push_back($elem); )*\n        list\n    }};\n}", "file_size": 504, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\mutex\\macro.rs", "language": "rust", "content": "/// Creates a new `Mutex` instance.\n///\n/// This macro takes a value and wraps it in a `Mutex`, providing thread-safe interior mutability.\n/// The `Mutex` type ensures mutual exclusion, allowing only one thread to access the value at a time.\n#[macro_export]\nmacro_rules! mutex {\n    ($val:expr) => {\n        std::sync::Mutex::new($val)\n    };\n}", "file_size": 344, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\linked_list\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_linked_test() {\n    use crate::*;\n    let my_list: LinkedList<i32> = linked_list!();\n    assert!(my_list.is_empty());\n    let my_list: LinkedList<i32> = linked_list!(1, 2, 3);\n    assert_eq!(my_list.len(), 3);\n    assert_eq!(my_list.front(), Some(&1));\n    assert_eq!(my_list.back(), Some(&3));\n}", "file_size": 312, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\mutex\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_mutex() {\n    use crate::*;\n    let my_mutex: Mutex<i32> = mutex!(5);\n    let lock: MutexGuard<'_, i32> = my_mutex.lock().unwrap();\n    assert_eq!(*lock, 5);\n}", "file_size": 175, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\execute\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_execute() {\n    use crate::*;\n    fn sum(data: &[i32]) -> i32 {\n        data.iter().sum()\n    }\n    fn add_offset(data: &[i32], offset: i32) -> i32 {\n        data.iter().map(|x| x + offset).sum()\n    }\n    let nums: Vec<i32> = vec![1, 2, 3];\n    let total: i32 = execute!(sum, &nums);\n    assert_eq!(total, 6);\n    let total_with_offset: i32 = execute!(add_offset, &nums, 10);\n    assert_eq!(total_with_offset, 36);\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_execute_async() {\n    use crate::*;\n    let data: Vec<i32> = vec![1, 2, 3];\n    async fn async_func(data: &[i32], offset: i32) -> i32 {\n        data.iter().map(|x| x + offset).sum()\n    }\n    let res: i32 = execute_async!(async_func, &data, 1).await;\n    assert_eq!(res, 9);\n}", "file_size": 753, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\hash_map\\macro.rs", "language": "rust", "content": "/// Creates a new hash map instance.\n///\n/// # Arguments\n///\n/// - `expr` - The key-value pairs to initialize the hash map.\n///\n/// # Returns\n///\n/// - `HashMap<K, V>` - A new hash map containing the given key-value pairs.\n#[macro_export]\nmacro_rules! hash_map {\n    () => {\n        std::collections::HashMap::new()\n    };\n    ($($key:expr => $val:expr),*) => {{\n        let mut map = std::collections::HashMap::new();\n        $( map.insert($key, $val); )*\n        map\n    }};\n}", "file_size": 478, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\ref_cell\\macro.rs", "language": "rust", "content": "/// Creates a new `RefCell` instance.\n///\n/// This macro takes a value and wraps it in a `RefCell`, providing interior mutability with dynamic borrow checking.\n/// `RefCell` allows mutable access to its contents even when it is shared among multiple references.\n#[macro_export]\nmacro_rules! refcell {\n    ($val:expr) => {\n        std::cell::RefCell::new($val)\n    };\n}", "file_size": 368, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\rc\\macro.rs", "language": "rust", "content": "/// Creates a new `Rc` (Reference Counted) instance.\n///\n/// This macro takes a value and wraps it in an `Rc`, providing shared ownership of the value.\n/// Multiple references to the same value can be made, and the value will be dropped when the last reference goes out of scope.\n#[macro_export]\nmacro_rules! rc {\n    ($val:expr) => {\n        std::rc::Rc::new($val)\n    };\n}", "file_size": 374, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\vector\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_vec() {\n    use crate::*;\n    let empty_vector: Vec<i32> = vector!();\n    assert!(empty_vector.is_empty());\n    let numbers: Vec<i32> = vector!(1, 2, 3);\n    assert_eq!(numbers.len(), 3);\n    assert_eq!(numbers[0], 1);\n    assert_eq!(numbers[1], 2);\n    assert_eq!(numbers[2], 3);\n}", "file_size": 298, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\ref_cell\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_ref_cell() {\n    use crate::*;\n\n    let my_refcell: RefCell<i32> = refcell!(5);\n    assert_eq!(*my_refcell.borrow(), 5);\n    my_refcell.replace(10);\n    assert_eq!(*my_refcell.borrow(), 10);\n}", "file_size": 208, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\path\\cfg.rs", "language": "rust", "content": "#[test]\nfn test() {\n    use crate::*;\n    let combined_path: String = join_paths!(\"/home/\", \"/user/\", \"/documents\", \"file.txt\");\n    assert_eq!(combined_path, \"/home/user/documents/file.txt\");\n    let another_path: String = join_paths!(\"C:/\", \"/Program Files\", \"App\");\n    assert_eq!(another_path, \"C:/Program Files/App\");\n}", "file_size": 324, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\string\\macro.rs", "language": "rust", "content": "/// Creates a new string instance.\n///\n/// # Arguments\n///\n/// - `expr` - The expression to initialize the string.\n///\n/// # Returns\n///\n/// - `String` - A new string containing the given value.\n#[macro_export]\nmacro_rules! string {\n    () => {\n        std::string::String::new()\n    };\n    ($s:expr) => {\n        std::string::String::from($s)\n    };\n}", "file_size": 352, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\vector_deque\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_vector_deque() {\n    use crate::*;\n    let empty_deque: VecDeque<i32> = vector_deque!();\n    assert!(empty_deque.is_empty());\n    let numbers: VecDeque<i32> = vector_deque!(1, 2, 3);\n    assert_eq!(numbers.len(), 3);\n    assert_eq!(numbers[0], 1);\n    assert_eq!(numbers[1], 2);\n    assert_eq!(numbers[2], 3);\n}", "file_size": 327, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\vector_deque\\macro.rs", "language": "rust", "content": "/// Creates a new `VecDeque` instance.\n///\n/// This macro can be used in two forms:\n/// - Without arguments, it creates an empty `VecDeque`.\n/// - With elements, it creates a `VecDeque` initialized with the provided elements.\n#[macro_export]\nmacro_rules! vector_deque {\n    () => {\n        std::collections::VecDeque::new()\n    };\n    ($($elem:expr),*) => {\n        std::collections::VecDeque::from([$($elem),*])\n    };\n}", "file_size": 421, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\cfg.rs", "language": "rust", "content": "#[test]\nfn test() {\n    use crate::*;\n    use std::{thread::sleep, time::Duration};\n    let thread_pool: ThreadPool = ThreadPool::new(1);\n    let first_res: SendResult = thread_pool.execute(|| {\n        println!(\"first\");\n    });\n    println!(\"{:?}\", first_res);\n    let panic_res: SendResult = thread_pool.execute_with_catch(\n        || {\n            panic!(\"[panic]\");\n        },\n        |err| {\n            println!(\"Catch panic {}\", err);\n        },\n    );\n    println!(\"{:?}\", panic_res);\n    let second_res: SendResult = thread_pool.execute_with_catch_finally(\n        || {\n            panic!(\"[panic]\");\n        },\n        |_err| {\n            panic!(\"[panic]\");\n        },\n        || {\n            println!(\"finally\");\n        },\n    );\n    println!(\"{:?}\", second_res);\n    sleep(Duration::from_secs(10));\n}\n\n#[tokio::test(flavor = \"multi_thread\")]\nasync fn async_test() {\n    use crate::*;\n    use std::{thread::sleep, time::Duration};\n    let thread_pool: ThreadPool = ThreadPool::new(1);\n    let first_res: SendResult = thread_pool.async_execute(|| async {\n        println!(\"first\");\n    });\n    println!(\"{:?}\", first_res);\n    let panic_res: SendResult = thread_pool.async_execute_with_catch(\n        || async {\n            panic!(\"[panic]\");\n        },\n        |err| async move {\n            println!(\"Catch panic {}\", err);\n        },\n    );\n    println!(\"{:?}\", panic_res);\n    let second_res: SendResult = thread_pool.async_execute_with_catch_finally(\n        || async {\n            panic!(\"[panic]\");\n        },\n        |_err| async {\n            panic!(\"[panic]\");\n        },\n        || async {\n            println!(\"finally\");\n        },\n    );\n    println!(\"{:?}\", second_res);\n    sleep(Duration::from_secs(10));\n}", "file_size": 1737, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\rw_lock\\macro.rs", "language": "rust", "content": "/// Creates a new `RwLock` instance.\n///\n/// This macro takes a value and wraps it in an `RwLock`, providing thread-safe access with multiple readers or a single writer.\n/// `RwLock` allows multiple immutable borrows or one mutable borrow at a time, enforcing read-write access at the runtime level.\n#[macro_export]\nmacro_rules! rw_lock {\n    ($val:expr) => {\n        std::sync::RwLock::new($val)\n    };\n}", "file_size": 405, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\rc\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_rc() {\n    use crate::*;\n    let my_rc: Rc<i32> = rc!(5);\n    assert_eq!(*my_rc, 5);\n}", "file_size": 102, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\string\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_string() {\n    use crate::*;\n    let empty_string: String = string!();\n    assert!(empty_string.is_empty());\n    let hello_string: String = string!(\"Hello\");\n    assert_eq!(hello_string, \"Hello\");\n}", "file_size": 214, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\path\\macro.rs", "language": "rust", "content": "/// Combines multiple paths into a single valid path, handling overlapping slashes.\n///\n/// - Removes trailing slashes from the base path.\n/// - Removes leading slashes from subsequent paths to avoid duplication.\n/// - Supports multiple path segments for flexible usage.\n///\n/// # Parameters\n/// - `base`: The base path as a string slice. It serves as the starting point for the combined path.\n/// - `sub_path`: One or more subsequent paths as string slices. These are appended to the base path in order.\n///\n/// # Returns\n/// - `String`: The resulting combined path as a `String`, with platform-specific separators and cleaned of redundant slashes.\n#[macro_export]\nmacro_rules! join_paths {\n    ($base:expr, $($sub_path:expr),+) => {{\n        let mut path = PathBuf::from($base.trim_end_matches(['/', '\\\\'].as_ref()));\n        if cfg!(target_os = \"windows\") {\n            if path.is_dir() && path.to_string_lossy().ends_with(\":\") {\n                path.push(\"/\");\n            }\n        }\n        $(\n            let clean_sub_path = $sub_path.trim_start_matches(['/', '\\\\'].as_ref());\n            path.push(clean_sub_path);\n        )+\n        path.to_string_lossy().replace(\"\\\\\", \"/\")\n    }};\n}", "file_size": 1194, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\manager\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;", "file_size": 94, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\manager\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default implementation for `ServerManager`.\nimpl Default for ServerManager {\n    /// Creates a default `ServerManager` instance with empty hooks and no PID file configured.\n    fn default() -> Self {\n        let empty_hook: ServerManagerHook = Arc::new(|| Box::pin(async {}));\n        Self {\n            pid_file: Default::default(),\n            stop_hook: empty_hook.clone(),\n            server_hook: empty_hook.clone(),\n            start_hook: empty_hook,\n        }\n    }\n}\n\n/// Implementation of server management operations.\n///\n/// Provides methods for starting, stopping and managing server processes.\nimpl ServerManager {\n    /// Creates a new `ServerManager` instance.\n    ///\n    /// This is a convenience method that calls `ServerManager::default()`.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the path to the PID file.\n    ///\n    /// # Arguments\n    ///\n    /// - `pid_file` - A string or any type that can be converted to a string representing the PID file path.\n    pub fn set_pid_file<P: ToString>(&mut self, pid_file: P) -> &mut Self {\n        self.pid_file = pid_file.to_string();\n        self\n    }\n\n    /// Sets the asynchronous function to be called before the server starts.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - An asynchronous function or closure to be executed.\n    pub fn set_start_hook<F, Fut>(&mut self, func: F) -> &mut Self\n    where\n        F: Fn() -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.start_hook = Arc::new(move || Box::pin(func()));\n        self\n    }\n\n    /// Sets the main server function to be executed.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The primary asynchronous function or closure for the server's logic.\n    pub fn set_server_hook<F, Fut>(&mut self, func: F) -> &mut Self\n    where\n        F: Fn() -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.server_hook = Arc::new(move || Box::pin(func()));\n        self\n    }\n\n    /// Sets the asynchronous function to be called before the server stops.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - An asynchronous function or closure to be executed for cleanup.\n    pub fn set_stop_hook<F, Fut>(&mut self, func: F) -> &mut Self\n    where\n        F: Fn() -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.stop_hook = Arc::new(move || Box::pin(func()));\n        self\n    }\n\n    /// Gets the configured PID file path.\n    pub fn get_pid_file(&self) -> &str {\n        &self.pid_file\n    }\n\n    /// Gets a reference to the start hook.\n    pub fn get_start_hook(&self) -> &ServerManagerHook {\n        &self.start_hook\n    }\n\n    /// Gets a reference to the server hook.\n    pub fn get_server_hook(&self) -> &ServerManagerHook {\n        &self.server_hook\n    }\n\n    /// Gets a reference to the stop hook.\n    pub fn get_stop_hook(&self) -> &ServerManagerHook {\n        &self.stop_hook\n    }\n\n    /// Starts the server in foreground mode.\n    ///\n    /// Writes the current process ID to the PID file and executes the server function.\n    pub async fn start(&self) {\n        (self.start_hook)().await;\n        if let Err(e) = self.write_pid_file() {\n            eprintln!(\"Failed to write pid file: {}\", e);\n            return;\n        }\n        (self.server_hook)().await;\n    }\n\n    /// Stops the running server process.\n    ///\n    /// Reads PID from file and terminates the process.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    pub async fn stop(&self) -> ServerManagerResult {\n        (self.stop_hook)().await;\n        let pid: i32 = self.read_pid_file()?;\n        self.kill_process(pid)\n    }\n\n    /// Starts the server in daemon (background) mode on Unix platforms.\n    #[cfg(not(windows))]\n    pub async fn start_daemon(&self) -> ServerManagerResult {\n        (self.start_hook)().await;\n        if std::env::var(RUNNING_AS_DAEMON).is_ok() {\n            self.write_pid_file()?;\n            let rt: Runtime = Runtime::new()?;\n            rt.block_on(async {\n                (self.server_hook)().await;\n            });\n            return Ok(());\n        }\n        let exe_path: PathBuf = std::env::current_exe()?;\n        let mut cmd: Command = Command::new(exe_path);\n        cmd.env(RUNNING_AS_DAEMON, RUNNING_AS_DAEMON_VALUE)\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .stdin(Stdio::null());\n        cmd.spawn()\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;\n        Ok(())\n    }\n\n    /// Starts the server in daemon (background) mode on Windows platforms.\n    #[cfg(windows)]\n    pub async fn start_daemon(&self) -> ServerManagerResult {\n        (self.start_hook)().await;\n        use std::os::windows::process::CommandExt;\n        if std::env::var(RUNNING_AS_DAEMON).is_ok() {\n            self.write_pid_file()?;\n            let rt: Runtime = Runtime::new()?;\n            rt.block_on(async {\n                (self.server_hook)().await;\n            });\n            return Ok(());\n        }\n        let exe_path: PathBuf = std::env::current_exe()?;\n        let mut cmd: Command = Command::new(exe_path);\n        cmd.env(RUNNING_AS_DAEMON, RUNNING_AS_DAEMON_VALUE)\n            .stdout(Stdio::null())\n            .stderr(Stdio::null())\n            .stdin(Stdio::null())\n            .creation_flags(0x00000008);\n        cmd.spawn()\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;\n        Ok(())\n    }\n\n    /// Reads process ID from the PID file.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<i32, Box<dyn std::error::Error>>` - Process ID if successful.\n    fn read_pid_file(&self) -> Result<i32, Box<dyn std::error::Error>> {\n        let pid_str: String = fs::read_to_string(&self.pid_file)?;\n        let pid: i32 = pid_str.trim().parse::<i32>()?;\n        Ok(pid)\n    }\n\n    /// Writes current process ID to the PID file.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    fn write_pid_file(&self) -> ServerManagerResult {\n        if let Some(parent) = Path::new(&self.pid_file).parent() {\n            fs::create_dir_all(parent)?;\n        }\n        let pid: u32 = id();\n        fs::write(&self.pid_file, pid.to_string())?;\n        Ok(())\n    }\n\n    /// Kills process by PID on Unix platforms.\n    ///\n    /// # Arguments\n    ///\n    /// - `pid` - The ID of the process to terminate.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    #[cfg(not(windows))]\n    fn kill_process(&self, pid: i32) -> ServerManagerResult {\n        let result: Result<Output, std::io::Error> = Command::new(\"kill\")\n            .arg(\"-TERM\")\n            .arg(pid.to_string())\n            .output();\n        match result {\n            Ok(output) if output.status.success() => Ok(()),\n            Ok(output) => Err(format!(\n                \"Failed to kill process with pid: {}, error: {}\",\n                pid,\n                String::from_utf8_lossy(&output.stderr)\n            )\n            .into()),\n            Err(e) => Err(format!(\"Failed to execute kill command: {}\", e).into()),\n        }\n    }\n\n    /// Kills process by PID on Windows platforms.\n    ///\n    /// # Arguments\n    ///\n    /// - `pid` - The ID of the process to terminate.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    #[cfg(windows)]\n    fn kill_process(&self, pid: i32) -> ServerManagerResult {\n        use std::ffi::c_void;\n        type DWORD = u32;\n        type BOOL = i32;\n        type HANDLE = *mut c_void;\n        type UINT = u32;\n        const PROCESS_TERMINATE: DWORD = 0x0001;\n        const PROCESS_ALL_ACCESS: DWORD = 0x1F0FFF;\n        unsafe extern \"system\" {\n            fn OpenProcess(\n                dwDesiredAccess: DWORD,\n                bInheritHandle: BOOL,\n                dwProcessId: DWORD,\n            ) -> HANDLE;\n            fn TerminateProcess(hProcess: HANDLE, uExitCode: UINT) -> BOOL;\n            fn CloseHandle(hObject: HANDLE) -> BOOL;\n            fn GetLastError() -> DWORD;\n        }\n        let process_id: DWORD = pid as DWORD;\n        let mut process_handle: HANDLE = unsafe { OpenProcess(PROCESS_TERMINATE, 0, process_id) };\n        if process_handle.is_null() {\n            process_handle = unsafe { OpenProcess(PROCESS_ALL_ACCESS, 0, process_id) };\n        }\n        if process_handle.is_null() {\n            let error_code = unsafe { GetLastError() };\n            return Err(format!(\n                \"Failed to open process with pid: {}. Error code: {}\",\n                pid, error_code\n            )\n            .into());\n        }\n        let terminate_result: BOOL = unsafe { TerminateProcess(process_handle, 1) };\n        if terminate_result == 0 {\n            let error_code = unsafe { GetLastError() };\n            unsafe {\n                CloseHandle(process_handle);\n            }\n            return Err(format!(\n                \"Failed to terminate process with pid: {}. Error code: {}\",\n                pid, error_code\n            )\n            .into());\n        }\n        unsafe {\n            CloseHandle(process_handle);\n        }\n        Ok(())\n    }\n\n    /// Runs the server with cargo-watch.\n    ///\n    /// # Arguments\n    ///\n    /// - `run_args` - A slice of string arguments to pass to `cargo-watch`.\n    /// - `wait` - A boolean indicating whether to wait for the `cargo-watch` process to complete.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    async fn run_with_cargo_watch(&self, run_args: &[&str], wait: bool) -> ServerManagerResult {\n        (self.start_hook)().await;\n        let cargo_watch_installed: Output = Command::new(\"cargo\")\n            .arg(\"install\")\n            .arg(\"--list\")\n            .output()?;\n        if !String::from_utf8_lossy(&cargo_watch_installed.stdout).contains(\"cargo-watch\") {\n            eprintln!(\"Cargo-watch not found. Attempting to install...\");\n            let install_status: ExitStatus = Command::new(\"cargo\")\n                .arg(\"install\")\n                .arg(\"cargo-watch\")\n                .stdout(Stdio::inherit())\n                .stderr(Stdio::inherit())\n                .spawn()?\n                .wait()?;\n            if !install_status.success() {\n                return Err(\"Failed to install cargo-watch. Please install it manually: `cargo install cargo-watch`\".into());\n            }\n            eprintln!(\"Cargo-watch installed successfully.\");\n        }\n        let mut command: Command = Command::new(\"cargo-watch\");\n        command\n            .args(run_args)\n            .stdout(Stdio::inherit())\n            .stderr(Stdio::inherit())\n            .stdin(Stdio::inherit());\n        let mut child: Child = command\n            .spawn()\n            .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;\n        if wait {\n            child\n                .wait()\n                .map_err(|e| Box::new(e) as Box<dyn std::error::Error>)?;\n        }\n        exit(0);\n    }\n\n    /// Starts the server with hot-reloading using `cargo-watch` in detached mode.\n    ///\n    /// This function spawns `cargo-watch` and returns immediately.\n    ///\n    /// # Arguments\n    ///\n    /// - `run_args` - A slice of string arguments to pass to `cargo-watch`.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    pub async fn watch_detached(&self, run_args: &[&str]) -> ServerManagerResult {\n        self.run_with_cargo_watch(run_args, false).await\n    }\n\n    /// Starts the server with hot-reloading using `cargo-watch` and waits for it to complete.\n    ///\n    /// This function is blocking and will wait for the `cargo-watch` process to exit.\n    ///\n    /// # Arguments\n    ///\n    /// - `run_args` - A slice of string arguments to pass to `cargo-watch`.\n    ///\n    /// # Returns\n    ///\n    /// - `ServerManagerResult` - Operation result.\n    pub async fn watch(&self, run_args: &[&str]) -> ServerManagerResult {\n        self.run_with_cargo_watch(run_args, true).await\n    }\n}", "file_size": 12112, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\vector\\macro.rs", "language": "rust", "content": "/// Creates a new vector instance.\n///\n/// # Arguments\n///\n/// - `expr` - The expression(s) to initialize the vector.\n///\n/// # Returns\n///\n/// - `Vec<T>` - A new vector containing the given elements.\n#[macro_export]\nmacro_rules! vector {\n    () => {\n        std::vec::Vec::new()\n    };\n    ($($elem:expr),*) => {\n        std::vec::Vec::from([$($elem),*])\n    };\n}", "file_size": 364, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\lib.rs", "language": "rust", "content": "//! server-manager\n//!\n//! server-manager is a rust library for managing server processes.\n//! It encapsulates service startup, shutdown, and background daemon mode.\n//! Users can specify the PID file, log file paths, and other configurations\n//! through custom settings, while also passing in their own asynchronous\n//! server function for execution. The library supports both synchronous\n//! and asynchronous operations. On Unix and Windows platforms,\n//! it enables background daemon processes.\n\npub(crate) mod cfg;\npub(crate) mod manager;\n\npub use manager::{r#struct::*, r#type::*};\n\npub(crate) use manager::r#const::*;\n\npub(crate) use std::{\n    fs,\n    future::Future,\n    path::{Path, PathBuf},\n    pin::Pin,\n    process::{Child, Command, ExitStatus, Output, Stdio, exit, id},\n    sync::Arc,\n};\n\n#[cfg(windows)]\npub(crate) use tokio::runtime::Runtime;\n\n#[cfg(not(windows))]\npub(crate) use tokio::runtime::Runtime;", "file_size": 920, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\std-macro-extensions\\src\\rw_lock\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_rw_lock() {\n    use crate::*;\n    let my_rwlock: RwLock<i32> = rw_lock!(5);\n    assert_eq!(*my_rwlock.read().unwrap(), 5);\n    *my_rwlock.write().unwrap() = 10;\n    assert_eq!(*my_rwlock.read().unwrap(), 10);\n}", "file_size": 226, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\lib.rs", "language": "rust", "content": "//! recoverable-thread-pool\n//!\n//! A thread pool that supports automatic recovery from panics,\n//! allowing threads to restart after a panic. Useful for resilient\n//! and fault-tolerant concurrency in network and web programming.\n\npub(crate) mod cfg;\npub(crate) mod thread_pool;\npub(crate) mod worker;\n\npub(crate) use std::sync::{\n    Arc, Mutex,\n    mpsc::{self, Receiver, SendError, Sender},\n};\npub(crate) use tokio::runtime::Builder;\n\npub use thread_pool::*;\npub use worker::*;", "file_size": 481, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\async\\impl.rs", "language": "rust", "content": "use crate::*;\nuse recoverable_spawn::r#async::*;\n\n/// Async implementation of thread pool operations.\nimpl ThreadPool {\n    /// Executes an async job in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The async function to execute.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn async_execute<F>(&self, job: F) -> SendResult\n    where\n        F: AsyncRecoverableFunction,\n    {\n        let job_with_handler = Box::new(move || {\n            Builder::new_current_thread()\n                .enable_all()\n                .build()\n                .unwrap()\n                .block_on(async move {\n                    let _ = async_run_function(move || async {\n                        job.call().await;\n                    })\n                    .await;\n                });\n        });\n        self.sender.send(job_with_handler)\n    }\n\n    /// Executes an async job with error handling in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The async function to execute.\n    /// - `E` - The async error handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn async_execute_with_catch<F, E>(&self, job: F, handle_error: E) -> SendResult\n    where\n        F: AsyncRecoverableFunction,\n        E: AsyncErrorHandlerFunction,\n    {\n        let job_with_handler = Box::new(move || {\n            Builder::new_current_thread()\n                .enable_all()\n                .build()\n                .unwrap()\n                .block_on(async move {\n                    let run_result: AsyncSpawnResult = async_run_function(move || async {\n                        job.call().await;\n                    })\n                    .await;\n                    if let Err(err) = run_result {\n                        let err_string: String = tokio_error_to_string(&err);\n                        let _: AsyncSpawnResult = async_run_error_handle_function(\n                            move |err_str| async move {\n                                handle_error.call(err_str).await;\n                            },\n                            Arc::new(err_string),\n                        )\n                        .await;\n                    }\n                });\n        });\n        self.sender.send(job_with_handler)\n    }\n\n    /// Executes an async job with error handling and finalization in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The async function to execute.\n    /// - `E` - The async error handler function.\n    /// - `L` - The async finally handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn async_execute_with_catch_finally<F, E, L>(\n        &self,\n        job: F,\n        handle_error: E,\n        finally: L,\n    ) -> SendResult\n    where\n        F: AsyncRecoverableFunction,\n        E: AsyncErrorHandlerFunction,\n        L: AsyncRecoverableFunction,\n    {\n        let job_with_handler = Box::new(move || {\n            Builder::new_current_thread()\n                .enable_all()\n                .build()\n                .unwrap()\n                .block_on(async move {\n                    let run_result: AsyncSpawnResult = async_run_function(move || async {\n                        job.call().await;\n                    })\n                    .await;\n                    if let Err(err) = run_result {\n                        let err_string: String = tokio_error_to_string(&err);\n                        let _: AsyncSpawnResult = async_run_error_handle_function(\n                            move |err_str| async move {\n                                handle_error.call(err_str).await;\n                            },\n                            Arc::new(err_string),\n                        )\n                        .await;\n                    }\n                    let _: AsyncSpawnResult = async_run_function(move || async {\n                        finally.call().await;\n                    })\n                    .await;\n                });\n        });\n        self.sender.send(job_with_handler)\n    }\n}", "file_size": 4134, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\worker\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub use r#struct::*;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// A thread pool that can execute tasks concurrently.\n///\n/// Manages a collection of worker threads and provides methods\n/// to submit tasks for execution.\n///\n/// # Returns\n///\n/// - `ThreadPool` - A new thread pool instance.\n#[derive(Debug)]\npub struct ThreadPool {\n    /// The collection of worker threads.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<Worker>` - The collection of worker threads.\n    #[allow(dead_code)]\n    pub(super) workers: Vec<Worker>,\n    /// The sender channel for submitting jobs to workers.\n    ///\n    /// # Returns\n    ///\n    /// - `Sender<ThreadPoolJob>` - The sender channel for submitting jobs to workers.\n    pub(super) sender: Sender<ThreadPoolJob>,\n}", "file_size": 709, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\type.rs", "language": "rust", "content": "use crate::*;\nuse recoverable_spawn::*;\n\n/// A job that can be executed by the thread pool.\npub type ThreadPoolJob = Box<dyn RecoverableFunction>;\n\n/// Error type for failed job submissions.\npub type SendErrorBox = SendError<ThreadPoolJob>;\n\n/// Result type for job submission operations.\npub type SendResult = Result<(), SendErrorBox>;", "file_size": 336, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\manager\\const.rs", "language": "rust", "content": "/// Environment variable name for daemon mode detection.\npub const RUNNING_AS_DAEMON: &str = \"RUNNING_AS_DAEMON\";\n\n/// Value indicating the process is running in daemon mode.\npub const RUNNING_AS_DAEMON_VALUE: &str = \"1\";", "file_size": 221, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn test_async_recoverable_spawn() {\n    use crate::r#async::*;\n    let msg: &str = \"test\";\n    let res: AsyncSpawnResult = async_recoverable_spawn(move || async move {\n        panic!(\"{}\", msg);\n    })\n    .await;\n    println!(\"test_async_recoverable_spawn handle res {:?}\", res);\n}\n\n#[tokio::test]\nasync fn test_async_recoverable_spawn_catch() {\n    use crate::r#async::*;\n    let msg: &str = \"test\";\n    let res: AsyncSpawnResult = async_recoverable_spawn_catch(\n        move || async move {\n            panic!(\"{}\", msg);\n        },\n        move |err| async move {\n            println!(\"async handle error => {}\", err);\n        },\n    )\n    .await;\n    println!(\"test_async_recoverable_spawn_catch handle res {:?}\", res);\n}\n\n#[tokio::test]\nasync fn test_async_recoverable_spawn_catch_finally() {\n    use crate::r#async::*;\n    let msg: &str = \"test\";\n    let res: AsyncSpawnResult = async_recoverable_spawn_catch_finally(\n        move || async move {\n            panic!(\"{}\", msg);\n        },\n        move |err| async move {\n            println!(\"async handle error => {}\", err);\n            panic!(\"{}\", err);\n        },\n        move || async move {\n            println!(\"finally\");\n        },\n    )\n    .await;\n    println!(\n        \"test_async_recoverable_spawn_catch_finally handle res {:?}\",\n        res\n    );\n}\n\n#[test]\nfn test_recoverable_spawn() {\n    use crate::r#sync::*;\n    let msg: &str = \"test\";\n    let res: SyncSpawnResult = recoverable_spawn(move || {\n        panic!(\"{}\", msg);\n    });\n    println!(\"test_recoverable_spawn handle res {:?}\", res);\n}\n\n#[test]\nfn test_recoverable_spawn_catch() {\n    use crate::r#sync::*;\n    let msg: &str = \"test\";\n    let res: SyncSpawnResult = recoverable_spawn_catch(\n        move || {\n            panic!(\"{}\", msg);\n        },\n        |err| {\n            println!(\"handle error => {}\", err);\n        },\n    );\n    println!(\"test_recoverable_spawn_catch handle res {:?}\", res);\n}\n\n#[test]\nfn test_recoverable_spawn_catch_finally() {\n    use crate::r#sync::*;\n    let msg: &str = \"test\";\n    let res: SyncSpawnResult = recoverable_spawn_catch_finally(\n        move || {\n            panic!(\"{}\", msg);\n        },\n        |err| {\n            println!(\"handle error => {}\", err);\n            panic!(\"{}\", err);\n        },\n        || {\n            println!(\"finally\");\n        },\n    );\n    println!(\"test_recoverable_spawn_catch_finally handle res {:?}\", res);\n}", "file_size": 2437, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\mod.rs", "language": "rust", "content": "pub(crate) mod r#async;\npub(crate) mod r#struct;\npub(crate) mod sync;\npub(crate) mod r#type;\n\npub use r#struct::*;\npub use r#type::*;", "file_size": 133, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\mod.rs", "language": "rust", "content": "pub mod r#async;\npub(crate) mod cfg;\npub mod sync;\npub(crate) mod r#trait;\npub(crate) mod r#type;", "file_size": 97, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\worker\\impl.rs", "language": "rust", "content": "use super::r#struct::Worker;\nuse crate::thread_pool::r#type::ThreadPoolJob;\nuse recoverable_spawn::*;\nuse std::{\n    sync::{Arc, Mutex, mpsc::Receiver},\n    thread::spawn,\n};\n\n/// Worker implementation for handling thread pool jobs.\nimpl Worker {\n    /// Creates a new worker thread.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The worker identifier.\n    /// - `Arc<Mutex<Receiver<ThreadPoolJob>>>` - The shared job receiver.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<Worker>` - The new worker instance.\n    pub fn new(id: usize, receiver: Arc<Mutex<Receiver<ThreadPoolJob>>>) -> Option<Worker> {\n        spawn(|| {\n            let _ = sync::recoverable_spawn(move || {\n                loop {\n                    if let Ok(receiver_lock) = receiver.lock() {\n                        if let Ok(job) = receiver_lock.recv() {\n                            let _ = sync::recoverable_spawn(job);\n                        }\n                    }\n                }\n            });\n        });\n        return Some(Worker { id });\n    }\n}", "file_size": 1047, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\manager\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Error type for server management operations.\npub type ServerManagerError = Box<dyn std::error::Error>;\n\n/// Result type for server management operations.\npub type ServerManagerResult = Result<(), ServerManagerError>;\n\n/// Type alias for the hook functions.\npub type ServerManagerHook =\n    Arc<dyn Fn() -> Pin<Box<dyn Future<Output = ()> + Send>> + Send + Sync>;", "file_size": 381, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\type.rs", "language": "rust", "content": "use crate::*;\nuse std::{any::Any, sync::Arc};\nuse tokio::task::JoinError;\n\n/// Error type for spawn operations.\npub type SpawnError = Box<dyn Any + Send>;\n\n/// Result type for asynchronous spawn operations.\n///\n/// # Returns\n///\n/// - `Result<(), JoinError>` - The spawn operation result.\npub type AsyncSpawnResult = Result<(), JoinError>;\n\n/// Result type for synchronous spawn operations.\n///\n/// # Returns\n///\n/// - `Result<(), SpawnError>` - The spawn operation result.\npub type SyncSpawnResult = Result<(), SpawnError>;\n\n/// Arc-wrapped asynchronous recoverable function.\n///\n/// # Type Parameters\n///\n/// - `O` - The output type.\n/// - `F` - The future type.\npub type ArcAsyncRecoverableFunction<O, F> =\n    Arc<dyn AsyncRecoverableFunction<Output = O, Future = F>>;\n\n/// Arc-wrapped asynchronous error handler function.\n///\n/// # Type Parameters\n///\n/// - `O` - The future type.\npub type ArcAsyncErrorHandlerFunction<O> = Arc<dyn AsyncErrorHandlerFunction<Future = O>>;", "file_size": 976, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\manager\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Main structure for managing server processes.\n#[derive(Clone)]\npub struct ServerManager {\n    /// Path to the PID file for process tracking.\n    pub(crate) pid_file: String,\n    /// An asynchronous function to be called before stopping the server.\n    pub(crate) stop_hook: ServerManagerHook,\n    /// An asynchronous function to be called before starting the server.\n    pub(crate) start_hook: ServerManagerHook,\n    /// Server function to be executed.\n    pub(crate) server_hook: ServerManagerHook,\n}", "file_size": 520, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\sync\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\n\npub use super::{r#trait::*, r#type::*};\npub use r#fn::*;", "file_size": 78, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\worker\\struct.rs", "language": "rust", "content": "/// A worker thread in the thread pool.\n///\n/// Each worker is responsible for executing jobs\n/// from the shared job queue.\n#[allow(dead_code)]\n#[derive(Debug, Default)]\npub struct Worker {\n    /// The unique identifier for this worker.\n    pub(super) id: usize,\n}", "file_size": 265, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\sync\\impl.rs", "language": "rust", "content": "use crate::*;\nuse recoverable_spawn::sync::*;\n\n/// Sync implementation of thread pool operations.\nimpl ThreadPool {\n    /// Creates a new thread pool with the specified number of workers.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The number of worker threads to create.\n    ///\n    /// # Returns\n    ///\n    /// - `ThreadPool` - The new thread pool instance.\n    pub fn new(size: usize) -> ThreadPool {\n        let (sender, receiver) = mpsc::channel();\n        let receiver: Arc<Mutex<Receiver<ThreadPoolJob>>> = Arc::new(Mutex::new(receiver));\n        let mut workers: Vec<Worker> = Vec::with_capacity(size);\n        let mut id: usize = 0;\n        loop {\n            if id >= size {\n                break;\n            }\n            let worker: Option<Worker> = Worker::new(id, Arc::clone(&receiver));\n            if worker.is_some() {\n                workers.push(worker.unwrap_or_default());\n                id += 1;\n            }\n        }\n        ThreadPool { workers, sender }\n    }\n\n    /// Executes a synchronous job in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The synchronous function to execute.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn execute<F>(&self, job: F) -> SendResult\n    where\n        F: RecoverableFunction,\n    {\n        let job_with_handler: ThreadPoolJob = Box::new(move || {\n            let _ = run_function(job);\n        });\n        self.sender.send(job_with_handler)\n    }\n\n    /// Executes a synchronous job with error handling in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The synchronous function to execute.\n    /// - `E` - The error handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn execute_with_catch<F, E>(&self, job: F, handle_error: E) -> SendResult\n    where\n        F: RecoverableFunction,\n        E: ErrorHandlerFunction,\n    {\n        let job_with_handler: ThreadPoolJob = Box::new(move || {\n            if let Err(err) = run_function(job) {\n                let err_string: String = spawn_error_to_string(&err);\n                let _ = run_error_handle_function(handle_error, &err_string);\n            }\n        });\n        self.sender.send(job_with_handler)\n    }\n\n    /// Executes a synchronous job with error handling and finalization in the thread pool.\n    ///\n    /// # Arguments\n    ///\n    /// - `F` - The synchronous function to execute.\n    /// - `E` - The error handler function.\n    /// - `L` - The finally handler function.\n    ///\n    /// # Returns\n    ///\n    /// - `SendResult` - Result of the job submission.\n    pub fn execute_with_catch_finally<F, E, L>(\n        &self,\n        job: F,\n        handle_error: E,\n        finally: L,\n    ) -> SendResult\n    where\n        F: RecoverableFunction,\n        E: ErrorHandlerFunction,\n        L: RecoverableFunction,\n    {\n        let job_with_handler: ThreadPoolJob = Box::new(move || {\n            if let Err(err) = run_function(job) {\n                let err_string: String = spawn_error_to_string(&err);\n                let _ = run_error_handle_function(handle_error, &err_string);\n            }\n            let _ = run_function(finally);\n        });\n        self.sender.send(job_with_handler)\n    }\n}", "file_size": 3299, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\async\\fn.rs", "language": "rust", "content": "use crate::*;\nuse tokio::task::JoinError;\n\n/// Executes a recoverable function within a panic-safe context.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing AsyncRecoverableFunction.\n///\n/// # Returns\n///\n/// - `AsyncSpawnResult` - The spawn operation result.\npub async fn async_run_function<F: AsyncRecoverableFunction>(func: F) -> AsyncSpawnResult {\n    set_hook(Box::new(move |_| {}));\n    let func = async move {\n        func.call().await;\n    };\n    return tokio::spawn(func).await;\n}\n\n/// Executes an error-handling function within a panic-safe context.\n///\n/// # Arguments\n///\n/// - `E` - Function implementing AsyncErrorHandlerFunction.\n/// - `Arc<String>` - The error message.\n///\n/// # Returns\n///\n/// - `AsyncSpawnResult` - The spawn operation result.\npub async fn async_run_error_handle_function<E: AsyncErrorHandlerFunction>(\n    func: E,\n    error: Arc<String>,\n) -> AsyncSpawnResult {\n    set_hook(Box::new(move |_| {}));\n    let func = async move {\n        func.call(error.clone()).await;\n    };\n    return tokio::spawn(func).await;\n}\n\n/// Converts a panic-captured error value into a string.\n///\n/// # Arguments\n///\n/// - `&JoinError` - The captured error value.\n///\n/// # Returns\n///\n/// - `String` - The error string representation.\npub fn tokio_error_to_string(err: &JoinError) -> String {\n    err.to_string()\n}\n\n/// Spawns a recoverable function.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing AsyncRecoverableFunction.\n///\n/// # Returns\n///\n/// - `AsyncSpawnResult` - The spawn operation result.\npub async fn async_recoverable_spawn<F>(function: F) -> AsyncSpawnResult\nwhere\n    F: AsyncRecoverableFunction,\n{\n    async_run_function(function).await\n}\n\n/// Spawns a recoverable function with error handling.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing AsyncRecoverableFunction.\n/// - `E` - Function implementing AsyncErrorHandlerFunction.\n///\n/// # Returns\n///\n/// - `AsyncSpawnResult` - The spawn operation result.\npub async fn async_recoverable_spawn_catch<F, E>(\n    function: F,\n    error_handle_function: E,\n) -> AsyncSpawnResult\nwhere\n    F: AsyncRecoverableFunction,\n    E: AsyncErrorHandlerFunction,\n{\n    let run_result: AsyncSpawnResult = async_run_function(function).await;\n    if let Err(err) = run_result.as_ref() {\n        let err_string: String = tokio_error_to_string(err);\n        let _: AsyncSpawnResult =\n            async_run_error_handle_function(error_handle_function, Arc::new(err_string)).await;\n    }\n    return run_result;\n}\n\n/// Spawns a recoverable function with error handling and finalization.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing AsyncRecoverableFunction.\n/// - `E` - Function implementing AsyncErrorHandlerFunction.\n/// - `L` - Function implementing AsyncRecoverableFunction.\n///\n/// # Returns\n///\n/// - `AsyncSpawnResult` - The spawn operation result.\npub async fn async_recoverable_spawn_catch_finally<F, E, L>(\n    function: F,\n    error_handle_function: E,\n    finally: L,\n) -> AsyncSpawnResult\nwhere\n    F: AsyncRecoverableFunction,\n    E: AsyncErrorHandlerFunction,\n    L: AsyncRecoverableFunction,\n{\n    let run_result: AsyncSpawnResult = async_run_function(function).await;\n    if let Err(err) = run_result.as_ref() {\n        let err_string: String = tokio_error_to_string(err);\n        let _: AsyncSpawnResult =\n            async_run_error_handle_function(error_handle_function, Arc::new(err_string)).await;\n    }\n    let _: AsyncSpawnResult = async_run_function(finally).await;\n    return run_result;\n}", "file_size": 3520, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\server-manager\\src\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn test_start_executes_server_fn() {\n    use crate::*;\n    use std::fs;\n    use std::time::Duration;\n\n    let pid_file: String = \"./process/test_pid.pid\".to_string();\n    let _ = fs::remove_file(&pid_file);\n    let server = || async {\n        tokio::time::sleep(Duration::from_secs(1)).await;\n    };\n    let mut manager: ServerManager = ServerManager::new();\n    manager\n        .set_pid_file(&pid_file)\n        .set_start_hook(|| async {\n            println!(\"Before start daemon hook executed\");\n        })\n        .set_server_hook(server)\n        .set_stop_hook(|| async {\n            println!(\"Before stop hook executed\");\n        });\n    let res: ServerManagerResult = manager.start_daemon().await;\n    println!(\"start_daemon {:?}\", res);\n    let res: ServerManagerResult = manager.stop().await;\n    println!(\"stop {:?}\", res);\n    manager.start().await;\n    let _ = fs::remove_file(&pid_file);\n}", "file_size": 922, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\cfg\\struct.rs", "language": "rust", "content": "use crate::{func::*, visibility::*};\n\n/// Represents the configuration for function types, visibility, and skipping behavior.\n///\n/// This struct holds the configuration for function types (`FuncType`),\n/// whether to skip processing (`skip`), and the visibility of the function (`Visibility`).\n///\n/// # Fields\n/// - `func_type`: A `FuncType` that specifies the function type.\n/// - `skip`: A boolean flag indicating whether the function should be skipped during processing.\n/// - `visibility`: A `Visibility` that defines the visibility of the function.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct Cfg {\n    /// A `FuncType` that specifies the function type.\n    pub(crate) func_type: FuncType,\n    /// A boolean flag indicating whether the function should be skipped during processing.\n    pub(crate) skip: bool,\n    /// A `Visibility` that defines the visibility of the function.\n    pub(crate) visibility: Visibility,\n}", "file_size": 930, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-thread-pool\\src\\thread_pool\\async\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;", "file_size": 22, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\cfg\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides default configuration values for the Cfg struct.\nimpl Default for Cfg {\n    /// Returns a default `Cfg` instance with unknown function type, skip set to false, and public visibility.\n    ///\n    /// # Returns\n    ///\n    /// - `Cfg` - A new `Cfg` instance with default values.\n    fn default() -> Self {\n        Self {\n            func_type: FuncType::Unknown,\n            skip: false,\n            visibility: Visibility::Public,\n        }\n    }\n}", "file_size": 475, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\trait.rs", "language": "rust", "content": "use std::{future::Future, sync::Arc};\n\n/// Trait alias for functions that can be executed in a recoverable context.\n///\n/// - Functions implementing this trait must satisfy `FnOnce() + Send + Sync + 'static`.\npub trait FunctionOnceTrait: FnOnce() + Send + Sync + 'static {}\n\nimpl<T> FunctionOnceTrait for T where T: FnOnce() + Send + Sync + 'static {}\n\n/// Trait alias for functions that can be executed in a recoverable context.\n///\n/// - Functions implementing this trait must satisfy `Fn() + Send + Sync + 'static`.\npub trait FunctionTrait: Fn() + Send + Sync + 'static {}\n\nimpl<T> FunctionTrait for T where T: Fn() + Send + Sync + 'static {}\n\n/// Trait alias for functions that can be executed in a recoverable context.\n///\n/// - Functions implementing this trait must satisfy `FnMut() + Send + Sync + 'static`.\npub trait FunctionMutTrait: FnMut() + Send + Sync + 'static {}\n\nimpl<T> FunctionMutTrait for T where T: FnMut() + Send + Sync + 'static {}\n\n/// Trait alias for asynchronous functions that can be executed in a recoverable context.\n///\n/// # Arguments\n///\n/// - `FnOnce() -> Future` - Function that returns a Future.\n///\n/// # Returns\n///\n/// - `Future` - The asynchronous computation result.\npub trait AsyncRecoverableFunction: Send + Sync + 'static {\n    type Output: Send;\n    type Future: Future<Output = Self::Output> + Send;\n\n    /// Executes the asynchronous function.\n    fn call(self) -> Self::Future;\n}\n\nimpl<F, Fut, O> AsyncRecoverableFunction for F\nwhere\n    F: FnOnce() -> Fut + Send + Sync + 'static,\n    Fut: Future<Output = O> + Send + 'static,\n    O: Send + 'static,\n{\n    type Output = O;\n    type Future = Fut;\n\n    fn call(self) -> Self::Future {\n        self()\n    }\n}\n\n/// Trait alias for asynchronous error-handling functions used in a recoverable context.\n///\n/// # Arguments\n///\n/// - `Arc<String>` - The error message to handle.\n///\n/// # Returns\n///\n/// - `Future` - The asynchronous error handling result.\npub trait AsyncErrorHandlerFunction: Send + Sync + 'static {\n    type Future: Future<Output = ()> + Send;\n\n    /// Handles an error asynchronously.\n    ///\n    /// - `error`: The error message to handle.\n    fn call(self, error: Arc<String>) -> Self::Future;\n}\n\nimpl<F, Fut> AsyncErrorHandlerFunction for F\nwhere\n    F: FnOnce(Arc<String>) -> Fut + Send + Sync + 'static,\n    Fut: Future<Output = ()> + Send + 'static,\n{\n    type Future = Fut;\n\n    fn call(self, error: Arc<String>) -> Self::Future {\n        self(error)\n    }\n}\n\n/// Trait alias for functions that can be executed in a recoverable context.\n///\n/// - Functions implementing this trait must satisfy `FnOnce() + Send + Sync + 'static`.\npub trait RecoverableFunction: FnOnce() + Send + Sync + 'static {}\n\nimpl<T> RecoverableFunction for T where T: FnOnce() + Send + Sync + 'static {}\n\n/// Trait alias for error-handling functions used in a recoverable context.\n///\n/// # Arguments\n///\n/// - `&str` - The error message to handle.\npub trait ErrorHandlerFunction: FnOnce(&str) + Send + Sync + 'static {}\n\nimpl<T> ErrorHandlerFunction for T where T: FnOnce(&str) + Send + Sync + 'static {}", "file_size": 3096, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\func\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides default implementation for FuncType.\nimpl Default for FuncType {\n    /// Returns the default value for FuncType, which is Unknown.\n    fn default() -> Self {\n        Self::Unknown\n    }\n}\n\n/// Implements the `FromStr` trait for `FuncType` to parse string representations into `FuncType` variants.\nimpl FromStr for FuncType {\n    type Err = String;\n\n    /// Parses a string slice into a `FuncType`.\n    ///\n    /// # Arguments\n    ///\n    /// - `s`: The string slice to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<FuncType, String>`: Ok containing the `FuncType` if parsing is successful,\n    ///   or an Err containing a String error message if parsing fails.\n    fn from_str(s: &str) -> Result<FuncType, std::string::String> {\n        match s {\n            GET => Ok(FuncType::Get),\n            GET_MUT => Ok(FuncType::GetMut),\n            SET => Ok(FuncType::Set),\n            DEBUG => Ok(FuncType::Debug),\n            _ => Ok(FuncType::Unknown),\n        }\n    }\n}\n\nimpl FuncType {\n    /// Checks if the `FuncType` is `Get`.\n    ///\n    /// # Parameters\n    /// - `self` - The reference to the `FuncType` instance.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` is `Get`; otherwise, `false`.\n    pub fn is_get(&self) -> bool {\n        *self == FuncType::Get\n    }\n\n    /// Checks if the `FuncType` is `GetMut`.\n    ///\n    /// # Parameters\n    /// - `self` - The reference to the `FuncType` instance.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` is `GetMut`; otherwise, `false`.\n    pub fn is_get_mut(&self) -> bool {\n        *self == FuncType::GetMut\n    }\n\n    /// Checks if the `FuncType` is `Set`.\n    ///\n    /// # Parameters\n    /// - `self` - The reference to the `FuncType` instance.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` is `Set`; otherwise, `false`.\n    pub fn is_set(&self) -> bool {\n        *self == FuncType::Set\n    }\n\n    /// Checks if the `FuncType` is `Debug`.\n    ///\n    /// # Parameters\n    /// - `self` - The reference to the `FuncType` instance.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` is `Debug`; otherwise, `false`.\n    pub fn is_debug(&self) -> bool {\n        *self == FuncType::Debug\n    }\n\n    /// Checks if the `FuncType` is `Unknown`.\n    ///\n    /// # Parameters\n    /// - `self` - The reference to the `FuncType` instance.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` is `Unknown`; otherwise, `false`.\n    pub fn is_unknown(&self) -> bool {\n        *self == Self::Unknown\n    }\n\n    /// Checks if the `FuncType` is `Unknown`.\n    ///\n    /// # Parameters\n    /// - `func_type_str`: The string slice representing the function type to check.\n    ///\n    /// # Returns\n    /// - `true` if the `FuncType` parsed from the string is not `Unknown`; otherwise, `false`.\n    pub fn is_known(func_type_str: &str) -> bool {\n        let func_type: FuncType = func_type_str.parse::<FuncType>().unwrap_or_default();\n        func_type != Self::Unknown\n    }\n}", "file_size": 3010, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\cfg\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub(crate) use r#struct::*;", "file_size": 76, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\thread\\sync\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Executes a recoverable function within a panic-safe context.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing RecoverableFunction.\n///\n/// # Returns\n///\n/// - `SyncSpawnResult` - The spawn operation result.\npub fn run_function<F: RecoverableFunction>(func: F) -> SyncSpawnResult {\n    set_hook(Box::new(move |_| {}));\n    std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n        func();\n    }))\n}\n\n/// Executes an error-handling function within a panic-safe context.\n///\n/// # Arguments\n///\n/// - `E` - Function implementing ErrorHandlerFunction.\n/// - `&str` - The error message.\n///\n/// # Returns\n///\n/// - `SyncSpawnResult` - The spawn operation result.\npub fn run_error_handle_function<E: ErrorHandlerFunction>(func: E, error: &str) -> SyncSpawnResult {\n    set_hook(Box::new(move |_| {}));\n    std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n        func(error);\n    }))\n}\n\n/// Converts a panic-captured error value into a string.\n///\n/// # Arguments\n///\n/// - `&SpawnError` - The captured error value.\n///\n/// # Returns\n///\n/// - `String` - The error string representation.\npub fn spawn_error_to_string(err: &SpawnError) -> String {\n    match err.downcast_ref::<&str>() {\n        Some(str_slice) => str_slice.to_string(),\n        None => match err.downcast_ref::<String>() {\n            Some(string) => string.to_owned(),\n            None => format!(\"{:?}\", err),\n        },\n    }\n}\n\n/// Spawns a recoverable function.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing RecoverableFunction.\n///\n/// # Returns\n///\n/// - `SyncSpawnResult` - The spawn operation result.\npub fn recoverable_spawn<F>(function: F) -> SyncSpawnResult\nwhere\n    F: RecoverableFunction,\n{\n    run_function(function)\n}\n\n/// Spawns a recoverable function with error handling.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing RecoverableFunction.\n/// - `E` - Function implementing ErrorHandlerFunction.\n///\n/// # Returns\n///\n/// - `SyncSpawnResult` - The spawn operation result.\npub fn recoverable_spawn_catch<F, E>(function: F, error_handle_function: E) -> SyncSpawnResult\nwhere\n    F: RecoverableFunction,\n    E: ErrorHandlerFunction,\n{\n    let run_result: SyncSpawnResult = run_function(function);\n    if let Err(err) = run_result.as_ref() {\n        let err_string: String = spawn_error_to_string(err);\n        let _: SyncSpawnResult = run_error_handle_function(error_handle_function, &err_string);\n    }\n    return run_result;\n}\n\n/// Spawns a recoverable function with error handling and finalization.\n///\n/// # Arguments\n///\n/// - `F` - Function implementing RecoverableFunction.\n/// - `E` - Function implementing ErrorHandlerFunction.\n/// - `L` - Function implementing RecoverableFunction.\n///\n/// # Returns\n///\n/// - `SyncSpawnResult` - The spawn operation result.\npub fn recoverable_spawn_catch_finally<F, E, L>(\n    function: F,\n    error_handle_function: E,\n    finally: L,\n) -> SyncSpawnResult\nwhere\n    F: RecoverableFunction,\n    E: ErrorHandlerFunction,\n    L: RecoverableFunction,\n{\n    let run_result: SyncSpawnResult = run_function(function);\n    if let Err(err) = run_result.as_ref() {\n        let err_string: String = spawn_error_to_string(err);\n        let _: SyncSpawnResult = run_error_handle_function(error_handle_function, &err_string);\n    }\n    let _: SyncSpawnResult = run_function(finally);\n    return run_result;\n}", "file_size": 3385, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\generate\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#fn;\n\npub(crate) use r#const::*;\npub(crate) use r#fn::*;", "file_size": 96, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\lib.rs", "language": "rust", "content": "//! lombok-macros\n//!\n//! A Rust procedural macro collection providing Lombok-like functionality.\n//! Automatically generates getters/setters with field-level visibility control,\n//! custom Debug implementations with field skipping, and Display trait implementations.\n//! Supports structs, enums, generics and lifetimes.\n\npub(crate) mod cfg;\npub(crate) mod func;\npub(crate) mod generate;\npub(crate) mod parse;\npub(crate) mod visibility;\n\npub(crate) use cfg::*;\npub(crate) use func::*;\npub(crate) use generate::*;\npub(crate) use parse::*;\npub(crate) use visibility::*;\n\npub(crate) use proc_macro::TokenStream;\npub(crate) use proc_macro2::{TokenStream as TokenStream2, TokenTree as TokenTree2};\npub(crate) use quote::{ToTokens, format_ident, quote};\npub(crate) use std::{collections::HashMap, str::FromStr};\npub(crate) use syn::{\n    Data, DeriveInput, Field,\n    GenericParam::{self},\n    Ident, Lifetime,\n    Type::{self},\n    TypeParam, WhereClause, parse_macro_input,\n};\n\n/// This is an example of how to use the `Lombok` procedural macro with `get` attributes.\n///\n/// The `Lombok` procedural macro is used to automatically generate getter methods for struct fields.\n/// The `get` attribute controls the visibility of the generated getter method.\n///\n/// Example:\n///\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(Getter, Clone)]\n/// struct LombokTest2<'a, 'b, T: Clone> {\n///     #[get(pub(crate))]\n///     list: Vec<String>,\n///     #[get(pub(crate))]\n///     opt_str_lifetime_a: Option<&'a T>,\n///     opt_str_lifetime_b: Option<&'b str>,\n/// }\n/// let list: Vec<String> = vec![\"hello\".to_string(), \"world\".to_string()];\n/// let data2: LombokTest2<usize> = LombokTest2 {\n///     list: list.clone(),\n///     opt_str_lifetime_a: None,\n///     opt_str_lifetime_b: None,\n/// };\n/// let get_list: Vec<String> = data2.get_list().clone();\n/// assert_eq!(get_list, list);\n/// ```\n#[proc_macro_derive(Getter, attributes(get))]\npub fn getter(input: TokenStream) -> TokenStream {\n    inner_lombok_data(input, true, false, false)\n}\n\n/// This is an example of how to use the `Lombok` procedural macro with `get_mut` attributes.\n///\n/// The `Lombok` procedural macro is used to automatically generate mutable getters for struct fields.\n/// The `get_mut` attribute controls the visibility of the mutable getter function.\n///\n/// Example:\n///\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(GetterMut, Clone)]\n/// struct LombokTest2<'a, 'b, T: Clone> {\n///     #[get_mut(pub(crate))]\n///     list: Vec<String>,\n///     #[get_mut(pub(crate))]\n///     opt_str_lifetime_a: Option<&'a T>,\n///     opt_str_lifetime_b: Option<&'b str>,\n/// }\n/// let list: Vec<String> = vec![\"hello\".to_string(), \"world\".to_string()];\n/// let mut data2: LombokTest2<usize> = LombokTest2 {\n///     list: list.clone(),\n///     opt_str_lifetime_a: None,\n///     opt_str_lifetime_b: None,\n/// };\n/// let get_list: Vec<String> = data2.get_mut_list().clone();\n/// assert_eq!(get_list, list);\n/// ```\n#[proc_macro_derive(GetterMut, attributes(get_mut))]\npub fn getter_mut(input: TokenStream) -> TokenStream {\n    inner_lombok_data(input, false, true, false)\n}\n\n/// This is an example of how to use the `Lombok` procedural macro with `set` attributes.\n///\n/// The `Lombok` procedural macro is used to automatically generate setters for struct fields.\n/// The `set` attribute controls the visibility of the setter function.\n///\n/// Example:\n///\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(Setter, Debug, Clone)]\n/// struct LombokTest<'a, 'b, T: Clone> {\n///     #[set(pub(crate))]\n///     list: Vec<String>,\n///     opt_str_lifetime_a: Option<&'a T>,\n///     #[set(private)]\n///     opt_str_lifetime_b: Option<&'b str>,\n/// }\n/// let mut data: LombokTest<usize> = LombokTest {\n///     list: Vec::new(),\n///     opt_str_lifetime_a: None,\n///     opt_str_lifetime_b: None,\n/// };\n/// let list: Vec<String> = vec![\"hello\".to_string(), \"world\".to_string()];\n/// data.set_list(list.clone());\n/// match data.list {\n///     left_val => {\n///         assert_eq!(*left_val, list);\n///     }\n/// }\n/// ```\n#[proc_macro_derive(Setter, attributes(set))]\npub fn setter(input: TokenStream) -> TokenStream {\n    inner_lombok_data(input, false, false, true)\n}\n\n/// This is an example of how to use the `Lombok` procedural macro with `get`, `get_mut`, and `set` attributes.\n///\n/// The `Lombok` procedural macro is used to automatically generate getters, mutable getters, and setters for struct fields.\n/// The `get` and `get_mut` attributes control the visibility of the getter functions, while the `set` attribute controls\n/// the visibility of the setter function.\n///\n/// Example:\n///\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(Data, Debug, Clone)]\n/// struct LombokTest<'a, 'b, T: Clone> {\n///     #[get(pub(crate))]\n///     #[set(pub(crate))]\n///     list: Vec<String>,\n///     #[get(pub(crate))]\n///     opt_str_lifetime_a: Option<&'a T>,\n///     #[set(private)]\n///     opt_str_lifetime_b: Option<&'b str>,\n/// }\n/// let mut data: LombokTest<usize> = LombokTest {\n///     list: Vec::new(),\n///     opt_str_lifetime_a: None,\n///     opt_str_lifetime_b: None,\n/// };\n/// let list: Vec<String> = vec![\"hello\".to_string(), \"world\".to_string()];\n/// data.set_list(list.clone());\n/// match data.get_list() {\n///     left_val => {\n///         assert_eq!(*left_val, list);\n///     }\n/// }\n/// ```\n#[proc_macro_derive(Data, attributes(set, get, get_mut))]\npub fn data(input: TokenStream) -> TokenStream {\n    inner_lombok_data(input, true, true, true)\n}\n\n/// A procedural macro that implements the `std::fmt::Display` trait for a type,\n/// using the standard debug format (`{:?}`) for formatting.\n///\n/// This macro derives the `Display` implementation for a type, allowing it to be formatted\n/// using `{:?}` in formatting macros. It uses the `inner_display_debug` function to generate\n/// the implementation with the standard debug format.\n///\n/// # Parameters\n/// - `input`: The input token stream representing the Rust item (struct, enum, etc.)\n///   for which the `Display` implementation will be generated.\n///\n/// # Returns\n/// - `TokenStream`: The generated `std::fmt::Display` implementation for the type\n///   using the standard debug format.\n#[proc_macro_derive(DisplayDebug)]\npub fn display_debug(input: TokenStream) -> TokenStream {\n    inner_display_debug(input)\n}\n\n/// A procedural macro that implements the `std::fmt::Display` trait for a type,\n/// using the detailed debug format (`{:#?}`) for formatting.\n///\n/// This macro derives the `Display` implementation for a type, allowing it to be formatted\n/// using `{:#?}` in formatting macros. It uses the `inner_display_debug_format` function\n/// to generate the implementation with the detailed debug format.\n///\n/// # Parameters\n/// - `input`: The input token stream representing the Rust item (struct, enum, etc.)\n///   for which the `Display` implementation will be generated.\n///\n/// # Returns\n/// - `TokenStream`: The generated `std::fmt::Display` implementation for the type\n///   using the detailed debug format.\n#[proc_macro_derive(DisplayDebugFormat)]\npub fn display_debug_format(input: TokenStream) -> TokenStream {\n    inner_display_debug_format(input)\n}\n\n/// A procedural macro that implements the `std::fmt::Debug` trait for a type,\n/// with support for the `#[debug(skip)]` attribute to skip specific fields.\n///\n/// This macro derives a custom Debug implementation that behaves like the standard\n/// library's Debug derive, but allows individual fields to be excluded from the\n/// debug output by annotating them with `#[debug(skip)]`.\n///\n/// # Supported Attributes\n/// - `#[debug(skip)]`: Excludes the field from the debug output\n///\n/// # Examples\n///\n/// ## Struct Example\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(CustomDebug)]\n/// struct User {\n///     name: String,\n///     #[debug(skip)]\n///     password: String,\n///     email: String,\n/// }\n///\n/// let user = User {\n///     name: \"Alice\".to_string(),\n///     password: \"secret123\".to_string(),\n///     email: \"alice@example.com\".to_string(),\n/// };\n/// println!(\"{:?}\", user);\n/// // Output: User { name: \"Alice\", email: \"alice@example.com\" }\n/// ```\n///\n/// ## Enum Example\n/// ```rust\n/// use lombok_macros::*;\n///\n/// #[derive(CustomDebug)]\n/// enum Response {\n///     Success { data: String },\n///     Error {\n///         message: String,\n///         #[debug(skip)]\n///         internal_code: u32,\n///     },\n/// }\n/// ```\n///\n/// # Parameters\n/// - `input`: The input token stream representing the Rust item (struct, enum, etc.)\n///   for which the Debug implementation will be generated.\n///\n/// # Returns\n/// - `TokenStream`: The generated `std::fmt::Debug` implementation for the type\n///   that respects the `#[debug(skip)]` attribute.\n#[proc_macro_derive(CustomDebug, attributes(debug))]\npub fn custom_debug(input: TokenStream) -> TokenStream {\n    inner_custom_debug(input)\n}", "file_size": 8921, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\generate\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Cleans an attribute string by removing the \"r#\" prefix if present.\n///\n/// # Arguments\n///\n/// - `&str` - The attribute string to clean.\n///\n/// # Returns\n///\n/// - `String` - The cleaned attribute name.\nfn get_clean_attr_name(attr_str: &str) -> String {\n    let clean_attr: String = if let Some(stripped) = attr_str.strip_prefix(\"r#\") {\n        stripped.to_owned()\n    } else {\n        attr_str.to_owned()\n    };\n    clean_attr\n}\n\n/// Generates getter and setter functions for a given struct field.\n///\n/// # Arguments\n///\n/// - `&Field` - The field structure for which to generate getter/setter.\n/// - `Option<usize>` - Optional index for tuple struct fields.\n/// - `bool` - Whether to generate a getter function.\n/// - `bool` - Whether to generate a mutable getter function.\n/// - `bool` - Whether to generate a setter function.\n///\n/// # Returns\n///\n/// - `TokenStream2` - The generated getter and setter functions.\npub fn generate_getter_setter(\n    field: &Field,\n    field_index: Option<usize>,\n    need_getter: bool,\n    need_getter_mut: bool,\n    need_setter: bool,\n) -> TokenStream2 {\n    if let Some(index) = field_index {\n        generate_tuple_getter_setter(field, index, need_getter, need_getter_mut, need_setter)\n    } else {\n        generate_named_getter_setter(field, need_getter, need_getter_mut, need_setter)\n    }\n}\n\n/// Generates getter and setter functions for named struct fields.\n///\n/// # Arguments\n///\n/// - `&Field` - The field structure to generate for.\n/// - `bool` - Whether to generate a getter function.\n/// - `bool` - Whether to generate a mutable getter function.\n/// - `bool` - Whether to generate a setter function.\n///\n/// # Returns\n///\n/// - `TokenStream2` - The generated getter and setter functions.\nfn generate_named_getter_setter(\n    field: &Field,\n    need_getter: bool,\n    need_getter_mut: bool,\n    need_setter: bool,\n) -> TokenStream2 {\n    let attr_name: String = field\n        .ident\n        .as_ref()\n        .expect(FIELD_SHOULD_HAVE_A_NAME)\n        .to_string();\n    let attr_name_ident: &Ident = field.ident.as_ref().unwrap();\n    let attr_ty: &Type = &field.ty;\n    let clean_attr_name: String = get_clean_attr_name(&attr_name);\n    let get_name: Ident = format_ident!(\"{}{}\", GET_METHOD_PREFIX, clean_attr_name);\n    let get_mut_name: Ident = format_ident!(\"{}{}\", GET_MUT_METHOD_PREFIX, clean_attr_name);\n    let set_name: Ident = format_ident!(\"{}{}\", SET_METHOD_PREFIX, clean_attr_name);\n    let mut generated: TokenStream2 = quote! {};\n    let mut cfg_map: HashMap<String, Vec<Cfg>> = HashMap::new();\n    for attr in &field.attrs {\n        let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n        let name: String = field.ident.to_token_stream().to_string();\n        cfg_map.entry(name).or_insert_with(Vec::new).push(cfg);\n    }\n    let get_quote = |vis: TokenStream2| {\n        if need_getter {\n            quote! {\n                #vis fn #get_name(&self) -> &#attr_ty {\n                    &self.#attr_name_ident\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let get_mut_quote = |vis: TokenStream2| {\n        if need_getter_mut {\n            quote! {\n                #vis fn #get_mut_name(&mut self) -> &mut #attr_ty {\n                    &mut self.#attr_name_ident\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let set_quote = |vis: TokenStream2| {\n        if need_setter {\n            quote! {\n                #vis fn #set_name(&mut self, val: #attr_ty) -> &mut Self {\n                    self.#attr_name_ident = val;\n                    self\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let mut has_add_get: bool = false;\n    let mut has_add_get_mut: bool = false;\n    let mut has_add_set: bool = false;\n    for (_key, cfg_list) in &cfg_map {\n        for cfg in cfg_list {\n            if has_add_get && has_add_set && has_add_get_mut {\n                break;\n            }\n            if cfg.skip && cfg.func_type.is_unknown() {\n                continue;\n            }\n            let vis: TokenStream2 = cfg.visibility.to_token_stream();\n            if cfg.func_type.is_get() {\n                if !cfg.skip && !has_add_get {\n                    generated.extend(get_quote(vis.clone()));\n                }\n                has_add_get = true;\n            }\n            if cfg.func_type.is_get_mut() {\n                if !cfg.skip && !has_add_get_mut {\n                    generated.extend(get_mut_quote(vis.clone()));\n                }\n                has_add_get_mut = true;\n            }\n            if cfg.func_type.is_set() {\n                if !cfg.skip && !has_add_set {\n                    generated.extend(set_quote(vis.clone()));\n                }\n                has_add_set = true;\n            }\n        }\n    }\n    if !has_add_get || !has_add_set || !has_add_get_mut {\n        let cfg: Cfg = Cfg::default();\n        let vis: TokenStream2 = cfg.visibility.to_token_stream();\n        if !has_add_get {\n            generated.extend(get_quote(vis.clone()));\n        }\n        if !has_add_get_mut {\n            generated.extend(get_mut_quote(vis.clone()));\n        }\n        if !has_add_set {\n            generated.extend(set_quote(vis.clone()));\n        }\n    }\n    generated\n}\n\n/// Generates getter and setter functions for tuple struct fields.\n///\n/// # Arguments\n///\n/// - `&Field` - The field structure to generate for.\n/// - `usize` - The index of the field in the tuple struct.\n/// - `bool` - Whether to generate a getter function.\n/// - `bool` - Whether to generate a mutable getter function.\n/// - `bool` - Whether to generate a setter function.\n///\n/// # Returns\n///\n/// - `TokenStream2` - The generated getter and setter functions.\nfn generate_tuple_getter_setter(\n    field: &Field,\n    index: usize,\n    need_getter: bool,\n    need_getter_mut: bool,\n    need_setter: bool,\n) -> TokenStream2 {\n    let attr_ty: &Type = &field.ty;\n    let get_name: Ident = format_ident!(\"{}{}\", GET_METHOD_PREFIX, index);\n    let get_mut_name: Ident = format_ident!(\"{}{}\", GET_MUT_METHOD_PREFIX, index);\n    let set_name: Ident = format_ident!(\"{}{}\", SET_METHOD_PREFIX, index);\n    let field_index: syn::Index = syn::Index::from(index);\n    let mut generated: TokenStream2 = quote! {};\n    let mut cfg_map: HashMap<String, Vec<Cfg>> = HashMap::new();\n    for attr in &field.attrs {\n        let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n        let name: String = index.to_string();\n        cfg_map.entry(name).or_insert_with(Vec::new).push(cfg);\n    }\n    let get_quote = |vis: TokenStream2| {\n        if need_getter {\n            quote! {\n                #vis fn #get_name(&self) -> &#attr_ty {\n                    &self.#field_index\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let get_mut_quote = |vis: TokenStream2| {\n        if need_getter_mut {\n            quote! {\n                #vis fn #get_mut_name(&mut self) -> &mut #attr_ty {\n                    &mut self.#field_index\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let set_quote = |vis: TokenStream2| {\n        if need_setter {\n            quote! {\n                #vis fn #set_name(&mut self, val: #attr_ty) -> &mut Self {\n                    self.#field_index = val;\n                    self\n                }\n            }\n        } else {\n            quote! {}\n        }\n    };\n    let mut has_add_get: bool = false;\n    let mut has_add_get_mut: bool = false;\n    let mut has_add_set: bool = false;\n    for (_key, cfg_list) in &cfg_map {\n        for cfg in cfg_list {\n            if has_add_get && has_add_set && has_add_get_mut {\n                break;\n            }\n            if cfg.skip && cfg.func_type.is_unknown() {\n                continue;\n            }\n            let vis: TokenStream2 = cfg.visibility.to_token_stream();\n            if cfg.func_type.is_get() {\n                if !cfg.skip && !has_add_get {\n                    generated.extend(get_quote(vis.clone()));\n                }\n                has_add_get = true;\n            }\n            if cfg.func_type.is_get_mut() {\n                if !cfg.skip && !has_add_get_mut {\n                    generated.extend(get_mut_quote(vis.clone()));\n                }\n                has_add_get_mut = true;\n            }\n            if cfg.func_type.is_set() {\n                if !cfg.skip && !has_add_set {\n                    generated.extend(set_quote(vis.clone()));\n                }\n                has_add_set = true;\n            }\n        }\n    }\n    if !has_add_get || !has_add_set || !has_add_get_mut {\n        let cfg: Cfg = Cfg::default();\n        let vis: TokenStream2 = cfg.visibility.to_token_stream();\n        if !has_add_get {\n            generated.extend(get_quote(vis.clone()));\n        }\n        if !has_add_get_mut {\n            generated.extend(get_mut_quote(vis.clone()));\n        }\n        if !has_add_set {\n            generated.extend(set_quote(vis.clone()));\n        }\n    }\n    generated\n}\n\n/// Processes the input token stream to generate `Lombok`-style boilerplate code.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input tokens to be processed.\n/// - `bool` - Whether to generate getter functions.\n/// - `bool` - Whether to generate mutable getter functions.\n/// - `bool` - Whether to generate setter functions.\n///\n/// # Returns\n///\n/// - `TokenStream` - The transformed tokens with `Lombok`-style data code.\npub fn inner_lombok_data(\n    input: TokenStream,\n    need_getter: bool,\n    need_getter_mut: bool,\n    need_setter: bool,\n) -> TokenStream {\n    let input: DeriveInput = parse_macro_input!(input as DeriveInput);\n    let name: &Ident = &input.ident;\n    let type_bounds: Vec<TypeParam> = input\n        .generics\n        .params\n        .iter()\n        .filter_map(|param| {\n            if let GenericParam::Type(type_param) = param {\n                Some(type_param.clone())\n            } else {\n                None\n            }\n        })\n        .collect();\n    let types: Vec<Ident> = input\n        .generics\n        .params\n        .iter()\n        .filter_map(|param| {\n            if let GenericParam::Type(type_param) = param {\n                Some(type_param.ident.clone())\n            } else {\n                None\n            }\n        })\n        .collect();\n    let lifetimes: Vec<Lifetime> = input\n        .generics\n        .params\n        .iter()\n        .filter_map(|param| {\n            if let GenericParam::Lifetime(lifetime_param) = param {\n                Some(lifetime_param.lifetime.clone())\n            } else {\n                None\n            }\n        })\n        .collect();\n    let where_clause: &Option<WhereClause> = &input.generics.where_clause;\n    let methods: Vec<TokenStream2> = match input.data {\n        Data::Struct(ref s) => match &s.fields {\n            syn::Fields::Named(_) => s\n                .fields\n                .iter()\n                .map(|field| {\n                    generate_getter_setter(field, None, need_getter, need_getter_mut, need_setter)\n                })\n                .collect::<Vec<_>>(),\n            syn::Fields::Unnamed(_) => s\n                .fields\n                .iter()\n                .enumerate()\n                .map(|(index, field)| {\n                    generate_getter_setter(\n                        field,\n                        Some(index),\n                        need_getter,\n                        need_getter_mut,\n                        need_setter,\n                    )\n                })\n                .collect::<Vec<_>>(),\n            syn::Fields::Unit => Vec::new(),\n        },\n        _ => panic!(\"{}\", UNSUPPORTED_LOMBOK_DERIVE),\n    };\n    let expanded: TokenStream2 = if lifetimes.is_empty() {\n        if type_bounds.is_empty() {\n            quote! {\n                impl #name #where_clause {\n                    #(#methods)*\n                }\n            }\n        } else {\n            let type_bounds_generics: TokenStream2 = quote! { #(#type_bounds),* };\n            let type_generics: TokenStream2 = quote! { #(#types),* };\n            quote! {\n                impl<#type_bounds_generics> #name<#type_generics> #where_clause {\n                    #(#methods)*\n                }\n            }\n        }\n    } else {\n        let lifetimes_generics: TokenStream2 = quote! { #(#lifetimes),* };\n        if type_bounds.is_empty() {\n            quote! {\n                impl<#lifetimes_generics> #name<#lifetimes_generics> #where_clause {\n                    #(#methods)*\n                }\n            }\n        } else {\n            let type_bounds_generics: TokenStream2 = quote! { #(#type_bounds),* };\n            let type_generics: TokenStream2 = quote! { #(#types),* };\n            quote! {\n                impl<#lifetimes_generics, #type_bounds_generics> #name<#lifetimes_generics, #type_generics> #where_clause {\n                    #(#methods)*\n                }\n            }\n        }\n    };\n    expanded.into()\n}\n\n/// Implements the `std::fmt::Display` trait for a given struct or enum.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to parse.\n/// - `bool` - Whether to use detailed debug format.\n///\n/// # Returns\n///\n/// - `TokenStream` - The generated `Display` implementation.\npub(super) fn inner_display(input: TokenStream, is_format: bool) -> TokenStream {\n    let input: DeriveInput = parse_macro_input!(input as DeriveInput);\n    let name: &Ident = &input.ident;\n    let generics: &syn::Generics = &input.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n    let expanded: TokenStream2 = if is_format {\n        quote! {\n            impl #impl_generics std::fmt::Display for #name #ty_generics #where_clause {\n                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                    f.write_fmt(format_args!(\"{0:#?}\", self))\n                }\n            }\n        }\n    } else {\n        quote! {\n            impl #impl_generics std::fmt::Display for #name #ty_generics #where_clause {\n                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                    f.write_fmt(format_args!(\"{:?}\", self))\n                }\n            }\n        }\n    };\n    TokenStream::from(expanded)\n}\n\n/// Generates `Display` implementation with standard debug format.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to parse.\n///\n/// # Returns\n///\n/// - `TokenStream` - The generated `Display` implementation.\npub fn inner_display_debug(input: TokenStream) -> TokenStream {\n    inner_display(input, false)\n}\n\n/// Generates `Display` implementation with detailed debug format.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to parse.\n///\n/// # Returns\n///\n/// - `TokenStream` - The generated `Display` implementation.\npub fn inner_display_debug_format(input: TokenStream) -> TokenStream {\n    inner_display(input, true)\n}\n\n/// Generates a custom Debug implementation respecting `#[debug(skip)]`.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to parse.\n///\n/// # Returns\n///\n/// - `TokenStream` - The generated `Debug` implementation.\npub fn inner_custom_debug(input: TokenStream) -> TokenStream {\n    let input: DeriveInput = parse_macro_input!(input as DeriveInput);\n    let name: &Ident = &input.ident;\n    let generics: &syn::Generics = &input.generics;\n    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();\n    match &input.data {\n        Data::Struct(data_struct) => {\n            let fields: &syn::Fields = &data_struct.fields;\n            match fields {\n                syn::Fields::Named(_) => {\n                    let debug_fields: Vec<TokenStream2> = fields\n                        .iter()\n                        .filter_map(|field: &Field| {\n                            let field_name: &Ident = field.ident.as_ref()?;\n                            let mut should_skip: bool = false;\n                            for attr in &field.attrs {\n                                let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n                                if cfg.func_type.is_debug() && cfg.skip {\n                                    should_skip = true;\n                                    break;\n                                }\n                            }\n                            if should_skip {\n                                None\n                            } else {\n                                let field_name_str: String = field_name.to_string();\n                                Some(quote! {\n                                    .field(#field_name_str, &self.#field_name)\n                                })\n                            }\n                        })\n                        .collect();\n                    let struct_name_str: String = name.to_string();\n                    let expanded: TokenStream2 = quote! {\n                        impl #impl_generics std::fmt::Debug for #name #ty_generics #where_clause {\n                            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                                f.debug_struct(#struct_name_str)\n                                    #(#debug_fields)*\n                                    .finish()\n                            }\n                        }\n                    };\n                    TokenStream::from(expanded)\n                }\n                syn::Fields::Unnamed(_) => {\n                    let debug_fields: Vec<TokenStream2> = fields\n                        .iter()\n                        .enumerate()\n                        .filter_map(|(i, field): (usize, &Field)| {\n                            let mut should_skip: bool = false;\n                            for attr in &field.attrs {\n                                let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n                                if cfg.func_type.is_debug() && cfg.skip {\n                                    should_skip = true;\n                                    break;\n                                }\n                            }\n                            if should_skip {\n                                None\n                            } else {\n                                let field_index: syn::Index = syn::Index::from(i);\n                                Some(quote! {\n                                    .field(&self.#field_index)\n                                })\n                            }\n                        })\n                        .collect();\n                    let struct_name_str: String = name.to_string();\n                    let expanded: TokenStream2 = quote! {\n                        impl #impl_generics std::fmt::Debug for #name #ty_generics #where_clause {\n                            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                                f.debug_tuple(#struct_name_str)\n                                    #(#debug_fields)*\n                                    .finish()\n                            }\n                        }\n                    };\n                    TokenStream::from(expanded)\n                }\n                syn::Fields::Unit => {\n                    let struct_name_str: String = name.to_string();\n                    let expanded: TokenStream2 = quote! {\n                        impl #impl_generics std::fmt::Debug for #name #ty_generics #where_clause {\n                            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                                f.debug_struct(#struct_name_str).finish()\n                            }\n                        }\n                    };\n                    TokenStream::from(expanded)\n                }\n            }\n        }\n        Data::Enum(data_enum) => {\n            let variants: Vec<TokenStream2> = data_enum\n                .variants\n                .iter()\n                .map(|variant: &syn::Variant| {\n                    let variant_name: &Ident = &variant.ident;\n                    let variant_name_str: String = variant_name.to_string();\n                    match &variant.fields {\n                        syn::Fields::Named(fields_named) => {\n                            let field_patterns: Vec<TokenStream2> = fields_named\n                                .named\n                                .iter()\n                                .map(|field: &Field| {\n                                    let field_name: &Ident = field.ident.as_ref().unwrap();\n                                    quote! { #field_name }\n                                })\n                                .collect();\n                            let debug_fields: Vec<TokenStream2> = fields_named\n                                .named\n                                .iter()\n                                .filter_map(|field: &Field| {\n                                    let field_name: &Ident = field.ident.as_ref()?;\n                                    let mut should_skip: bool = false;\n                                    for attr in &field.attrs {\n                                        let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n                                        if cfg.func_type.is_debug() && cfg.skip {\n                                            should_skip = true;\n                                            break;\n                                        }\n                                    }\n                                    if should_skip {\n                                        None\n                                    } else {\n                                        let field_name_str: String = field_name.to_string();\n                                        Some(quote! {\n                                            .field(#field_name_str, #field_name)\n                                        })\n                                    }\n                                })\n                                .collect();\n                            quote! {\n                                #name::#variant_name { #(#field_patterns),* } => {\n                                    f.debug_struct(#variant_name_str)\n                                        #(#debug_fields)*\n                                        .finish()\n                                }\n                            }\n                        }\n                        syn::Fields::Unnamed(fields_unnamed) => {\n                            let field_patterns: Vec<TokenStream2> = fields_unnamed\n                                .unnamed\n                                .iter()\n                                .enumerate()\n                                .map(|(i, _): (usize, &Field)| {\n                                    let field_name: Ident = format_ident!(\"field_{}\", i);\n                                    quote! { #field_name }\n                                })\n                                .collect();\n                            let debug_fields: Vec<TokenStream2> = fields_unnamed\n                                .unnamed\n                                .iter()\n                                .enumerate()\n                                .filter_map(|(i, field): (usize, &Field)| {\n                                    let mut should_skip: bool = false;\n                                    for attr in &field.attrs {\n                                        let cfg: Cfg = analyze_attributes(attr.to_token_stream());\n                                        if cfg.func_type.is_debug() && cfg.skip {\n                                            should_skip = true;\n                                            break;\n                                        }\n                                    }\n                                    if should_skip {\n                                        None\n                                    } else {\n                                        let field_name: Ident = format_ident!(\"field_{}\", i);\n                                        Some(quote! {\n                                            .field(#field_name)\n                                        })\n                                    }\n                                })\n                                .collect();\n                            quote! {\n                                #name::#variant_name(#(#field_patterns),*) => {\n                                    f.debug_tuple(#variant_name_str)\n                                        #(#debug_fields)*\n                                        .finish()\n                                }\n                            }\n                        }\n                        syn::Fields::Unit => {\n                            quote! {\n                                #name::#variant_name => {\n                                    f.debug_struct(#variant_name_str).finish()\n                                }\n                            }\n                        }\n                    }\n                })\n                .collect();\n            let expanded: TokenStream2 = quote! {\n                impl #impl_generics std::fmt::Debug for #name #ty_generics #where_clause {\n                    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n                        match self {\n                            #(#variants)*\n                        }\n                    }\n                }\n            };\n            TokenStream::from(expanded)\n        }\n        Data::Union(_) => {\n            panic!(\"Debug derive is not supported for unions\")\n        }\n    }\n}", "file_size": 25667, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\generate\\const.rs", "language": "rust", "content": "/// Error message indicating that a field must have a name.\npub const FIELD_SHOULD_HAVE_A_NAME: &str = \"Field should have a name\";\n/// Prefix for getter methods.\npub const GET_METHOD_PREFIX: &str = \"get_\";\n/// Prefix for mutable getter methods.\npub const GET_MUT_METHOD_PREFIX: &str = \"get_mut_\";\n/// Prefix for setter methods.\npub const SET_METHOD_PREFIX: &str = \"set_\";\n/// Error message indicating that #[derive(Lombok)] is only supported for structs.\npub const UNSUPPORTED_LOMBOK_DERIVE: &str = \"#[derive(Lombok)] is only supported for structs.\";", "file_size": 550, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\visibility\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Visibility {\n    /// Converts the `Visibility` enum variant into a token stream representation.\n    ///\n    /// # Parameters\n    /// - `self`: The reference to the `Visibility` instance being converted.\n    ///\n    /// # Returns\n    /// - A `TokenStream2` representing the corresponding visibility modifier in Rust syntax.\n    pub fn to_token_stream(&self) -> TokenStream2 {\n        match self {\n            Visibility::Public => quote! { pub },\n            Visibility::PublicCrate => quote! { pub(crate) },\n            Visibility::PublicSuper => quote! { pub(super) },\n            Visibility::Private => quote! {},\n        }\n    }\n\n    /// Determines if the `Visibility` is public.\n    ///\n    /// # Parameters\n    /// - `self`: The reference to the `Visibility` instance being checked.\n    ///\n    /// # Returns\n    /// - `true` if the visibility is `Public`; otherwise, `false`.\n    pub fn is_public(&self) -> bool {\n        *self == Self::Public\n    }\n}", "file_size": 977, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\recoverable-spawn\\src\\lib.rs", "language": "rust", "content": "//! recoverable-spawn\n//!\n//! A thread that supports automatic recovery from panics,\n//! allowing threads to restart after a panic. Useful for resilient\n//! and fault-tolerant concurrency in network and web programming.\n\npub(crate) mod thread;\n\npub(crate) use std::panic::set_hook;\npub(crate) use std::sync::Arc;\n\npub use thread::{r#async, sync, r#trait::*, r#type::*};", "file_size": 369, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\parse\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Parses the provided token stream and modifies the given configuration.\n///\n/// # Parameters\n/// - `tokens`: A `TokenStream2` containing the tokens to be parsed.\n/// - `cfg`: A mutable reference to the `Cfg` structure that will be modified based on the parsed tokens.\n///\n/// # Returns\n/// - The function does not return a value. It modifies the provided `cfg` in place.\npub fn parse_tokens(tokens: TokenStream2, cfg: &mut Cfg) {\n    for token in tokens {\n        match token {\n            TokenTree2::Ident(ident) => {\n                let ident_str: String = ident.to_string();\n                if FuncType::is_known(&ident_str) {\n                    if cfg.func_type.is_unknown() {\n                        cfg.func_type = ident_str.parse::<FuncType>().unwrap_or_default();\n                    }\n                } else if ident_str == SKIP {\n                    cfg.skip = true;\n                } else if ident_str == PUBLIC {\n                    cfg.visibility = Visibility::Public;\n                } else if ident_str == PRIVATE {\n                    cfg.visibility = Visibility::Private;\n                } else if ident_str == PUBLIC_CRATE && cfg.visibility.is_public() {\n                    cfg.visibility = Visibility::PublicCrate;\n                } else if ident_str == PUBLIC_SUPER && cfg.visibility.is_public() {\n                    cfg.visibility = Visibility::PublicSuper;\n                }\n            }\n            TokenTree2::Group(group) => {\n                parse_tokens(group.stream(), cfg);\n            }\n            _ => {}\n        }\n    }\n}\n\n/// Analyzes the given token stream and returns a configuration based on the attributes found.\n///\n/// # Parameters\n/// - `tokens`: A `TokenStream2` containing the tokens representing the attributes to be analyzed.\n///\n/// # Returns\n/// - A `Cfg` structure representing the parsed configuration based on the attributes in the token stream.\npub fn analyze_attributes(tokens: TokenStream2) -> Cfg {\n    let mut cfg: Cfg = Cfg::default();\n    parse_tokens(tokens, &mut cfg);\n    cfg\n}", "file_size": 2060, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\debug\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"debug\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nlombok-macros = { path = \"../\" }", "file_size": 108, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\src\\time\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Leap Year\npub const LEAP_YEAR: [u64; 12] = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n/// Common Year\npub const COMMON_YEAR: [u64; 12] = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n/// Days\npub const DAYS: [&str; 7] = [\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\"];\n/// Months\npub const MONTHS: [&str; 12] = [\n    \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\",\n];\n\n/// Determines if a year is a leap year.\n///\n/// # Arguments\n///\n/// - `u64` - The year to check.\n///\n/// # Returns\n///\n/// - `bool` - Whether the year is a leap year.\npub fn is_leap_year(year: u64) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n}\n\n/// Gets the current time, including the date and time.\n///\n/// # Returns\n///\n/// - `String` - The formatted time as \"YYYY-MM-DD HH:MM:SS\"\npub fn time() -> String {\n    let (year, month, day, hour, minute, second, _, _) = calculate_time();\n    let mut date_time: String = String::new();\n    write!(\n        &mut date_time,\n        \"{:04}-{:02}-{:02} {:02}:{:02}:{:02}\",\n        year, month, day, hour, minute, second\n    )\n    .unwrap_or_default();\n    date_time\n}\n\n/// Gets the current day, without the time.\n///\n/// # Returns\n///\n/// - `String` - The formatted date as \"YYYY-MM-DD\"\npub fn date() -> String {\n    let (year, month, day, _, _, _, _, _) = calculate_time();\n    let mut date_time: String = String::new();\n    write!(&mut date_time, \"{:04}-{:02}-{:02}\", year, month, day).unwrap_or_default();\n    date_time\n}\n\n/// Computes the year, month, and day from days since Unix epoch (1970-01-01).\n///\n/// # Arguments\n///\n/// - `u64` - Number of days since Unix epoch.\n///\n/// # Returns\n///\n/// - `(u64, u64, u64)` - Tuple containing year, month and day.\npub fn compute_date(mut days_since_epoch: u64) -> (u64, u64, u64) {\n    let mut year: u64 = 1970;\n    loop {\n        let days_in_year: u64 = if is_leap_year(year) { 366 } else { 365 };\n        if days_since_epoch < days_in_year {\n            break;\n        }\n        days_since_epoch -= days_in_year as u64;\n        year += 1;\n    }\n    let mut month: u64 = 0;\n    for (i, &days) in COMMON_YEAR.iter().enumerate() {\n        let days_in_month = if i == 1 && is_leap_year(year) {\n            days + 1\n        } else {\n            days\n        };\n        if days_since_epoch < days_in_month as u64 {\n            month = i as u64 + 1;\n            return (year, month, (days_since_epoch + 1) as u64);\n        }\n        days_since_epoch -= days_in_month as u64;\n    }\n\n    (year, month, 1)\n}\n\n/// Gets the current date and time in GMT format.\n///\n/// # Returns\n///\n/// - `String` - The current date and time in GMT format.\npub fn gmt() -> String {\n    let now: SystemTime = SystemTime::now();\n    let duration_since_epoch: Duration = now.duration_since(UNIX_EPOCH).unwrap();\n    let timestamp: u64 = duration_since_epoch.as_secs();\n    let seconds_in_day: u64 = 86_400;\n    let days_since_epoch: u64 = timestamp / seconds_in_day;\n    let seconds_of_day: u64 = timestamp % seconds_in_day;\n    let hours: u64 = (seconds_of_day / 3600) as u64;\n    let minutes: u64 = ((seconds_of_day % 3600) / 60) as u64;\n    let seconds: u64 = (seconds_of_day % 60) as u64;\n    let (year, month, day) = compute_date(days_since_epoch);\n    let weekday: usize = ((days_since_epoch + 4) % 7) as usize;\n    format!(\n        \"{}, {:02} {} {} {:02}:{:02}:{:02} GMT\",\n        DAYS[weekday],\n        day,\n        MONTHS[month as usize - 1],\n        year,\n        hours,\n        minutes,\n        seconds\n    )\n}\n\n/// Gets the current year.\n///\n/// # Returns\n///\n/// - `u64` - The current year\npub fn year() -> u64 {\n    calculate_time().0\n}\n\n/// Gets the current month.\n///\n/// # Returns\n///\n/// - `u64` - The current month (1-12)\npub fn month() -> u64 {\n    calculate_time().1\n}\n\n/// Gets the current day.\n///\n/// # Returns\n///\n/// - `u64` - The current day of the month\npub fn day() -> u64 {\n    calculate_time().2\n}\n\n/// Gets the current hour.\n///\n/// # Returns\n///\n/// - `u64` - The current hour (0-23)\npub fn hour() -> u64 {\n    calculate_time().3\n}\n\n/// Gets the current minute.\n///\n/// # Returns\n///\n/// - `u64` - The current minute (0-59)\npub fn minute() -> u64 {\n    calculate_time().4\n}\n\n/// Gets the current second.\n///\n/// # Returns\n///\n/// - `u64` - The current second (0-59)\npub fn second() -> u64 {\n    calculate_time().5\n}\n\n/// Gets the current timestamp in milliseconds.\n///\n/// # Returns\n///\n/// - `u64` - The current timestamp in milliseconds since Unix epoch\npub fn millis() -> u64 {\n    calculate_time().6\n}\n\n/// Gets the current timestamp in microseconds.\n///\n/// # Returns\n///\n/// - `u64` - The current timestamp in microseconds since Unix epoch\npub fn micros() -> u64 {\n    calculate_time().7\n}\n\n/// Calculates the current year, month, day, hour, minute, second, millisecond and microsecond.\n///\n/// # Returns\n///\n/// - `(u64, u64, u64, u64, u64, u64, u64, u64)` - Tuple containing:\n///   - Year\n///   - Month\n///   - Day\n///   - Hour (0-23)\n///   - Minute (0-59)\n///   - Second (0-59)\n///   - Milliseconds in current second\n///   - Microseconds in current second\npub fn calculate_time() -> (u64, u64, u64, u64, u64, u64, u64, u64) {\n    let start: SystemTime = SystemTime::now();\n    let duration: Duration = start.duration_since(UNIX_EPOCH).unwrap();\n    let total_seconds: u64 = duration.as_secs();\n    let nanoseconds: u64 = duration.subsec_nanos() as u64;\n    let milliseconds: u64 = nanoseconds / 1_000_000;\n    let microseconds: u64 = nanoseconds / 1_000;\n    let mut total_days: u64 = total_seconds / 86400;\n    let mut year: u64 = 1970;\n    while total_days >= if is_leap_year(year) { 366 } else { 365 } {\n        total_days -= if is_leap_year(year) { 366 } else { 365 };\n        year += 1;\n    }\n    let mut month: u64 = 1;\n    let month_days: [u64; 12] = if is_leap_year(year) {\n        LEAP_YEAR\n    } else {\n        COMMON_YEAR\n    };\n    while total_days >= month_days[month as usize - 1] {\n        total_days -= month_days[month as usize - 1];\n        month += 1;\n    }\n    let day: u64 = total_days + 1;\n    let remaining_seconds: u64 = total_seconds % 86400;\n    let timezone_offset: u64 = from_env_var().value();\n    let hour: u64 = ((remaining_seconds + timezone_offset) / 3600) % 24;\n    let minute: u64 = (remaining_seconds % 3600) / 60;\n    let second: u64 = remaining_seconds % 60;\n    (\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second,\n        milliseconds,\n        microseconds,\n    )\n}\n\n/// Gets the current time with milliseconds, including the date and time.\n///\n/// # Returns\n///\n/// - `String` - The formatted time as \"YYYY-MM-DD HH:MM:SS.sss\"\npub fn time_millis() -> String {\n    let (year, month, day, hour, minute, second, millisecond, _) = calculate_time();\n    let mut date_time: String = String::new();\n    write!(\n        &mut date_time,\n        \"{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:03}\",\n        year, month, day, hour, minute, second, millisecond\n    )\n    .unwrap_or_default();\n    date_time\n}\n\n/// Gets the current time with microseconds, including the date and time.\n///\n/// # Returns\n///\n/// - `String` - The formatted time as \"YYYY-MM-DD HH:MM:SS.ssssss\"\npub fn time_micros() -> String {\n    let (year, month, day, hour, minute, second, _, microseconds) = calculate_time();\n    let mut date_time: String = String::new();\n    write!(\n        &mut date_time,\n        \"{:04}-{:02}-{:02} {:02}:{:02}:{:02}.{:06}\",\n        year, month, day, hour, minute, second, microseconds\n    )\n    .unwrap_or_default();\n    date_time\n}\n\n/// Gets the current timestamp in seconds since Unix epoch.\n///\n/// # Returns\n///\n/// - `u64` - The current timestamp in seconds\npub fn timestamp() -> u64 {\n    let timezone_offset: u64 = from_env_var().value();\n    SystemTime::now()\n        .duration_since(UNIX_EPOCH)\n        .unwrap()\n        .as_secs()\n        .saturating_add(timezone_offset)\n}\n\n/// Gets the current timestamp in milliseconds since Unix epoch.\n///\n/// # Returns\n///\n/// - `u64` - The current timestamp in milliseconds\npub fn timestamp_millis() -> u64 {\n    let timezone_offset: u64 = from_env_var().value();\n    let duration: Duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n    (duration.as_secs().saturating_add(timezone_offset)) * 1000 + duration.subsec_millis() as u64\n}\n\n/// Gets the current timestamp in microseconds since Unix epoch.\n///\n/// # Returns\n///\n/// - `u64` - The current timestamp in microseconds\npub fn timestamp_micros() -> u64 {\n    let timezone_offset: u64 = from_env_var().value();\n    let duration: Duration = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();\n    (duration.as_secs().saturating_add(timezone_offset)) * 1_000_000\n        + duration.subsec_micros() as u64\n}", "file_size": 8754, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\func\\enum.rs", "language": "rust", "content": "/// Represents the type of a function in the context of getter and setter methods.\n///\n/// # Variants\n/// - `Get`: Represents a getter function.\n/// - `GetMut`: Represents a mutable getter function.\n/// - `Set`: Represents a setter function.\n/// - `Debug`: Represents a debug function.\n/// - `Unknown`: Represents an unknown or unspecified function type.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum FuncType {\n    /// Represents a getter function.\n    Get,\n    /// Represents a mutable getter function.\n    GetMut,\n    /// Represents a setter function.\n    Set,\n    /// Represents a debug function.\n    Debug,\n    /// Represents an unknown or unspecified function type.\n    Unknown,\n}", "file_size": 688, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\parse\\const.rs", "language": "rust", "content": "/// Constant for the \"get\" function type.\npub const GET: &str = \"get\";\n/// Constant for the \"get_mut\" function type.\npub const GET_MUT: &str = \"get_mut\";\n/// Constant for the \"set\" function type.\npub const SET: &str = \"set\";\n/// Constant for the \"debug\" attribute.\npub const DEBUG: &str = \"debug\";\n/// Constant for the \"skip\" attribute.\npub const SKIP: &str = \"skip\";\n/// Constant for public visibility.\npub const PUBLIC: &str = \"pub\";\n/// Constant for private visibility.\npub const PRIVATE: &str = \"private\";\n/// Constant for crate-level visibility.\npub const PUBLIC_CRATE: &str = \"crate\";\n/// Constant for super-level visibility.\npub const PUBLIC_SUPER: &str = \"super\";", "file_size": 671, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\src\\time\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents supported languages.\n///\n/// Each variant corresponds to a specific language and locale combination.\n#[derive(Debug, Clone, PartialEq)]\npub enum Lang {\n    /// English (United States).\n    EnUsUtf8,\n    /// Chinese (China).\n    ZhCnUtf8,\n    /// French (France).\n    FrFrUtf8,\n    /// German (Germany).\n    DeDeUtf8,\n    /// Spanish (Spain).\n    EsEsUtf8,\n    /// Italian (Italy).\n    ItItUtf8,\n    /// Japanese (Japan).\n    JaJpUtf8,\n    /// Korean (South Korea).\n    KoKrUtf8,\n    /// Portuguese (Portugal).\n    PtPtUtf8,\n    /// Russian (Russia).\n    RuRuUtf8,\n    /// Arabic (Saudi Arabia).\n    ArSaUtf8,\n    /// Hindi (India).\n    HiInUtf8,\n    /// Thai (Thailand).\n    ThThUtf8,\n    /// Vietnamese (Vietnam).\n    ViVnUtf8,\n    /// Dutch (Netherlands).\n    NlNlUtf8,\n    /// Swedish (Sweden).\n    SvSeUtf8,\n    /// Finnish (Finland).\n    FiFiUtf8,\n}\n/// Implementation of Display trait for Lang.\n///\n/// Provides a human-readable string representation for each language variant.\nimpl fmt::Display for Lang {\n    /// Formats the language for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter` - The formatter to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - The result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        let lang_str: &str = match self {\n            Lang::EnUsUtf8 => \"English (US)\",\n            Lang::ZhCnUtf8 => \"中文 (中国)\",\n            Lang::FrFrUtf8 => \"Français (France)\",\n            Lang::DeDeUtf8 => \"Deutsch (Deutschland)\",\n            Lang::EsEsUtf8 => \"Español (España)\",\n            Lang::ItItUtf8 => \"Italiano (Italia)\",\n            Lang::JaJpUtf8 => \"日本語 (日本)\",\n            Lang::KoKrUtf8 => \"한국어 (한국)\",\n            Lang::PtPtUtf8 => \"Português (Portugal)\",\n            Lang::RuRuUtf8 => \"Русский (Россия)\",\n            Lang::ArSaUtf8 => \"العربية (السعودية)\",\n            Lang::HiInUtf8 => \"हिन्दी (भारत)\",\n            Lang::ThThUtf8 => \"ภาษาไทย (ประเทศไทย)\",\n            Lang::ViVnUtf8 => \"Tiếng Việt (Việt Nam)\",\n            Lang::NlNlUtf8 => \"Nederlands (Nederland)\",\n            Lang::SvSeUtf8 => \"Svenska (Sverige)\",\n            Lang::FiFiUtf8 => \"Suomi (Suomi)\",\n        };\n        write!(f, \"{}\", lang_str)\n    }\n}\nimpl Lang {\n    /// Returns the UTC offset in seconds for the corresponding language.\n    ///\n    /// Each language is associated with a specific UTC offset,\n    /// indicating the difference from Coordinated Universal Time (UTC).\n    ///\n    /// # Returns\n    ///\n    /// - `u64` - The UTC offset in seconds.\n    pub fn value(&self) -> u64 {\n        match self {\n            Lang::EnUsUtf8 => 0,     // UTC\n            Lang::ZhCnUtf8 => 28800, // UTC+8\n            Lang::FrFrUtf8 => 3600,  // UTC+1\n            Lang::DeDeUtf8 => 3600,  // UTC+1\n            Lang::EsEsUtf8 => 3600,  // UTC+1\n            Lang::ItItUtf8 => 3600,  // UTC+1\n            Lang::JaJpUtf8 => 32400, // UTC+9\n            Lang::KoKrUtf8 => 32400, // UTC+9\n            Lang::PtPtUtf8 => 3600,  // UTC+1\n            Lang::RuRuUtf8 => 10800, // UTC+3\n            Lang::ArSaUtf8 => 10800, // UTC+3\n            Lang::HiInUtf8 => 19800, // UTC+5:30\n            Lang::ThThUtf8 => 25200, // UTC+7\n            Lang::ViVnUtf8 => 25200, // UTC+7\n            Lang::NlNlUtf8 => 3600,  // UTC+1\n            Lang::SvSeUtf8 => 3600,  // UTC+1\n            Lang::FiFiUtf8 => 3600,  // UTC+1\n        }\n    }\n}\n\n/// Implementation of Default trait for Lang.\n///\n/// Provides a default value for the Lang enum.\nimpl Default for Lang {\n    /// Returns the default language.\n    ///\n    /// # Returns\n    ///\n    /// - `Lang` - The default language (Chinese/China).\n    fn default() -> Self {\n        Lang::ZhCnUtf8\n    }\n}\n/// Implementation of FromStr trait for Lang.\n///\n/// Allows parsing a string into a Lang variant.\nimpl FromStr for Lang {\n    /// The error type for parsing operations.\n    type Err = ();\n\n    /// Parses a string into a Lang variant.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The string to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Self, Self::Err>` - The parsed Lang variant or an error.\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        match s {\n            \"en_US.UTF-8\" => Ok(Lang::EnUsUtf8),\n            \"zh_CN.UTF-8\" => Ok(Lang::ZhCnUtf8),\n            \"fr_FR.UTF-8\" => Ok(Lang::FrFrUtf8),\n            \"de_DE.UTF-8\" => Ok(Lang::DeDeUtf8),\n            \"es_ES.UTF-8\" => Ok(Lang::EsEsUtf8),\n            \"it_IT.UTF-8\" => Ok(Lang::ItItUtf8),\n            \"ja_JP.UTF-8\" => Ok(Lang::JaJpUtf8),\n            \"ko_KR.UTF-8\" => Ok(Lang::KoKrUtf8),\n            \"pt_PT.UTF-8\" => Ok(Lang::PtPtUtf8),\n            \"ru_RU.UTF-8\" => Ok(Lang::RuRuUtf8),\n            \"ar_SA.UTF-8\" => Ok(Lang::ArSaUtf8),\n            \"hi_IN.UTF-8\" => Ok(Lang::HiInUtf8),\n            \"th_TH.UTF-8\" => Ok(Lang::ThThUtf8),\n            \"vi_VN.UTF-8\" => Ok(Lang::ViVnUtf8),\n            \"nl_NL.UTF-8\" => Ok(Lang::NlNlUtf8),\n            \"sv_SE.UTF-8\" => Ok(Lang::SvSeUtf8),\n            \"fi_FI.UTF-8\" => Ok(Lang::FiFiUtf8),\n            _ => Err(()),\n        }\n    }\n}\n\n/// Gets the time zone offset from the system environment variable.\n///\n/// This function retrieves the `LANG` environment variable and attempts to\n/// parse it into a `Lang` value. If the variable is not set or cannot be\n/// parsed, it defaults to `Lang::EnUsUtf8`.\n///\n/// # Returns\n///\n/// - `Lang` - The corresponding `Lang` value based on the `LANG` environment variable.\npub fn from_env_var() -> Lang {\n    let lang: Lang = env::var(\"LANG\")\n        .unwrap_or_default()\n        .parse::<Lang>()\n        .unwrap_or_default();\n    lang\n}", "file_size": 5665, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\src\\lib.rs", "language": "rust", "content": "//! hyperlane-time\n//!\n//! A library for fetching the current time based on the system's locale settings.\n\npub(crate) mod time;\n\npub use time::r#fn::*;\n\npub(crate) use time::r#enum::from_env_var;\n\npub(crate) use std::{\n    env, fmt,\n    fmt::Write,\n    str::FromStr,\n    time::{Duration, SystemTime, UNIX_EPOCH},\n};", "file_size": 315, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\debug\\src\\main.rs", "language": "rust", "content": "#![allow(warnings)]\n\nuse lombok_macros::*;\nuse std::fmt::Debug;\n\n#[derive(Data, Debug, Clone, DisplayDebugFormat)]\nstruct LombokTest<'a, T: Clone + Debug> {\n    #[get(pub(crate))]\n    #[set(pub(crate))]\n    list: Vec<String>,\n    #[get(pub(crate))]\n    opt_value: Option<&'a T>,\n    #[get_mut(pub(crate))]\n    #[set(private)]\n    name: String,\n}\n\n#[derive(CustomDebug)]\nstruct User {\n    name: String,\n    #[debug(skip)]\n    password: String,\n    email: String,\n}\n\n#[derive(Data, Debug, Clone)]\nstruct TupleStruct(\n    #[get(pub)] String,\n    #[set(pub)] i32,\n    #[get(pub)]\n    #[set(pub)]\n    bool,\n);\n\n#[derive(CustomDebug)]\nenum Response {\n    Success {\n        data: String,\n    },\n    Error {\n        message: String,\n        #[debug(skip)]\n        internal_code: u32,\n    },\n}\n\nfn main() {\n    let mut data: LombokTest<usize> = LombokTest {\n        list: Vec::new(),\n        opt_value: None,\n        name: \"test\".to_string(),\n    };\n    let list: Vec<String> = vec![\"hello\".to_string(), \"world\".to_string()];\n    data.set_list(list.clone());\n    assert_eq!(*data.get_list(), list);\n    let opt_value: &Option<&usize> = data.get_opt_value();\n    assert_eq!(*opt_value, None);\n    let name_mut: &mut String = data.get_mut_name();\n    *name_mut = \"updated\".to_string();\n    assert!(!data.to_string().is_empty());\n    let mut tuple_data: TupleStruct = TupleStruct(\"hello\".to_string(), 42, true);\n    let field0: &String = tuple_data.get_0();\n    assert_eq!(field0, \"hello\");\n    tuple_data.set_1(100);\n    let field2: &bool = tuple_data.get_2();\n    assert_eq!(*field2, true);\n    tuple_data.set_2(false);\n    let user: User = User {\n        name: \"Alice\".to_string(),\n        password: \"secret123\".to_string(),\n        email: \"alice@example.com\".to_string(),\n    };\n    let user_debug: String = format!(\"{:?}\", user);\n    assert!(user_debug.contains(\"Alice\"));\n    assert!(user_debug.contains(\"alice@example.com\"));\n    assert!(!user_debug.contains(\"secret123\"));\n    let success: Response = Response::Success {\n        data: \"Operation completed\".to_string(),\n    };\n    let success_debug: String = format!(\"{:?}\", success);\n    assert!(success_debug.contains(\"Operation completed\"));\n    let error: Response = Response::Error {\n        message: \"Something went wrong\".to_string(),\n        internal_code: 500,\n    };\n    let error_debug: String = format!(\"{:?}\", error);\n    assert!(error_debug.contains(\"Something went wrong\"));\n    assert!(!error_debug.contains(\"500\"));\n}", "file_size": 2480, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a WebSocket instance.\n///\n/// This struct manages broadcast capabilities and holds the internal broadcast map\n/// responsible for handling message distribution to various WebSocket connections.\n#[derive(Debug, Clone)]\npub struct WebSocket {\n    /// The internal broadcast map.\n    ///\n    /// This map is used for managing WebSocket message distribution.\n    pub(super) broadcast_map: BroadcastMap<Vec<u8>>,\n}\n\n/// Configuration for a WebSocket connection.\n///\n/// This struct encapsulates all necessary parameters for setting up and managing\n/// a WebSocket connection, including context, buffer sizes, capacity, broadcast type,\n/// and various hook functions for different lifecycle events.\n///\n/// # Type Parameters\n///\n/// - `B`: The type used for broadcast keys, which must implement `BroadcastTypeTrait`.\n#[derive(Clone)]\npub struct WebSocketConfig<B: BroadcastTypeTrait> {\n    /// The Hyperlane context.\n    ///\n    /// This context is associated with this WebSocket connection.\n    pub(super) context: Context,\n    /// The buffer size.\n    ///\n    /// This is the size of the buffer used for reading from the WebSocket stream.\n    pub(super) buffer_size: usize,\n    /// The capacity.\n    ///\n    /// This is the capacity of the broadcast sender channel.\n    pub(super) capacity: Capacity,\n    /// The broadcast type.\n    ///\n    /// This defines the type of broadcast this WebSocket connection will participate in\n    /// (point-to-point or point-to-group).\n    pub(super) broadcast_type: BroadcastType<B>,\n    /// The request hook function.\n    ///\n    /// This hook is executed when a new request is received on the WebSocket.\n    pub(super) request_hook: ArcFnContextPinBoxSendSync<()>,\n    /// The sended hook function.\n    ///\n    /// This hook is executed after a message has been successfully sent over the WebSocket.\n    pub(super) sended_hook: ArcFnContextPinBoxSendSync<()>,\n    /// The closed hook function.\n    ///\n    /// This hook is executed when the WebSocket connection is closed.\n    pub(super) closed_hook: ArcFnContextPinBoxSendSync<()>,\n}", "file_size": 2097, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\src\\time\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_lang() {\n    use crate::time::r#enum::from_env_var;\n    println!(\"test_lang: {}\", from_env_var());\n}\n\n#[test]\nfn test_now_time() {\n    use crate::*;\n    println!(\"test_now_time: {}\", time());\n}\n\n#[test]\nfn test_methods() {\n    use crate::*;\n\n    println!(\"Current Time: {}\", time());\n    println!(\"Current Date: {}\", date());\n    println!(\"GMT Date: {}\", gmt());\n    println!(\"Timestamp (s): {}\", timestamp());\n    println!(\"Timestamp (ms): {}\", timestamp_millis());\n    println!(\"Timestamp (μs): {}\", timestamp_micros());\n    println!(\"Current Year: {}\", year());\n    println!(\"Current Month: {}\", month());\n    println!(\"Current Day: {}\", day());\n    println!(\"Current Hour: {}\", hour());\n    println!(\"Current Minute: {}\", minute());\n    println!(\"Current Second: {}\", second());\n    println!(\"Current Millis: {}\", millis());\n    println!(\"Current Micros: {}\", micros());\n    println!(\"Is Leap Year (1949): {}\", is_leap_year(1949));\n    println!(\"Calculate Current Time: {:?}\", calculate_time());\n    println!(\"Compute Date (10000 days): {:?}\", compute_date(10000));\n    println!(\"Current Time with Millis: {}\", time_millis());\n    println!(\"Current Time with Micros: {}\", time_micros());\n}", "file_size": 1209, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\cfg.rs", "language": "rust", "content": "use crate::*;\n\n#[tokio::test]\nasync fn test() {\n    static BROADCAST_MAP: OnceLock<WebSocket> = OnceLock::new();\n\n    fn get_broadcast_map() -> &'static WebSocket {\n        BROADCAST_MAP.get_or_init(|| WebSocket::new())\n    }\n\n    async fn connected_hook(ctx: Context) {\n        let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n        let broadcast_type: BroadcastType<String> = BroadcastType::PointToGroup(group_name);\n        let receiver_count: ReceiverCount =\n            get_broadcast_map().receiver_count_after_increment(broadcast_type.clone());\n        let data: String = format!(\"receiver_count => {:?}\", receiver_count).into();\n        tokio::spawn(async move {\n            tokio::task::yield_now().await;\n            get_broadcast_map()\n                .send(broadcast_type, data.clone())\n                .unwrap_or_else(|err| {\n                    println!(\"[connected_hook]send error => {:?}\", err.to_string());\n                    None\n                });\n        });\n        println!(\"[connected_hook]receiver_count => {:?}\", receiver_count);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn group_chat_hook(ws_ctx: Context) {\n        let group_name: String = ws_ctx.get_route_param(\"group_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToGroup(group_name);\n        let mut receiver_count: ReceiverCount = get_broadcast_map().receiver_count(key.clone());\n        let mut body: RequestBody = ws_ctx.get_request_body().await;\n        if body.is_empty() {\n            receiver_count = get_broadcast_map().receiver_count_after_decrement(key);\n            body = format!(\"receiver_count => {:?}\", receiver_count).into();\n        }\n        ws_ctx.set_response_body(body).await;\n        println!(\"[group_chat]receiver_count => {:?}\", receiver_count);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn group_closed(ctx: Context) {\n        let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToGroup(group_name);\n        let receiver_count: ReceiverCount =\n            get_broadcast_map().receiver_count_after_decrement(key.clone());\n        let body: String = format!(\"receiver_count => {:?}\", receiver_count);\n        ctx.set_response_body(body).await;\n        println!(\"[group_closed]receiver_count => {:?}\", receiver_count);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn private_chat_hook(ctx: Context) {\n        let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n        let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToPoint(my_name, your_name);\n        let mut receiver_count: ReceiverCount = get_broadcast_map().receiver_count(key.clone());\n        let mut body: RequestBody = ctx.get_request_body().await;\n        if body.is_empty() {\n            receiver_count = get_broadcast_map().receiver_count_after_decrement(key);\n            body = format!(\"receiver_count => {:?}\", receiver_count).into();\n        }\n        ctx.set_response_body(body).await;\n        println!(\"[private_chat]receiver_count => {:?}\", receiver_count);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn private_closed(ctx: Context) {\n        let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n        let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToPoint(my_name, your_name);\n        let receiver_count: ReceiverCount = get_broadcast_map().receiver_count_after_decrement(key);\n        let body: String = format!(\"receiver_count => {:?}\", receiver_count);\n        ctx.set_response_body(body).await;\n        println!(\"[private_closed]receiver_count => {:?}\", receiver_count);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn sended(ctx: Context) {\n        let msg: String = ctx.get_response_body_string().await;\n        println!(\"[sended_hook]msg => {}\", msg);\n        let _ = std::io::Write::flush(&mut std::io::stderr());\n    }\n\n    async fn private_chat(ctx: Context) {\n        let my_name: String = ctx.get_route_param(\"my_name\").await.unwrap();\n        let your_name: String = ctx.get_route_param(\"your_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToPoint(my_name, your_name);\n        let config: WebSocketConfig<String> = WebSocketConfig::new()\n            .set_context(ctx.clone())\n            .set_broadcast_type(key)\n            .set_buffer_size(4096)\n            .set_capacity(1024)\n            .set_request_hook(private_chat_hook)\n            .set_sended_hook(sended)\n            .set_closed_hook(private_closed);\n        get_broadcast_map().run(config).await;\n    }\n\n    async fn group_chat(ctx: Context) {\n        let group_name: String = ctx.get_route_param(\"group_name\").await.unwrap();\n        let key: BroadcastType<String> = BroadcastType::PointToGroup(group_name);\n        let config: WebSocketConfig<String> = WebSocketConfig::new()\n            .set_context(ctx.clone())\n            .set_broadcast_type(key)\n            .set_buffer_size(4096)\n            .set_capacity(1024)\n            .set_request_hook(group_chat_hook)\n            .set_sended_hook(sended)\n            .set_closed_hook(group_closed);\n        get_broadcast_map().run(config).await;\n    }\n\n    async fn main() {\n        let server: Server = Server::new().await;\n        let config: ServerConfig = ServerConfig::new().await;\n        config.host(\"0.0.0.0\").await;\n        config.port(60000).await;\n        config.enable_nodelay().await;\n        config.http_buffer(4096).await;\n        config.ws_buffer(4096).await;\n        server.config(config).await;\n        server.disable_ws_hook(\"/{group_name}\").await;\n        server.route(\"/{group_name}\", group_chat).await;\n        server.disable_ws_hook(\"/{my_name}/{your_name}\").await;\n        server.route(\"/{my_name}/{your_name}\", private_chat).await;\n        server.connected_hook(connected_hook).await;\n        let server_hook: ServerHook = server.run().await.unwrap_or_default();\n        let server_hook_clone: ServerHook = server_hook.clone();\n        tokio::spawn(async move {\n            tokio::time::sleep(std::time::Duration::from_secs(60)).await;\n            server_hook.shutdown().await;\n        });\n        server_hook_clone.wait().await;\n    }\n\n    let _ = tokio::time::timeout(std::time::Duration::from_secs(60), main()).await;\n}", "file_size": 6624, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\closed\\mod.rs", "language": "rust", "content": "mod r#fn;\n\npub(crate) use r#fn::*;", "file_size": 34, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Allows `String` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for String {}\n/// Allows string slices to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &str {}\n/// Allows `char` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for char {}\n/// Allows `bool` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for bool {}\n/// Allows `i8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for i8 {}\n/// Allows `i16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for i16 {}\n/// Allows `i32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for i32 {}\n/// Allows `i64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for i64 {}\n/// Allows `i128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for i128 {}\n/// Allows `isize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for isize {}\n/// Allows `u8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for u8 {}\n/// Allows `u16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for u16 {}\n/// Allows `u32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for u32 {}\n/// Allows `u64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for u64 {}\n/// Allows `u128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for u128 {}\n/// Allows `usize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for usize {}\n/// Allows `f32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for f32 {}\n/// Allows `f64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for f64 {}\n/// Allows `IpAddr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for IpAddr {}\n/// Allows `Ipv4Addr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for Ipv4Addr {}\n/// Allows `Ipv6Addr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for Ipv6Addr {}\n/// Allows `SocketAddr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for SocketAddr {}\n/// Allows `NonZeroU8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroU8 {}\n/// Allows `NonZeroU16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroU16 {}\n/// Allows `NonZeroU32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroU32 {}\n/// Allows `NonZeroU64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroU64 {}\n/// Allows `NonZeroU128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroU128 {}\n/// Allows `NonZeroUsize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroUsize {}\n/// Allows `NonZeroI8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroI8 {}\n/// Allows `NonZeroI16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroI16 {}\n/// Allows `NonZeroI32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroI32 {}\n/// Allows `NonZeroI64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroI64 {}\n/// Allows `NonZeroI128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroI128 {}\n/// Allows `NonZeroIsize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for NonZeroIsize {}\n/// Allows `Infallible` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for Infallible {}\n\n/// Allows references to `String` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &String {}\n/// Allows double references to string slices to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &&str {}\n/// Allows references to `char` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &char {}\n/// Allows references to `bool` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &bool {}\n/// Allows references to `i8` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &i8 {}\n/// Allows references to `i16` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &i16 {}\n/// Allows references to `i32` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &i32 {}\n/// Allows references to `i64` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &i64 {}\n/// Allows references to `i128` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &i128 {}\n/// Allows references to `isize` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &isize {}\n/// Allows references to `u8` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &u8 {}\n/// Allows references to `u16` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &u16 {}\n/// Allows references to `u32` to be used as broadcast identifiers.\nimpl BroadcastTypeTrait for &u32 {}\n/// Allows references to `u64` to be used as\n/// Implements `BroadcastTypeTrait` for `&u128`.\n///\n/// This allows references to `u128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &u128 {}\n/// Implements `BroadcastTypeTrait` for `&usize`.\n///\n/// This allows references to `usize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &usize {}\n/// Implements `BroadcastTypeTrait` for `&f32`.\n///\n/// This allows references to `f32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &f32 {}\n/// Implements `BroadcastTypeTrait` for `&f64`.\n///\n/// This allows references to `f64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &f64 {}\n/// Implements `BroadcastTypeTrait` for `&IpAddr`.\n///\n/// This allows references to `IpAddr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &IpAddr {}\n/// Implements `BroadcastTypeTrait` for `&Ipv4Addr`.\n///\n/// This allows references to `Ipv4Addr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &Ipv4Addr {}\n/// Implements `BroadcastTypeTrait` for `&Ipv6Addr`.\n///\n/// This allows references to `Ipv6Addr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &Ipv6Addr {}\n/// Implements `BroadcastTypeTrait` for `&SocketAddr`.\n///\n/// This allows references to `SocketAddr` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &SocketAddr {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroU8`.\n///\n/// This allows references to `NonZeroU8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroU8 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroU16`.\n///\n/// This allows references to `NonZeroU16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroU16 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroU32`.\n///\n/// This allows references to `NonZeroU32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroU32 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroU64`.\n///\n/// This allows references to `NonZeroU64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroU64 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroU128`.\n///\n/// This allows references to `NonZeroU128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroU128 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroUsize`.\n///\n/// This allows references to `NonZeroUsize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroUsize {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroI8`.\n///\n/// This allows references to `NonZeroI8` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroI8 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroI16`.\n///\n/// This allows references to `NonZeroI16` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroI16 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroI32`.\n///\n/// This allows references to `NonZeroI32` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroI32 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroI64`.\n///\n/// This allows references to `NonZeroI64` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroI64 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroI128`.\n///\n/// This allows references to `NonZeroI128` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroI128 {}\n/// Implements `BroadcastTypeTrait` for `&NonZeroIsize`.\n///\n/// This allows references to `NonZeroIsize` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &NonZeroIsize {}\n/// Implements `BroadcastTypeTrait` for `&Infallible`.\n///\n/// This allows references to `Infallible` to be used as a broadcast identifier.\nimpl BroadcastTypeTrait for &Infallible {}\n\n/// Implements the `Default` trait for `BroadcastType`.\n///\n/// The default value is `BroadcastType::Unknown`.\n///\n/// # Type Parameters\n///\n/// - `B`: The type parameter for `BroadcastType`, which must implement `BroadcastTypeTrait`.\nimpl<B: BroadcastTypeTrait> Default for BroadcastType<B> {\n    fn default() -> Self {\n        BroadcastType::Unknown\n    }\n}\n\nimpl<B: BroadcastTypeTrait> BroadcastType<B> {\n    /// Generates a unique key string for a given broadcast type.\n    ///\n    /// For point-to-point types, the keys are sorted to ensure consistent key generation\n    /// regardless of the order of the input keys.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type for which to generate the key.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The unique key string for the broadcast type.\n    pub fn get_key(broadcast_type: BroadcastType<B>) -> String {\n        match broadcast_type {\n            BroadcastType::PointToPoint(key1, key2) => {\n                let (first_key, second_key) = if key1 <= key2 {\n                    (key1, key2)\n                } else {\n                    (key2, key1)\n                };\n                format!(\n                    \"{}-{}-{}\",\n                    POINT_TO_POINT_KEY,\n                    first_key.to_string(),\n                    second_key.to_string()\n                )\n            }\n            BroadcastType::PointToGroup(key) => {\n                format!(\"{}-{}\", POINT_TO_GROUP_KEY, key.to_string())\n            }\n            BroadcastType::Unknown => String::new(),\n        }\n    }\n}\n\n/// Implements the `Default` trait for `WebSocketConfig`.\n///\n/// Provides a default configuration for WebSocket connections, including\n/// default hook functions that do nothing.\n///\n/// # Type Parameters\n///\n/// - `B`: The type parameter for `WebSocketConfig`, which must implement `BroadcastTypeTrait`.\nimpl<B: BroadcastTypeTrait> Default for WebSocketConfig<B> {\n    fn default() -> Self {\n        let default_hook: ArcFnContextPinBoxSendSync<()> = Arc::new(move |_| Box::pin(async {}));\n        Self {\n            context: Context::default(),\n            buffer_size: DEFAULT_BUFFER_SIZE,\n            capacity: DEFAULT_BROADCAST_SENDER_CAPACITY,\n            broadcast_type: BroadcastType::default(),\n            request_hook: default_hook.clone(),\n            sended_hook: default_hook.clone(),\n            closed_hook: default_hook,\n        }\n    }\n}\n\nimpl<B: BroadcastTypeTrait> WebSocketConfig<B> {\n    /// Creates a new WebSocket configuration with default values.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketConfig<B>` - A new WebSocket configuration instance.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the buffer size for the WebSocket connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The desired buffer size in bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketConfig<B>` - The modified WebSocket configuration instance.\n    pub fn set_buffer_size(mut self, buffer_size: usize) -> Self {\n        self.buffer_size = buffer_size;\n        self\n    }\n\n    /// Sets the capacity for the broadcast sender.\n    ///\n    /// # Arguments\n    ///\n    /// - `Capacity` - The desired capacity.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketConfig<B>` - The modified WebSocket configuration instance.\n    pub fn set_capacity(mut self, capacity: Capacity) -> Self {\n        self.capacity = capacity;\n        self\n    }\n\n    /// Sets the context for the WebSocket connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `Context` - The context object to associate with the WebSocket.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketConfig<B>` - The modified WebSocket configuration instance.\n    pub fn set_context(mut self, context: Context) -> Self {\n        self.context = context;\n        self\n    }\n\n    /// Sets the broadcast type for the WebSocket connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type to use for this WebSocket.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketConfig<B>` - The modified WebSocket configuration instance.\n    pub fn set_broadcast_type(mut self, broadcast_type: BroadcastType<B>) -> Self {\n        self.broadcast_type = broadcast_type;\n        self\n    }\n\n    /// Sets the request hook function.\n    ///\n    /// This hook is executed when a new request is received.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `F`: The type of the function, which must be `Fn(Context) -> Fut + Send + Sync + 'static`.\n    /// - `Fut`: The future returned by the function, which must be `Future<Output = ()> + Send + 'static`.\n    ///\n    /// # Arguments\n    ///\n    /// - `hook` - The function to be used as the request hook.\n    ///\n    /// # Returns\n    ///\n    /// The modified WebSocket configuration instance.\n    pub fn set_request_hook<F, Fut>(mut self, hook: F) -> Self\n    where\n        F: Fn(Context) -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.request_hook = Arc::new(move |ctx| Box::pin(hook(ctx)));\n        self\n    }\n\n    /// Sets the sended hook function.\n    ///\n    /// This hook is executed after a message has been sent.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `F`: The type of the function, which must be `Fn(Context) -> Fut + Send + Sync + 'static`.\n    /// - `Fut`: The future returned by the function, which must be `Future<Output = ()> + Send + 'static`.\n    ///\n    /// # Arguments\n    ///\n    /// - `hook` - The function to be used as the sended hook.\n    ///\n    /// # Returns\n    ///\n    /// The modified WebSocket configuration instance.\n    pub fn set_sended_hook<F, Fut>(mut self, hook: F) -> Self\n    where\n        F: Fn(Context) -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.sended_hook = Arc::new(move |ctx| Box::pin(hook(ctx)));\n        self\n    }\n\n    /// Sets the closed hook function.\n    ///\n    /// This hook is executed when the WebSocket connection is closed.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `F`: The type of the function, which must be `Fn(Context) -> Fut + Send + Sync + 'static`.\n    /// - `Fut`: The future returned by the function, which must be `Future<Output = ()> + Send + 'static`.\n    ///\n    /// # Arguments\n    ///\n    /// - `hook` - The function to be used as the closed hook.\n    ///\n    /// # Returns\n    ///\n    /// The modified WebSocket configuration instance.\n    pub fn set_closed_hook<F, Fut>(mut self, hook: F) -> Self\n    where\n        F: Fn(Context) -> Fut + Send + Sync + 'static,\n        Fut: Future<Output = ()> + Send + 'static,\n    {\n        self.closed_hook = Arc::new(move |ctx| Box::pin(hook(ctx)));\n        self\n    }\n\n    /// Retrieves a reference to the context associated with this configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `&Context` - A reference to the context object.\n    pub fn get_context(&self) -> &Context {\n        &self.context\n    }\n\n    /// Retrieves the buffer size configured for the WebSocket connection.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The buffer size in bytes.\n    pub fn get_buffer_size(&self) -> usize {\n        self.buffer_size\n    }\n\n    /// Retrieves the capacity configured for the broadcast sender.\n    ///\n    /// # Returns\n    ///\n    /// - `Capacity` - The capacity.\n    pub fn get_capacity(&self) -> Capacity {\n        self.capacity\n    }\n\n    /// Retrieves a reference to the broadcast type configured for this WebSocket.\n    ///\n    /// # Returns\n    ///\n    /// - `&BroadcastType<B>` - A reference to the broadcast type object.\n    pub fn get_broadcast_type(&self) -> &BroadcastType<B> {\n        &self.broadcast_type\n    }\n\n    /// Retrieves a reference to the request hook function.\n    ///\n    /// # Returns\n    ///\n    /// - `&ArcFnContextPinBoxSendSync<()>` - A reference to the request hook.\n    pub fn get_request_hook(&self) -> &ArcFnContextPinBoxSendSync<()> {\n        &self.request_hook\n    }\n\n    /// Retrieves a reference to the sended hook function.\n    ///\n    /// # Returns\n    ///\n    /// - `&ArcFnContextPinBoxSendSync<()>` - A reference to the sended hook.\n    pub fn get_sended_hook(&self) -> &ArcFnContextPinBoxSendSync<()> {\n        &self.sended_hook\n    }\n\n    /// Retrieves a reference to the closed hook function.\n    ///\n    /// # Returns\n    ///\n    /// - `&ArcFnContextPinBoxSendSync<()>` - A reference to the closed hook.\n    pub fn get_closed_hook(&self) -> &ArcFnContextPinBoxSendSync<()> {\n        &self.closed_hook\n    }\n}\n\nimpl WebSocket {\n    /// Creates a new WebSocket instance.\n    ///\n    /// Initializes with a default broadcast map.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocket` - A new WebSocket instance.\n    pub fn new() -> Self {\n        Self {\n            broadcast_map: BroadcastMap::default(),\n        }\n    }\n\n    /// Subscribes to a broadcast type or inserts a new one if it doesn't exist.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type to subscribe to.\n    /// - `Capacity` - The capacity for the broadcast sender if a new one is inserted.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMapReceiver<Vec<u8>>` - A broadcast map receiver for the specified broadcast type.\n    fn subscribe_unwrap_or_insert<B: BroadcastTypeTrait>(\n        &self,\n        broadcast_type: BroadcastType<B>,\n        capacity: Capacity,\n    ) -> BroadcastMapReceiver<Vec<u8>> {\n        let key: String = BroadcastType::get_key(broadcast_type);\n        self.broadcast_map.subscribe_or_insert(&key, capacity)\n    }\n\n    /// Subscribes to a point-to-point broadcast.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&B` - The first identifier for the point-to-point communication.\n    /// - `&B` - The second identifier for the point-to-point communication.\n    /// - `Capacity` - The capacity for the broadcast sender.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMapReceiver<Vec<u8>>` - A broadcast map receiver for the point-to-point broadcast.\n    fn point_to_point<B: BroadcastTypeTrait>(\n        &self,\n        key1: &B,\n        key2: &B,\n        capacity: Capacity,\n    ) -> BroadcastMapReceiver<Vec<u8>> {\n        self.subscribe_unwrap_or_insert(\n            BroadcastType::PointToPoint(key1.clone(), key2.clone()),\n            capacity,\n        )\n    }\n\n    /// Subscribes to a point-to-group broadcast.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&B` - The identifier for the group.\n    /// - `Capacity` - The capacity for the broadcast sender.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMapReceiver<Vec<u8>>` - A broadcast map receiver for the point-to-group broadcast.\n    fn point_to_group<B: BroadcastTypeTrait>(\n        &self,\n        key: &B,\n        capacity: Capacity,\n    ) -> BroadcastMapReceiver<Vec<u8>> {\n        self.subscribe_unwrap_or_insert(BroadcastType::PointToGroup(key.clone()), capacity)\n    }\n\n    /// Retrieves the current receiver count for a given broadcast type.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type for which to get the receiver count.\n    ///\n    /// # Returns\n    ///\n    /// - `ReceiverCount` - The number of active receivers for the broadcast type, or 0 if not found.\n    pub fn receiver_count<'a, B: BroadcastTypeTrait>(\n        &self,\n        broadcast_type: BroadcastType<B>,\n    ) -> ReceiverCount {\n        let key: String = BroadcastType::get_key(broadcast_type);\n        self.broadcast_map.receiver_count(&key).unwrap_or(0)\n    }\n\n    /// Calculates the receiver count after incrementing it.\n    ///\n    /// Ensures the count does not exceed the maximum allowed value minus one.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type for which to increment the receiver count.\n    ///\n    /// # Returns\n    ///\n    /// - `ReceiverCount` - The incremented receiver count.\n    pub fn receiver_count_after_increment<B: BroadcastTypeTrait>(\n        &self,\n        broadcast_type: BroadcastType<B>,\n    ) -> ReceiverCount {\n        let count: ReceiverCount = self.receiver_count(broadcast_type);\n        count.max(0).min(ReceiverCount::MAX - 1) + 1\n    }\n\n    /// Calculates the receiver count after decrementing it.\n    ///\n    /// Ensures the count does not go below 0.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type for which to decrement the receiver count.\n    ///\n    /// # Returns\n    ///\n    /// - `ReceiverCount` - The decremented receiver count.\n    pub fn receiver_count_after_decrement<B: BroadcastTypeTrait>(\n        &self,\n        broadcast_type: BroadcastType<B>,\n    ) -> ReceiverCount {\n        let count: ReceiverCount = self.receiver_count(broadcast_type);\n        count.max(1).min(ReceiverCount::MAX) - 1\n    }\n\n    /// Sends data to all active receivers for a given broadcast type.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `T`: The type of data to send, which must be convertible to `Vec<u8>`.\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `BroadcastType<B>` - The broadcast type to which to send the data.\n    /// - `T` - The data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMapSendResult<Vec<u8>>` - A result indicating the success or failure of the send operation.\n    pub fn send<T, B>(\n        &self,\n        broadcast_type: BroadcastType<B>,\n        data: T,\n    ) -> BroadcastMapSendResult<Vec<u8>>\n    where\n        T: Into<Vec<u8>>,\n        B: BroadcastTypeTrait,\n    {\n        let key: String = BroadcastType::get_key(broadcast_type);\n        self.broadcast_map.send(&key, data.into())\n    }\n\n    /// Runs the WebSocket connection, handling incoming requests and outgoing messages.\n    ///\n    /// This asynchronous function continuously monitors for new WebSocket requests\n    /// and incoming broadcast messages, processing them according to the configured hooks.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `B`: The type implementing `BroadcastTypeTrait`.\n    ///\n    /// # Arguments\n    ///\n    /// - `WebSocketConfig<B>` - The WebSocket configuration containing the configuration for this WebSocket instance.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the context in the WebSocket configuration is not set (i.e., it's the default context).\n    /// Panics if the broadcast type in the WebSocket configuration is `BroadcastType::Unknown`.\n    pub async fn run<B: BroadcastTypeTrait>(&self, config: WebSocketConfig<B>) {\n        let ctx: Context = config.get_context().clone();\n        if ctx.to_string() == Context::default().to_string() {\n            panic!(\"Context must be set\");\n        }\n        let buffer_size: usize = config.get_buffer_size();\n        let capacity: Capacity = config.get_capacity();\n        let broadcast_type: BroadcastType<B> = config.get_broadcast_type().clone();\n        let mut receiver: Receiver<Vec<u8>> = match &broadcast_type {\n            BroadcastType::PointToPoint(key1, key2) => self.point_to_point(key1, key2, capacity),\n            BroadcastType::PointToGroup(key) => self.point_to_group(key, capacity),\n            BroadcastType::Unknown => panic!(\"BroadcastType must be PointToPoint or PointToGroup\"),\n        };\n        let key: String = BroadcastType::get_key(broadcast_type);\n        let result_handle = || async {\n            ctx.aborted().await;\n            ctx.closed().await;\n        };\n        loop {\n            tokio::select! {\n                request_res = ctx.ws_from_stream(buffer_size) => {\n                    let mut need_break = false;\n                    if request_res.is_ok() {\n                        config.get_request_hook()(ctx.clone()).await;\n                    } else {\n                        need_break = true;\n                        config.get_closed_hook()(ctx.clone()).await;\n                    }\n                    let body: ResponseBody = ctx.get_response_body().await;\n                    let is_err: bool = self.broadcast_map.send(&key, body).is_err();\n                    config.get_sended_hook()(ctx.clone()).await;\n                    if need_break || is_err {\n                        break;\n                    }\n                },\n                msg_res = receiver.recv() => {\n                    if let Ok(msg) = msg_res {\n                        if ctx.set_response_body(msg).await.send_body().await.is_ok() {\n                            continue;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        result_handle().await;\n    }\n}", "file_size": 25846, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the type of broadcast for WebSocket messages.\n///\n/// This enum allows specifying whether a message is intended for a direct\n/// point-to-point communication between two entities or for a group of entities.\n///\n/// # Type Parameters\n///\n/// - `T`: The type used to identify points or groups, which must implement `BroadcastTypeTrait`.\n#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\npub enum BroadcastType<T: BroadcastTypeTrait> {\n    /// Indicates a point-to-point broadcast between two specific entities.\n    ///\n    /// The tuple contains the identifiers of the two entities involved in the communication.\n    PointToPoint(T, T),\n    /// Indicates a broadcast to a specific group of entities.\n    ///\n    /// The tuple contains the identifier of the group.\n    PointToGroup(T),\n    /// Represents an unknown or unhandled broadcast type.\n    ///\n    /// This variant is used as a default or fallback for unhandled cases.\n    Unknown,\n}", "file_size": 970, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#trait;", "file_size": 118, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-time\\src\\time\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#enum;\npub(crate) mod r#fn;", "file_size": 63, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\aborted\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Expands macro to generate async aborted call.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with aborted call.\npub(crate) fn aborted_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.aborted().await;\n        }\n    })\n}", "file_size": 436, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\lib.rs", "language": "rust", "content": "//! A WebSocket plugin for the Hyperlane framework.\n//!\n//! A WebSocket plugin for the Hyperlane framework,\n//! providing robust WebSocket communication capabilities and integrating\n//! with hyperlane-broadcast for efficient message dissemination.\n\npub(crate) mod cfg;\npub(crate) mod websocket;\n\npub use websocket::{r#enum::*, r#struct::*};\n\npub(crate) use websocket::{r#const::*, r#trait::*};\n\npub(crate) use std::{\n    convert::Infallible,\n    net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr},\n    num::{\n        NonZeroI8, NonZeroI16, NonZeroI32, NonZeroI64, NonZeroI128, NonZeroIsize, NonZeroU8,\n        NonZeroU16, NonZeroU32, NonZeroU64, NonZeroU128, NonZeroUsize,\n    },\n    sync::Arc,\n};\n\npub(crate) use hyperlane::{tokio::sync::broadcast::Receiver, *};\npub(crate) use hyperlane_broadcast::*;\n\n#[cfg(test)]\npub(crate) use std::sync::OnceLock;", "file_size": 847, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\lombok-macros\\src\\visibility\\enum.rs", "language": "rust", "content": "/// Represents the visibility of an item in a Rust module.\n///\n/// # Variants\n/// - `Public`: The item is visible to all modules.\n/// - `PublicCrate`: The item is visible only within the current crate.\n/// - `PublicSuper`: The item is visible to the parent module and its descendants.\n/// - `Private`: The item is visible only within the current module.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Visibility {\n    Public,\n    PublicCrate,\n    PublicSuper,\n    Private,\n}", "file_size": 475, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\common\\mod.rs", "language": "rust", "content": "mod utils;\n\npub(crate) use utils::*;", "file_size": 36, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-utils\\src\\lib.rs", "language": "rust", "content": "//! hyperlane-utils\n//!\n//! A library providing utils for hyperlane.\n\npub use bin_encode_decode::*;\npub use chunkify::*;\npub use clonelicious::*;\npub use color_output::*;\npub use compare_version::*;\npub use file_operation::*;\npub use future_fn::*;\npub use hot_restart::*;\npub use hyperlane_broadcast::*;\npub use hyperlane_log::*;\npub use hyperlane_macros::*;\npub use hyperlane_plugin_websocket::*;\npub use lombok_macros::*;\npub use recoverable_spawn::*;\npub use recoverable_thread_pool::*;\npub use server_manager::*;\npub use std_macro_extensions::*;\n\npub use ahash;\npub use futures;\npub use inventory;\npub use log;\npub use num_cpus;\npub use once_cell;\npub use serde;\npub use serde_json;\npub use serde_urlencoded;\npub use serde_xml_rs;\npub use simd_json;\npub use twox_hash;\npub use urlencoding;\npub use utoipa;\npub use utoipa_rapidoc;\npub use utoipa_swagger_ui;", "file_size": 860, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\host\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Filters requests matching the specified host.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with host filter.\npub(crate) fn host_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let host_data: HostData = parse_macro_input!(attr as HostData);\n    let host_value: Expr = host_data.host_value;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let request_host: RequestHost = #context.get_request_host().await;\n            if request_host != #host_value.to_string() {\n                return;\n            }\n        }\n    })\n}\n\n/// Filters requests not matching the specified host.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with inverse host filter.\npub(crate) fn host_filter_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let host_data: HostData = parse_macro_input!(attr as HostData);\n    let host_value: Expr = host_data.host_value;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let request_host: RequestHost = #context.get_request_host().await;\n            if request_host == #host_value.to_string() {\n                return;\n            }\n        }\n    })\n}", "file_size": 1500, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\const.rs", "language": "rust", "content": "/// Represents the prefix for point-to-point broadcast keys.\n///\n/// This constant is used to construct unique keys for point-to-point WebSocket broadcasts.\npub(crate) const POINT_TO_POINT_KEY: &str = \"ptp-\";\n/// Represents the prefix for point-to-group broadcast keys.\n///\n/// This constant is used to construct unique keys for point-to-group WebSocket broadcasts.\npub(crate) const POINT_TO_GROUP_KEY: &str = \"ptg-\";", "file_size": 417, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\lib.rs", "language": "rust", "content": "//! hyperlane-macros\n//!\n//! A comprehensive collection of procedural macros for building\n//! HTTP servers with enhanced functionality. This crate provides\n//! attribute macros that simplify HTTP request handling, protocol\n//! validation, response management, and request data extraction.\n\nmod aborted;\nmod closed;\nmod common;\nmod filter;\nmod flush;\nmod hook;\nmod host;\nmod http;\nmod hyperlane;\nmod protocol;\nmod referer;\nmod request;\nmod response;\nmod send;\n\npub(crate) use aborted::*;\npub(crate) use closed::*;\npub(crate) use common::*;\npub(crate) use filter::*;\npub(crate) use flush::*;\npub(crate) use hook::*;\npub(crate) use host::*;\npub(crate) use http::*;\npub(crate) use hyperlane::*;\npub(crate) use protocol::*;\npub(crate) use referer::*;\npub(crate) use request::*;\npub(crate) use response::*;\npub(crate) use send::*;\n\npub(crate) use proc_macro::TokenStream;\npub(crate) use proc_macro2::TokenStream as TokenStream2;\npub(crate) use quote::quote;\npub(crate) use syn::{\n    Ident, Token,\n    parse::{Parse, ParseStream, Result},\n    punctuated::Punctuated,\n    *,\n};\n\n/// Restricts function execution to HTTP GET requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the GET HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[get]\n/// async fn handle_get(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn get(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    get_handler(item)\n}\n\n/// Restricts function execution to HTTP POST requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the POST HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[post]\n/// async fn handle_post(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn post(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    post_handler(item)\n}\n\n/// Restricts function execution to HTTP PUT requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the PUT HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[put]\n/// async fn handle_put(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn put(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    put_handler(item)\n}\n\n/// Restricts function execution to HTTP DELETE requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the DELETE HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[delete]\n/// async fn handle_delete(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn delete(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    delete_handler(item)\n}\n\n/// Restricts function execution to HTTP PATCH requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the PATCH HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[patch]\n/// async fn handle_patch(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn patch(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    patch_handler(item)\n}\n\n/// Restricts function execution to HTTP HEAD requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the HEAD HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[head]\n/// async fn handle_head(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn head(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    head_handler(item)\n}\n\n/// Restricts function execution to HTTP OPTIONS requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the OPTIONS HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[options]\n/// async fn handle_options(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn options(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    options_handler(item)\n}\n\n/// Restricts function execution to HTTP CONNECT requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the CONNECT HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[connect]\n/// async fn handle_connect(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn connect(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    connect_handler(item)\n}\n\n/// Restricts function execution to HTTP TRACE requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// uses the TRACE HTTP method. Requests with other methods will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[trace]\n/// async fn handle_trace(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn trace(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    trace_handler(item)\n}\n\n/// Allows function to handle multiple HTTP methods.\n///\n/// This attribute macro configures the decorated function to execute for any of the specified\n/// HTTP methods. Methods should be provided as a comma-separated list.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[methods(get, post)]\n/// async fn handle_get_post(ctx: Context) {\n///     // Function body\n/// }\n///\n/// #[methods(put, patch, delete)]\n/// async fn handle_modifications(ctx: Context) {\n///     // Function body\n/// }\n/// ```\n///\n/// The macro accepts a comma-separated list of HTTP method names (lowercase) and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn methods(attr: TokenStream, item: TokenStream) -> TokenStream {\n    methods_macro(attr, item)\n}\n\n/// Restricts function execution to WebSocket upgrade requests only.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// is a valid WebSocket upgrade request with proper request headers and protocol negotiation.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[ws]\n/// async fn handle_websocket(ctx: Context) {\n///     // WebSocket handling logic\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn ws(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    ws_macro(item)\n}\n\n/// Restricts function execution to standard HTTP requests only.\n///\n/// This attribute macro ensures the decorated function only executes for standard HTTP requests,\n/// excluding WebSocket upgrades and other protocol upgrade requests.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http]\n/// async fn handle_http(ctx: Context) {\n///     // HTTP request handling logic\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http_macro(item)\n}\n\n/// Sets the HTTP status code for the response.\n///\n/// This attribute macro configures the HTTP status code that will be sent with the response.\n/// The status code can be provided as a numeric literal or a global constant.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// const CUSTOM_STATUS: i32 = 418;\n///\n/// #[response_status_code(200)]\n/// async fn success_handler(ctx: Context) {\n///     // Response will have status code 200\n/// }\n///\n/// #[response_status_code(404)]\n/// async fn not_found_handler(ctx: Context) {\n///     // Response will have status code 404\n/// }\n///\n/// #[response_status_code(CUSTOM_STATUS)]\n/// async fn custom_handler(ctx: Context) {\n///     // Response will have status code from global constant\n/// }\n/// ```\n///\n/// The macro accepts a numeric HTTP status code or a global constant\n/// and should be applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn response_status_code(attr: TokenStream, item: TokenStream) -> TokenStream {\n    response_status_code_macro(attr, item)\n}\n\n/// Sets the HTTP reason phrase for the response.\n///\n/// This attribute macro configures the HTTP reason phrase that accompanies the status code.\n/// The reason phrase can be provided as a string literal or a global constant.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// const CUSTOM_REASON: &str = \"I'm a teapot\";\n///\n/// #[response_reason_phrase(\"OK\")]\n/// async fn success_handler(ctx: Context) {\n///     // Response will have reason phrase \"OK\"\n/// }\n///\n/// #[response_reason_phrase(\"Not Found\")]\n/// async fn not_found_handler(ctx: Context) {\n///     // Response will have reason phrase \"Not Found\"\n/// }\n///\n/// #[response_reason_phrase(CUSTOM_REASON)]\n/// async fn custom_handler(ctx: Context) {\n///     // Response will have reason phrase from global constant\n/// }\n/// ```\n///\n/// The macro accepts a string literal or global constant for the reason phrase and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn response_reason_phrase(attr: TokenStream, item: TokenStream) -> TokenStream {\n    response_reason_phrase_macro(attr, item)\n}\n\n/// Sets or replaces a specific HTTP response header.\n///\n/// This attribute macro configures a specific HTTP response header that will be sent with the response.\n/// Both the header name and value can be provided as string literals or global constants.\n/// Use `\"key\", \"value\"` to set a header (add to existing headers) or `\"key\" => \"value\"` to replace a header (overwrite existing).\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// const HEADER_NAME: &str = \"X-Custom-Header\";\n/// const HEADER_VALUE: &str = \"custom-value\";\n///\n/// #[response_header(\"Content-Type\", \"application/json\")]\n/// async fn json_handler(ctx: Context) {\n///     // Response will have Content-Type header set to application/json\n/// }\n///\n/// #[response_header(\"X-Static-Header\" => \"static-value\")]\n/// async fn set_header_handler(ctx: Context) {\n///     // Response will have static header replaced (overwrite existing)\n/// }\n///\n/// #[response_header(HEADER_NAME, HEADER_VALUE)]\n/// async fn dynamic_header_handler(ctx: Context) {\n///     // Response will have header from global constants\n/// }\n///\n/// #[response_header(\"Cache-Control\" => \"no-cache\")]\n/// async fn set_cache_handler(ctx: Context) {\n///     // Response will have Cache-Control header replaced\n/// }\n///\n/// #[response_header(\"X-Add-Header\", \"add-value\")]\n/// #[response_header(\"X-Set-Header\" => \"set-value\")]\n/// async fn header_operations_handler(ctx: Context) {\n///     // Response will have X-Add-Header set and X-Set-Header replaced\n/// }\n/// ```\n///\n/// The macro accepts header name and header value, both can be string literals or global constants.\n/// Use `\"key\", \"value\"` for setting headers and `\"key\" => \"value\"` for replacing headers.\n/// Should be applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn response_header(attr: TokenStream, item: TokenStream) -> TokenStream {\n    response_header_macro(attr, item)\n}\n\n/// Sets the HTTP response body.\n///\n/// This attribute macro configures the HTTP response body that will be sent with the response.\n/// The body content can be provided as a string literal or a global constant.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// const RESPONSE_DATA: &str = \"Dynamic content from constant\";\n///\n/// #[response_body(\"Hello, World!\")]\n/// async fn hello_handler(ctx: Context) {\n///     // Response will have body \"Hello, World!\"\n/// }\n///\n/// #[response_body(\"{\\\"message\\\": \\\"success\\\"}\")]\n/// async fn json_response_handler(ctx: Context) {\n///     // Response will have JSON body\n/// }\n///\n/// #[response_body(RESPONSE_DATA)]\n/// async fn dynamic_body_handler(ctx: Context) {\n///     // Response will have body from global constant\n/// }\n/// ```\n///\n/// The macro accepts a string literal or global constant for the response body and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn response_body(attr: TokenStream, item: TokenStream) -> TokenStream {\n    response_body_macro(attr, item)\n}\n\n/// Sets the HTTP response version.\n///\n/// This attribute macro configures the HTTP response version that will be sent with the response.\n/// The version can be provided as a variable or code block.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[response_version(HttpVersion::HTTP1_1)]\n/// async fn version_from_constant(ctx: Context) {\n///     // Response will have version from global constant\n/// }\n/// ```\n///\n/// The macro accepts a variable or code block for the response version and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn response_version(attr: TokenStream, item: TokenStream) -> TokenStream {\n    response_version_macro(attr, item)\n}\n\n/// Automatically sends the complete response after function execution.\n///\n/// This attribute macro ensures that the response (request headers and body) is automatically sent\n/// to the client after the function completes execution.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[send]\n/// async fn auto_send_handler(ctx: Context) {\n///     let _ = ctx.set_response_body(\"Hello World\").await;\n///     // Response is automatically sent after function returns\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn send(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    send_macro(item)\n}\n\n/// Automatically sends only the response body after function execution.\n///\n/// This attribute macro ensures that only the response body is automatically sent\n/// to the client after the function completes, handling request headers separately.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[send_body]\n/// async fn auto_send_body_handler(ctx: Context) {\n///     let _ = ctx.set_response_body(\"Response body content\").await;\n///     // Only response body is automatically sent after function returns\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn send_body(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    send_body_macro(item)\n}\n\n/// Sends the complete response exactly once after function execution.\n///\n/// This attribute macro ensures that the response is sent exactly once to the client,\n/// preventing multiple response transmissions for single-use scenarios.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[send_once]\n/// async fn send_once_handler(ctx: Context) {\n///     let _ = ctx.set_response_body(\"One-time response\").await;\n///     // Response is sent exactly once after function returns\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn send_once(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    send_once_macro(item)\n}\n\n/// Sends only the response body exactly once after function execution.\n///\n/// This attribute macro ensures that the response body is sent exactly once to the client,\n/// preventing multiple body transmissions for single-use scenarios.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[send_once_body]\n/// async fn send_once_body_handler(ctx: Context) {\n///     let _ = ctx.set_response_body(\"One-time body content\").await;\n///     // Response body is sent exactly once after function returns\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn send_once_body(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    send_once_body_macro(item)\n}\n\n/// Flushes the response stream after function execution.\n///\n/// This attribute macro ensures that the response stream is flushed to guarantee immediate\n/// data transmission, forcing any buffered response data to be sent to the client.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[flush]\n/// async fn flush_handler(ctx: Context) {\n///     let _ = ctx.set_response_body(\"Immediate response\").await;\n///     // Response stream is flushed after function returns\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn flush(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    flush_macro(item)\n}\n\n/// Handles aborted request scenarios.\n///\n/// This attribute macro configures the function to handle cases where the client has\n/// aborted the request, providing appropriate handling for interrupted or cancelled requests.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[aborted]\n/// async fn handle_aborted(ctx: Context) {\n///     // Handle aborted request logic\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn aborted(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    aborted_macro(item)\n}\n\n/// Handles closed connection scenarios.\n///\n/// This attribute macro configures the function to handle cases where the connection\n/// has been closed, providing appropriate handling for terminated or disconnected connections.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[closed]\n/// async fn handle_closed(ctx: Context) {\n///     // Handle closed connection logic\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn closed(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    closed_macro(item)\n}\n\n/// Restricts function execution to HTTP/2 Cleartext (h2c) requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/2 cleartext\n/// requests that use the h2c upgrade mechanism.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[h2c]\n/// async fn handle_h2c(ctx: Context) {\n///     // Handle HTTP/2 cleartext requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn h2c(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    h2c_macro(item)\n}\n\n/// Restricts function execution to HTTP/0.9 requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/0.9\n/// protocol requests, the earliest version of the HTTP protocol.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http0_9]\n/// async fn handle_http09(ctx: Context) {\n///     // Handle HTTP/0.9 requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http0_9(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http0_9_macro(item)\n}\n\n/// Restricts function execution to HTTP/1.0 requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/1.0\n/// protocol requests.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http1_0]\n/// async fn handle_http10(ctx: Context) {\n///     // Handle HTTP/1.0 requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http1_0(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http1_0_macro(item)\n}\n\n/// Restricts function execution to HTTP/1.1 requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/1.1\n/// protocol requests.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http1_1]\n/// async fn handle_http11(ctx: Context) {\n///     // Handle HTTP/1.1 requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http1_1(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http1_1_macro(item)\n}\n\n/// Restricts function execution to HTTP/1.1 or higher protocol versions.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/1.1\n/// or newer protocol versions, including HTTP/2, HTTP/3, and future versions.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http1_1_or_higher]\n/// async fn handle_modern_http(ctx: Context) {\n///     // Handle HTTP/1.1, HTTP/2, HTTP/3, etc.\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http1_1_or_higher(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http1_1_or_higher_macro(item)\n}\n\n/// Restricts function execution to HTTP/2 requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/2\n/// protocol requests.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http2]\n/// async fn handle_http2(ctx: Context) {\n///     // Handle HTTP/2 requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http2(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http2_macro(item)\n}\n\n/// Restricts function execution to HTTP/3 requests only.\n///\n/// This attribute macro ensures the decorated function only executes for HTTP/3\n/// protocol requests, the latest version of the HTTP protocol.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[http3]\n/// async fn handle_http3(ctx: Context) {\n///     // Handle HTTP/3 requests\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn http3(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    http3_macro(item)\n}\n\n/// Restricts function execution to TLS-encrypted requests only.\n///\n/// This attribute macro ensures the decorated function only executes for requests\n/// that use TLS/SSL encryption on the connection.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[tls]\n/// async fn handle_secure(ctx: Context) {\n///     // Handle TLS-encrypted requests only\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn tls(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    tls_macro(item)\n}\n\n/// Handles requests with unknown or non-standard HTTP methods.\n///\n/// This attribute macro configures the function to handle requests that use\n/// unrecognized or unsupported HTTP methods, providing a fallback for non-standard methods.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[filter_unknown_method]\n/// async fn handle_unknown_method(ctx: Context) {\n///     // Handle requests with unknown HTTP methods\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn filter_unknown_method(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    filter_unknown_method_macro(item)\n}\n\n/// Handles requests with unknown or non-standard upgrade protocols.\n///\n/// This attribute macro configures the function to handle requests that specify\n/// unrecognized upgrade protocols, providing a fallback for non-standard upgrade request headers.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[filter_unknown_upgrade]\n/// async fn handle_unknown_upgrade(ctx: Context) {\n///     // Handle requests with unknown upgrade protocols\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn filter_unknown_upgrade(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    filter_unknown_upgrade_macro(item)\n}\n\n/// Handles requests with unknown or non-standard HTTP versions.\n///\n/// This attribute macro configures the function to handle requests that use\n/// unrecognized HTTP protocol versions, providing a fallback for non-standard versions.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[filter_unknown_version]\n/// async fn handle_unknown_version(ctx: Context) {\n///     // Handle requests with unknown HTTP versions\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn filter_unknown_version(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    filter_unknown_version_macro(item)\n}\n\n/// Handles requests with any unknown characteristics.\n///\n/// This attribute macro combines filtering for unknown methods, upgrade protocols, and HTTP versions,\n/// providing comprehensive handling for requests with any unrecognized characteristics.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[filter_unknown]\n/// async fn handle_all_unknown(ctx: Context) {\n///     // Handle requests with any unknown characteristics\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn filter_unknown(_attr: TokenStream, item: TokenStream) -> TokenStream {\n    filter_unknown_macro(item)\n}\n\n/// Restricts function execution to requests with a specific host.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// has a host header that matches the specified value. Requests with different or missing host headers will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[host(\"localhost\")]\n/// async fn handle_example_com(ctx: Context) {\n///     // Function body for localhost requests\n/// }\n///\n/// #[host(\"api.localhost\")]\n/// async fn handle_api_subdomain(ctx: Context) {\n///     // Function body for api.localhost requests\n/// }\n/// ```\n///\n/// The macro accepts a string literal specifying the expected host value and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn host(attr: TokenStream, item: TokenStream) -> TokenStream {\n    host_macro(attr, item)\n}\n\n/// Filters requests that have no host header.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// has a host header present. Requests without a host header will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[host_filter(\"localhost\")]\n/// async fn handle_with_host(ctx: Context) {\n///     // Function body for requests with host header\n/// }\n/// ```\n///\n/// The macro takes no parameters and should be applied directly to async functions\n/// that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn host_filter(attr: TokenStream, item: TokenStream) -> TokenStream {\n    host_filter_macro(attr, item)\n}\n\n/// Restricts function execution to requests with a specific referer.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// has a referer header that matches the specified value. Requests with different or missing referer headers will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[referer(\"http://localhost\")]\n/// async fn handle_example_referer(ctx: Context) {\n///     // Function body for requests from localhost\n/// }\n///\n/// #[referer(\"https://api.localhost\")]\n/// async fn handle_api_referer(ctx: Context) {\n///     // Function body for requests from api.localhost\n/// }\n/// ```\n///\n/// The macro accepts a string literal specifying the expected referer value and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn referer(attr: TokenStream, item: TokenStream) -> TokenStream {\n    referer_macro(attr, item)\n}\n\n/// Filters requests that have a specific referer header.\n///\n/// This attribute macro ensures the decorated function only executes when the incoming request\n/// does not have a referer header that matches the specified value. Requests with the matching referer header will be filtered out.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[referer_filter(\"http://localhost\")]\n/// async fn handle_without_spam_referer(ctx: Context) {\n///     // Function body for requests not from localhost\n/// }\n/// ```\n///\n/// The macro accepts a string literal specifying the referer value to filter out and should be\n/// applied to async functions that accept a `Context` parameter.\n#[proc_macro_attribute]\npub fn referer_filter(attr: TokenStream, item: TokenStream) -> TokenStream {\n    referer_filter_macro(attr, item)\n}\n\n/// Executes a specified function before the main handler function.\n///\n/// This attribute macro configures a pre-execution hook that runs before the main function logic.\n/// The specified hook function will be called first, followed by the main function execution.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[get]\n/// async fn pre_handler(ctx: Context) {\n///     // Pre-execution logic\n/// }\n///\n/// #[pre_hook(pre_handler)]\n/// async fn main_handler(ctx: Context) {\n///     // Main function logic (runs after pre_handler)\n/// }\n/// ```\n///\n/// The macro accepts a function name as parameter. Both the hook function and main function\n/// must accept a `Context` parameter. Avoid combining this macro with other macros on the\n/// same function to prevent macro expansion conflicts.\n#[proc_macro_attribute]\npub fn pre_hook(attr: TokenStream, item: TokenStream) -> TokenStream {\n    pre_hook_macro(attr, item)\n}\n\n/// Executes a specified function after the main handler function.\n///\n/// This attribute macro configures a post-execution hook that runs after the main function logic.\n/// The main function will execute first, followed by the specified hook function.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[send]\n/// async fn post_handler(ctx: Context) {\n///     // Post-execution logic\n/// }\n///\n/// #[post_hook(post_handler)]\n/// async fn main_handler(ctx: Context) {\n///     // Main function logic (runs before post_handler)\n/// }\n/// ```\n///\n/// The macro accepts a function name as parameter. Both the hook function and main function\n/// must accept a `Context` parameter. Avoid combining this macro with other macros on the\n/// same function to prevent macro expansion conflicts.\n#[proc_macro_attribute]\npub fn post_hook(attr: TokenStream, item: TokenStream) -> TokenStream {\n    post_hook_macro(attr, item)\n}\n\n/// Extracts the raw request body into a specified variable.\n///\n/// This attribute macro extracts the raw request body content into a variable\n/// with the fixed type `RequestBody`. The body content is not parsed or deserialized.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_body(raw_body)]\n/// async fn handle_raw_body(ctx: Context) {\n///     // Use the raw request body\n///     let body_content = raw_body;\n/// }\n/// ```\n///\n/// The macro accepts only a variable name. The variable will be available\n/// in the function scope as a `RequestBody` type.\n#[proc_macro_attribute]\npub fn request_body(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_body_macro(attr, item)\n}\n\n/// Parses the request body as JSON into a specified variable and type.\n///\n/// This attribute macro extracts and deserializes the request body content as JSON into a variable\n/// with the specified type. The body content is parsed as JSON using serde.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n/// use serde::Deserialize;\n///\n/// #[derive(Deserialize, Clone)]\n/// struct UserData {\n///     name: String,\n///     age: u32,\n/// }\n///\n/// #[request_body_json(user_data: UserData)]\n/// async fn handle_user(ctx: Context) {\n///     if let Ok(data) = user_data {\n///         // Use the parsed user data\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name and type in the format `variable_name: Type`.\n/// The variable will be available in the function scope as a `Result<Type, JsonError>`.\n#[proc_macro_attribute]\npub fn request_body_json(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_body_json_macro(attr, item)\n}\n\n/// Extracts a specific attribute value into a variable.\n///\n/// This attribute macro retrieves a specific attribute by key and makes it available\n/// as a typed variable from the request context.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n/// use serde::Deserialize;\n///\n/// const USER_KEY: &str = \"user_data\";\n///\n/// #[derive(Deserialize, Clone)]\n/// struct User {\n///     id: u64,\n///     name: String,\n/// }\n///\n/// #[attribute(USER_KEY => user: User)]\n/// async fn handle_with_attribute(ctx: Context) {\n///     if let Some(user_data) = user {\n///         // Use the extracted attribute\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a key-to-variable mapping in the format `key => variable_name: Type`.\n/// The variable will be available as an `Option<Type>` in the function scope.\n#[proc_macro_attribute]\npub fn attribute(attr: TokenStream, item: TokenStream) -> TokenStream {\n    attribute_macro(attr, item)\n}\n\n/// Extracts all attributes into a HashMap variable.\n///\n/// This attribute macro retrieves all available attributes from the request context\n/// and makes them available as a HashMap for comprehensive attribute access.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[attributes(all_attrs)]\n/// async fn handle_with_all_attributes(ctx: Context) {\n///     for (key, value) in all_attrs {\n///         // Process each attribute\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain a HashMap of all attributes.\n/// The variable will be available as a HashMap in the function scope.\n#[proc_macro_attribute]\npub fn attributes(attr: TokenStream, item: TokenStream) -> TokenStream {\n    attributes_macro(attr, item)\n}\n\n/// Extracts a specific route parameter into a variable.\n///\n/// This attribute macro retrieves a specific route parameter by key and makes it\n/// available as a variable. Route parameters are extracted from the URL path segments.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// // For route like \"/users/{id}\"\n/// #[route_param(\"id\" => user_id)]\n/// async fn get_user(ctx: Context) {\n///     if let Some(id) = user_id {\n///         // Use the route parameter\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a key-to-variable mapping in the format `\"key\" => variable_name`.\n/// The variable will be available as an `Option<String>` in the function scope.\n#[proc_macro_attribute]\npub fn route_param(attr: TokenStream, item: TokenStream) -> TokenStream {\n    route_param_macro(attr, item)\n}\n\n/// Extracts all route parameters into a collection variable.\n///\n/// This attribute macro retrieves all available route parameters from the URL path\n/// and makes them available as a collection for comprehensive route parameter access.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// // For route like \"/users/{id}/posts/{post_id}\"\n/// #[route_params(params)]\n/// async fn handle_nested_route(ctx: Context) {\n///     for (key, value) in params {\n///         // Process each route parameter\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain all route parameters.\n/// The variable will be available as a collection in the function scope.\n#[proc_macro_attribute]\npub fn route_params(attr: TokenStream, item: TokenStream) -> TokenStream {\n    route_params_macro(attr, item)\n}\n\n/// Extracts a specific request query parameter into a variable.\n///\n/// This attribute macro retrieves a specific request query parameter by key and makes it\n/// available as a variable. Query parameters are extracted from the URL request query string.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// // For URL like \"/search?q=rust&limit=10\"\n/// #[request_query(\"q\" => search_term)]\n/// async fn search(ctx: Context) {\n///     if let Some(term) = search_term {\n///         // Use the request query parameter\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a key-to-variable mapping in the format `\"key\" => variable_name`.\n/// The variable will be available as an `Option<String>` in the function scope.\n#[proc_macro_attribute]\npub fn request_query(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_query_macro(attr, item)\n}\n\n/// Extracts all request query parameters into a collection variable.\n///\n/// This attribute macro retrieves all available request query parameters from the URL request query string\n/// and makes them available as a collection for comprehensive request query parameter access.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// // For URL like \"/search?q=rust&limit=10&sort=date\"\n/// #[request_querys(all_params)]\n/// async fn search_with_params(ctx: Context) {\n///     for (key, value) in all_params {\n///         // Process each request query parameter\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain all request query parameters.\n/// The variable will be available as a collection in the function scope.\n#[proc_macro_attribute]\npub fn request_querys(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_querys_macro(attr, item)\n}\n\n/// Extracts a specific HTTP request header into a variable.\n///\n/// This attribute macro retrieves a specific HTTP request header by name and makes it\n/// available as a variable. Header values are extracted from the request request headers collection.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_header(HOST => host_request_header)]\n/// async fn handle_with_host(ctx: Context) {\n///     if let Some(host) = host_request_header {\n///         // Use the host request_header value\n///     }\n/// }\n///\n/// #[request_header(\"Content-Type\" => content_type)]\n/// async fn handle_with_content_type(ctx: Context) {\n///     if let Some(ct) = content_type {\n///         // Use the content type request_header\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a request header name-to-variable mapping in the format `HEADER_NAME => variable_name`\n/// or `\"Header-Name\" => variable_name`. The variable will be available as an `Option<String>`.\n#[proc_macro_attribute]\npub fn request_header(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_header_macro(attr, item)\n}\n\n/// Extracts all HTTP request headers into a collection variable.\n///\n/// This attribute macro retrieves all available HTTP request headers from the request\n/// and makes them available as a collection for comprehensive request header access.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_headers(all_request_headers)]\n/// async fn handle_with_all_request_headers(ctx: Context) {\n///     for (name, value) in all_request_headers {\n///         // Process each request_header\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain all HTTP request headers.\n/// The variable will be available as a collection in the function scope.\n#[proc_macro_attribute]\npub fn request_headers(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_headers_macro(attr, item)\n}\n\n/// Extracts a specific cookie value or all cookies into a variable.\n///\n/// This attribute macro supports two syntaxes:\n/// 1. `cookie(key => variable_name)` - Extract a specific cookie value by key\n/// 2. `cookie(variable_name)` - Extract all cookies as a raw string\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_cookie(\"session_id\" => session_cookie_opt)]\n/// async fn handle_with_session(ctx: Context) {\n///     if let Some(session) = session_cookie_opt {\n///         // Use the session cookie value\n///     }\n/// }\n/// ```\n///\n/// For specific cookie extraction, the variable will be available as `Option<String>`.\n/// For all cookies extraction, the variable will be available as `String`.\n#[proc_macro_attribute]\npub fn request_cookie(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_cookie_macro(attr, item)\n}\n\n/// Extracts all cookies as a raw string into a variable.\n///\n/// This attribute macro retrieves the entire Cookie header from the request and makes it\n/// available as a String variable. If no Cookie header is present, an empty string is used.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_cookies(cookie_value)]\n/// async fn handle_with_cookies(ctx: Context) {\n///     // Use the cookie value\n///     if !cookie_value.is_empty() {\n///         // Process cookie data\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain the Cookie header value.\n/// The variable will be available as a String in the function scope.\n#[proc_macro_attribute]\npub fn request_cookies(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_cookies_macro(attr, item)\n}\n\n/// Extracts the HTTP request version into a variable.\n///\n/// This attribute macro retrieves the HTTP version from the request and makes it\n/// available as a variable. The version represents the HTTP protocol version used.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_version(http_version)]\n/// async fn handle_with_version(ctx: Context) {\n///     // Use the HTTP version\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain the HTTP request version.\n/// The variable will be available as a RequestVersion type in the function scope.\n#[proc_macro_attribute]\npub fn request_version(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_version_macro(attr, item)\n}\n\n/// Extracts the HTTP request path into a variable.\n///\n/// This attribute macro retrieves the request path from the HTTP request and makes it\n/// available as a variable. The path represents the URL path portion of the request.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[request_path(request_path)]\n/// async fn handle_with_path(ctx: Context) {\n///     // Use the request path\n///     if request_path.starts_with(\"/api/\") {\n///         // Handle API requests\n///     }\n/// }\n/// ```\n///\n/// The macro accepts a variable name that will contain the HTTP request path.\n/// The variable will be available as a RequestPath type in the function scope.\n#[proc_macro_attribute]\npub fn request_path(attr: TokenStream, item: TokenStream) -> TokenStream {\n    request_path_macro(attr, item)\n}\n\n/// Creates a new instance of a specified type with a given variable name.\n///\n/// This attribute macro generates an instance initialization at the beginning of the function.\n///\n/// # Usage\n///\n/// ```rust\n/// use hyperlane::*;\n/// use hyperlane_macros::*;\n///\n/// #[hyperlane(server: Server)]\n/// #[tokio::main]\n/// async fn main() {\n///     // `server` is now available as: `let server: Server = Server::new().await;`\n///     // The function body can now use `server`.\n/// }\n/// ```\n///\n/// The macro accepts a `variable_name: Type` pair.\n/// The variable will be available as an instance of the specified type in the function scope.\n#[proc_macro_attribute]\npub fn hyperlane(attr: TokenStream, item: TokenStream) -> TokenStream {\n    hyperlane_macro(attr, item)\n}", "file_size": 47336, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\filter\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Filters requests with unknown method, upgrade and version.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with filter checks.\npub(crate) fn filter_unknown_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            if !#context.get_request().await.is_unknown_method() {\n                return;\n            }\n            if !#context.get_request().await.is_unknown_upgrade() {\n                return;\n            }\n            if !#context.get_request().await.is_unknown_version() {\n                return;\n            }\n        }\n    })\n}\n\nmacro_rules! impl_filter_macro {\n    ($name:ident, $check:ident) => {\n        pub(crate) fn $name(item: TokenStream) -> TokenStream {\n            expand_check_macro(item, |context| {\n                let check_fn = Ident::new(stringify!($check), proc_macro2::Span::call_site());\n                quote! {\n                    if !#context.get_request().await.#check_fn() {\n                        return;\n                    }\n                }\n            })\n        }\n    };\n}\n\nimpl_filter_macro!(filter_unknown_method_macro, is_unknown_method);\nimpl_filter_macro!(filter_unknown_upgrade_macro, is_unknown_upgrade);\nimpl_filter_macro!(filter_unknown_version_macro, is_unknown_version);", "file_size": 1415, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\debug\\Cargo.toml", "language": "toml", "content": "[package]\nname = \"debug\"\nversion = \"0.1.0\"\nedition = \"2024\"\n\n[dependencies]\nhyperlane-macros = { path = \"../\" }\nhyperlane = \"*\"\nserde = { version = \"*\", features = [\"derive\"] }", "file_size": 176, "extension": ".toml"}
{"file_path": "training_sources\\crates-dev\\hyperlane-plugin-websocket\\src\\websocket\\trait.rs", "language": "rust", "content": "/// A trait for types that can be used as broadcast identifiers.\n///\n/// Types implementing this trait must be convertible to a string,\n/// be partially orderable, and be cloneable.\npub trait BroadcastTypeTrait: ToString + PartialOrd + Clone {}", "file_size": 244, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\common\\utils.rs", "language": "rust", "content": "use crate::*;\n\n/// Expands macro with code inserted before function body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n/// - `impl FnOnce(&Ident) -> TokenStream2` - Function to generate code inserted before.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with inserted code.\npub(crate) fn expand_macro_with_before_insertion(\n    input: TokenStream,\n    before_fn: impl FnOnce(&Ident) -> TokenStream2,\n) -> TokenStream {\n    let input_fn: ItemFn = parse_macro_input!(input as ItemFn);\n    let vis: &Visibility = &input_fn.vis;\n    let sig: &Signature = &input_fn.sig;\n    let block: &Block = &input_fn.block;\n    let attrs: &Vec<Attribute> = &input_fn.attrs;\n    match parse_context_from_fn(sig) {\n        Ok(context) => {\n            let before_code: TokenStream2 = before_fn(context);\n            let stmts: &Vec<Stmt> = &block.stmts;\n            let gen_code: TokenStream2 = quote! {\n                #(#attrs)*\n                #vis #sig {\n                    #before_code\n                    #(#stmts)*\n                }\n            };\n            gen_code.into()\n        }\n        Err(err) => err.to_compile_error().into(),\n    }\n}\n\n/// Expands macro with code inserted after function body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n/// - `impl FnOnce(&Ident) -> TokenStream2` - Function to generate code inserted after.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with inserted code.\npub(crate) fn expand_macro_with_after_insertion(\n    input: TokenStream,\n    after_fn: impl FnOnce(&Ident) -> TokenStream2,\n) -> TokenStream {\n    let input_fn: ItemFn = parse_macro_input!(input as ItemFn);\n    let vis: &Visibility = &input_fn.vis;\n    let sig: &Signature = &input_fn.sig;\n    let block: &Block = &input_fn.block;\n    let attrs: &Vec<Attribute> = &input_fn.attrs;\n    match parse_context_from_fn(sig) {\n        Ok(context) => {\n            let after_code: TokenStream2 = after_fn(context);\n            let stmts: &Vec<Stmt> = &block.stmts;\n            let gen_code: TokenStream2 = quote! {\n                #(#attrs)*\n                #vis #sig {\n                    #(#stmts)*\n                    #after_code\n                }\n            };\n            gen_code.into()\n        }\n        Err(err) => err.to_compile_error().into(),\n    }\n}\n\n/// Expands macro with attribute parsing and code insertion before function body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream to parse.\n/// - `TokenStream` - The input token stream to process.\n/// - `impl FnOnce(TokenStream) -> syn::Result<T>` - Function to parse attributes.\n/// - `impl FnOnce(&Ident, T) -> TokenStream2` - Function to generate code inserted before.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with inserted code.\npub(crate) fn expand_macro_with_attr_and_before_insertion<T>(\n    attr: TokenStream,\n    item: TokenStream,\n    parse_attr: impl FnOnce(TokenStream) -> syn::Result<T>,\n    before_fn: impl FnOnce(&Ident, T) -> TokenStream2,\n) -> TokenStream {\n    match parse_attr(attr) {\n        Ok(value) => expand_macro_with_before_insertion(item, |context| before_fn(context, value)),\n        Err(err) => err.to_compile_error().into(),\n    }\n}\n\n/// Expands macro with check code inserted before function body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n/// - `impl FnOnce(&Ident) -> TokenStream2` - Function to generate check code.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with check code.\npub(crate) fn expand_check_macro(\n    input: TokenStream,\n    check_fn: impl FnOnce(&Ident) -> TokenStream2,\n) -> TokenStream {\n    expand_macro_with_before_insertion(input, check_fn)\n}\n\n/// Parses context identifier from function signature.\n///\n/// # Arguments\n///\n/// - `&Signature` - The function signature to parse.\n///\n/// # Returns\n///\n/// - `syn::Result<&Ident>` - The parsed context identifier or error.\npub(crate) fn parse_context_from_fn(sig: &Signature) -> syn::Result<&Ident> {\n    match sig.inputs.first() {\n        Some(FnArg::Typed(pat_type)) => match &*pat_type.pat {\n            Pat::Ident(pat_ident) => Ok(&pat_ident.ident),\n            Pat::Wild(wild) => Err(syn::Error::new_spanned(\n                wild,\n                \"The argument cannot be anonymous `_`, please use a named identifier\",\n            )),\n            _ => Err(syn::Error::new_spanned(\n                &pat_type.pat,\n                \"expected identifier as first argument\",\n            )),\n        },\n        _ => Err(syn::Error::new_spanned(\n            &sig.inputs,\n            \"expected at least one argument\",\n        )),\n    }\n}", "file_size": 4719, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\hyperlane\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub(crate) use r#fn::*;\npub(crate) use r#struct::*;", "file_size": 121, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\closed\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Expands macro to generate async closed call.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with closed call.\npub(crate) fn closed_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.closed().await;\n        }\n    })\n}", "file_size": 432, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\flush\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Expands macro to generate async flush call.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with flush call.\npub(crate) fn flush_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.flush().await;\n        }\n    })\n}", "file_size": 428, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\hook\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Expands macro to add pre-hook function call.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with pre-hook call.\npub(crate) fn pre_hook_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let function_name: Ident = parse_macro_input!(attr as Ident);\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let _ = #function_name(#context.clone()).await;\n        }\n    })\n}\n\n/// Expands macro to add post-hook function call.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with post-hook call.\npub(crate) fn post_hook_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let function_name: Ident = parse_macro_input!(attr as Ident);\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #function_name(#context.clone()).await;\n        }\n    })\n}", "file_size": 1163, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\host\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of Parse trait for HostData.\n///\n/// Parses host value expression from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<HostData>` - Parsed HostData or error.\nimpl Parse for HostData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let host_value: Expr = input.parse()?;\n        Ok(HostData { host_value })\n    }\n}", "file_size": 441, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\hyperlane\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the attribute for the Hyperlane macro.\n///\n/// It consists of a variable name and a type name, separated by `:`.\npub(crate) struct HyperlaneAttr {\n    /// The variable name to assign the initialized component to.\n    pub(crate) var_name: Ident,\n    /// The colon token `:` separating the variable and type names.\n    pub(crate) _colon: Token![:],\n    /// The type name of the component to initialize.\n    pub(crate) type_name: Ident,\n}", "file_size": 465, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\request\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of Parse trait for RequestMethods.\n///\n/// Parses HTTP methods from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RequestMethods>` - Parsed RequestMethods or error.\nimpl Parse for RequestMethods {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        Ok(RequestMethods {\n            methods: Punctuated::parse_separated_nonempty(input)?,\n        })\n    }\n}\n\n/// Implementation of Parse trait for RequestBodyData.\n///\n/// Parses request body variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RequestBodyData>` - Parsed RequestBodyData or error.\nimpl Parse for RequestBodyData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(RequestBodyData { variable })\n    }\n}\n\n/// Implementation of Parse trait for RequestBodyJsonData.\n///\n/// Parses request body JSON variable and type from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RequestBodyJsonData>` - Parsed RequestBodyJsonData or error.\nimpl Parse for RequestBodyJsonData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        input.parse::<Token![:]>()?;\n        let type_name: Type = input.parse()?;\n        Ok(RequestBodyJsonData {\n            variable,\n            type_name,\n        })\n    }\n}\n\n/// Implementation of Parse trait for AttributeData.\n///\n/// Parses attribute key, variable and type from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<AttributeData>` - Parsed AttributeData or error.\nimpl Parse for AttributeData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key_name: Expr = input.parse()?;\n        input.parse::<Token![=>]>()?;\n        let variable: Ident = input.parse()?;\n        input.parse::<Token![:]>()?;\n        let type_name: Type = input.parse()?;\n        Ok(AttributeData {\n            variable,\n            key_name,\n            type_name,\n        })\n    }\n}\n\n/// Implementation of Parse trait for AttributesData.\n///\n/// Parses attributes variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<AttributesData>` - Parsed AttributesData or error.\nimpl Parse for AttributesData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(AttributesData { variable })\n    }\n}\n\n/// Implementation of Parse trait for RouteParamData.\n///\n/// Parses route parameter key and variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RouteParamData>` - Parsed RouteParamData or error.\nimpl Parse for RouteParamData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key_name: Expr = input.parse()?;\n        input.parse::<Token![=>]>()?;\n        let variable: Ident = input.parse()?;\n        Ok(RouteParamData { key_name, variable })\n    }\n}\n\n/// Implementation of Parse trait for RouteParamsData.\n///\n/// Parses route parameters variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RouteParamsData>` - Parsed RouteParamsData or error.\nimpl Parse for RouteParamsData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(RouteParamsData { variable })\n    }\n}\n\n/// Implementation of Parse trait for QueryData.\n///\n/// Parses query parameter key and variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<QueryData>` - Parsed QueryData or error.\nimpl Parse for QueryData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key_name: Expr = input.parse()?;\n        input.parse::<Token![=>]>()?;\n        let variable: Ident = input.parse()?;\n        Ok(QueryData { key_name, variable })\n    }\n}\n\n/// Implementation of Parse trait for QuerysData.\n///\n/// Parses query parameters variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<QuerysData>` - Parsed QuerysData or error.\nimpl Parse for QuerysData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(QuerysData { variable })\n    }\n}\n\n/// Implementation of Parse trait for HeaderData.\n///\n/// Parses header key and variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<HeaderData>` - Parsed HeaderData or error.\nimpl Parse for HeaderData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key_name: Expr = input.parse()?;\n        input.parse::<Token![=>]>()?;\n        let variable: Ident = input.parse()?;\n        Ok(HeaderData { key_name, variable })\n    }\n}\n\n/// Implementation of Parse trait for HeadersData.\n///\n/// Parses headers variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<HeadersData>` - Parsed HeadersData or error.\nimpl Parse for HeadersData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(HeadersData { variable })\n    }\n}\n\n/// Implementation of Parse trait for CookieData.\n///\n/// Parses cookie key and variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<CookieData>` - Parsed CookieData or error.\nimpl Parse for CookieData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key_name: Expr = input.parse()?;\n        input.parse::<Token![=>]>()?;\n        let variable: Ident = input.parse()?;\n        Ok(CookieData { variable, key_name })\n    }\n}\n\n/// Implementation of Parse trait for CookiesData.\n///\n/// Parses cookies variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<CookiesData>` - Parsed CookiesData or error.\nimpl Parse for CookiesData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(CookiesData { variable })\n    }\n}\n\n/// Implementation of Parse trait for RequestVersionData.\n///\n/// Parses request version variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RequestVersionData>` - Parsed RequestVersionData or error.\nimpl Parse for RequestVersionData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(RequestVersionData { variable })\n    }\n}\n\n/// Implementation of Parse trait for RequestPathData.\n///\n/// Parses request path variable from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RequestPathData>` - Parsed RequestPathData or error.\nimpl Parse for RequestPathData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let variable: Ident = input.parse()?;\n        Ok(RequestPathData { variable })\n    }\n}", "file_size": 7570, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\http\\fn.rs", "language": "rust", "content": "use crate::*;\n\nmacro_rules! impl_http_method_macro {\n    ($name:ident, $method:expr) => {\n        pub(crate) fn $name(item: TokenStream) -> TokenStream {\n            expand_check_macro(\n                item,\n                create_method_check($method, proc_macro2::Span::call_site()),\n            )\n        }\n    };\n}\n\nimpl_http_method_macro!(get_handler, \"get\");\nimpl_http_method_macro!(post_handler, \"post\");\nimpl_http_method_macro!(put_handler, \"put\");\nimpl_http_method_macro!(delete_handler, \"delete\");\nimpl_http_method_macro!(patch_handler, \"patch\");\nimpl_http_method_macro!(head_handler, \"head\");\nimpl_http_method_macro!(options_handler, \"options\");\nimpl_http_method_macro!(connect_handler, \"connect\");\nimpl_http_method_macro!(trace_handler, \"trace\");\n\n/// Creates method check function for HTTP request validation.\n///\n/// # Arguments\n///\n/// - `&str` - The method name string.\n/// - `proc_macro2::Span` - The span for error reporting.\n///\n/// # Returns\n///\n/// - `impl FnOnce(&Ident) -> TokenStream2` - The generated check function.\npub(crate) fn create_method_check(\n    method_name: &str,\n    span: proc_macro2::Span,\n) -> impl FnOnce(&Ident) -> TokenStream2 {\n    let check_method: Ident = Ident::new(&format!(\"is_{}\", method_name), span);\n    move |context| {\n        quote! {\n            if !#context.get_request().await.#check_method() {\n                return;\n            }\n        }\n    }\n}\n\n/// Handles HTTP requests for multiple method types.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with methods check.\npub(crate) fn methods_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let methods: RequestMethods = parse_macro_input!(attr as RequestMethods);\n    let input_fn: ItemFn = parse_macro_input!(item as ItemFn);\n    let vis: &Visibility = &input_fn.vis;\n    let sig: &Signature = &input_fn.sig;\n    let block: &Block = &input_fn.block;\n    let attrs: &Vec<Attribute> = &input_fn.attrs;\n    match parse_context_from_fn(sig) {\n        Ok(context) => {\n            let method_checks = methods.methods.iter().map(|method| {\n                let check_fn: Ident = Ident::new(&format!(\"is_{}\", method), method.span());\n                quote! {\n                    #context.get_request().await.#check_fn()\n                }\n            });\n            let check_expr: TokenStream2 = quote! {\n                if !(#(#method_checks)||*) {\n                    return;\n                }\n            };\n            let stmts: &Vec<Stmt> = &block.stmts;\n            let gen_code: TokenStream2 = quote! {\n                #(#attrs)*\n                #vis #sig {\n                    #check_expr\n                    #(#stmts)*\n                }\n            };\n            gen_code.into()\n        }\n        Err(err) => err.to_compile_error().into(),\n    }\n}", "file_size": 2933, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\response\\enum.rs", "language": "rust", "content": "/// Defines operations that can be performed on response headers.\npub(crate) enum HeaderOperation {\n    /// Sets an existing header value, keeping the original if not present.\n    Set,\n    /// Add a new header value, overwriting any existing value.\n    Add,\n}", "file_size": 259, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\hyperlane\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of the `Parse` trait for `HyperlaneAttr`.\n///\n/// This implementation allows parsing a `HyperlaneAttr` from a token stream,\n/// expecting the format `variable_name: TypeName`.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The `ParseStream` to parse from.\n///\n/// # Returns\n///\n/// A `syn::Result` containing the parsed `HyperlaneAttr` or an error.\nimpl Parse for HyperlaneAttr {\n    fn parse(input: ParseStream) -> Result<Self> {\n        Ok(HyperlaneAttr {\n            var_name: input.parse()?,\n            _colon: input.parse()?,\n            type_name: input.parse()?,\n        })\n    }\n}", "file_size": 622, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\send\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Sends the response with both headers and body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with send operation.\npub(crate) fn send_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.send().await;\n        }\n    })\n}\n\n/// Sends only the response body.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with body send operation.\npub(crate) fn send_body_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.send_body().await;\n        }\n    })\n}\n\n/// Sends the response once with both headers and body (no keep-alive).\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with single send operation.\npub(crate) fn send_once_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.send_once().await;\n        }\n    })\n}\n\n/// Sends only the response body once (no keep-alive).\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with single body send operation.\npub(crate) fn send_once_body_macro(item: TokenStream) -> TokenStream {\n    expand_macro_with_after_insertion(item, |context| {\n        quote! {\n            let _ = #context.send_once_body().await;\n        }\n    })\n}", "file_size": 1765, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\referer\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Filters requests matching the specified Referer header.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with Referer filter.\npub(crate) fn referer_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let referer_data: RefererData = parse_macro_input!(attr as RefererData);\n    let referer_value: Expr = referer_data.referer_value;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let referer: OptionRequestHeadersValueItem = #context.get_request_header_back(REFERER).await;\n            if let Some(referer_header) = referer {\n                if referer_header != #referer_value {\n                    return;\n                }\n            } else {\n                return;\n            }\n        }\n    })\n}\n\n/// Filters requests not matching the specified Referer header.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with inverse Referer filter.\npub(crate) fn referer_filter_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let referer_data: RefererData = parse_macro_input!(attr as RefererData);\n    let referer_value: Expr = referer_data.referer_value;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let referer: OptionRequestHeadersValueItem = #context.get_request_header_back(REFERER).await;\n            if let Some(referer_header) = referer {\n                if referer_header == #referer_value {\n                    return;\n                }\n            }\n        }\n    })\n}", "file_size": 1809, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\response\\struct.rs", "language": "rust", "content": "use crate::*;\n\npub(crate) struct ResponseHeaderData {\n    pub(crate) key: Expr,\n    pub(crate) value: Expr,\n    pub(crate) operation: HeaderOperation,\n}\n\npub(crate) struct ResponseBodyData {\n    pub(crate) body: Expr,\n}", "file_size": 219, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\referer\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of Parse trait for RefererData.\n///\n/// Parses referer value expression from input stream.\n///\n/// # Arguments\n///\n/// - `ParseStream` - The input parse stream.\n///\n/// # Returns\n///\n/// - `syn::Result<RefererData>` - Parsed RefererData or error.\nimpl Parse for RefererData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let referer_value: Expr = input.parse()?;\n        Ok(RefererData { referer_value })\n    }\n}", "file_size": 465, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\protocol\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Checks if request is WebSocket protocol.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with protocol check.\npub(crate) fn ws_macro(item: TokenStream) -> TokenStream {\n    expand_check_macro(item, |context| {\n        quote! {\n            if !#context.get_request().await.is_ws() {\n                return;\n            }\n        }\n    })\n}\n\n/// Checks if request is HTTP protocol.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with protocol check.\npub(crate) fn http_macro(item: TokenStream) -> TokenStream {\n    expand_check_macro(item, |context| {\n        quote! {\n            if !#context.get_request().await.is_http() {\n                return;\n            }\n        }\n    })\n}\n\nmacro_rules! impl_protocol_check_macro {\n    ($name:ident, $check:ident) => {\n        pub(crate) fn $name(item: TokenStream) -> TokenStream {\n            expand_check_macro(item, |context| {\n                let check_fn = Ident::new(stringify!($check), proc_macro2::Span::call_site());\n                quote! {\n                    if !#context.get_request().await.#check_fn() {\n                        return;\n                    }\n                }\n            })\n        }\n    };\n}\n\nimpl_protocol_check_macro!(h2c_macro, is_h2c);\nimpl_protocol_check_macro!(http0_9_macro, is_http0_9);\nimpl_protocol_check_macro!(http1_0_macro, is_http1_0);\nimpl_protocol_check_macro!(http1_1_macro, is_http1_1);\nimpl_protocol_check_macro!(http1_1_or_higher_macro, is_http1_1_or_higher);\nimpl_protocol_check_macro!(http2_macro, is_http2);\nimpl_protocol_check_macro!(http3_macro, is_http3);\nimpl_protocol_check_macro!(tls_macro, is_tls);", "file_size": 1828, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\referer\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Referer data container storing referer value expression.\n///\n/// Used for Referer header matching in request processing.\npub(crate) struct RefererData {\n    /// The referer value expression to match against.\n    pub(crate) referer_value: Expr,\n}", "file_size": 264, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\request\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Container for HTTP methods data.\n///\n/// Used to store parsed HTTP methods from macro input.\npub(crate) struct RequestMethods {\n    /// The parsed HTTP methods as punctuated identifiers.\n    pub(crate) methods: Punctuated<Ident, Token![,]>,\n}\n\n/// Container for raw request body data.\n///\n/// Used to store parsed request body variable from macro input.\npub(crate) struct RequestBodyData {\n    /// The variable name to store the request body.\n    pub(crate) variable: Ident,\n}\n\n/// Container for JSON request body data.\n///\n/// Used to store parsed JSON request body variable and type from macro input.\npub(crate) struct RequestBodyJsonData {\n    /// The variable name to store the parsed JSON.\n    pub(crate) variable: Ident,\n    /// The type to parse the JSON into.\n    pub(crate) type_name: Type,\n}\n\n/// Container for request attribute data.\n///\n/// Used to store parsed attribute key, variable and type from macro input.\npub(crate) struct AttributeData {\n    /// The variable name to store the attribute value.\n    pub(crate) variable: Ident,\n    /// The type to parse the attribute into.\n    pub(crate) type_name: Type,\n    /// The attribute key name.\n    pub(crate) key_name: Expr,\n}\n\n/// Container for request attributes data.\n///\n/// Used to store parsed attributes variable from macro input.\npub(crate) struct AttributesData {\n    /// The variable name to store all attributes.\n    pub(crate) variable: Ident,\n}\n\n/// Container for route parameter data.\n///\n/// Used to store parsed route parameter key and variable from macro input.\npub(crate) struct RouteParamData {\n    /// The variable name to store the route parameter value.\n    pub(crate) variable: Ident,\n    /// The route parameter key name.\n    pub(crate) key_name: Expr,\n}\n\n/// Container for route parameters data.\n///\n/// Used to store parsed route parameters variable from macro input.\npub(crate) struct RouteParamsData {\n    /// The variable name to store all route parameters.\n    pub(crate) variable: Ident,\n}\n\n/// Container for query parameter data.\n///\n/// Used to store parsed query parameter key and variable from macro input.\npub(crate) struct QueryData {\n    /// The variable name to store the query parameter value.\n    pub(crate) variable: Ident,\n    /// The query parameter key name.\n    pub(crate) key_name: Expr,\n}\n\n/// Container for query parameters data.\n///\n/// Used to store parsed query parameters variable from macro input.\npub(crate) struct QuerysData {\n    /// The variable name to store all query parameters.\n    pub(crate) variable: Ident,\n}\n\n/// Container for request header data.\n///\n/// Used to store parsed header key and variable from macro input.\npub(crate) struct HeaderData {\n    /// The variable name to store the header value.\n    pub(crate) variable: Ident,\n    /// The header key name.\n    pub(crate) key_name: Expr,\n}\n\n/// Container for request headers data.\n///\n/// Used to store parsed headers variable from macro input.\npub(crate) struct HeadersData {\n    /// The variable name to store all headers.\n    pub(crate) variable: Ident,\n}\n\n/// Container for request cookie data.\n///\n/// Used to store parsed cookie key and variable from macro input.\npub(crate) struct CookieData {\n    /// The variable name to store the cookie value.\n    pub(crate) variable: Ident,\n    /// The cookie key name.\n    pub(crate) key_name: Expr,\n}\n\n/// Container for request cookies data.\n///\n/// Used to store parsed cookies variable from macro input.\npub(crate) struct CookiesData {\n    /// The variable name to store all cookies.\n    pub(crate) variable: Ident,\n}\n\n/// Container for request version data.\n///\n/// Used to store parsed request version variable from macro input.\npub(crate) struct RequestVersionData {\n    /// The variable name to store the request version.\n    pub(crate) variable: Ident,\n}\n\n/// Container for request path data.\n///\n/// Used to store parsed request path variable from macro input.\npub(crate) struct RequestPathData {\n    /// The variable name to store the request path.\n    pub(crate) variable: Ident,\n}", "file_size": 4043, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\host\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Host data container storing host value expression.\n///\n/// Used for host matching in request processing.\npub(crate) struct HostData {\n    /// The host value expression to match against.\n    pub(crate) host_value: Expr,\n}", "file_size": 239, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\request\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Gets raw request body and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with body extraction.\npub(crate) fn request_body_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let body_param: RequestBodyData = parse_macro_input!(attr as RequestBodyData);\n    let variable: Ident = body_param.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RequestBody = #context.get_request_body().await;\n        }\n    })\n}\n\n/// Parses request body as JSON and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with JSON parsing.\npub(crate) fn request_body_json_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let body_param: RequestBodyJsonData = parse_macro_input!(attr as RequestBodyJsonData);\n    let variable: Ident = body_param.variable;\n    let type_name: Type = body_param.type_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: ResultJsonError<#type_name> = #context.get_request_body_json::<#type_name>().await;\n        }\n    })\n}\n\n/// Gets request attribute by key and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with attribute extraction.\npub(crate) fn attribute_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let attribute: AttributeData = parse_macro_input!(attr as AttributeData);\n    let variable: Ident = attribute.variable;\n    let type_name: Type = attribute.type_name;\n    let key_name: Expr = attribute.key_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: Option<#type_name> = #context.get_attribute::<#type_name>(#key_name).await;\n        }\n    })\n}\n\n/// Gets all request attributes and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with attributes extraction.\npub(crate) fn attributes_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let attributes: AttributesData = parse_macro_input!(attr as AttributesData);\n    let variable: Ident = attributes.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: HashMapArcAnySendSync = #context.get_attributes().await;\n        }\n    })\n}\n\n/// Gets route parameter by key and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with route param extraction.\npub(crate) fn route_param_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let route_param: RouteParamData = parse_macro_input!(attr as RouteParamData);\n    let variable: Ident = route_param.variable;\n    let key_name: Expr = route_param.key_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: OptionString = #context.get_route_param(#key_name).await;\n        }\n    })\n}\n\n/// Gets all route parameters and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with route params extraction.\npub(crate) fn route_params_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let route_params: RouteParamsData = parse_macro_input!(attr as RouteParamsData);\n    let variable: Ident = route_params.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RouteParams = #context.get_route_params().await;\n        }\n    })\n}\n\n/// Gets request query parameter by key and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with query param extraction.\npub(crate) fn request_query_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let request_query: QueryData = parse_macro_input!(attr as QueryData);\n    let variable: Ident = request_query.variable;\n    let key_name: Expr = request_query.key_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: OptionRequestQuerysValue = #context.get_request_query(#key_name).await;\n        }\n    })\n}\n\n/// Gets all request query parameters and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with query params extraction.\npub(crate) fn request_querys_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let request_query: QuerysData = parse_macro_input!(attr as QuerysData);\n    let variable: Ident = request_query.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RequestQuerys = #context.get_request_querys().await;\n        }\n    })\n}\n\n/// Gets request header by key and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with header extraction.\npub(crate) fn request_header_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let request_header: HeaderData = parse_macro_input!(attr as HeaderData);\n    let variable: Ident = request_header.variable;\n    let key_name: Expr = request_header.key_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: OptionRequestHeadersValueItem = #context.get_request_header_back(#key_name).await;\n        }\n    })\n}\n\n/// Gets all request headers and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with headers extraction.\npub(crate) fn request_headers_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let request_headers: HeadersData = parse_macro_input!(attr as HeadersData);\n    let variable: Ident = request_headers.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RequestHeaders = #context.get_request_headers().await;\n        }\n    })\n}\n\n/// Gets request cookie by key and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with cookie extraction.\npub(crate) fn request_cookie_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let cookie_data: CookieData = parse_macro_input!(attr as CookieData);\n    let variable: Ident = cookie_data.variable;\n    let key: Expr = cookie_data.key_name;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: OptionCookiesValue = #context.get_request_cookie(#key).await;\n        }\n    })\n}\n\n/// Gets all request cookies and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with cookies extraction.\npub(crate) fn request_cookies_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let cookies_data: CookiesData = parse_macro_input!(attr as CookiesData);\n    let variable: Ident = cookies_data.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: Cookies = #context.get_request_cookies().await;\n        }\n    })\n}\n\n/// Gets request version and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with version extraction.\npub(crate) fn request_version_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let version_data: RequestVersionData = parse_macro_input!(attr as RequestVersionData);\n    let variable: Ident = version_data.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RequestVersion = #context.get_request_version().await;\n        }\n    })\n}\n\n/// Gets request path and assigns to specified variable.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with path extraction.\npub(crate) fn request_path_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let path_data: RequestPathData = parse_macro_input!(attr as RequestPathData);\n    let variable: Ident = path_data.variable;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            let #variable: RequestPath = #context.get_request_path().await;\n        }\n    })\n}", "file_size": 10036, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\response\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Parses a TokenStream into an Expr.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The input token stream to parse.\n///\n/// # Returns\n///\n/// - `syn::Result<Expr>` - The parsed expression or error.\nfn parse_expr(input: TokenStream) -> syn::Result<Expr> {\n    syn::parse::<Expr>(input)\n}\n\n/// Sets response status code from macro input.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with status code setting.\npub(crate) fn response_status_code_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    expand_macro_with_attr_and_before_insertion(attr, item, parse_expr, |context, value| {\n        quote! {\n            #context.set_response_status_code(hyperlane::ResponseStatusCode::from(#value as usize)).await;\n        }\n    })\n}\n\n/// Sets response reason phrase from macro input.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with reason phrase setting.\npub(crate) fn response_reason_phrase_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    expand_macro_with_attr_and_before_insertion(attr, item, parse_expr, |context, value| {\n        quote! {\n            #context.set_response_reason_phrase(#value).await;\n        }\n    })\n}\n\n/// Sets or replaces response header from macro input.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with header operation.\npub(crate) fn response_header_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let header_data: ResponseHeaderData = parse_macro_input!(attr as ResponseHeaderData);\n    let key: Expr = header_data.key;\n    let value: Expr = header_data.value;\n    let operation: HeaderOperation = header_data.operation;\n    expand_macro_with_before_insertion(item, |context| match operation {\n        HeaderOperation::Add => {\n            quote! {\n                #context.add_response_header(#key, #value).await;\n            }\n        }\n        HeaderOperation::Set => {\n            quote! {\n                #context.set_response_header(#key, #value).await;\n            }\n        }\n    })\n}\n\n/// Sets response body from macro input.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with body setting.\npub(crate) fn response_body_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let body_data: ResponseBodyData = parse_macro_input!(attr as ResponseBodyData);\n    let body: Expr = body_data.body;\n    expand_macro_with_before_insertion(item, |context| {\n        quote! {\n            #context.set_response_body(#body).await;\n        }\n    })\n}\n\n/// Sets response version from macro input.\n///\n/// # Arguments\n///\n/// - `TokenStream` - The attribute token stream.\n/// - `TokenStream` - The input token stream to process.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with version setting.\npub(crate) fn response_version_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    expand_macro_with_attr_and_before_insertion(attr, item, parse_expr, |context, value| {\n        quote! {\n            #context.set_response_version(#value).await;\n        }\n    })\n}", "file_size": 3610, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\response\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of Parse trait for ResponseHeaderData.\n///\n/// Parses header key, operation and value from input stream.\nimpl Parse for ResponseHeaderData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let key: Expr = input.parse()?;\n        let operation: HeaderOperation = if input.peek(Token![=>]) {\n            input.parse::<Token![=>]>()?;\n            HeaderOperation::Set\n        } else if input.peek(Token![,]) {\n            input.parse::<Token![,]>()?;\n            HeaderOperation::Add\n        } else {\n            return Err(syn::Error::new(\n                input.span(),\n                \"Expected either ',' for add operation or '=>' for set operation\",\n            ));\n        };\n        let value: Expr = input.parse()?;\n        Ok(ResponseHeaderData {\n            key,\n            value,\n            operation,\n        })\n    }\n}\n\n/// Implementation of Parse trait for ResponseBodyData.\n///\n/// Parses response body expression from input stream.\nimpl Parse for ResponseBodyData {\n    fn parse(input: ParseStream) -> syn::Result<Self> {\n        let body: Expr = input.parse()?;\n        Ok(ResponseBodyData { body })\n    }\n}", "file_size": 1172, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\referer\\mod.rs", "language": "rust", "content": "mod r#fn;\nmod r#impl;\nmod r#struct;\n\npub(crate) use r#fn::*;\npub(crate) use r#struct::*;", "file_size": 88, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-log\\src\\cfg.rs", "language": "rust", "content": "#[cfg(test)]\n#[tokio::test]\nasync fn test() {\n    use crate::*;\n    let log: Log = Log::new(\"./logs\", 1_024_000);\n    let error_str: String = String::from(\"custom error message\");\n    log.error(error_str, |error| {\n        let write_data: String = format!(\"User error func => {:?}\\n\", error);\n        write_data\n    });\n    let info_str: String = String::from(\"custom info message\");\n    log.info(info_str, |info| {\n        let write_data: String = format!(\"User info func => {:?}\\n\", info);\n        write_data\n    });\n    let debug_str: String = String::from(\"custom debug message\");\n    log.debug(debug_str, |debug| {\n        let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n        write_data\n    });\n    let async_error_str: String = String::from(\"custom async error message\");\n    log.async_error(async_error_str, |error| {\n        let write_data: String = format!(\"User error func => {:?}\\n\", error);\n        write_data\n    })\n    .await;\n    let async_info_str: String = String::from(\"custom async info message\");\n    log.async_info(async_info_str, |info| {\n        let write_data: String = format!(\"User info func => {:?}\\n\", info);\n        write_data\n    })\n    .await;\n    let async_debug_str: String = String::from(\"custom async debug message\");\n    log.async_debug(async_debug_str, |debug| {\n        let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n        write_data\n    })\n    .await;\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_more_log_first() {\n    use crate::*;\n    let log: Log = Log::new(\"./logs\", DISABLE_LOG_FILE_SIZE);\n    log.error(\"error data => \", |error| {\n        let write_data: String = format!(\"User error func => {:?}\\n\", error);\n        write_data\n    });\n    log.info(\"info data => \", |info| {\n        let write_data: String = format!(\"User info func => {:?}\\n\", info);\n        write_data\n    });\n    log.debug(\"debug data => \", |debug| {\n        let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n        write_data\n    });\n    log.async_error(\"async error data => \", |error| {\n        let write_data: String = format!(\"User error func => {:?}\\n\", error);\n        write_data\n    })\n    .await;\n    log.async_info(\"async info data => \", |info| {\n        let write_data: String = format!(\"User info func => {:?}\\n\", info);\n        write_data\n    })\n    .await;\n    log.async_debug(\"async debug data => \", |debug| {\n        let write_data: String = format!(\"User debug func => {:#?}\\n\", debug);\n        write_data\n    })\n    .await;\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_more_log_second() {\n    use crate::*;\n    for _ in 0..10 {\n        let log: Log = Log::new(\"./logs\", 512_000);\n        log.error(\"error data!\\n\", common_log);\n        log.async_error(\"async error data!\\n\", common_log).await;\n    }\n}", "file_size": 2807, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\hyperlane\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Main macro for creating and configuring a Hyperlane server instance.\n///\n/// This macro expects an attribute in the format `#[hyperlane(variable_name: TypeName)]`.\n///\n/// # Arguments\n///\n/// - `TokenStream`: The attribute token stream, containing the variable and type name.\n/// - `TokenStream`: The input token stream to process, typically an `async fn`.\n///\n/// # Returns\n///\n/// - `TokenStream` - The expanded token stream with server initialization.\npub(crate) fn hyperlane_macro(attr: TokenStream, item: TokenStream) -> TokenStream {\n    let hyperlane_attr: HyperlaneAttr = parse_macro_input!(attr as HyperlaneAttr);\n    let input_fn: ItemFn = parse_macro_input!(item as ItemFn);\n    let vis: &Visibility = &input_fn.vis;\n    let sig: &Signature = &input_fn.sig;\n    let block: &Block = &input_fn.block;\n    let ident: &Ident = &sig.ident;\n    let attrs: &Vec<Attribute> = &input_fn.attrs;\n    let stmts: &Vec<Stmt> = &block.stmts;\n    let inputs: &Punctuated<FnArg, token::Comma> = &sig.inputs;\n    let output: &ReturnType = &sig.output;\n    let mut init_statements: Vec<TokenStream2> = Vec::new();\n    let var_name: &Ident = &hyperlane_attr.var_name;\n    let type_name: &Ident = &hyperlane_attr.type_name;\n    init_statements.push(quote! {\n        let #var_name: #type_name = #type_name::new().await;\n    });\n    let gen_code: TokenStream2 = quote! {\n        #(#attrs)*\n        #vis async fn #ident(#inputs) #output {\n            #(#init_statements)*\n            #(#stmts)*\n        }\n    };\n    gen_code.into()\n}", "file_size": 1539, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\cfg.rs", "language": "rust", "content": "#[tokio::test]\npub async fn test_broadcast() {\n    use crate::*;\n\n    let broadcast: Broadcast<usize> = Broadcast::new(10);\n    let mut rec1: BroadcastReceiver<usize> = broadcast.subscribe();\n    let mut rec2: BroadcastReceiver<usize> = broadcast.subscribe();\n    broadcast.send(20).unwrap();\n    assert_eq!(rec1.recv().await, Ok(20));\n    assert_eq!(rec2.recv().await, Ok(20));\n}\n\n#[tokio::test]\npub async fn test_broadcast_map() {\n    use crate::*;\n\n    let broadcast_map: BroadcastMap<usize> = BroadcastMap::new();\n    broadcast_map.insert(\"a\", 10);\n    let mut rec1: BroadcastMapReceiver<usize> = broadcast_map.subscribe(\"a\").unwrap();\n    let mut rec2: BroadcastMapReceiver<usize> = broadcast_map.subscribe(\"a\").unwrap();\n    let mut rec3: BroadcastMapReceiver<usize> =\n        broadcast_map.subscribe_or_insert(\"b\", DEFAULT_BROADCAST_SENDER_CAPACITY);\n    broadcast_map.send(\"a\", 20).unwrap();\n    broadcast_map.send(\"b\", 10).unwrap();\n    assert_eq!(rec1.recv().await, Ok(20));\n    assert_eq!(rec2.recv().await, Ok(20));\n    assert_eq!(rec3.recv().await, Ok(10));\n}", "file_size": 1072, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\const.rs", "language": "rust", "content": "/// Defines the default capacity for a broadcast sender.\n///\n/// This constant specifies the initial buffer size for messages awaiting delivery\n/// to receivers in a broadcast channel.\npub const DEFAULT_BROADCAST_SENDER_CAPACITY: usize = 1024;", "file_size": 243, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `BroadcastTrait` for any type that also implements `Clone` and `Debug`.\n/// This blanket implementation allows any clonable and debuggable type to be used in the broadcast system.\nimpl<T: Clone + Debug> BroadcastTrait for T {}\n\n/// Provides a default implementation for `Broadcast` instances.\n///\n/// The default broadcast channel is initialized with a predefined sender capacity.\nimpl<T: BroadcastTrait> Default for Broadcast<T> {\n    /// Creates a new `Broadcast` instance with default settings.\n    ///\n    /// # Returns\n    ///\n    /// - `Broadcast<T>` - A broadcast instance with default sender capacity.\n    fn default() -> Self {\n        let sender: BroadcastSender<T> = BroadcastSender::new(DEFAULT_BROADCAST_SENDER_CAPACITY);\n        Broadcast {\n            capacity: 0,\n            sender,\n        }\n    }\n}\n\n/// Implements core functionalities for the `Broadcast` struct.\nimpl<T: BroadcastTrait> Broadcast<T> {\n    /// Creates a new `Broadcast` instance with a specified capacity.\n    ///\n    /// # Arguments\n    ///\n    /// - `Capacity` - The maximum number of messages that can be buffered.\n    ///\n    /// # Returns\n    ///\n    /// - `Broadcast<T>` - A new broadcast instance.\n    pub fn new(capacity: Capacity) -> Self {\n        let sender: BroadcastSender<T> = BroadcastSender::new(capacity);\n        let mut broadcast: Broadcast<T> = Broadcast::default();\n        broadcast.sender = sender;\n        broadcast.capacity = capacity;\n        broadcast\n    }\n\n    /// Retrieves the current number of active receivers subscribed to this broadcast channel.\n    ///\n    /// # Returns\n    ///\n    /// - `ReceiverCount` - The total count of active receivers.\n    pub fn receiver_count(&self) -> ReceiverCount {\n        self.sender.receiver_count()\n    }\n\n    /// Subscribes a new receiver to the broadcast channel.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastReceiver<T>` - A new receiver instance.\n    pub fn subscribe(&self) -> BroadcastReceiver<T> {\n        self.sender.subscribe()\n    }\n\n    /// Sends a message to all active receivers subscribed to this broadcast channel.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The message to be broadcasted.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastSendResult<T>` - Result indicating send status.\n    pub fn send(&self, data: T) -> BroadcastSendResult<T> {\n        self.sender.send(data)\n    }\n}", "file_size": 2412, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\debug\\src\\main.rs", "language": "rust", "content": "use hyperlane::*;\nuse hyperlane_macros::*;\nuse serde::{Deserialize, Serialize};\n\nconst TEST_ATTRIBUTE_KEY: &str = \"test_attribute_key\";\nconst CUSTOM_STATUS_CODE: i32 = 200;\nconst CUSTOM_REASON: &str = \"Accepted\";\nconst CUSTOM_HEADER_NAME: &str = \"X-Custom-Header\";\nconst CUSTOM_HEADER_VALUE: &str = \"custom-value\";\nconst RESPONSE_DATA: &str = \"{\\\"status\\\": \\\"success\\\"}\";\n\n#[derive(Debug, Serialize, Deserialize, Clone)]\nstruct TestData {\n    name: String,\n    age: u32,\n}\n\n#[response_version(HttpVersion::HTTP1_1)]\nasync fn request_middleware(ctx: Context) {}\n\n#[get]\n#[http]\nasync fn ctx_pre_hook(ctx: Context) {}\n\n#[flush]\n#[send]\n#[response_status_code(200)]\nasync fn ctx_post_hook(ctx: Context) {}\n\n#[send]\n#[response_status_code(CUSTOM_STATUS_CODE)]\n#[response_reason_phrase(CUSTOM_REASON)]\n#[response_header(CUSTOM_HEADER_NAME => CUSTOM_HEADER_VALUE)]\n#[response_body(RESPONSE_DATA)]\nasync fn response(ctx: Context) {}\n\n#[connect]\nasync fn connect(ctx: Context) {\n    let _ = ctx.set_response_body(\"connect\").await.send().await;\n}\n\n#[delete]\nasync fn delete(ctx: Context) {\n    let _ = ctx.set_response_body(\"delete\").await.send().await;\n}\n\n#[head]\nasync fn head(ctx: Context) {\n    let _ = ctx.set_response_body(\"head\").await.send().await;\n}\n\n#[options]\nasync fn options(ctx: Context) {\n    let _ = ctx.set_response_body(\"options\").await.send().await;\n}\n\n#[patch]\nasync fn patch(ctx: Context) {\n    let _ = ctx.set_response_body(\"patch\").await.send().await;\n}\n\n#[put]\nasync fn put(ctx: Context) {\n    let _ = ctx.set_response_body(\"put\").await.send().await;\n}\n\n#[trace]\nasync fn trace(ctx: Context) {\n    let _ = ctx.set_response_body(\"trace\").await.send().await;\n}\n\n#[send]\n#[h2c]\nasync fn h2c(ctx: Context) {\n    let _ = ctx.set_response_body(\"h2c\").await;\n}\n\n#[send]\n#[http]\nasync fn http_only(ctx: Context) {\n    let _ = ctx.set_response_body(\"http\").await;\n}\n\n#[send]\n#[http0_9]\nasync fn http0_9(ctx: Context) {\n    let _ = ctx.set_response_body(\"http0.9\").await;\n}\n\n#[send]\n#[http1_0]\nasync fn http1_0(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.0\").await;\n}\n\n#[send]\n#[http1_1]\nasync fn http1_1(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.1\").await;\n}\n\n#[send]\n#[http2]\nasync fn http2(ctx: Context) {\n    let _ = ctx.set_response_body(\"http2\").await;\n}\n\n#[send]\n#[http3]\nasync fn http3(ctx: Context) {\n    let _ = ctx.set_response_body(\"http3\").await;\n}\n\n#[send]\n#[tls]\nasync fn tls(ctx: Context) {\n    let _ = ctx.set_response_body(\"tls\").await;\n}\n\n#[send]\n#[http1_1_or_higher]\nasync fn http1_1_or_higher(ctx: Context) {\n    let _ = ctx.set_response_body(\"http1.1+\").await;\n}\n\n#[send]\n#[filter_unknown_method]\nasync fn unknown_method(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown method\").await;\n}\n\n#[send]\n#[filter_unknown_upgrade]\nasync fn unknown_upgrade(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown upgrade\").await;\n}\n\n#[send]\n#[filter_unknown_version]\nasync fn unknown_version(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown version\").await;\n}\n\n#[send]\n#[filter_unknown]\nasync fn unknown_all(ctx: Context) {\n    let _ = ctx.set_response_body(\"unknown all\").await;\n}\n\n#[send_body]\n#[ws]\n#[get]\nasync fn get(ctx: Context) {\n    let _ = ctx.set_response_body(\"get\").await;\n}\n\n#[send_once]\n#[post]\nasync fn post(ctx: Context) {\n    let _ = ctx.set_response_body(\"post\").await;\n}\n\n#[send_once_body]\n#[ws]\nasync fn websocket(ctx: Context) {\n    let _ = ctx.set_response_body(\"websocket\").await;\n}\n\n#[send]\n#[pre_hook(ctx_pre_hook)]\n#[post_hook(ctx_post_hook)]\nasync fn ctx_hook(ctx: Context) {\n    let _ = ctx.set_response_body(\"Testing hook macro\").await;\n}\n\n#[closed]\n#[send]\n#[response_reason_phrase(\"OK\")]\n#[response_status_code(200)]\n#[methods(get, post)]\n#[http]\nasync fn get_post(ctx: Context) {\n    let _ = ctx.set_response_body(\"get_post\").await;\n}\n\n#[send]\n#[attributes(request_attributes)]\nasync fn attributes(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_attributes);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[route_params(request_route_params)]\nasync fn route_params(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_route_params);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_querys(request_querys)]\nasync fn request_querys(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_querys);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_headers(request_headers)]\nasync fn request_headers(ctx: Context) {\n    let response: String = format!(\"{:?}\", request_headers);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[route_param(\"test\" => request_route_param)]\nasync fn route_param(ctx: Context) {\n    if let Some(data) = request_route_param {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_query(\"test\" => request_query_option)]\nasync fn request_query(ctx: Context) {\n    if let Some(data) = request_query_option {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_header(HOST => request_header_option)]\nasync fn request_header(ctx: Context) {\n    if let Some(data) = request_header_option {\n        let _ = ctx.set_response_body(data).await;\n    }\n}\n\n#[send]\n#[request_body(raw_body)]\nasync fn request_body(ctx: Context) {\n    let response: String = format!(\"Raw body: {:?}\", raw_body);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[host(\"localhost\")]\nasync fn host(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"host string literal: localhost\")\n        .await;\n}\n\n#[send]\n#[host_filter(\"filter.localhost\")]\nasync fn host_filter(ctx: Context) {\n    let _ = ctx.set_response_body(\"host filter string literal\").await;\n}\n\n#[send]\n#[attribute(TEST_ATTRIBUTE_KEY => request_attribute_option: TestData)]\nasync fn attribute(ctx: Context) {\n    if let Some(data) = request_attribute_option {\n        let response: String = format!(\"name={}, age={}\", data.name, data.age);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[request_body_json(request_data_result: TestData)]\nasync fn request_body_json(ctx: Context) {\n    if let Ok(data) = request_data_result {\n        let response: String = format!(\"name={}, age={}\", data.name, data.age);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[referer(\"http://localhost\")]\nasync fn referer(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"referer string literal: http://localhost\")\n        .await;\n}\n\n#[send]\n#[referer_filter(\"http://localhost\")]\nasync fn referer_filter(ctx: Context) {\n    let _ = ctx.set_response_body(\"referer filter string literal\").await;\n}\n\n#[send]\n#[request_cookies(cookie_value)]\nasync fn cookies(ctx: Context) {\n    let response: String = format!(\"All cookies: {:?}\", cookie_value);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_cookie(\"test\" => session_cookie_opt)]\nasync fn cookie(ctx: Context) {\n    if let Some(session) = session_cookie_opt {\n        let response: String = format!(\"Session cookie: {}\", session);\n        let _ = ctx.set_response_body(response).await;\n    }\n}\n\n#[send]\n#[request_version(http_version)]\nasync fn request_version_test(ctx: Context) {\n    let response: String = format!(\"HTTP Version: {:?}\", http_version);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[request_path(request_path)]\nasync fn request_path_test(ctx: Context) {\n    let response: String = format!(\"Request Path: {:?}\", request_path);\n    let _ = ctx.set_response_body(response).await;\n}\n\n#[send]\n#[response_header(\"X-Add-Header\", \"add-value\")]\n#[response_header(\"X-Set-Header\" => \"set-value\")]\nasync fn response_header_test(ctx: Context) {\n    let _ = ctx\n        .set_response_body(\"Testing header set and replace operations\")\n        .await;\n}\n\n#[send]\n#[response_status_code(201)]\n#[response_reason_phrase(HttpStatus::Created.to_string())]\n#[response_header(CONTENT_TYPE => APPLICATION_JSON)]\n#[response_body(\"{\\\"message\\\": \\\"Resource created\\\"}\")]\nasync fn literals(ctx: Context) {}\n\n#[hyperlane(server: Server)]\n#[hyperlane(config: ServerConfig)]\n#[tokio::main]\nasync fn main() {\n    config.disable_nodelay().await;\n    server.config(config).await;\n    server.request_middleware(request_middleware).await;\n    server.route(\"/response\", response).await;\n    server.route(\"/connect\", connect).await;\n    server.route(\"/delete\", delete).await;\n    server.route(\"/head\", head).await;\n    server.route(\"/options\", options).await;\n    server.route(\"/patch\", patch).await;\n    server.route(\"/put\", put).await;\n    server.route(\"/trace\", trace).await;\n    server.route(\"/h2c\", h2c).await;\n    server.route(\"/http\", http_only).await;\n    server.route(\"/http0_9\", http0_9).await;\n    server.route(\"/http1_0\", http1_0).await;\n    server.route(\"/http1_1\", http1_1).await;\n    server.route(\"/http2\", http2).await;\n    server.route(\"/http3\", http3).await;\n    server.route(\"/tls\", tls).await;\n    server.route(\"/http1_1_or_higher\", http1_1_or_higher).await;\n    server.route(\"/unknown_method\", unknown_method).await;\n    server.route(\"/unknown_upgrade\", unknown_upgrade).await;\n    server.route(\"/unknown_version\", unknown_version).await;\n    server.route(\"/unknown_all\", unknown_all).await;\n    server.route(\"/get\", get).await;\n    server.route(\"/post\", post).await;\n    server.route(\"/websocket\", websocket).await;\n    server.route(\"/ctx_hook\", ctx_hook).await;\n    server.route(\"/get_post\", get_post).await;\n    server.route(\"/attributes\", attributes).await;\n    server.route(\"/route_params/:test\", route_params).await;\n    server.route(\"/request_querys\", request_querys).await;\n    server.route(\"/request_headers\", request_headers).await;\n    server.route(\"/route_param/:test\", route_param).await;\n    server.route(\"/request_query\", request_query).await;\n    server.route(\"/request_header\", request_header).await;\n    server.route(\"/request_body\", request_body).await;\n    server.route(\"/host\", host).await;\n    server.route(\"/host_filter\", host_filter).await;\n    server.route(\"/attribute\", attribute).await;\n    server.route(\"/request_body_json\", request_body_json).await;\n    server.route(\"/referer\", referer).await;\n    server.route(\"/referer_filter\", referer_filter).await;\n    server.route(\"/cookies\", cookies).await;\n    server.route(\"/cookie\", cookie).await;\n    server.route(\"/request_version\", request_version_test).await;\n    server.route(\"/request_path\", request_path_test).await;\n    server.route(\"/response_header\", response_header_test).await;\n    server.route(\"/literals\", literals).await;\n    let server_hook: ServerHook = server.run().await.unwrap_or_default();\n    let server_hook_clone: ServerHook = server_hook.clone();\n    tokio::spawn(async move {\n        tokio::time::sleep(std::time::Duration::from_secs(60)).await;\n        server_hook.shutdown().await;\n    });\n    server_hook_clone.wait().await;\n}", "file_size": 10900, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-macros\\src\\response\\mod.rs", "language": "rust", "content": "mod r#enum;\nmod r#fn;\nmod r#impl;\nmod r#struct;\n\npub(crate) use r#enum::*;\npub(crate) use r#fn::*;\npub(crate) use r#struct::*;", "file_size": 126, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-log\\src\\lib.rs", "language": "rust", "content": "//! hyperlane-log\n//!\n//! A Rust logging library that supports both asynchronous and synchronous logging.\n//! It provides multiple log levels, such as error, info, and debug.\n//! Users can define custom log handling methods and configure log file paths.\n//! The library supports log rotation, automatically creating a new log file\n//! when the current file reaches the specified size limit.\n//! It allows flexible logging configurations, making it suitable for\n//! both high-performance asynchronous applications and\n//! traditional synchronous logging scenarios. The asynchronous mode utilizes\n//! Tokio's async channels for efficient log buffering,\n//! while the synchronous mode writes logs directly to the file system.\n\npub(crate) mod cfg;\npub(crate) mod log;\n\npub use log::*;\n\npub(crate) use file_operation::*;\npub(crate) use hyperlane_time::*;\npub(crate) use std::{\n    fs::read_dir,\n    sync::{Arc, RwLock},\n};", "file_size": 917, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Defines the essential traits required for types that can be broadcast.\n///\n/// Any type implementing `BroadcastTrait` must also implement `Clone` and `Debug`,\n/// enabling efficient duplication and debugging within the broadcast system.\npub trait BroadcastTrait: Clone + Debug {}", "file_size": 298, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\lib.rs", "language": "rust", "content": "//! hyperlane-broadcast\n//!\n//! hyperlane-broadcast is a lightweight\n//! and ergonomic wrapper over Tokio’s broadcast channel designed\n//! for easy-to-use publish-subscribe messaging in async Rust applications.\n//! It simplifies the native Tokio broadcast API by providing a straightforward\n//! interface for broadcasting messages to multiple subscribers with minimal boilerplate.\n\npub(crate) mod broadcast;\npub(crate) mod broadcast_map;\npub(crate) mod cfg;\n\npub use broadcast::{r#const::*, r#struct::*, r#trait::*, r#type::*};\npub use broadcast_map::{r#struct::*, r#trait::*, r#type::*};\n\npub(crate) use std::{fmt::Debug, hash::BuildHasherDefault};\n\npub(crate) use dashmap::*;\npub(crate) use tokio::sync::broadcast::{\n    error::SendError,\n    {Receiver, Sender},\n};\npub(crate) use twox_hash::XxHash3_64;", "file_size": 805, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\mod.rs", "language": "rust", "content": "pub mod r#const;\npub mod r#impl;\npub mod r#struct;\npub mod r#trait;\npub mod r#type;", "file_size": 83, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast_map\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `BroadcastMapTrait` for any type that also implements `Clone` and `Debug`.\n/// This blanket implementation allows any clonable and debuggable type to be used as a value in the broadcast map system.\nimpl<T: Clone + Debug> BroadcastMapTrait for T {}\n\n/// Provides a default implementation for `BroadcastMap` instances.\n///\n/// The default broadcast map is initialized as an empty `DashMap`.\nimpl<T: BroadcastMapTrait> Default for BroadcastMap<T> {\n    /// Creates a new, empty `BroadcastMap` instance.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMap<T>` - An empty broadcast map.\n    fn default() -> Self {\n        Self(DashMap::with_hasher(BuildHasherDefault::default()))\n    }\n}\n\n/// Implements core functionalities for the `BroadcastMap` struct.\nimpl<T: BroadcastMapTrait> BroadcastMap<T> {\n    /// Creates a new, empty `BroadcastMap` instance.\n    ///\n    /// This is a convenience constructor that simply calls `default()`.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastMap<T>` - An empty broadcast map.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Retrieves an immutable reference to the underlying `DashMapStringBroadcast`.\n    ///\n    /// This private helper method provides direct access to the internal map.\n    ///\n    /// # Returns\n    ///\n    /// - `&DashMapStringBroadcast<T>` - Reference to the internal map.\n    fn get(&self) -> &DashMapStringBroadcast<T> {\n        &self.0\n    }\n\n    /// Inserts a new broadcast channel into the map with a specified key and capacity.\n    ///\n    /// If a broadcast channel with the given key already exists, it will be replaced.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - Key convertible to `String`.\n    /// - `Capacity` - Maximum number of buffered messages.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<Broadcast<T>>` - Previous broadcast channel if replaced.\n    pub fn insert<K>(&self, key: K, capacity: Capacity) -> OptionBroadcast<T>\n    where\n        K: ToString,\n    {\n        let key_string: String = key.to_string();\n        let broadcast: Broadcast<T> = Broadcast::new(capacity);\n        self.get().insert(key_string, broadcast)\n    }\n\n    /// Retrieves the number of active receivers for the broadcast channel associated with the given key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - Key convertible to `String`.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<ReceiverCount>` - Number of receivers if channel exists.\n    pub fn receiver_count<K>(&self, key: K) -> OptionReceiverCount\n    where\n        K: ToString,\n    {\n        self.get()\n            .get(&key.to_string())\n            .map(|receiver| receiver.receiver_count())\n    }\n\n    /// Subscribes a new receiver to the broadcast channel associated with the given key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - Key convertible to `String`.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<BroadcastReceiver<T>>` - New receiver if channel exists.\n    pub fn subscribe<K>(&self, key: K) -> OptionBroadcastMapReceiver<T>\n    where\n        K: ToString,\n    {\n        self.get()\n            .get(&key.to_string())\n            .map(|receiver| receiver.subscribe())\n    }\n\n    /// Subscribes a new receiver to the broadcast channel associated with the given key.\n    /// If the channel does not exist, it will be created with the specified capacity before subscribing.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - Key convertible to `String`.\n    /// - `Capacity` - Capacity for new channel if needed.\n    ///\n    /// # Returns\n    ///\n    /// - `BroadcastReceiver<T>` - New receiver for the channel.\n    pub fn subscribe_or_insert<K>(&self, key: K, capacity: Capacity) -> BroadcastMapReceiver<T>\n    where\n        K: ToString,\n    {\n        let key_string: String = key.to_string();\n        match self.get().get(&key_string) {\n            Some(sender) => sender.subscribe(),\n            None => {\n                self.insert(key, capacity);\n                self.subscribe_or_insert(key_string, capacity)\n            }\n        }\n    }\n\n    /// Sends a message to the broadcast channel associated with the given key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - Key convertible to `String`.\n    /// - `T` - Message to broadcast.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Option<ReceiverCount>, SendError<T>>` - Send result with receiver count or error.\n    pub fn send<K: ToString>(&self, key: K, data: T) -> BroadcastMapSendResult<T>\n    where\n        K: ToString,\n    {\n        match self.get().get(&key.to_string()) {\n            Some(sender) => sender.send(data).map(|result| Some(result)),\n            None => Ok(None),\n        }\n    }\n}", "file_size": 4694, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\box_rwlock\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a heap-allocated read-write lock.\n///\n/// This type is an alias for `Box<RwLock<T>>`, providing a way to manage\n/// a read-write lock allocated on the heap.\npub type BoxRwLock<T> = Box<RwLock<T>>;", "file_size": 232, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\any\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements `AnySend` for types that are `Any` and `Send`.\n///\n/// This trait signifies that a type can be safely sent across thread boundaries.\nimpl<T: Any + Send> AnySend for T {}\n\n/// Implements `AnySendClone` for types that are `Any`, `Send`, and `Clone`.\n///\n/// This trait signifies that a type can be safely sent across thread boundaries and cloned.\nimpl<T: Any + Send + Clone> AnySendClone for T {}\n\n/// Implements `AnySync` for types that are `Any` and `Sync`.\n///\n/// This trait signifies that a type can be safely accessed from multiple threads concurrently.\nimpl<T: Any + Sync> AnySync for T {}\n\n/// Implements `AnySyncClone` for types that are `Any`, `Sync`, and `Clone`.\n///\n/// This trait signifies that a type can be safely accessed concurrently and cloned.\nimpl<T: Any + Sync + Clone> AnySyncClone for T {}\n\n/// Implements `AnySendSync` for types that are `Any`, `Send`, and `Sync`.\n///\n/// This trait signifies that a type can be safely sent across thread boundaries and accessed concurrently.\nimpl<T: Any + Send + Sync> AnySendSync for T {}\n\n/// Implements `AnySendSyncClone` for types that are `Any`, `Send`, `Sync`, and `Clone`.\n///\n/// This trait signifies that a type can be safely sent across thread boundaries, accessed concurrently, and cloned.\nimpl<T: Any + Send + Sync + Clone> AnySendSyncClone for T {}", "file_size": 1349, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a broadcast mechanism for sending messages to multiple receivers.\n///\n/// This struct encapsulates the core components required for broadcasting,\n/// including the capacity of the broadcast channel and the sender responsible\n/// for dispatching messages.\n#[derive(Debug, Clone)]\npub struct Broadcast<T: BroadcastTrait> {\n    /// The maximum number of messages that can be buffered in the broadcast channel.\n    pub(super) capacity: Capacity,\n    /// The sender component responsible for distributing messages to all connected receivers.\n    pub(super) sender: BroadcastSender<T>,\n}", "file_size": 611, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\lib.rs", "language": "rust", "content": "//! http-type\n//!\n//! A comprehensive Rust library providing essential types for HTTP operations.\n//! Includes core HTTP abstractions (request/response, methods, status codes, versions),\n//! content types, cookies, WebSocket support, and thread-safe\n//! concurrent types (ArcMutex, ArcRwLock). Also provides convenient\n//! Option-wrapped primitive types for flexible HTTP handling.\n\npub(crate) mod any;\npub(crate) mod arc_mutex;\npub(crate) mod arc_rwlock;\npub(crate) mod box_rwlock;\npub(crate) mod content_type;\npub(crate) mod cookie;\npub(crate) mod file_extension;\npub(crate) mod hash_map_xx_hash3_64;\npub(crate) mod hash_set_xx_hash3_64;\npub(crate) mod http_status;\npub(crate) mod http_url;\npub(crate) mod http_version;\npub(crate) mod json;\npub(crate) mod methods;\npub(crate) mod option_bool;\npub(crate) mod option_compress;\npub(crate) mod option_duration;\npub(crate) mod option_i128;\npub(crate) mod option_i32;\npub(crate) mod option_i64;\npub(crate) mod option_str;\npub(crate) mod option_string;\npub(crate) mod option_u128;\npub(crate) mod option_u16;\npub(crate) mod option_u32;\npub(crate) mod option_u64;\npub(crate) mod option_usize;\npub(crate) mod option_vec_u8;\npub(crate) mod protocol;\npub(crate) mod rc_rwlock;\npub(crate) mod request;\npub(crate) mod response;\npub(crate) mod stream;\npub(crate) mod upgrade_type;\npub(crate) mod websocket_frame;\n\npub use any::*;\npub use arc_mutex::*;\npub use arc_rwlock::*;\npub use box_rwlock::*;\npub use content_type::*;\npub use cookie::*;\npub use file_extension::*;\npub use hash_map_xx_hash3_64::*;\npub use hash_set_xx_hash3_64::*;\npub use http_status::*;\npub use http_url::*;\npub use http_version::*;\npub use json::*;\npub use methods::*;\npub use option_bool::*;\npub use option_compress::*;\npub use option_duration::*;\npub use option_i32::*;\npub use option_i64::*;\npub use option_i128::*;\npub use option_str::*;\npub use option_string::*;\npub use option_u16::*;\npub use option_u32::*;\npub use option_u64::*;\npub use option_u128::*;\npub use option_usize::*;\npub use option_vec_u8::*;\npub use protocol::*;\npub use rc_rwlock::*;\npub use request::*;\npub use response::*;\npub use stream::*;\npub use upgrade_type::*;\npub use websocket_frame::*;\n\npub use http_compress::*;\npub use http_constant::*;\npub use tokio;\n\npub(crate) use core::hash::BuildHasherDefault;\npub(crate) use lombok_macros::*;\npub(crate) use serde::{Serialize, de::DeserializeOwned};\npub(crate) use std::{\n    any::Any,\n    borrow::Cow,\n    collections::{HashMap, HashSet, VecDeque},\n    error::Error as StdError,\n    fmt::{self, Debug, Display},\n    hash::Hash,\n    io::ErrorKind,\n    net::{IpAddr, SocketAddr},\n    rc::Rc,\n    result::Result,\n    str::FromStr,\n    sync::Arc,\n    time::Duration,\n};\npub(crate) use tokio::{\n    io::{AsyncBufReadExt, AsyncReadExt, AsyncWriteExt, BufReader},\n    net::TcpStream,\n    sync::{Mutex, MutexGuard, RwLock, RwLockReadGuard, RwLockWriteGuard},\n};", "file_size": 2888, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast_map\\mod.rs", "language": "rust", "content": "pub mod r#impl;\npub mod r#struct;\npub mod r#trait;\npub mod r#type;", "file_size": 66, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\any\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a boxed `Any` trait object.\n///\n/// This represents a dynamically dispatched trait object that owns its data.\npub type BoxAny = Box<dyn Any>;\n/// An optional `BoxAny`.\npub type OptionBoxAny = Option<BoxAny>;\n/// A type alias for an `Rc` wrapped `Any` trait object.\n///\n/// This represents a reference-counted trait object that can be shared across threads.\npub type RcAny = Rc<dyn Any>;\n/// An optional `RcAny`.\npub type OptionRcAny = Option<RcAny>;\n/// A type alias for an `Arc` wrapped `Any` trait object.\n///\n/// This represents an atomically reference-counted trait object that can be shared across threads.\npub type ArcAny = Arc<dyn Any>;\n/// An optional `ArcAny`.\npub type OptionArcAny = Option<ArcAny>;\n/// A type alias for a boxed `Any + Send` trait object.\n///\n/// This represents a dynamically dispatched trait object that owns its data and is safe to send across threads.\npub type BoxAnySend = Box<dyn Any + Send>;\n/// An optional `BoxAnySend`.\npub type OptionBoxAnySend = Option<BoxAnySend>;\n/// A type alias for an `Rc` wrapped `Any + Send` trait object.\n///\n/// This represents a reference-counted trait object that can be shared across threads and is safe to send.\npub type RcAnySend = Rc<dyn Any + Send>;\n/// An optional `RcAnySend`.\npub type OptionRcAnySend = Option<RcAnySend>;\n/// A type alias for an `Arc` wrapped `Any + Send` trait object.\n///\n/// This represents an atomically reference-counted trait object that can be shared across threads and is safe to send.\npub type ArcAnySend = Arc<dyn Any + Send>;\n/// An optional `ArcAnySend`.\npub type OptionArcAnySend = Option<ArcAnySend>;\n/// A type alias for a boxed `Any + Sync` trait object.\n///\n/// This represents a dynamically dispatched trait object that owns its data and is safe to share across threads.\npub type BoxAnySync = Box<dyn Any + Sync>;\n/// An optional `BoxAnySync`.\npub type OptionBoxAnySync = Option<BoxAnySync>;\n/// A type alias for an `Rc` wrapped `Any + Sync` trait object.\n///\n/// This represents a reference-counted trait object that can be shared across threads and is safe to share.\npub type RcAnySync = Rc<dyn Any + Sync>;\n/// An optional `RcAnySync`.\npub type OptionRcAnySync = Option<RcAnySync>;\n/// A type alias for an `Arc` wrapped `Any + Sync` trait object.\n///\n/// This represents an atomically reference-counted trait object that can be shared across threads and is safe to share.\npub type ArcAnySync = Arc<dyn Any + Sync>;\n/// An optional `ArcAnySync`.\npub type OptionArcAnySync = Option<ArcAnySync>;\n/// A type alias for a boxed `Any + Send + Sync` trait object.\n///\n/// This represents a dynamically dispatched trait object that owns its data and is safe to send and share across threads.\npub type BoxAnySendSync = Box<dyn Any + Send + Sync>;\n/// An optional `BoxAnySendSync`.\npub type OptionBoxAnySendSync = Option<BoxAnySendSync>;\n/// A type alias for an `Rc` wrapped `Any + Send + Sync` trait object.\n///\n/// This represents a reference-counted trait object that can be shared across threads and is safe to send and share.\npub type RcAnySendSync = Rc<dyn Any + Send + Sync>;\n/// An optional `RcAnySendSync`.\npub type OptionRcAnySendSync = Option<RcAnySendSync>;\n/// A type alias for an `Arc` wrapped `Any + Send + Sync` trait object.\n///\n/// This represents an atomically reference-counted trait object that can be shared across threads and is safe to send and share.\npub type ArcAnySendSync = Arc<dyn Any + Send + Sync>;\n/// An optional `ArcAnySendSync`.\npub type OptionArcAnySendSync = Option<ArcAnySendSync>;", "file_size": 3556, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the number of active receivers subscribed to a broadcast channel.\npub type ReceiverCount = usize;\n/// Represents an error that occurs when attempting to send a message via broadcast.\npub type BroadcastSendError<T> = SendError<T>;\n/// Represents the result of a broadcast send operation, indicating either success with the number of receivers or an error.\npub type BroadcastSendResult<T> = Result<ReceiverCount, BroadcastSendError<T>>;\n/// Represents a receiver endpoint for a broadcast channel, allowing consumption of broadcasted messages.\npub type BroadcastReceiver<T> = Receiver<T>;\n/// Represents a sender endpoint for a broadcast channel, used to dispatch messages to all subscribed receivers.\npub type BroadcastSender<T> = Sender<T>;\n/// Represents the maximum capacity or buffer size of a broadcast channel.\npub type Capacity = usize;", "file_size": 871, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast_map\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Defines the essential traits required for types that can be used as values in a `BroadcastMap`.\n///\n/// Any type implementing `BroadcastMapTrait` must also implement `Clone` and `Debug`,\n/// enabling efficient duplication and debugging within the broadcast map system.\npub trait BroadcastMapTrait: Clone + Debug {}", "file_size": 333, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast_map\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a concurrent, thread-safe map of broadcast channels, keyed by string.\n///\n/// This struct provides a way to manage multiple broadcast channels, each identified by a unique string,\n/// allowing for dynamic creation, retrieval, and management of broadcast streams.\n#[derive(Debug, Clone)]\npub struct BroadcastMap<T: BroadcastTrait>(pub(super) DashMapStringBroadcast<T>);", "file_size": 398, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\arc_rwlock\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\npub(crate) mod r#type;\n\npub use r#fn::*;\npub use r#type::*;", "file_size": 80, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\arc_rwlock\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a thread-safe, atomically reference-counted read-write lock.\n///\n/// This type is an alias for `Arc<RwLock<T>>`, providing a convenient way to\n/// manage shared mutable state with read-write locking capabilities across threads.\npub type ArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 303, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\content_type\\enum.rs", "language": "rust", "content": "/// Supported HTTP content types.\n///\n/// Defines common content types for HTTP communication.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ContentType {\n    /// `application/json` content type.\n    ///\n    /// For JSON data format.\n    ApplicationJson,\n    /// `application/xml` content type.\n    ///\n    /// For XML data format.\n    ApplicationXml,\n    /// `text/plain` content type.\n    ///\n    /// For plain text data.\n    TextPlain,\n    /// `text/html` content type.\n    ///\n    /// For HTML documents.\n    TextHtml,\n    /// `application/x-www-form-urlencoded` content type.\n    ///\n    /// For form data submission.\n    FormUrlEncoded,\n    /// Unknown content type.\n    ///\n    /// For unrecognized content types.\n    Unknown,\n}", "file_size": 737, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\arc_mutex\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new `ArcMutex` from the given data.\n///\n/// # Arguments\n///\n/// - `T` - The data to be wrapped in an `Arc<Mutex>`.\n///\n/// # Returns\n///\n/// An `ArcMutex<T>` containing the provided data.\npub fn arc_mutex<T>(data: T) -> ArcMutex<T> {\n    Arc::new(Mutex::new(data))\n}", "file_size": 295, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\content_type\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation for `ContentType` enum.\nimpl ContentType {\n    /// Serializes data into JSON format.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to serialize\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Serialized JSON string\n    fn get_application_json<T>(data: &T) -> String\n    where\n        T: Serialize + Display,\n    {\n        json_to_string(data).unwrap_or_else(|_| \"{}\".to_string())\n    }\n\n    /// Serializes data into XML format.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to serialize\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Serialized XML string\n    fn get_application_xml<T>(data: &T) -> String\n    where\n        T: Serialize + Display,\n    {\n        serde_xml_rs::to_string(data).unwrap_or_else(|_| \"<root></root>\".to_string())\n    }\n\n    /// Formats data into plain text.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to format\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Formatted plain text\n    fn get_text_plain<T>(data: &T) -> String\n    where\n        T: Serialize + Debug + Clone + Default + Display,\n    {\n        data.to_string()\n    }\n\n    /// Formats data into HTML.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to format\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Formatted HTML\n    fn get_text_html<T>(data: &T) -> String\n    where\n        T: Serialize + Debug + Clone + Default,\n    {\n        let mut html: String = String::with_capacity(64);\n        html.push_str(\"<table><tr><td>\");\n        html.push_str(&format!(\"{:?}\", data));\n        html.push_str(\"</td></tr></table>\");\n        html\n    }\n\n    /// Serializes data into URL-encoded format.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to serialize\n    ///\n    /// # Returns\n    ///\n    /// - `String` - URL-encoded string\n    fn get_form_url_encoded<T>(data: &T) -> String\n    where\n        T: Serialize + Display,\n    {\n        serde_urlencoded::to_string(data).unwrap_or_else(|_| String::new())\n    }\n\n    /// Formats data as hexadecimal string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to format\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Hexadecimal encoded string\n    fn get_binary<T>(data: &T) -> String\n    where\n        T: Serialize + Debug + Clone + Default + Display,\n    {\n        hex::encode(data.to_string())\n    }\n\n    /// Gets formatted body string for content type.\n    ///\n    /// # Arguments\n    ///\n    /// - `&T` - Data to format\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Formatted body string\n    pub fn get_body_string<T>(&self, data: &T) -> String\n    where\n        T: Serialize + Debug + Clone + Default + Display,\n    {\n        match self {\n            Self::ApplicationJson => Self::get_application_json(data),\n            Self::ApplicationXml => Self::get_application_xml(data),\n            Self::TextPlain => Self::get_text_plain(data),\n            Self::TextHtml => Self::get_text_html(data),\n            Self::FormUrlEncoded => Self::get_form_url_encoded(data),\n            Self::Unknown => Self::get_binary(data),\n        }\n    }\n\n    /// Formats content type with charset.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Content type\n    /// - `&str` - Charset\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Formatted string\n    pub fn format_content_type_with_charset(content_type: &str, charset: &str) -> String {\n        let mut result: String = String::with_capacity(\n            content_type.len() + SEMICOLON_SPACE.len() + CHARSET_EQUAL.len() + charset.len(),\n        );\n        result.push_str(content_type);\n        result.push_str(SEMICOLON_SPACE);\n        result.push_str(CHARSET_EQUAL);\n        result.push_str(charset);\n        result\n    }\n\n    /// Formats content type with charset declaration.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Content type\n    /// - `&str` - Charset declaration\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Formatted string\n    pub fn format_content_type_with_charset_declaration(\n        content_type: &str,\n        charset_with_key: &str,\n    ) -> String {\n        let mut result: String = String::with_capacity(\n            content_type.len() + SEMICOLON_SPACE.len() + charset_with_key.len(),\n        );\n        result.push_str(content_type);\n        result.push_str(SEMICOLON_SPACE);\n        result.push_str(charset_with_key);\n        result\n    }\n}\n\n/// Implements `FromStr` for `ContentType`.\nimpl FromStr for ContentType {\n    type Err = ();\n\n    /// Parses string into ContentType.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - String to parse\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Self, Self::Err>` - Parse result\n    fn from_str(data: &str) -> Result<Self, Self::Err> {\n        match data.to_ascii_lowercase().as_str() {\n            APPLICATION_JSON => Ok(Self::ApplicationJson),\n            APPLICATION_XML => Ok(Self::ApplicationXml),\n            TEXT_PLAIN => Ok(Self::TextPlain),\n            TEXT_HTML => Ok(Self::TextHtml),\n            FORM_URLENCODED => Ok(Self::FormUrlEncoded),\n            _ => Ok(Self::Unknown),\n        }\n    }\n}\n\n/// Implements `Default` for `ContentType`.\nimpl Default for ContentType {\n    /// Gets default ContentType.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - Default variant\n    fn default() -> Self {\n        Self::Unknown\n    }\n}", "file_size": 5376, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\any\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a type that can be dynamically downcast and is safe to send across threads.\n///\n/// This trait combines the capabilities of `Any` and `Send`, ensuring that types implementing\n/// it can be safely sent across thread boundaries.\npub trait AnySend: Any + Send {}\n\n/// Represents a type that can be dynamically downcast, is safe to send across threads, and can be cloned.\n///\n/// This trait combines the capabilities of `Any`, `Send`, and `Clone`, ensuring that types implementing\n/// it can be safely sent across thread boundaries and can be cloned.\npub trait AnySendClone: Any + Send + Clone {}\n\n/// Represents a type that can be dynamically downcast and is safe to share across threads.\n///\n/// This trait combines the capabilities of `Any` and `Sync`, ensuring that types implementing\n/// it can be safely shared across thread boundaries.\npub trait AnySync: Any + Sync {}\n\n/// Represents a type that can be dynamically downcast, is safe to share across threads, and can be cloned.\n///\n/// This trait combines the capabilities of `Any`, `Sync`, and `Clone`, ensuring that types implementing\n/// it can be safely shared across thread boundaries and can be cloned.\npub trait AnySyncClone: Any + Sync + Clone {}\n\n/// Represents a type that can be dynamically downcast and is safe to both send and share across threads.\n///\n/// This trait combines the capabilities of `Any`, `Send`, and `Sync`, ensuring that types implementing\n/// it can be safely sent and shared across thread boundaries.\npub trait AnySendSync: Any + Send + Sync {}\n\n/// Represents a type that can be dynamically downcast, is safe to both send and share across threads, and can be cloned.\n///\n/// This trait combines the capabilities of `Any`, `Send`, `Sync`, and `Clone`, ensuring that types implementing\n/// it can be safely sent and shared across thread boundaries and can be cloned.\npub trait AnySendSyncClone: Any + Send + Sync + Clone {}", "file_size": 1937, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\arc_rwlock\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new thread-safe reference-counted read-write lock.\n///\n/// # Arguments\n///\n/// - `T` - The data type to be wrapped.\n///\n/// # Returns\n///\n/// - `ArcRwLock<T>` - A new atomic reference-counted read-write lock.\npub fn arc_rwlock<T>(data: T) -> ArcRwLock<T> {\n    Arc::new(RwLock::new(data))\n}", "file_size": 319, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hyperlane-broadcast\\src\\broadcast_map\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents an error that occurs when attempting to send a message via a broadcast channel within a map.\npub type BroadcastMapSendError<T> = SendError<T>;\n/// Represents the result of a broadcast map send operation, indicating either success with an optional receiver count or an error.\npub type BroadcastMapSendResult<T> = Result<Option<ReceiverCount>, BroadcastMapSendError<T>>;\n/// Represents a receiver endpoint for a broadcast channel within a map, allowing consumption of broadcasted messages.\npub type BroadcastMapReceiver<T> = Receiver<T>;\n/// Represents an optional broadcast channel.\npub type OptionBroadcast<T> = Option<Broadcast<T>>;\n/// Represents an optional receiver endpoint for a broadcast channel within a map.\npub type OptionBroadcastMapReceiver<T> = Option<BroadcastMapReceiver<T>>;\n/// Represents a sender endpoint for a broadcast channel within a map, used to dispatch messages.\npub type BroadcastMapSender<T> = Sender<T>;\n/// Represents an optional sender endpoint for a broadcast channel within a map.\npub type OptionBroadcastMapSender<T> = Option<BroadcastMapSender<T>>;\n/// Represents an optional count of active receivers.\npub type OptionReceiverCount = Option<ReceiverCount>;\n/// A concurrent, thread-safe map where keys are strings and values are broadcast channels.\npub type DashMapStringBroadcast<T> = DashMap<String, Broadcast<T>, BuildHasherDefault<XxHash3_64>>;", "file_size": 1413, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\any\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use r#trait::*;\npub use r#type::*;", "file_size": 109, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\content_type\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_content_type_from_str() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(\n        APPLICATION_JSON.parse::<ContentType>().unwrap(),\n        ContentType::ApplicationJson\n    );\n    assert_eq!(\n        APPLICATION_XML.parse::<ContentType>().unwrap(),\n        ContentType::ApplicationXml\n    );\n    assert_eq!(\n        TEXT_PLAIN.parse::<ContentType>().unwrap(),\n        ContentType::TextPlain\n    );\n    assert_eq!(\n        TEXT_HTML.parse::<ContentType>().unwrap(),\n        ContentType::TextHtml\n    );\n    assert_eq!(\n        FORM_URLENCODED.parse::<ContentType>().unwrap(),\n        ContentType::FormUrlEncoded\n    );\n    assert_eq!(\n        \"unknown/type\".parse::<ContentType>().unwrap(),\n        ContentType::Unknown\n    );\n    assert_eq!(\"\".parse::<ContentType>().unwrap(), ContentType::Unknown);\n}\n\n#[test]\nfn test_content_type_from_str_case_insensitive() {\n    use super::*;\n    assert_eq!(\n        \"APPLICATION/JSON\".parse::<ContentType>().unwrap(),\n        ContentType::ApplicationJson\n    );\n    assert_eq!(\n        \"Application/Json\".parse::<ContentType>().unwrap(),\n        ContentType::ApplicationJson\n    );\n    assert_eq!(\n        \"TEXT/PLAIN\".parse::<ContentType>().unwrap(),\n        ContentType::TextPlain\n    );\n    assert_eq!(\n        \"Text/Plain\".parse::<ContentType>().unwrap(),\n        ContentType::TextPlain\n    );\n    assert_eq!(\n        \"text/HTML\".parse::<ContentType>().unwrap(),\n        ContentType::TextHtml\n    );\n}\n\n#[test]\nfn test_content_type_default() {\n    use super::*;\n    assert_eq!(ContentType::default(), ContentType::Unknown);\n}\n\n#[test]\nfn test_content_type_clone() {\n    use super::*;\n    let content_type: ContentType = ContentType::ApplicationJson;\n    let cloned_content_type: ContentType = content_type.clone();\n    assert_eq!(content_type, cloned_content_type);\n}\n\n#[test]\nfn test_content_type_debug() {\n    use super::*;\n    let content_type: ContentType = ContentType::ApplicationJson;\n    let debug_str: String = format!(\"{:?}\", content_type);\n    assert_eq!(debug_str, \"ApplicationJson\");\n}\n\n#[test]\nfn test_content_type_equality() {\n    use super::*;\n    assert_eq!(ContentType::ApplicationJson, ContentType::ApplicationJson);\n    assert_ne!(ContentType::ApplicationJson, ContentType::ApplicationXml);\n    assert_eq!(ContentType::Unknown, ContentType::Unknown);\n    assert_ne!(ContentType::TextPlain, ContentType::TextHtml);\n}\n\n#[test]\nfn test_content_type_get_body_string_with_simple_string() {\n    use super::*;\n    let data: String = \"Hello, World!\".to_string();\n    let json_result: String = ContentType::ApplicationJson.get_body_string(&data);\n    assert_eq!(json_result, \"\\\"Hello, World!\\\"\");\n    let plain_result: String = ContentType::TextPlain.get_body_string(&data);\n    assert_eq!(plain_result, \"Hello, World!\");\n    let html_result: String = ContentType::TextHtml.get_body_string(&data);\n    assert!(html_result.contains(\"Hello, World!\"));\n    assert!(html_result.starts_with(\"<table><tr><td>\"));\n}\n\n#[test]\nfn test_content_type_get_body_string_with_number() {\n    use super::*;\n    let data: i32 = 42;\n    let json_result: String = ContentType::ApplicationJson.get_body_string(&data);\n    assert_eq!(json_result, \"42\");\n    let plain_result: String = ContentType::TextPlain.get_body_string(&data);\n    assert_eq!(plain_result, \"42\");\n    let html_result: String = ContentType::TextHtml.get_body_string(&data);\n    assert!(html_result.contains(\"42\"));\n}\n\n#[test]\nfn test_content_type_format_content_type_with_charset() {\n    use super::*;\n    let result: String = ContentType::format_content_type_with_charset(\"text/html\", \"utf-8\");\n    assert_eq!(result, \"text/html; charset=utf-8\");\n    let result2: String =\n        ContentType::format_content_type_with_charset(\"application/json\", \"iso-8859-1\");\n    assert_eq!(result2, \"application/json; charset=iso-8859-1\");\n}\n\n#[test]\nfn test_content_type_format_content_type_with_charset_declaration() {\n    use super::*;\n    let result: String =\n        ContentType::format_content_type_with_charset_declaration(\"text/html\", \"charset=utf-8\");\n    assert_eq!(result, \"text/html; charset=utf-8\");\n    let result2: String = ContentType::format_content_type_with_charset_declaration(\n        \"application/json\",\n        \"charset=iso-8859-1\",\n    );\n    assert_eq!(result2, \"application/json; charset=iso-8859-1\");\n}\n\n#[test]\nfn test_content_type_all_variants() {\n    use super::*;\n    let content_types: Vec<ContentType> = vec![\n        ContentType::ApplicationJson,\n        ContentType::ApplicationXml,\n        ContentType::TextPlain,\n        ContentType::TextHtml,\n        ContentType::FormUrlEncoded,\n        ContentType::Unknown,\n    ];\n    for content_type in content_types {\n        let debug_str: String = format!(\"{:?}\", content_type);\n        assert!(!debug_str.is_empty());\n    }\n}\n\n#[test]\nfn test_content_type_pattern_matching() {\n    use super::*;\n    let content_type: ContentType = ContentType::ApplicationJson;\n    match content_type {\n        ContentType::ApplicationJson => assert!(true),\n        ContentType::ApplicationXml => panic!(\"Should not match ApplicationXml\"),\n        ContentType::TextPlain => panic!(\"Should not match TextPlain\"),\n        ContentType::TextHtml => panic!(\"Should not match TextHtml\"),\n        ContentType::FormUrlEncoded => panic!(\"Should not match FormUrlEncoded\"),\n        ContentType::Unknown => panic!(\"Should not match Unknown\"),\n    }\n}\n\n#[test]\nfn test_content_type_charset_formatting_edge_cases() {\n    use super::*;\n    let result_empty: String = ContentType::format_content_type_with_charset(\"\", \"\");\n    assert_eq!(result_empty, \"; charset=\");\n    let result_spaces: String =\n        ContentType::format_content_type_with_charset(\"text/html\", \"utf-8 \");\n    assert_eq!(result_spaces, \"text/html; charset=utf-8 \");\n    let result_special: String = ContentType::format_content_type_with_charset(\n        \"application/json\",\n        \"utf-8;boundary=something\",\n    );\n    assert_eq!(\n        result_special,\n        \"application/json; charset=utf-8;boundary=something\"\n    );\n}\n\n#[test]\nfn test_content_type_memory_size() {\n    use super::*;\n    use std::mem;\n    let size: usize = mem::size_of::<ContentType>();\n    assert!(size > 0);\n    let json_size: usize = mem::size_of_val(&ContentType::ApplicationJson);\n    let unknown_size: usize = mem::size_of_val(&ContentType::Unknown);\n    assert_eq!(json_size, unknown_size);\n}\n\n#[test]\nfn test_content_type_get_body_string_unknown() {\n    use super::*;\n    let data: String = \"test_data\".to_string();\n    let content_type: ContentType = ContentType::Unknown;\n    let result: String = content_type.get_body_string(&data);\n    assert!(!result.is_empty());\n}\n\n#[test]\nfn test_content_type_get_body_string_xml() {\n    use super::*;\n    let data: String = \"test_data\".to_string();\n    let content_type: ContentType = ContentType::ApplicationXml;\n    let result: String = content_type.get_body_string(&data);\n    assert!(!result.is_empty());\n}\n\n#[test]\nfn test_content_type_get_body_string_form_url_encoded() {\n    use super::*;\n    let data: String = \"test_data\".to_string();\n    let content_type: ContentType = ContentType::FormUrlEncoded;\n    let result: String = content_type.get_body_string(&data);\n    assert_eq!(result, \"\");\n}\n\n#[test]\nfn test_content_type_from_str_with_parameters() {\n    use super::*;\n    assert_eq!(\n        \"application/json; charset=utf-8\"\n            .parse::<ContentType>()\n            .unwrap(),\n        ContentType::Unknown\n    );\n    assert_eq!(\n        \"text/html; charset=utf-8\".parse::<ContentType>().unwrap(),\n        ContentType::Unknown\n    );\n}\n\n#[test]\nfn test_content_type_case_variations() {\n    use super::*;\n    assert_eq!(\n        \"application/JSON\".parse::<ContentType>().unwrap(),\n        ContentType::ApplicationJson\n    );\n    assert_eq!(\n        \"APPLICATION/json\".parse::<ContentType>().unwrap(),\n        ContentType::ApplicationJson\n    );\n    assert_eq!(\n        \"text/PLAIN\".parse::<ContentType>().unwrap(),\n        ContentType::TextPlain\n    );\n    assert_eq!(\n        \"TEXT/plain\".parse::<ContentType>().unwrap(),\n        ContentType::TextPlain\n    );\n}", "file_size": 8138, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\cookie\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation for `CookieBuilder`.\nimpl CookieBuilder {\n    /// Creates a new cookie builder instance.\n    ///\n    /// # Arguments\n    ///\n    /// - `N` - The cookie name type.\n    /// - `V` - The cookie value type.\n    ///\n    /// # Returns\n    ///\n    /// - `CookieBuilder` - A new builder instance.\n    pub fn new<N, V>(name: N, value: V) -> Self\n    where\n        N: Into<CookieKey>,\n        V: Into<CookieValue>,\n    {\n        Self {\n            name: name.into(),\n            value: value.into(),\n            expires: None,\n            max_age: None,\n            domain: None,\n            path: None,\n            secure: false,\n            http_only: false,\n            same_site: None,\n        }\n    }\n\n    /// Parses a `Set-Cookie` header string into a `CookieBuilder`.\n    ///\n    /// This method takes a `Set-Cookie` header string and extracts the various\n    /// attributes of a cookie, populating a `CookieBuilder` instance.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The `Set-Cookie` header string to parse.\n    ///\n    /// # Returns\n    ///\n    /// A `CookieBuilder` instance populated with the parsed cookie attributes.\n    pub fn parse(cookie_string: &str) -> Self {\n        let mut cookie_builder: Self = Self::default();\n        let parts: Vec<&str> = cookie_string.split(SEMICOLON).collect();\n        if parts.is_empty() {\n            return cookie_builder;\n        }\n        if let Some(name_value_pair) = parts.first() {\n            let name_value_pair: &str = name_value_pair.trim();\n            if let Some((name, value)) = name_value_pair.split_once(EQUAL) {\n                cookie_builder.name = name.trim().to_string();\n                cookie_builder.value = value.trim().to_string();\n            } else if !name_value_pair.is_empty() {\n                cookie_builder.name = name_value_pair.to_string();\n                cookie_builder.value = String::new();\n            }\n        }\n        for part in parts.iter().skip(1) {\n            let part: &str = part.trim();\n            if part.is_empty() {\n                continue;\n            }\n            if let Some((key, value)) = part.split_once(EQUAL) {\n                let key_lowercase: String = key.trim().to_lowercase();\n                let value: String = value.trim().to_string();\n                match key_lowercase.as_str() {\n                    COOKIE_EXPIRES_LOWERCASE => {\n                        cookie_builder.expires = Some(value);\n                    }\n                    COOKIE_MAX_AGE_LOWERCASE => {\n                        if let Ok(max_age_value) = value.parse::<i64>() {\n                            cookie_builder.max_age = Some(max_age_value);\n                        }\n                    }\n                    COOKIE_DOMAIN_LOWERCASE => {\n                        cookie_builder.domain = Some(value);\n                    }\n                    COOKIE_PATH_LOWERCASE => {\n                        cookie_builder.path = Some(value);\n                    }\n                    COOKIE_SAME_SITE_LOWERCASE => {\n                        cookie_builder.same_site = Some(value);\n                    }\n                    _ => {}\n                }\n            } else {\n                let attribute_lowercase: String = part.to_lowercase();\n                match attribute_lowercase.as_str() {\n                    COOKIE_SECURE_LOWERCASE => {\n                        cookie_builder.secure = true;\n                    }\n                    COOKIE_HTTP_ONLY_LOWERCASE => {\n                        cookie_builder.http_only = true;\n                    }\n                    _ => {}\n                }\n            }\n        }\n        cookie_builder\n    }\n\n    /// Sets the expiration date for the cookie.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The expiration date string.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn expires<T>(&mut self, expires: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.expires = Some(expires.into());\n        self\n    }\n\n    /// Sets the maximum age for the cookie in seconds.\n    ///\n    /// # Arguments\n    ///\n    /// - `i64` - The maximum age in seconds.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn max_age(&mut self, max_age: i64) -> &mut Self {\n        self.max_age = Some(max_age);\n        self\n    }\n\n    /// Sets the domain for the cookie.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The domain for the cookie.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn domain<T>(&mut self, domain: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.domain = Some(domain.into());\n        self\n    }\n\n    /// Sets the path for the cookie.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The path for the cookie.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn path<T>(&mut self, path: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.path = Some(path.into());\n        self\n    }\n\n    /// Sets the `Secure` flag for the cookie.\n    ///\n    /// This flag indicates that the cookie should only be transmitted over secure (HTTPS) connections.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn secure(&mut self) -> &mut Self {\n        self.secure = true;\n        self\n    }\n\n    /// Sets the `HttpOnly` flag for the cookie.\n    ///\n    /// This flag prevents client-side JavaScript from accessing the cookie.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn http_only(&mut self) -> &mut Self {\n        self.http_only = true;\n        self\n    }\n\n    /// Sets the `SameSite` policy for the cookie.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The `SameSite` policy.\n    ///\n    /// # Returns\n    ///\n    /// The `CookieBuilder` instance for method chaining.\n    pub fn same_site<T>(&mut self, same_site: T) -> &mut Self\n    where\n        T: Into<String>,\n    {\n        self.same_site = Some(same_site.into());\n        self\n    }\n\n    /// Builds the cookie string according to the `Set-Cookie` header format.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - A formatted cookie string ready to be sent in a `Set-Cookie` header.\n    pub fn build(&self) -> String {\n        if self.name.is_empty() {\n            return String::new();\n        }\n        let mut cookie_string: String = format!(\"{}={}\", self.name, self.value);\n        if let Some(ref expires_value) = self.expires {\n            cookie_string.push_str(COOKIE_EXPIRES_ATTRIBUTE_LOWERCASE);\n            cookie_string.push_str(expires_value);\n        }\n        if let Some(max_age_value) = self.max_age {\n            cookie_string.push_str(COOKIE_MAX_AGE_ATTRIBUTE_LOWERCASE);\n            cookie_string.push_str(&max_age_value.to_string());\n        }\n        if let Some(ref domain_value) = self.domain {\n            cookie_string.push_str(COOKIE_DOMAIN_ATTRIBUTE_LOWERCASE);\n            cookie_string.push_str(domain_value);\n        }\n        if let Some(ref path_value) = self.path {\n            cookie_string.push_str(COOKIE_PATH_ATTRIBUTE_LOWERCASE);\n            cookie_string.push_str(path_value);\n        }\n        if self.secure {\n            cookie_string.push_str(COOKIE_SECURE_ATTRIBUTE_LOWERCASE);\n        }\n        if self.http_only {\n            cookie_string.push_str(COOKIE_HTTP_ONLY_ATTRIBUTE_LOWERCASE);\n        }\n        if let Some(ref same_site_value) = self.same_site {\n            cookie_string.push_str(COOKIE_SAME_SITE_ATTRIBUTE_LOWERCASE);\n            cookie_string.push_str(same_site_value);\n        }\n        cookie_string\n    }\n}\n\n/// Implementation for `Cookie`.\nimpl Cookie {\n    /// Parses a `Cookie` header string into a collection of key-value pairs.\n    ///\n    /// This method takes a `Cookie` header string (typically from a `Cookie` request header)\n    /// and parses it into a map of cookie names to their values.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The `Cookie` header string to parse.\n    ///\n    /// # Returns\n    ///\n    /// A `Cookies` collection (a hash map) containing all parsed cookie key-value pairs.\n    pub fn parse(cookie_string: &str) -> Cookies {\n        let mut cookies: Cookies = hash_map_xx_hash3_64();\n        if cookie_string.trim().is_empty() {\n            return cookies;\n        }\n        let parts: Vec<&str> = cookie_string.split(SEMICOLON).collect();\n        for part in parts {\n            let part: &str = part.trim();\n            if part.is_empty() {\n                continue;\n            }\n            if let Some((name, value)) = part.split_once(EQUAL) {\n                let name: String = name.trim().to_string();\n                let value: String = value.trim().to_string();\n                if !name.is_empty() {\n                    cookies.insert(name, value);\n                }\n            } else if !part.is_empty() {\n                cookies.insert(part.to_string(), String::new());\n            }\n        }\n        cookies\n    }\n}", "file_size": 9143, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\content_type\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#enum;\npub(crate) mod r#impl;\n\npub use r#enum::*;", "file_size": 85, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\arc_mutex\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a thread-safe, atomically reference-counted mutex.\n///\n/// This type is an alias for `Arc<Mutex<T>>`, providing a convenient way to\n/// manage shared mutable state across threads.\npub type ArcMutex<T> = Arc<Mutex<T>>;", "file_size": 253, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\file_extension\\enum.rs", "language": "rust", "content": "/// Enumeration of supported file extensions.\n///\n/// Contains all known file extensions with their corresponding MIME types.\n/// Used for content type detection and file handling.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum FileExtension {\n    /// The `123` file extension.\n    FileExtension123,\n    /// The `3dml` file extension.\n    FileExtension3dml,\n    /// The `3ds` file extension.\n    FileExtension3ds,\n    /// The `3g2` file extension.\n    FileExtension3g2,\n    /// The `3gp` file extension.\n    FileExtension3gp,\n    /// The `7z` file extension.\n    FileExtension7z,\n    /// The `aab` file extension.\n    FileExtensionAab,\n    /// The `aac` file extension.\n    FileExtensionAac,\n    /// The `aam` file extension.\n    FileExtensionAam,\n    /// The `aas` file extension.\n    FileExtensionAas,\n    /// The `abs` file extension.\n    FileExtensionAbs,\n    /// The `abw` file extension.\n    FileExtensionAbw,\n    /// The `ac` file extension.\n    FileExtensionAc,\n    /// The `acc` file extension.\n    FileExtensionAcc,\n    /// The `ace` file extension.\n    FileExtensionAce,\n    /// The `acu` file extension.\n    FileExtensionAcu,\n    /// The `acutc` file extension.\n    FileExtensionAcutc,\n    /// The `adp` file extension.\n    FileExtensionAdp,\n    /// The `aep` file extension.\n    FileExtensionAep,\n    /// The `afm` file extension.\n    FileExtensionAfm,\n    /// The `afp` file extension.\n    FileExtensionAfp,\n    /// The `ahead` file extension.\n    FileExtensionAhead,\n    /// The `ai` file extension.\n    FileExtensionAi,\n    /// The `aif` file extension.\n    FileExtensionAif,\n    /// The `aifc` file extension.\n    FileExtensionAifc,\n    /// The `aiff` file extension.\n    FileExtensionAiff,\n    /// The `aim` file extension.\n    FileExtensionAim,\n    /// The `air` file extension.\n    FileExtensionAir,\n    /// The `ait` file extension.\n    FileExtensionAit,\n    /// The `ami` file extension.\n    FileExtensionAmi,\n    /// The `anx` file extension.\n    FileExtensionAnx,\n    /// The `apk` file extension.\n    FileExtensionApk,\n    /// The `appcache` file extension.\n    FileExtensionAppcache,\n    /// The `application` file extension.\n    FileExtensionApplication,\n    /// The `apr` file extension.\n    FileExtensionApr,\n    /// The `arc` file extension.\n    FileExtensionArc,\n    /// The `art` file extension.\n    FileExtensionArt,\n    /// The `asc` file extension.\n    FileExtensionAsc,\n    /// The `asf` file extension.\n    FileExtensionAsf,\n    /// The `asm` file extension.\n    FileExtensionAsm,\n    /// The `aso` file extension.\n    FileExtensionAso,\n    /// The `asx` file extension.\n    FileExtensionAsx,\n    /// The `atc` file extension.\n    FileExtensionAtc,\n    /// The `atom` file extension.\n    FileExtensionAtom,\n    /// The `atomcat` file extension.\n    FileExtensionAtomcat,\n    /// The `atomsvc` file extension.\n    FileExtensionAtomsvc,\n    /// The `atx` file extension.\n    FileExtensionAtx,\n    /// The `au` file extension.\n    FileExtensionAu,\n    /// The `avi` file extension.\n    FileExtensionAvi,\n    /// The `avx` file extension.\n    FileExtensionAvx,\n    /// The `aw` file extension.\n    FileExtensionAw,\n    /// The `axa` file extension.\n    FileExtensionAxa,\n    /// The `axv` file extension.\n    FileExtensionAxv,\n    /// The `azf` file extension.\n    FileExtensionAzf,\n    /// The `azs` file extension.\n    FileExtensionAzs,\n    /// The `azw` file extension.\n    FileExtensionAzw,\n    /// The `bat` file extension.\n    FileExtensionBat,\n    /// The `bcpio` file extension.\n    FileExtensionBcpio,\n    /// The `bdf` file extension.\n    FileExtensionBdf,\n    /// The `bdm` file extension.\n    FileExtensionBdm,\n    /// The `bed` file extension.\n    FileExtensionBed,\n    /// The `bh2` file extension.\n    FileExtensionBh2,\n    /// The `bin` file extension.\n    FileExtensionBin,\n    /// The `blb` file extension.\n    FileExtensionBlb,\n    /// The `blorb` file extension.\n    FileExtensionBlorb,\n    /// The `bmi` file extension.\n    FileExtensionBmi,\n    /// The `bmp` file extension.\n    FileExtensionBmp,\n    /// The `body` file extension.\n    FileExtensionBody,\n    /// The `book` file extension.\n    FileExtensionBook,\n    /// The `box` file extension.\n    FileExtensionBox,\n    /// The `boz` file extension.\n    FileExtensionBoz,\n    /// The `bpk` file extension.\n    FileExtensionBpk,\n    /// The `btif` file extension.\n    FileExtensionBtif,\n    /// The `bz` file extension.\n    FileExtensionBz,\n    /// The `bz2` file extension.\n    FileExtensionBz2,\n    /// The `c` file extension.\n    FileExtensionC,\n    /// The `c11amc` file extension.\n    FileExtensionC11amc,\n    /// The `c11amz` file extension.\n    FileExtensionC11amz,\n    /// The `c4d` file extension.\n    FileExtensionC4d,\n    /// The `c4f` file extension.\n    FileExtensionC4f,\n    /// The `c4g` file extension.\n    FileExtensionC4g,\n    /// The `c4p` file extension.\n    FileExtensionC4p,\n    /// The `c4u` file extension.\n    FileExtensionC4u,\n    /// The `cab` file extension.\n    FileExtensionCab,\n    /// The `caf` file extension.\n    FileExtensionCaf,\n    /// The `cap` file extension.\n    FileExtensionCap,\n    /// The `car` file extension.\n    FileExtensionCar,\n    /// The `cat` file extension.\n    FileExtensionCat,\n    /// The `cb7` file extension.\n    FileExtensionCb7,\n    /// The `cba` file extension.\n    FileExtensionCba,\n    /// The `cbr` file extension.\n    FileExtensionCbr,\n    /// The `cbt` file extension.\n    FileExtensionCbt,\n    /// The `cbz` file extension.\n    FileExtensionCbz,\n    /// The `cc` file extension.\n    FileExtensionCc,\n    /// The `cct` file extension.\n    FileExtensionCct,\n    /// The `ccxml` file extension.\n    FileExtensionCcxml,\n    /// The `cdbcmsg` file extension.\n    FileExtensionCdbcmsg,\n    /// The `cdf` file extension.\n    FileExtensionCdf,\n    /// The `cdkey` file extension.\n    FileExtensionCdkey,\n    /// The `cdmia` file extension.\n    FileExtensionCdmia,\n    /// The `cdmic` file extension.\n    FileExtensionCdmic,\n    /// The `cdmid` file extension.\n    FileExtensionCdmid,\n    /// The `cdmio` file extension.\n    FileExtensionCdmio,\n    /// The `cdmiq` file extension.\n    FileExtensionCdmiq,\n    /// The `cdx` file extension.\n    FileExtensionCdx,\n    /// The `cdxml` file extension.\n    FileExtensionCdxml,\n    /// The `cdy` file extension.\n    FileExtensionCdy,\n    /// The `cer` file extension.\n    FileExtensionCer,\n    /// The `cfs` file extension.\n    FileExtensionCfs,\n    /// The `cgm` file extension.\n    FileExtensionCgm,\n    /// The `chat` file extension.\n    FileExtensionChat,\n    /// The `chm` file extension.\n    FileExtensionChm,\n    /// The `chrt` file extension.\n    FileExtensionChrt,\n    /// The `cif` file extension.\n    FileExtensionCif,\n    /// The `cii` file extension.\n    FileExtensionCii,\n    /// The `cil` file extension.\n    FileExtensionCil,\n    /// The `cla` file extension.\n    FileExtensionCla,\n    /// The `class` file extension.\n    FileExtensionClass,\n    /// The `clkk` file extension.\n    FileExtensionClkk,\n    /// The `clkp` file extension.\n    FileExtensionClkp,\n    /// The `clkt` file extension.\n    FileExtensionClkt,\n    /// The `clkw` file extension.\n    FileExtensionClkw,\n    /// The `clkx` file extension.\n    FileExtensionClkx,\n    /// The `clp` file extension.\n    FileExtensionClp,\n    /// The `cmc` file extension.\n    FileExtensionCmc,\n    /// The `cmdf` file extension.\n    FileExtensionCmdf,\n    /// The `cml` file extension.\n    FileExtensionCml,\n    /// The `cmp` file extension.\n    FileExtensionCmp,\n    /// The `cmx` file extension.\n    FileExtensionCmx,\n    /// The `cod` file extension.\n    FileExtensionCod,\n    /// The `com` file extension.\n    FileExtensionCom,\n    /// The `conf` file extension.\n    FileExtensionConf,\n    /// The `cpio` file extension.\n    FileExtensionCpio,\n    /// The `cpp` file extension.\n    FileExtensionCpp,\n    /// The `cpt` file extension.\n    FileExtensionCpt,\n    /// The `crd` file extension.\n    FileExtensionCrd,\n    /// The `crl` file extension.\n    FileExtensionCrl,\n    /// The `crt` file extension.\n    FileExtensionCrt,\n    /// The `cryptonote` file extension.\n    FileExtensionCryptonote,\n    /// The `csh` file extension.\n    FileExtensionCsh,\n    /// The `csml` file extension.\n    FileExtensionCsml,\n    /// The `csp` file extension.\n    FileExtensionCsp,\n    /// The `css` file extension.\n    FileExtensionCss,\n    /// The `cst` file extension.\n    FileExtensionCst,\n    /// The `csv` file extension.\n    FileExtensionCsv,\n    /// The `cu` file extension.\n    FileExtensionCu,\n    /// The `curl` file extension.\n    FileExtensionCurl,\n    /// The `cww` file extension.\n    FileExtensionCww,\n    /// The `cxt` file extension.\n    FileExtensionCxt,\n    /// The `cxx` file extension.\n    FileExtensionCxx,\n    /// The `dae` file extension.\n    FileExtensionDae,\n    /// The `daf` file extension.\n    FileExtensionDaf,\n    /// The `dart` file extension.\n    FileExtensionDart,\n    /// The `dataless` file extension.\n    FileExtensionDataless,\n    /// The `davmount` file extension.\n    FileExtensionDavmount,\n    /// The `dbk` file extension.\n    FileExtensionDbk,\n    /// The `dcr` file extension.\n    FileExtensionDcr,\n    /// The `dcurl` file extension.\n    FileExtensionDcurl,\n    /// The `dd2` file extension.\n    FileExtensionDd2,\n    /// The `ddd` file extension.\n    FileExtensionDdd,\n    /// The `deb` file extension.\n    FileExtensionDeb,\n    /// The `def` file extension.\n    FileExtensionDef,\n    /// The `deploy` file extension.\n    FileExtensionDeploy,\n    /// The `der` file extension.\n    FileExtensionDer,\n    /// The `dfac` file extension.\n    FileExtensionDfac,\n    /// The `dgc` file extension.\n    FileExtensionDgc,\n    /// The `dib` file extension.\n    FileExtensionDib,\n    /// The `dic` file extension.\n    FileExtensionDic,\n    /// The `dir` file extension.\n    FileExtensionDir,\n    /// The `dis` file extension.\n    FileExtensionDis,\n    /// The `dist` file extension.\n    FileExtensionDist,\n    /// The `distz` file extension.\n    FileExtensionDistz,\n    /// The `djv` file extension.\n    FileExtensionDjv,\n    /// The `djvu` file extension.\n    FileExtensionDjvu,\n    /// The `dll` file extension.\n    FileExtensionDll,\n    /// The `dmg` file extension.\n    FileExtensionDmg,\n    /// The `dmp` file extension.\n    FileExtensionDmp,\n    /// The `dms` file extension.\n    FileExtensionDms,\n    /// The `dna` file extension.\n    FileExtensionDna,\n    /// The `doc` file extension.\n    FileExtensionDoc,\n    /// The `docm` file extension.\n    FileExtensionDocm,\n    /// The `docx` file extension.\n    FileExtensionDocx,\n    /// The `dot` file extension.\n    FileExtensionDot,\n    /// The `dotm` file extension.\n    FileExtensionDotm,\n    /// The `dotx` file extension.\n    FileExtensionDotx,\n    /// The `dp` file extension.\n    FileExtensionDp,\n    /// The `dpg` file extension.\n    FileExtensionDpg,\n    /// The `dra` file extension.\n    FileExtensionDra,\n    /// The `dsc` file extension.\n    FileExtensionDsc,\n    /// The `dssc` file extension.\n    FileExtensionDssc,\n    /// The `dtb` file extension.\n    FileExtensionDtb,\n    /// The `dtd` file extension.\n    FileExtensionDtd,\n    /// The `dts` file extension.\n    FileExtensionDts,\n    /// The `dtshd` file extension.\n    FileExtensionDtshd,\n    /// The `dump` file extension.\n    FileExtensionDump,\n    /// The `dv` file extension.\n    FileExtensionDv,\n    /// The `dvb` file extension.\n    FileExtensionDvb,\n    /// The `dvi` file extension.\n    FileExtensionDvi,\n    /// The `dwf` file extension.\n    FileExtensionDwf,\n    /// The `dwg` file extension.\n    FileExtensionDwg,\n    /// The `dxf` file extension.\n    FileExtensionDxf,\n    /// The `dxp` file extension.\n    FileExtensionDxp,\n    /// The `dxr` file extension.\n    FileExtensionDxr,\n    /// The `ecelp4800` file extension.\n    FileExtensionEcelp4800,\n    /// The `ecelp7470` file extension.\n    FileExtensionEcelp7470,\n    /// The `ecelp9600` file extension.\n    FileExtensionEcelp9600,\n    /// The `ecma` file extension.\n    FileExtensionEcma,\n    /// The `edm` file extension.\n    FileExtensionEdm,\n    /// The `edx` file extension.\n    FileExtensionEdx,\n    /// The `efif` file extension.\n    FileExtensionEfif,\n    /// The `ei6` file extension.\n    FileExtensionEi6,\n    /// The `elc` file extension.\n    FileExtensionElc,\n    /// The `emf` file extension.\n    FileExtensionEmf,\n    /// The `eml` file extension.\n    FileExtensionEml,\n    /// The `emma` file extension.\n    FileExtensionEmma,\n    /// The `emz` file extension.\n    FileExtensionEmz,\n    /// The `eol` file extension.\n    FileExtensionEol,\n    /// The `eot` file extension.\n    FileExtensionEot,\n    /// The `eps` file extension.\n    FileExtensionEps,\n    /// The `epub` file extension.\n    FileExtensionEpub,\n    /// The `es3` file extension.\n    FileExtensionEs3,\n    /// The `esa` file extension.\n    FileExtensionEsa,\n    /// The `esf` file extension.\n    FileExtensionEsf,\n    /// The `et3` file extension.\n    FileExtensionEt3,\n    /// The `etx` file extension.\n    FileExtensionEtx,\n    /// The `eva` file extension.\n    FileExtensionEva,\n    /// The `evy` file extension.\n    FileExtensionEvy,\n    /// The `exe` file extension.\n    FileExtensionExe,\n    /// The `exi` file extension.\n    FileExtensionExi,\n    /// The `ext` file extension.\n    FileExtensionExt,\n    /// The `ez` file extension.\n    FileExtensionEz,\n    /// The `ez2` file extension.\n    FileExtensionEz2,\n    /// The `ez3` file extension.\n    FileExtensionEz3,\n    /// The `f` file extension.\n    FileExtensionF,\n    /// The `f4v` file extension.\n    FileExtensionF4v,\n    /// The `f77` file extension.\n    FileExtensionF77,\n    /// The `f90` file extension.\n    FileExtensionF90,\n    /// The `fbs` file extension.\n    FileExtensionFbs,\n    /// The `fcdt` file extension.\n    FileExtensionFcdt,\n    /// The `fcs` file extension.\n    FileExtensionFcs,\n    /// The `fdf` file extension.\n    FileExtensionFdf,\n    /// The `fe_launch` file extension.\n    FileExtensionFeLaunch,\n    /// The `fg5` file extension.\n    FileExtensionFg5,\n    /// The `fgd` file extension.\n    FileExtensionFgd,\n    /// The `fh` file extension.\n    FileExtensionFh,\n    /// The `fh4` file extension.\n    FileExtensionFh4,\n    /// The `fh5` file extension.\n    FileExtensionFh5,\n    /// The `fh7` file extension.\n    FileExtensionFh7,\n    /// The `fhc` file extension.\n    FileExtensionFhc,\n    /// The `fig` file extension.\n    FileExtensionFig,\n    /// The `flac` file extension.\n    FileExtensionFlac,\n    /// The `fli` file extension.\n    FileExtensionFli,\n    /// The `flo` file extension.\n    FileExtensionFlo,\n    /// The `flv` file extension.\n    FileExtensionFlv,\n    /// The `flw` file extension.\n    FileExtensionFlw,\n    /// The `flx` file extension.\n    FileExtensionFlx,\n    /// The `fly` file extension.\n    FileExtensionFly,\n    /// The `fm` file extension.\n    FileExtensionFm,\n    /// The `fnc` file extension.\n    FileExtensionFnc,\n    /// The `for` file extension.\n    FileExtensionFor,\n    /// The `fpx` file extension.\n    FileExtensionFpx,\n    /// The `frame` file extension.\n    FileExtensionFrame,\n    /// The `fsc` file extension.\n    FileExtensionFsc,\n    /// The `fst` file extension.\n    FileExtensionFst,\n    /// The `ftc` file extension.\n    FileExtensionFtc,\n    /// The `fti` file extension.\n    FileExtensionFti,\n    /// The `fvt` file extension.\n    FileExtensionFvt,\n    /// The `fxp` file extension.\n    FileExtensionFxp,\n    /// The `fxpl` file extension.\n    FileExtensionFxpl,\n    /// The `fzs` file extension.\n    FileExtensionFzs,\n    /// The `g2w` file extension.\n    FileExtensionG2w,\n    /// The `g3` file extension.\n    FileExtensionG3,\n    /// The `g3w` file extension.\n    FileExtensionG3w,\n    /// The `gac` file extension.\n    FileExtensionGac,\n    /// The `gam` file extension.\n    FileExtensionGam,\n    /// The `gbr` file extension.\n    FileExtensionGbr,\n    /// The `gca` file extension.\n    FileExtensionGca,\n    /// The `gdl` file extension.\n    FileExtensionGdl,\n    /// The `geo` file extension.\n    FileExtensionGeo,\n    /// The `gex` file extension.\n    FileExtensionGex,\n    /// The `ggb` file extension.\n    FileExtensionGgb,\n    /// The `ggt` file extension.\n    FileExtensionGgt,\n    /// The `ghf` file extension.\n    FileExtensionGhf,\n    /// The `gif` file extension.\n    FileExtensionGif,\n    /// The `gim` file extension.\n    FileExtensionGim,\n    /// The `gml` file extension.\n    FileExtensionGml,\n    /// The `gmx` file extension.\n    FileExtensionGmx,\n    /// The `gnumeric` file extension.\n    FileExtensionGnumeric,\n    /// The `gph` file extension.\n    FileExtensionGph,\n    /// The `gpx` file extension.\n    FileExtensionGpx,\n    /// The `gqf` file extension.\n    FileExtensionGqf,\n    /// The `gqs` file extension.\n    FileExtensionGqs,\n    /// The `gram` file extension.\n    FileExtensionGram,\n    /// The `gramps` file extension.\n    FileExtensionGramps,\n    /// The `gre` file extension.\n    FileExtensionGre,\n    /// The `grv` file extension.\n    FileExtensionGrv,\n    /// The `grxml` file extension.\n    FileExtensionGrxml,\n    /// The `gsf` file extension.\n    FileExtensionGsf,\n    /// The `gtar` file extension.\n    FileExtensionGtar,\n    /// The `gtm` file extension.\n    FileExtensionGtm,\n    /// The `gtw` file extension.\n    FileExtensionGtw,\n    /// The `gv` file extension.\n    FileExtensionGv,\n    /// The `gxf` file extension.\n    FileExtensionGxf,\n    /// The `gxt` file extension.\n    FileExtensionGxt,\n    /// The `gz` file extension.\n    FileExtensionGz,\n    /// The `h` file extension.\n    FileExtensionH,\n    /// The `h261` file extension.\n    FileExtensionH261,\n    /// The `h263` file extension.\n    FileExtensionH263,\n    /// The `h264` file extension.\n    FileExtensionH264,\n    /// The `hal` file extension.\n    FileExtensionHal,\n    /// The `hbci` file extension.\n    FileExtensionHbci,\n    /// The `hdf` file extension.\n    FileExtensionHdf,\n    /// The `hh` file extension.\n    FileExtensionHh,\n    /// The `hlp` file extension.\n    FileExtensionHlp,\n    /// The `hpgl` file extension.\n    FileExtensionHpgl,\n    /// The `hpid` file extension.\n    FileExtensionHpid,\n    /// The `hps` file extension.\n    FileExtensionHps,\n    /// The `hqx` file extension.\n    FileExtensionHqx,\n    /// The `htc` file extension.\n    FileExtensionHtc,\n    /// The `htke` file extension.\n    FileExtensionHtke,\n    /// The `htm` file extension.\n    FileExtensionHtm,\n    /// The `html` file extension.\n    FileExtensionHtml,\n    /// The `hvd` file extension.\n    FileExtensionHvd,\n    /// The `hvp` file extension.\n    FileExtensionHvp,\n    /// The `hvs` file extension.\n    FileExtensionHvs,\n    /// The `i2g` file extension.\n    FileExtensionI2g,\n    /// The `icc` file extension.\n    FileExtensionIcc,\n    /// The `ice` file extension.\n    FileExtensionIce,\n    /// The `icm` file extension.\n    FileExtensionIcm,\n    /// The `ico` file extension.\n    FileExtensionIco,\n    /// The `ics` file extension.\n    FileExtensionIcs,\n    /// The `ief` file extension.\n    FileExtensionIef,\n    /// The `ifb` file extension.\n    FileExtensionIfb,\n    /// The `ifm` file extension.\n    FileExtensionIfm,\n    /// The `iges` file extension.\n    FileExtensionIges,\n    /// The `igl` file extension.\n    FileExtensionIgl,\n    /// The `igm` file extension.\n    FileExtensionIgm,\n    /// The `igs` file extension.\n    FileExtensionIgs,\n    /// The `igx` file extension.\n    FileExtensionIgx,\n    /// The `iif` file extension.\n    FileExtensionIif,\n    /// The `imp` file extension.\n    FileExtensionImp,\n    /// The `ims` file extension.\n    FileExtensionIms,\n    /// The `in` file extension.\n    FileExtensionIn,\n    /// The `ink` file extension.\n    FileExtensionInk,\n    /// The `inkml` file extension.\n    FileExtensionInkml,\n    /// The `install` file extension.\n    FileExtensionInstall,\n    /// The `iota` file extension.\n    FileExtensionIota,\n    /// The `ipfix` file extension.\n    FileExtensionIpfix,\n    /// The `ipk` file extension.\n    FileExtensionIpk,\n    /// The `irm` file extension.\n    FileExtensionIrm,\n    /// The `irp` file extension.\n    FileExtensionIrp,\n    /// The `iso` file extension.\n    FileExtensionIso,\n    /// The `itp` file extension.\n    FileExtensionItp,\n    /// The `ivp` file extension.\n    FileExtensionIvp,\n    /// The `ivu` file extension.\n    FileExtensionIvu,\n    /// The `jad` file extension.\n    FileExtensionJad,\n    /// The `jam` file extension.\n    FileExtensionJam,\n    /// The `jar` file extension.\n    FileExtensionJar,\n    /// The `java` file extension.\n    FileExtensionJava,\n    /// The `jisp` file extension.\n    FileExtensionJisp,\n    /// The `jlt` file extension.\n    FileExtensionJlt,\n    /// The `jnlp` file extension.\n    FileExtensionJnlp,\n    /// The `joda` file extension.\n    FileExtensionJoda,\n    /// The `jpe` file extension.\n    FileExtensionJpe,\n    /// The `jpeg` file extension.\n    FileExtensionJpeg,\n    /// The `jpg` file extension.\n    FileExtensionJpg,\n    /// The `jpgm` file extension.\n    FileExtensionJpgm,\n    /// The `jpgv` file extension.\n    FileExtensionJpgv,\n    /// The `jpm` file extension.\n    FileExtensionJpm,\n    /// The `js` file extension.\n    FileExtensionJs,\n    /// The `jsf` file extension.\n    FileExtensionJsf,\n    /// The `json` file extension.\n    FileExtensionJson,\n    /// The `jsonml` file extension.\n    FileExtensionJsonml,\n    /// The `jspf` file extension.\n    FileExtensionJspf,\n    /// The `kar` file extension.\n    FileExtensionKar,\n    /// The `karbon` file extension.\n    FileExtensionKarbon,\n    /// The `kfo` file extension.\n    FileExtensionKfo,\n    /// The `kia` file extension.\n    FileExtensionKia,\n    /// The `kml` file extension.\n    FileExtensionKml,\n    /// The `kmz` file extension.\n    FileExtensionKmz,\n    /// The `kne` file extension.\n    FileExtensionKne,\n    /// The `knp` file extension.\n    FileExtensionKnp,\n    /// The `kon` file extension.\n    FileExtensionKon,\n    /// The `kpr` file extension.\n    FileExtensionKpr,\n    /// The `kpt` file extension.\n    FileExtensionKpt,\n    /// The `kpxx` file extension.\n    FileExtensionKpxx,\n    /// The `ksp` file extension.\n    FileExtensionKsp,\n    /// The `ktr` file extension.\n    FileExtensionKtr,\n    /// The `ktx` file extension.\n    FileExtensionKtx,\n    /// The `ktz` file extension.\n    FileExtensionKtz,\n    /// The `kwd` file extension.\n    FileExtensionKwd,\n    /// The `kwt` file extension.\n    FileExtensionKwt,\n    /// The `lasxml` file extension.\n    FileExtensionLasxml,\n    /// The `latex` file extension.\n    FileExtensionLatex,\n    /// The `lbd` file extension.\n    FileExtensionLbd,\n    /// The `lbe` file extension.\n    FileExtensionLbe,\n    /// The `les` file extension.\n    FileExtensionLes,\n    /// The `lha` file extension.\n    FileExtensionLha,\n    /// The `link66` file extension.\n    FileExtensionLink66,\n    /// The `list` file extension.\n    FileExtensionList,\n    /// The `list3820` file extension.\n    FileExtensionList3820,\n    /// The `listafp` file extension.\n    FileExtensionListafp,\n    /// The `lnk` file extension.\n    FileExtensionLnk,\n    /// The `log` file extension.\n    FileExtensionLog,\n    /// The `lostxml` file extension.\n    FileExtensionLostxml,\n    /// The `lrf` file extension.\n    FileExtensionLrf,\n    /// The `lrm` file extension.\n    FileExtensionLrm,\n    /// The `ltf` file extension.\n    FileExtensionLtf,\n    /// The `lvp` file extension.\n    FileExtensionLvp,\n    /// The `lwp` file extension.\n    FileExtensionLwp,\n    /// The `lzh` file extension.\n    FileExtensionLzh,\n    /// The `m13` file extension.\n    FileExtensionM13,\n    /// The `m14` file extension.\n    FileExtensionM14,\n    /// The `m1v` file extension.\n    FileExtensionM1v,\n    /// The `m21` file extension.\n    FileExtensionM21,\n    /// The `m2a` file extension.\n    FileExtensionM2a,\n    /// The `m2v` file extension.\n    FileExtensionM2v,\n    /// The `m3a` file extension.\n    FileExtensionM3a,\n    /// The `m3u` file extension.\n    FileExtensionM3u,\n    /// The `m3u8` file extension.\n    FileExtensionM3u8,\n    /// The `m4a` file extension.\n    FileExtensionM4a,\n    /// The `m4b` file extension.\n    FileExtensionM4b,\n    /// The `m4r` file extension.\n    FileExtensionM4r,\n    /// The `m4u` file extension.\n    FileExtensionM4u,\n    /// The `m4v` file extension.\n    FileExtensionM4v,\n    /// The file extension for markdown.\n    FileExtensionMarkdown,\n    /// The file extension for toml.\n    FileExtensionToml,\n    /// The file extension for yaml.\n    FileExtensionYaml,\n    /// The file extension for yaml.\n    FileExtensionYml,\n    /// The file extension for ini.\n    FileExtensionIni,\n    /// The file extension for cfg.\n    FileExtensionCfg,\n    /// The file extension for Python.\n    FileExtensionPython,\n    /// The file extension for Go.\n    FileExtensionGo,\n    /// The file extension for TypeScript.\n    FileExtensionTypeScript,\n    /// The file extension for C#.\n    FileExtensionCSharp,\n    /// The file extension for PHP.\n    FileExtensionPhp,\n    /// The file extension for Ruby.\n    FileExtensionRuby,\n    /// The file extension for Swift.\n    FileExtensionSwift,\n    /// The file extension for Kotlin.\n    FileExtensionKotlin,\n    /// The file extension for Kotlin Script.\n    FileExtensionKotlinScript,\n    /// The file extension for Scala.\n    FileExtensionScala,\n    /// The file extension for IBM Secure Container or Scala Script.\n    FileExtensionIbmScOrScalaScript,\n    /// The file extension for Perl.\n    FileExtensionPerl,\n    /// The file extension for Perl Module.\n    FileExtensionPerlModule,\n    /// The file extension for Lua.\n    FileExtensionLua,\n    /// The file extension for PowerShell.\n    FileExtensionPowerShell,\n    /// The file extension for C++ Header.\n    FileExtensionCppHeader,\n    /// The file extension for Objective-C.\n    FileExtensionObjectiveC,\n    /// The file extension for Objective-C++.\n    FileExtensionObjectiveCpp,\n    /// The file extension for Groovy.\n    FileExtensionGroovy,\n    /// The file extension for R.\n    FileExtensionR,\n    /// The file extension for SCSS.\n    FileExtensionScss,\n    /// The file extension for SASS.\n    FileExtensionSass,\n    /// The file extension for LESS.\n    FileExtensionLess,\n    /// The file extension for Vue.\n    FileExtensionVue,\n    /// The file extension for JSX.\n    FileExtensionJsx,\n    /// The file extension for TSX.\n    FileExtensionTsx,\n    /// The file extension for Dockerfile.\n    FileExtensionDockerfile,\n    /// The file extension for Makefile.\n    FileExtensionMakefile,\n    /// The file extension for RLS Services XML or Rust.\n    FileExtensionRs,\n    /// The file extension for Haskell.\n    FileExtensionHaskell,\n    /// The file extension for Erlang.\n    FileExtensionErlang,\n    /// The file extension for Elixir.\n    FileExtensionElixir,\n    /// The file extension for Elixir Script.\n    FileExtensionElixirScript,\n    /// The file extension for Clojure.\n    FileExtensionClojure,\n    /// The file extension for ClojureScript.\n    FileExtensionClojureScript,\n    /// The file extension for Clojure Common.\n    FileExtensionClojureCommon,\n    /// The file extension for F#.\n    FileExtensionFSharp,\n    /// The file extension for F# Script.\n    FileExtensionFSharpScript,\n    /// The file extension for OCaml.\n    FileExtensionOCaml,\n    /// The file extension for OCaml Interface.\n    FileExtensionOCamlInterface,\n    /// The file extension for Bash.\n    FileExtensionBash,\n    /// The file extension for Zsh.\n    FileExtensionZsh,\n    /// The file extension for env.\n    FileExtensionEnv,\n    /// The file extension for cj.\n    FileExtensionCj,\n    /// The file extension for Gitignore.\n    FileExtensionGitignore,\n    /// The `ma` file extension.\n    FileExtensionMa,\n    /// The `mac` file extension.\n    FileExtensionMac,\n    /// The `mads` file extension.\n    FileExtensionMads,\n    /// The `mag` file extension.\n    FileExtensionMag,\n    /// The `maker` file extension.\n    FileExtensionMaker,\n    /// The `man` file extension.\n    FileExtensionMan,\n    /// The `mar` file extension.\n    FileExtensionMar,\n    /// The `mathml` file extension.\n    FileExtensionMathml,\n    /// The `mb` file extension.\n    FileExtensionMb,\n    /// The `mbk` file extension.\n    FileExtensionMbk,\n    /// The `mbox` file extension.\n    FileExtensionMbox,\n    /// The `mc1` file extension.\n    FileExtensionMc1,\n    /// The `mcd` file extension.\n    FileExtensionMcd,\n    /// The `mcurl` file extension.\n    FileExtensionMcurl,\n    /// The `mdb` file extension.\n    FileExtensionMdb,\n    /// The `mdi` file extension.\n    FileExtensionMdi,\n    /// The `me` file extension.\n    FileExtensionMe,\n    /// The `mesh` file extension.\n    FileExtensionMesh,\n    /// The `meta4` file extension.\n    FileExtensionMeta4,\n    /// The `metalink` file extension.\n    FileExtensionMetalink,\n    /// The `mets` file extension.\n    FileExtensionMets,\n    /// The `mfm` file extension.\n    FileExtensionMfm,\n    /// The `mft` file extension.\n    FileExtensionMft,\n    /// The `mgp` file extension.\n    FileExtensionMgp,\n    /// The `mgz` file extension.\n    FileExtensionMgz,\n    /// The `mid` file extension.\n    FileExtensionMid,\n    /// The `midi` file extension.\n    FileExtensionMidi,\n    /// The `mie` file extension.\n    FileExtensionMie,\n    /// The `mif` file extension.\n    FileExtensionMif,\n    /// The `mime` file extension.\n    FileExtensionMime,\n    /// The `mj2` file extension.\n    FileExtensionMj2,\n    /// The `mjp2` file extension.\n    FileExtensionMjp2,\n    /// The `mk3d` file extension.\n    FileExtensionMk3d,\n    /// The `mka` file extension.\n    FileExtensionMka,\n    /// The `mks` file extension.\n    FileExtensionMks,\n    /// The `mkv` file extension.\n    FileExtensionMkv,\n    /// The `mlp` file extension.\n    FileExtensionMlp,\n    /// The `mmd` file extension.\n    FileExtensionMmd,\n    /// The `mmf` file extension.\n    FileExtensionMmf,\n    /// The `mmr` file extension.\n    FileExtensionMmr,\n    /// The `mng` file extension.\n    FileExtensionMng,\n    /// The `mny` file extension.\n    FileExtensionMny,\n    /// The `mobi` file extension.\n    FileExtensionMobi,\n    /// The `mods` file extension.\n    FileExtensionMods,\n    /// The `mov` file extension.\n    FileExtensionMov,\n    /// The `movie` file extension.\n    FileExtensionMovie,\n    /// The `mp1` file extension.\n    FileExtensionMp1,\n    /// The `mp2` file extension.\n    FileExtensionMp2,\n    /// The `mp21` file extension.\n    FileExtensionMp21,\n    /// The `mp2a` file extension.\n    FileExtensionMp2a,\n    /// The `mp3` file extension.\n    FileExtensionMp3,\n    /// The `mp4` file extension.\n    FileExtensionMp4,\n    /// The `mp4a` file extension.\n    FileExtensionMp4a,\n    /// The `mp4s` file extension.\n    FileExtensionMp4s,\n    /// The `mp4v` file extension.\n    FileExtensionMp4v,\n    /// The `mpa` file extension.\n    FileExtensionMpa,\n    /// The `mpc` file extension.\n    FileExtensionMpc,\n    /// The `mpe` file extension.\n    FileExtensionMpe,\n    /// The `mpeg` file extension.\n    FileExtensionMpeg,\n    /// The `mpega` file extension.\n    FileExtensionMpega,\n    /// The `mpg` file extension.\n    FileExtensionMpg,\n    /// The `mpg4` file extension.\n    FileExtensionMpg4,\n    /// The `mpga` file extension.\n    FileExtensionMpga,\n    /// The `mpkg` file extension.\n    FileExtensionMpkg,\n    /// The `mpm` file extension.\n    FileExtensionMpm,\n    /// The `mpn` file extension.\n    FileExtensionMpn,\n    /// The `mpp` file extension.\n    FileExtensionMpp,\n    /// The `mpt` file extension.\n    FileExtensionMpt,\n    /// The `mpv2` file extension.\n    FileExtensionMpv2,\n    /// The `mpy` file extension.\n    FileExtensionMpy,\n    /// The `mqy` file extension.\n    FileExtensionMqy,\n    /// The `mrc` file extension.\n    FileExtensionMrc,\n    /// The `mrcx` file extension.\n    FileExtensionMrcx,\n    /// The `ms` file extension.\n    FileExtensionMs,\n    /// The `mscml` file extension.\n    FileExtensionMscml,\n    /// The `mseed` file extension.\n    FileExtensionMseed,\n    /// The `mseq` file extension.\n    FileExtensionMseq,\n    /// The `msf` file extension.\n    FileExtensionMsf,\n    /// The `msh` file extension.\n    FileExtensionMsh,\n    /// The `msi` file extension.\n    FileExtensionMsi,\n    /// The `msl` file extension.\n    FileExtensionMsl,\n    /// The `msty` file extension.\n    FileExtensionMsty,\n    /// The `mts` file extension.\n    FileExtensionMts,\n    /// The `mus` file extension.\n    FileExtensionMus,\n    /// The `musicxml` file extension.\n    FileExtensionMusicxml,\n    /// The `mvb` file extension.\n    FileExtensionMvb,\n    /// The `mwf` file extension.\n    FileExtensionMwf,\n    /// The `mxf` file extension.\n    FileExtensionMxf,\n    /// The `mxl` file extension.\n    FileExtensionMxl,\n    /// The `mxml` file extension.\n    FileExtensionMxml,\n    /// The `mxs` file extension.\n    FileExtensionMxs,\n    /// The `mxu` file extension.\n    FileExtensionMxu,\n    /// The `n-gage` file extension.\n    FileExtensionNGage,\n    /// The `n3` file extension.\n    FileExtensionN3,\n    /// The `nb` file extension.\n    FileExtensionNb,\n    /// The `nbp` file extension.\n    FileExtensionNbp,\n    /// The `nc` file extension.\n    FileExtensionNc,\n    /// The `ncx` file extension.\n    FileExtensionNcx,\n    /// The `nfo` file extension.\n    FileExtensionNfo,\n    /// The `ngdat` file extension.\n    FileExtensionNgdat,\n    /// The `nitf` file extension.\n    FileExtensionNitf,\n    /// The `nlu` file extension.\n    FileExtensionNlu,\n    /// The `nml` file extension.\n    FileExtensionNml,\n    /// The `nnd` file extension.\n    FileExtensionNnd,\n    /// The `nns` file extension.\n    FileExtensionNns,\n    /// The `nnw` file extension.\n    FileExtensionNnw,\n    /// The `npx` file extension.\n    FileExtensionNpx,\n    /// The `nsc` file extension.\n    FileExtensionNsc,\n    /// The `nsf` file extension.\n    FileExtensionNsf,\n    /// The `ntf` file extension.\n    FileExtensionNtf,\n    /// The `nzb` file extension.\n    FileExtensionNzb,\n    /// The `oa2` file extension.\n    FileExtensionOa2,\n    /// The `oa3` file extension.\n    FileExtensionOa3,\n    /// The `oas` file extension.\n    FileExtensionOas,\n    /// The `obd` file extension.\n    FileExtensionObd,\n    /// The `obj` file extension.\n    FileExtensionObj,\n    /// The `oda` file extension.\n    FileExtensionOda,\n    /// The `odb` file extension.\n    FileExtensionOdb,\n    /// The `odc` file extension.\n    FileExtensionOdc,\n    /// The `odf` file extension.\n    FileExtensionOdf,\n    /// The `odft` file extension.\n    FileExtensionOdft,\n    /// The `odg` file extension.\n    FileExtensionOdg,\n    /// The `odi` file extension.\n    FileExtensionOdi,\n    /// The `odm` file extension.\n    FileExtensionOdm,\n    /// The `odp` file extension.\n    FileExtensionOdp,\n    /// The `ods` file extension.\n    FileExtensionOds,\n    /// The `odt` file extension.\n    FileExtensionOdt,\n    /// The `oga` file extension.\n    FileExtensionOga,\n    /// The `ogg` file extension.\n    FileExtensionOgg,\n    /// The `ogv` file extension.\n    FileExtensionOgv,\n    /// The `ogx` file extension.\n    FileExtensionOgx,\n    /// The `omdoc` file extension.\n    FileExtensionOmdoc,\n    /// The `onepkg` file extension.\n    FileExtensionOnepkg,\n    /// The `onetmp` file extension.\n    FileExtensionOnetmp,\n    /// The `onetoc` file extension.\n    FileExtensionOnetoc,\n    /// The `onetoc2` file extension.\n    FileExtensionOnetoc2,\n    /// The `opf` file extension.\n    FileExtensionOpf,\n    /// The `opml` file extension.\n    FileExtensionOpml,\n    /// The `oprc` file extension.\n    FileExtensionOprc,\n    /// The `org` file extension.\n    FileExtensionOrg,\n    /// The `osf` file extension.\n    FileExtensionOsf,\n    /// The `osfpvg` file extension.\n    FileExtensionOsfpvg,\n    /// The `otc` file extension.\n    FileExtensionOtc,\n    /// The `otf` file extension.\n    FileExtensionOtf,\n    /// The `otg` file extension.\n    FileExtensionOtg,\n    /// The `oth` file extension.\n    FileExtensionOth,\n    /// The `oti` file extension.\n    FileExtensionOti,\n    /// The `otp` file extension.\n    FileExtensionOtp,\n    /// The `ots` file extension.\n    FileExtensionOts,\n    /// The `ott` file extension.\n    FileExtensionOtt,\n    /// The `oxps` file extension.\n    FileExtensionOxps,\n    /// The `oxt` file extension.\n    FileExtensionOxt,\n    /// The `p` file extension.\n    FileExtensionP,\n    /// The `p10` file extension.\n    FileExtensionP10,\n    /// The `p12` file extension.\n    FileExtensionP12,\n    /// The `p7b` file extension.\n    FileExtensionP7b,\n    /// The `p7c` file extension.\n    FileExtensionP7c,\n    /// The `p7m` file extension.\n    FileExtensionP7m,\n    /// The `p7r` file extension.\n    FileExtensionP7r,\n    /// The `p7s` file extension.\n    FileExtensionP7s,\n    /// The `p8` file extension.\n    FileExtensionP8,\n    /// The `pas` file extension.\n    FileExtensionPas,\n    /// The `paw` file extension.\n    FileExtensionPaw,\n    /// The `pbd` file extension.\n    FileExtensionPbd,\n    /// The `pbm` file extension.\n    FileExtensionPbm,\n    /// The `pcap` file extension.\n    FileExtensionPcap,\n    /// The `pcf` file extension.\n    FileExtensionPcf,\n    /// The `pcl` file extension.\n    FileExtensionPcl,\n    /// The `pclxl` file extension.\n    FileExtensionPclxl,\n    /// The `pct` file extension.\n    FileExtensionPct,\n    /// The `pcurl` file extension.\n    FileExtensionPcurl,\n    /// The `pcx` file extension.\n    FileExtensionPcx,\n    /// The `pdb` file extension.\n    FileExtensionPdb,\n    /// The `pdf` file extension.\n    FileExtensionPdf,\n    /// The `pfa` file extension.\n    FileExtensionPfa,\n    /// The `pfb` file extension.\n    FileExtensionPfb,\n    /// The `pfm` file extension.\n    FileExtensionPfm,\n    /// The `pfr` file extension.\n    FileExtensionPfr,\n    /// The `pfx` file extension.\n    FileExtensionPfx,\n    /// The `pgm` file extension.\n    FileExtensionPgm,\n    /// The `pgn` file extension.\n    FileExtensionPgn,\n    /// The `pgp` file extension.\n    FileExtensionPgp,\n    /// The `pic` file extension.\n    FileExtensionPic,\n    /// The `pict` file extension.\n    FileExtensionPict,\n    /// The `pkg` file extension.\n    FileExtensionPkg,\n    /// The `pki` file extension.\n    FileExtensionPki,\n    /// The `pkipath` file extension.\n    FileExtensionPkipath,\n    /// The `plb` file extension.\n    FileExtensionPlb,\n    /// The `plc` file extension.\n    FileExtensionPlc,\n    /// The `plf` file extension.\n    FileExtensionPlf,\n    /// The `pls` file extension.\n    FileExtensionPls,\n    /// The `pml` file extension.\n    FileExtensionPml,\n    /// The `png` file extension.\n    FileExtensionPng,\n    /// The `pnm` file extension.\n    FileExtensionPnm,\n    /// The `pnt` file extension.\n    FileExtensionPnt,\n    /// The `portpkg` file extension.\n    FileExtensionPortpkg,\n    /// The `pot` file extension.\n    FileExtensionPot,\n    /// The `potm` file extension.\n    FileExtensionPotm,\n    /// The `potx` file extension.\n    FileExtensionPotx,\n    /// The `ppam` file extension.\n    FileExtensionPpam,\n    /// The `ppd` file extension.\n    FileExtensionPpd,\n    /// The `ppm` file extension.\n    FileExtensionPpm,\n    /// The `pps` file extension.\n    FileExtensionPps,\n    /// The `ppsm` file extension.\n    FileExtensionPpsm,\n    /// The `ppsx` file extension.\n    FileExtensionPpsx,\n    /// The `ppt` file extension.\n    FileExtensionPpt,\n    /// The `pptm` file extension.\n    FileExtensionPptm,\n    /// The `pptx` file extension.\n    FileExtensionPptx,\n    /// The `pqa` file extension.\n    FileExtensionPqa,\n    /// The `prc` file extension.\n    FileExtensionPrc,\n    /// The `pre` file extension.\n    FileExtensionPre,\n    /// The `prf` file extension.\n    FileExtensionPrf,\n    /// The `ps` file extension.\n    FileExtensionPs,\n    /// The `psb` file extension.\n    FileExtensionPsb,\n    /// The `psd` file extension.\n    FileExtensionPsd,\n    /// The `psf` file extension.\n    FileExtensionPsf,\n    /// The `pskcxml` file extension.\n    FileExtensionPskcxml,\n    /// The `ptid` file extension.\n    FileExtensionPtid,\n    /// The `pub` file extension.\n    FileExtensionPub,\n    /// The `pvb` file extension.\n    FileExtensionPvb,\n    /// The `pwn` file extension.\n    FileExtensionPwn,\n    /// The `pya` file extension.\n    FileExtensionPya,\n    /// The `pyv` file extension.\n    FileExtensionPyv,\n    /// The `qam` file extension.\n    FileExtensionQam,\n    /// The `qbo` file extension.\n    FileExtensionQbo,\n    /// The `qfx` file extension.\n    FileExtensionQfx,\n    /// The `qps` file extension.\n    FileExtensionQps,\n    /// The `qt` file extension.\n    FileExtensionQt,\n    /// The `qti` file extension.\n    FileExtensionQti,\n    /// The `qtif` file extension.\n    FileExtensionQtif,\n    /// The `qwd` file extension.\n    FileExtensionQwd,\n    /// The `qwt` file extension.\n    FileExtensionQwt,\n    /// The `qxb` file extension.\n    FileExtensionQxb,\n    /// The `qxd` file extension.\n    FileExtensionQxd,\n    /// The `qxl` file extension.\n    FileExtensionQxl,\n    /// The `qxt` file extension.\n    FileExtensionQxt,\n    /// The `ra` file extension.\n    FileExtensionRa,\n    /// The `ram` file extension.\n    FileExtensionRam,\n    /// The `rar` file extension.\n    FileExtensionRar,\n    /// The `ras` file extension.\n    FileExtensionRas,\n    /// The `rcprofile` file extension.\n    FileExtensionRcprofile,\n    /// The `rdf` file extension.\n    FileExtensionRdf,\n    /// The `rdz` file extension.\n    FileExtensionRdz,\n    /// The `rep` file extension.\n    FileExtensionRep,\n    /// The `res` file extension.\n    FileExtensionRes,\n    /// The `rgb` file extension.\n    FileExtensionRgb,\n    /// The `rif` file extension.\n    FileExtensionRif,\n    /// The `rip` file extension.\n    FileExtensionRip,\n    /// The `ris` file extension.\n    FileExtensionRis,\n    /// The `rl` file extension.\n    FileExtensionRl,\n    /// The `rlc` file extension.\n    FileExtensionRlc,\n    /// The `rld` file extension.\n    FileExtensionRld,\n    /// The `rm` file extension.\n    FileExtensionRm,\n    /// The `rmi` file extension.\n    FileExtensionRmi,\n    /// The `rmp` file extension.\n    FileExtensionRmp,\n    /// The `rms` file extension.\n    FileExtensionRms,\n    /// The `rmvb` file extension.\n    FileExtensionRmvb,\n    /// The `rnc` file extension.\n    FileExtensionRnc,\n    /// The `roa` file extension.\n    FileExtensionRoa,\n    /// The `roff` file extension.\n    FileExtensionRoff,\n    /// The `rp9` file extension.\n    FileExtensionRp9,\n    /// The `rpss` file extension.\n    FileExtensionRpss,\n    /// The `rpst` file extension.\n    FileExtensionRpst,\n    /// The `rq` file extension.\n    FileExtensionRq,\n    /// The `rsd` file extension.\n    FileExtensionRsd,\n    /// The `rss` file extension.\n    FileExtensionRss,\n    /// The `rtf` file extension.\n    FileExtensionRtf,\n    /// The `rtx` file extension.\n    FileExtensionRtx,\n    /// The `s` file extension.\n    FileExtensionS,\n    /// The `s3m` file extension.\n    FileExtensionS3m,\n    /// The `saf` file extension.\n    FileExtensionSaf,\n    /// The `sbml` file extension.\n    FileExtensionSbml,\n    /// The `sc` file extension.\n    FileExtensionSc,\n    /// The `scd` file extension.\n    FileExtensionScd,\n    /// The `scm` file extension.\n    FileExtensionScm,\n    /// The `scq` file extension.\n    FileExtensionScq,\n    /// The `scs` file extension.\n    FileExtensionScs,\n    /// The `scurl` file extension.\n    FileExtensionScurl,\n    /// The `sda` file extension.\n    FileExtensionSda,\n    /// The `sdc` file extension.\n    FileExtensionSdc,\n    /// The `sdd` file extension.\n    FileExtensionSdd,\n    /// The `sdkd` file extension.\n    FileExtensionSdkd,\n    /// The `sdkm` file extension.\n    FileExtensionSdkm,\n    /// The `sdp` file extension.\n    FileExtensionSdp,\n    /// The `sdw` file extension.\n    FileExtensionSdw,\n    /// The `see` file extension.\n    FileExtensionSee,\n    /// The `seed` file extension.\n    FileExtensionSeed,\n    /// The `sema` file extension.\n    FileExtensionSema,\n    /// The `semd` file extension.\n    FileExtensionSemd,\n    /// The `semf` file extension.\n    FileExtensionSemf,\n    /// The `ser` file extension.\n    FileExtensionSer,\n    /// The `setpay` file extension.\n    FileExtensionSetpay,\n    /// The `setreg` file extension.\n    FileExtensionSetreg,\n    /// The `sfd-hdstx` file extension.\n    FileExtensionSfdHdstx,\n    /// The `sfs` file extension.\n    FileExtensionSfs,\n    /// The `sfv` file extension.\n    FileExtensionSfv,\n    /// The `sgi` file extension.\n    FileExtensionSgi,\n    /// The `sgl` file extension.\n    FileExtensionSgl,\n    /// The `sgm` file extension.\n    FileExtensionSgm,\n    /// The `sgml` file extension.\n    FileExtensionSgml,\n    /// The `sh` file extension.\n    FileExtensionSh,\n    /// The `shar` file extension.\n    FileExtensionShar,\n    /// The `shf` file extension.\n    FileExtensionShf,\n    /// The `sid` file extension.\n    FileExtensionSid,\n    /// The `sig` file extension.\n    FileExtensionSig,\n    /// The `sil` file extension.\n    FileExtensionSil,\n    /// The `silo` file extension.\n    FileExtensionSilo,\n    /// The `sis` file extension.\n    FileExtensionSis,\n    /// The `sisx` file extension.\n    FileExtensionSisx,\n    /// The `sit` file extension.\n    FileExtensionSit,\n    /// The `sitx` file extension.\n    FileExtensionSitx,\n    /// The `skd` file extension.\n    FileExtensionSkd,\n    /// The `skm` file extension.\n    FileExtensionSkm,\n    /// The `skp` file extension.\n    FileExtensionSkp,\n    /// The `skt` file extension.\n    FileExtensionSkt,\n    /// The `sldm` file extension.\n    FileExtensionSldm,\n    /// The `sldx` file extension.\n    FileExtensionSldx,\n    /// The `slt` file extension.\n    FileExtensionSlt,\n    /// The `sm` file extension.\n    FileExtensionSm,\n    /// The `smf` file extension.\n    FileExtensionSmf,\n    /// The `smi` file extension.\n    FileExtensionSmi,\n    /// The `smil` file extension.\n    FileExtensionSmil,\n    /// The `smv` file extension.\n    FileExtensionSmv,\n    /// The `smzip` file extension.\n    FileExtensionSmzip,\n    /// The `snd` file extension.\n    FileExtensionSnd,\n    /// The `snf` file extension.\n    FileExtensionSnf,\n    /// The `so` file extension.\n    FileExtensionSo,\n    /// The `spc` file extension.\n    FileExtensionSpc,\n    /// The `spf` file extension.\n    FileExtensionSpf,\n    /// The `spl` file extension.\n    FileExtensionSpl,\n    /// The `spot` file extension.\n    FileExtensionSpot,\n    /// The `spp` file extension.\n    FileExtensionSpp,\n    /// The `spq` file extension.\n    FileExtensionSpq,\n    /// The `spx` file extension.\n    FileExtensionSpx,\n    /// The `sql` file extension.\n    FileExtensionSql,\n    /// The `src` file extension.\n    FileExtensionSrc,\n    /// The `srt` file extension.\n    FileExtensionSrt,\n    /// The `sru` file extension.\n    FileExtensionSru,\n    /// The `srx` file extension.\n    FileExtensionSrx,\n    /// The `ssdl` file extension.\n    FileExtensionSsdl,\n    /// The `sse` file extension.\n    FileExtensionSse,\n    /// The `ssf` file extension.\n    FileExtensionSsf,\n    /// The `ssml` file extension.\n    FileExtensionSsml,\n    /// The `st` file extension.\n    FileExtensionSt,\n    /// The `stc` file extension.\n    FileExtensionStc,\n    /// The `std` file extension.\n    FileExtensionStd,\n    /// The `stf` file extension.\n    FileExtensionStf,\n    /// The `sti` file extension.\n    FileExtensionSti,\n    /// The `stk` file extension.\n    FileExtensionStk,\n    /// The `stl` file extension.\n    FileExtensionStl,\n    /// The `str` file extension.\n    FileExtensionStr,\n    /// The `stw` file extension.\n    FileExtensionStw,\n    /// The `sub` file extension.\n    FileExtensionSub,\n    /// The `sus` file extension.\n    FileExtensionSus,\n    /// The `susp` file extension.\n    FileExtensionSusp,\n    /// The `sv4cpio` file extension.\n    FileExtensionSv4cpio,\n    /// The `sv4crc` file extension.\n    FileExtensionSv4crc,\n    /// The `svc` file extension.\n    FileExtensionSvc,\n    /// The `svd` file extension.\n    FileExtensionSvd,\n    /// The `svg` file extension.\n    FileExtensionSvg,\n    /// The `svgz` file extension.\n    FileExtensionSvgz,\n    /// The `swa` file extension.\n    FileExtensionSwa,\n    /// The `swf` file extension.\n    FileExtensionSwf,\n    /// The `swi` file extension.\n    FileExtensionSwi,\n    /// The `sxc` file extension.\n    FileExtensionSxc,\n    /// The `sxd` file extension.\n    FileExtensionSxd,\n    /// The `sxg` file extension.\n    FileExtensionSxg,\n    /// The `sxi` file extension.\n    FileExtensionSxi,\n    /// The `sxm` file extension.\n    FileExtensionSxm,\n    /// The `sxw` file extension.\n    FileExtensionSxw,\n    /// The `t` file extension.\n    FileExtensionT,\n    /// The `t3` file extension.\n    FileExtensionT3,\n    /// The `taglet` file extension.\n    FileExtensionTaglet,\n    /// The `tao` file extension.\n    FileExtensionTao,\n    /// The `tar` file extension.\n    FileExtensionTar,\n    /// The `tcap` file extension.\n    FileExtensionTcap,\n    /// The `tcl` file extension.\n    FileExtensionTcl,\n    /// The `teacher` file extension.\n    FileExtensionTeacher,\n    /// The `tei` file extension.\n    FileExtensionTei,\n    /// The `teicorpus` file extension.\n    FileExtensionTeicorpus,\n    /// The `tex` file extension.\n    FileExtensionTex,\n    /// The `texi` file extension.\n    FileExtensionTexi,\n    /// The `texinfo` file extension.\n    FileExtensionTexinfo,\n    /// The `text` file extension.\n    FileExtensionText,\n    /// The `tfi` file extension.\n    FileExtensionTfi,\n    /// The `tfm` file extension.\n    FileExtensionTfm,\n    /// The `tga` file extension.\n    FileExtensionTga,\n    /// The `thmx` file extension.\n    FileExtensionThmx,\n    /// The `tif` file extension.\n    FileExtensionTif,\n    /// The `tiff` file extension.\n    FileExtensionTiff,\n    /// The `tmo` file extension.\n    FileExtensionTmo,\n    /// The `torrent` file extension.\n    FileExtensionTorrent,\n    /// The `tpl` file extension.\n    FileExtensionTpl,\n    /// The `tpt` file extension.\n    FileExtensionTpt,\n    /// The `tr` file extension.\n    FileExtensionTr,\n    /// The `tra` file extension.\n    FileExtensionTra,\n    /// The `trm` file extension.\n    FileExtensionTrm,\n    /// The `tsd` file extension.\n    FileExtensionTsd,\n    /// The `tsv` file extension.\n    FileExtensionTsv,\n    /// The `ttc` file extension.\n    FileExtensionTtc,\n    /// The `ttf` file extension.\n    FileExtensionTtf,\n    /// The `ttl` file extension.\n    FileExtensionTtl,\n    /// The `twd` file extension.\n    FileExtensionTwd,\n    /// The `twds` file extension.\n    FileExtensionTwds,\n    /// The `txd` file extension.\n    FileExtensionTxd,\n    /// The `txf` file extension.\n    FileExtensionTxf,\n    /// The `txt` file extension.\n    FileExtensionTxt,\n    /// The `u32` file extension.\n    FileExtensionU32,\n    /// The `udeb` file extension.\n    FileExtensionUdeb,\n    /// The `ufd` file extension.\n    FileExtensionUfd,\n    /// The `ufdl` file extension.\n    FileExtensionUfdl,\n    /// The `ulw` file extension.\n    FileExtensionUlw,\n    /// The `ulx` file extension.\n    FileExtensionUlx,\n    /// The `umj` file extension.\n    FileExtensionUmj,\n    /// The `unityweb` file extension.\n    FileExtensionUnityweb,\n    /// The `uoml` file extension.\n    FileExtensionUoml,\n    /// The `uri` file extension.\n    FileExtensionUri,\n    /// The `uris` file extension.\n    FileExtensionUris,\n    /// The `urls` file extension.\n    FileExtensionUrls,\n    /// The `ustar` file extension.\n    FileExtensionUstar,\n    /// The `utz` file extension.\n    FileExtensionUtz,\n    /// The `uu` file extension.\n    FileExtensionUu,\n    /// The `uva` file extension.\n    FileExtensionUva,\n    /// The `uvd` file extension.\n    FileExtensionUvd,\n    /// The `uvf` file extension.\n    FileExtensionUvf,\n    /// The `uvg` file extension.\n    FileExtensionUvg,\n    /// The `uvh` file extension.\n    FileExtensionUvh,\n    /// The `uvi` file extension.\n    FileExtensionUvi,\n    /// The `uvm` file extension.\n    FileExtensionUvm,\n    /// The `uvp` file extension.\n    FileExtensionUvp,\n    /// The `uvs` file extension.\n    FileExtensionUvs,\n    /// The `uvt` file extension.\n    FileExtensionUvt,\n    /// The `uvu` file extension.\n    FileExtensionUvu,\n    /// The `uvv` file extension.\n    FileExtensionUvv,\n    /// The `uvva` file extension.\n    FileExtensionUvva,\n    /// The `uvvd` file extension.\n    FileExtensionUvvd,\n    /// The `uvvf` file extension.\n    FileExtensionUvvf,\n    /// The `uvvg` file extension.\n    FileExtensionUvvg,\n    /// The `uvvh` file extension.\n    FileExtensionUvvh,\n    /// The `uvvi` file extension.\n    FileExtensionUvvi,\n    /// The `uvvm` file extension.\n    FileExtensionUvvm,\n    /// The `uvvp` file extension.\n    FileExtensionUvvp,\n    /// The `uvvs` file extension.\n    FileExtensionUvvs,\n    /// The `uvvt` file extension.\n    FileExtensionUvvt,\n    /// The `uvvu` file extension.\n    FileExtensionUvvu,\n    /// The `uvvv` file extension.\n    FileExtensionUvvv,\n    /// The `uvvx` file extension.\n    FileExtensionUvvx,\n    /// The `uvvz` file extension.\n    FileExtensionUvvz,\n    /// The `uvx` file extension.\n    FileExtensionUvx,\n    /// The `uvz` file extension.\n    FileExtensionUvz,\n    /// The `vcard` file extension.\n    FileExtensionVcard,\n    /// The `vcd` file extension.\n    FileExtensionVcd,\n    /// The `vcf` file extension.\n    FileExtensionVcf,\n    /// The `vcg` file extension.\n    FileExtensionVcg,\n    /// The `vcs` file extension.\n    FileExtensionVcs,\n    /// The `vcx` file extension.\n    FileExtensionVcx,\n    /// The `vis` file extension.\n    FileExtensionVis,\n    /// The `viv` file extension.\n    FileExtensionViv,\n    /// The `vob` file extension.\n    FileExtensionVob,\n    /// The `vor` file extension.\n    FileExtensionVor,\n    /// The `vox` file extension.\n    FileExtensionVox,\n    /// The `vrml` file extension.\n    FileExtensionVrml,\n    /// The `vsd` file extension.\n    FileExtensionVsd,\n    /// The `vsf` file extension.\n    FileExtensionVsf,\n    /// The `vss` file extension.\n    FileExtensionVss,\n    /// The `vst` file extension.\n    FileExtensionVst,\n    /// The `vsw` file extension.\n    FileExtensionVsw,\n    /// The `vtu` file extension.\n    FileExtensionVtu,\n    /// The `vxml` file extension.\n    FileExtensionVxml,\n    /// The `w3d` file extension.\n    FileExtensionW3d,\n    /// The `wad` file extension.\n    FileExtensionWad,\n    /// The `wav` file extension.\n    FileExtensionWav,\n    /// The `wax` file extension.\n    FileExtensionWax,\n    /// The `wbmp` file extension.\n    FileExtensionWbmp,\n    /// The `wbs` file extension.\n    FileExtensionWbs,\n    /// The `wbxml` file extension.\n    FileExtensionWbxml,\n    /// The `wcm` file extension.\n    FileExtensionWcm,\n    /// The `wdb` file extension.\n    FileExtensionWdb,\n    /// The `wdp` file extension.\n    FileExtensionWdp,\n    /// The `weba` file extension.\n    FileExtensionWeba,\n    /// The `webm` file extension.\n    FileExtensionWebm,\n    /// The `webp` file extension.\n    FileExtensionWebp,\n    /// The `wg` file extension.\n    FileExtensionWg,\n    /// The `wgt` file extension.\n    FileExtensionWgt,\n    /// The `wks` file extension.\n    FileExtensionWks,\n    /// The `wm` file extension.\n    FileExtensionWm,\n    /// The `wma` file extension.\n    FileExtensionWma,\n    /// The `wmd` file extension.\n    FileExtensionWmd,\n    /// The `wmf` file extension.\n    FileExtensionWmf,\n    /// The `wml` file extension.\n    FileExtensionWml,\n    /// The `wmlc` file extension.\n    FileExtensionWmlc,\n    /// The `wmls` file extension.\n    FileExtensionWmls,\n    /// The `wmlsc` file extension.\n    FileExtensionWmlsc,\n    /// The `wmv` file extension.\n    FileExtensionWmv,\n    /// The `wmx` file extension.\n    FileExtensionWmx,\n    /// The `wmz` file extension.\n    FileExtensionWmz,\n    /// The `woff` file extension.\n    FileExtensionWoff,\n    /// The `woff2` file extension.\n    FileExtensionWoff2,\n    /// The `wpd` file extension.\n    FileExtensionWpd,\n    /// The `wpl` file extension.\n    FileExtensionWpl,\n    /// The `wps` file extension.\n    FileExtensionWps,\n    /// The `wqd` file extension.\n    FileExtensionWqd,\n    /// The `wri` file extension.\n    FileExtensionWri,\n    /// The `wrl` file extension.\n    FileExtensionWrl,\n    /// The `wsdl` file extension.\n    FileExtensionWsdl,\n    /// The `wspolicy` file extension.\n    FileExtensionWspolicy,\n    /// The `wtb` file extension.\n    FileExtensionWtb,\n    /// The `wvx` file extension.\n    FileExtensionWvx,\n    /// The `x32` file extension.\n    FileExtensionX32,\n    /// The `x3d` file extension.\n    FileExtensionX3d,\n    /// The `x3db` file extension.\n    FileExtensionX3db,\n    /// The `x3dbz` file extension.\n    FileExtensionX3dbz,\n    /// The `x3dv` file extension.\n    FileExtensionX3dv,\n    /// The `x3dvz` file extension.\n    FileExtensionX3dvz,\n    /// The `x3dz` file extension.\n    FileExtensionX3dz,\n    /// The `xaml` file extension.\n    FileExtensionXaml,\n    /// The `xap` file extension.\n    FileExtensionXap,\n    /// The `xar` file extension.\n    FileExtensionXar,\n    /// The `xbap` file extension.\n    FileExtensionXbap,\n    /// The `xbd` file extension.\n    FileExtensionXbd,\n    /// The `xbm` file extension.\n    FileExtensionXbm,\n    /// The `xdf` file extension.\n    FileExtensionXdf,\n    /// The `xdm` file extension.\n    FileExtensionXdm,\n    /// The `xdp` file extension.\n    FileExtensionXdp,\n    /// The `xdssc` file extension.\n    FileExtensionXdssc,\n    /// The `xdw` file extension.\n    FileExtensionXdw,\n    /// The `xenc` file extension.\n    FileExtensionXenc,\n    /// The `xer` file extension.\n    FileExtensionXer,\n    /// The `xfdf` file extension.\n    FileExtensionXfdf,\n    /// The `xfdl` file extension.\n    FileExtensionXfdl,\n    /// The `xht` file extension.\n    FileExtensionXht,\n    /// The `xhtml` file extension.\n    FileExtensionXhtml,\n    /// The `xhvml` file extension.\n    FileExtensionXhvml,\n    /// The `xif` file extension.\n    FileExtensionXif,\n    /// The `xla` file extension.\n    FileExtensionXla,\n    /// The `xlam` file extension.\n    FileExtensionXlam,\n    /// The `xlc` file extension.\n    FileExtensionXlc,\n    /// The `xlf` file extension.\n    FileExtensionXlf,\n    /// The `xlm` file extension.\n    FileExtensionXlm,\n    /// The `xls` file extension.\n    FileExtensionXls,\n    /// The `xlsb` file extension.\n    FileExtensionXlsb,\n    /// The `xlsm` file extension.\n    FileExtensionXlsm,\n    /// The `xlsx` file extension.\n    FileExtensionXlsx,\n    /// The `xlt` file extension.\n    FileExtensionXlt,\n    /// The `xltm` file extension.\n    FileExtensionXltm,\n    /// The `xltx` file extension.\n    FileExtensionXltx,\n    /// The `xlw` file extension.\n    FileExtensionXlw,\n    /// The `xm` file extension.\n    FileExtensionXm,\n    /// The `xml` file extension.\n    FileExtensionXml,\n    /// The `xo` file extension.\n    FileExtensionXo,\n    /// The `xop` file extension.\n    FileExtensionXop,\n    /// The `xpi` file extension.\n    FileExtensionXpi,\n    /// The `xpl` file extension.\n    FileExtensionXpl,\n    /// The `xpm` file extension.\n    FileExtensionXpm,\n    /// The `xpr` file extension.\n    FileExtensionXpr,\n    /// The `xps` file extension.\n    FileExtensionXps,\n    /// The `xpw` file extension.\n    FileExtensionXpw,\n    /// The `xpx` file extension.\n    FileExtensionXpx,\n    /// The `xsl` file extension.\n    FileExtensionXsl,\n    /// The `xslt` file extension.\n    FileExtensionXslt,\n    /// The `xsm` file extension.\n    FileExtensionXsm,\n    /// The `xspf` file extension.\n    FileExtensionXspf,\n    /// The `xul` file extension.\n    FileExtensionXul,\n    /// The `xvm` file extension.\n    FileExtensionXvm,\n    /// The `xvml` file extension.\n    FileExtensionXvml,\n    /// The `xwd` file extension.\n    FileExtensionXwd,\n    /// The `xyz` file extension.\n    FileExtensionXyz,\n    /// The `xz` file extension.\n    FileExtensionXz,\n    /// The `yang` file extension.\n    FileExtensionYang,\n    /// The `yin` file extension.\n    FileExtensionYin,\n    /// The `z` file extension.\n    FileExtensionZ,\n    /// The `z1` file extension.\n    FileExtensionZ1,\n    /// The `z2` file extension.\n    FileExtensionZ2,\n    /// The `z3` file extension.\n    FileExtensionZ3,\n    /// The `z4` file extension.\n    FileExtensionZ4,\n    /// The `z5` file extension.\n    FileExtensionZ5,\n    /// The `z6` file extension.\n    FileExtensionZ6,\n    /// The `z7` file extension.\n    FileExtensionZ7,\n    /// The `z8` file extension.\n    FileExtensionZ8,\n    /// The `zaz` file extension.\n    FileExtensionZaz,\n    /// The `zip` file extension.\n    FileExtensionZip,\n    /// The `zir` file extension.\n    FileExtensionZir,\n    /// The `zirz` file extension.\n    FileExtensionZirz,\n    /// The `zmm` file extension.\n    FileExtensionZmm,\n    /// An empty or unknown file extension.\n    FileExtensionEmpty,\n}", "file_size": 60985, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\cookie\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the raw cookie string from an HTTP request header.\n///\n/// Contains the complete cookie header value as received from the client.\npub type CookieString = String;\n/// Represents the key/name of an HTTP cookie.\n///\n/// Used to identify individual cookies in requests and responses.\npub type CookieKey = String;\n/// Represents the value/content of an HTTP cookie.\n///\n/// Stores the actual data associated with a cookie name/key.\npub type CookieValue = String;\n/// Represents an optional cookie value.\n///\n/// Used when a cookie value may or may not be present.\npub type OptionCookiesValue = Option<CookieValue>;\n/// Represents an optional cookie expiration date.\n///\n/// Stores the RFC 1123 formatted date string when present.\npub type OptionCookieExpires = Option<String>;\n/// Represents an optional cookie maximum age in seconds.\n///\n/// Specifies the lifetime of the cookie in seconds when present.\npub type OptionCookieMaxAge = Option<i64>;\n/// Represents an optional cookie domain scope.\n///\n/// Specifies which hosts can receive the cookie when present.\npub type OptionCookieDomain = Option<String>;\n/// Represents an optional cookie path scope.\n///\n/// Specifies URL path that must exist in the requested URL when present.\npub type OptionCookiePath = Option<String>;\n/// Represents an optional cookie SameSite policy.\n///\n/// Specifies if/how cookies should be restricted to first-party sites when present.\n/// Possible values: \"Strict\", \"Lax\", or \"None\".\npub type OptionCookieSameSite = Option<String>;\n/// Represents a collection of HTTP cookies.\n///\n/// Stores multiple cookies as key-value pairs using a high-performance hash map.\npub type Cookies = HashMapXxHash3_64<CookieKey, CookieValue>;", "file_size": 1731, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\cookie\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#struct::*;\npub use r#type::*;", "file_size": 131, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\box_rwlock\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new boxed read-write lock.\n///\n/// # Arguments\n///\n/// - `T` - The data type to be wrapped.\n///\n/// # Returns\n///\n/// - `BoxRwLock<T>` - A new boxed read-write lock.\npub fn box_rwlock<T>(data: T) -> BoxRwLock<T> {\n    Box::new(RwLock::new(data))\n}", "file_size": 276, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\file_extension\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default value for `FileExtension`.\n///\n/// The default `FileExtension` is `FileExtensionEmpty`.\nimpl Default for FileExtension {\n    fn default() -> Self {\n        Self::FileExtensionEmpty\n    }\n}\n\nimpl FileExtension {\n    /// Parses a string into a `FileExtension`.\n    ///\n    /// # Arguments\n    ///\n    /// - `file_extension` - The string to parse.\n    ///\n    /// # Returns\n    ///\n    /// The parsed `FileExtension`.\n    pub fn parse(file_extension: &str) -> Self {\n        file_extension.parse::<Self>().unwrap_or_default()\n    }\n\n    /// Gets the extension name from a full path.\n    ///\n    /// # Arguments\n    ///\n    /// - `full_path` - The full path to the file.\n    ///\n    /// # Returns\n    ///\n    /// The extension name.\n    pub fn get_extension_name(full_path: &str) -> String {\n        full_path\n            .rfind(POINT)\n            .map(|pos| full_path[pos + 1..].to_string())\n            .unwrap_or_default()\n    }\n\n    /// Gets the content type for the file extension.\n    ///\n    /// # Returns\n    ///\n    /// The content type as a string slice.\n    pub fn get_content_type(&self) -> &'static str {\n        match self {\n            Self::FileExtension123 => APPLICATION_VND_LOTUS_1_2_3,\n            Self::FileExtension3dml => TEXT_VND_IN3D_3DML,\n            Self::FileExtension3ds => IMAGE_X_3DS,\n            Self::FileExtension3g2 => VIDEO_3GPP2,\n            Self::FileExtension3gp => VIDEO_3GPP,\n            Self::FileExtension7z => APPLICATION_X_7Z_COMPRESSED,\n            Self::FileExtensionAab => APPLICATION_X_AUTHORWARE_BIN,\n            Self::FileExtensionAac => AUDIO_X_AAC,\n            Self::FileExtensionAam => APPLICATION_X_AUTHORWARE_MAP,\n            Self::FileExtensionAas => APPLICATION_X_AUTHORWARE_SEG,\n            Self::FileExtensionAbs => AUDIO_X_MPEG,\n            Self::FileExtensionAbw => APPLICATION_X_ABIWORD,\n            Self::FileExtensionAc => APPLICATION_PKIX_ATTR_CERT,\n            Self::FileExtensionAcc => APPLICATION_VND_AMERICANDYNAMICS_ACC,\n            Self::FileExtensionAce => APPLICATION_X_ACE_COMPRESSED,\n            Self::FileExtensionAcu => APPLICATION_VND_ACUCOBOL,\n            Self::FileExtensionAcutc => APPLICATION_VND_ACUCORP,\n            Self::FileExtensionAdp => AUDIO_ADPCM,\n            Self::FileExtensionAep => APPLICATION_VND_AUDIOGRAPH,\n            Self::FileExtensionAfm => APPLICATION_X_FONT_TYPE1,\n            Self::FileExtensionAfp => APPLICATION_VND_IBM_MODCAP,\n            Self::FileExtensionAhead => APPLICATION_VND_AHEAD_SPACE,\n            Self::FileExtensionAi => APPLICATION_POSTSCRIPT,\n            Self::FileExtensionAif => AUDIO_X_AIFF,\n            Self::FileExtensionAifc => AUDIO_X_AIFF,\n            Self::FileExtensionAiff => AUDIO_X_AIFF,\n            Self::FileExtensionAim => APPLICATION_X_AIM,\n            Self::FileExtensionAir => APPLICATION_VND_ADOBE_AIR_APPLICATION_INSTALLER_PACKAGE_ZIP,\n            Self::FileExtensionAit => APPLICATION_VND_DVB_AIT,\n            Self::FileExtensionAmi => APPLICATION_VND_AMIGA_AMI,\n            Self::FileExtensionAnx => APPLICATION_ANNODEX,\n            Self::FileExtensionApk => APPLICATION_VND_ANDROID_PACKAGE_ARCHIVE,\n            Self::FileExtensionAppcache => TEXT_CACHE_MANIFEST,\n            Self::FileExtensionApplication => APPLICATION_X_MS_APPLICATION,\n            Self::FileExtensionApr => APPLICATION_VND_LOTUS_APPROACH,\n            Self::FileExtensionArc => APPLICATION_X_FREEARC,\n            Self::FileExtensionArt => IMAGE_X_JG,\n            Self::FileExtensionAsc => APPLICATION_PGP_SIGNATURE,\n            Self::FileExtensionAsf => VIDEO_X_MS_ASF,\n            Self::FileExtensionAsm => TEXT_X_ASM,\n            Self::FileExtensionAso => APPLICATION_VND_ACCPAC_SIMPLY_ASO,\n            Self::FileExtensionAsx => VIDEO_X_MS_ASF,\n            Self::FileExtensionAtc => APPLICATION_VND_ACUCORP,\n            Self::FileExtensionAtom => APPLICATION_ATOM_XML,\n            Self::FileExtensionAtomcat => APPLICATION_ATOMCAT_XML,\n            Self::FileExtensionAtomsvc => APPLICATION_ATOMSVC_XML,\n            Self::FileExtensionAtx => APPLICATION_VND_ANTIX_GAME_COMPONENT,\n            Self::FileExtensionAu => AUDIO_BASIC,\n            Self::FileExtensionAvi => VIDEO_X_MSVIDEO,\n            Self::FileExtensionAvx => VIDEO_X_RAD_SCREENPLAY,\n            Self::FileExtensionAw => APPLICATION_APPLIXWARE,\n            Self::FileExtensionAxa => AUDIO_ANNODEX,\n            Self::FileExtensionAxv => VIDEO_ANNODEX,\n            Self::FileExtensionAzf => APPLICATION_VND_AIRZIP_FILESECURE_AZF,\n            Self::FileExtensionAzs => APPLICATION_VND_AIRZIP_FILESECURE_AZS,\n            Self::FileExtensionAzw => APPLICATION_VND_AMAZON_EBOOK,\n            Self::FileExtensionBat => APPLICATION_X_MSDOWNLOAD,\n            Self::FileExtensionBcpio => APPLICATION_X_BCPIO,\n            Self::FileExtensionBdf => APPLICATION_X_FONT_BDF,\n            Self::FileExtensionBdm => APPLICATION_VND_SYNCML_DM_WBXML,\n            Self::FileExtensionBed => APPLICATION_VND_REALVNC_BED,\n            Self::FileExtensionBh2 => APPLICATION_VND_FUJITSU_OASYSPRS,\n            Self::FileExtensionBin => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionBlb => APPLICATION_X_BLORB,\n            Self::FileExtensionBlorb => APPLICATION_X_BLORB,\n            Self::FileExtensionBmi => APPLICATION_VND_BMI,\n            Self::FileExtensionBmp => IMAGE_BMP,\n            Self::FileExtensionBody => TEXT_HTML,\n            Self::FileExtensionBook => APPLICATION_VND_FRAMEMAKER,\n            Self::FileExtensionBox => APPLICATION_VND_PREVIEWSYSTEMS_BOX,\n            Self::FileExtensionBoz => APPLICATION_X_BZIP2,\n            Self::FileExtensionBpk => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionBtif => IMAGE_PRS_BTIF,\n            Self::FileExtensionBz => APPLICATION_X_BZIP,\n            Self::FileExtensionBz2 => APPLICATION_X_BZIP2,\n            Self::FileExtensionC => TEXT_X_C,\n            Self::FileExtensionC11amc => APPLICATION_VND_CLUETRUST_CARTOMOBILE_CONFIG,\n            Self::FileExtensionC11amz => APPLICATION_VND_CLUETRUST_CARTOMOBILE_CONFIG_PKG,\n            Self::FileExtensionC4d => APPLICATION_VND_CLONK_C4GROUP,\n            Self::FileExtensionC4f => APPLICATION_VND_CLONK_C4GROUP,\n            Self::FileExtensionC4g => APPLICATION_VND_CLONK_C4GROUP,\n            Self::FileExtensionC4p => APPLICATION_VND_CLONK_C4GROUP,\n            Self::FileExtensionC4u => APPLICATION_VND_CLONK_C4GROUP,\n            Self::FileExtensionCab => APPLICATION_VND_MS_CAB_COMPRESSED,\n            Self::FileExtensionCaf => AUDIO_X_CAF,\n            Self::FileExtensionCap => APPLICATION_VND_TCPDUMP_PCAP,\n            Self::FileExtensionCar => APPLICATION_VND_CURL_CAR,\n            Self::FileExtensionCat => APPLICATION_VND_MS_PKI_SECCAT,\n            Self::FileExtensionCb7 => APPLICATION_X_CBR,\n            Self::FileExtensionCba => APPLICATION_X_CBR,\n            Self::FileExtensionCbr => APPLICATION_X_CBR,\n            Self::FileExtensionCbt => APPLICATION_X_CBR,\n            Self::FileExtensionCbz => APPLICATION_X_CBR,\n            Self::FileExtensionCc => TEXT_X_C,\n            Self::FileExtensionCct => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionCcxml => APPLICATION_CCXML_XML,\n            Self::FileExtensionCdbcmsg => APPLICATION_VND_CONTACT_CMSG,\n            Self::FileExtensionCdf => APPLICATION_X_CDF,\n            Self::FileExtensionCdkey => APPLICATION_VND_MEDIASTATION_CDKEY,\n            Self::FileExtensionCdmia => APPLICATION_CDMI_CAPABILITY,\n            Self::FileExtensionCdmic => APPLICATION_CDMI_CONTAINER,\n            Self::FileExtensionCdmid => APPLICATION_CDMI_DOMAIN,\n            Self::FileExtensionCdmio => APPLICATION_CDMI_OBJECT,\n            Self::FileExtensionCdmiq => APPLICATION_CDMI_QUEUE,\n            Self::FileExtensionCdx => CHEMICAL_X_CDX,\n            Self::FileExtensionCdxml => APPLICATION_VND_CHEMDRAW_XML,\n            Self::FileExtensionCdy => APPLICATION_VND_CINDERELLA,\n            Self::FileExtensionCer => APPLICATION_PKIX_CERT,\n            Self::FileExtensionCfs => APPLICATION_X_CFS_COMPRESSED,\n            Self::FileExtensionCgm => IMAGE_CGM,\n            Self::FileExtensionChat => APPLICATION_X_CHAT,\n            Self::FileExtensionChm => APPLICATION_VND_MS_HTMLHELP,\n            Self::FileExtensionChrt => APPLICATION_VND_KDE_KCHART,\n            Self::FileExtensionCif => CHEMICAL_X_CIF,\n            Self::FileExtensionCii => APPLICATION_VND_ANSER_WEB_CERTIFICATE_ISSUE_INITIATION,\n            Self::FileExtensionCil => APPLICATION_VND_MS_ARTGALRY,\n            Self::FileExtensionCla => APPLICATION_VND_CLAYMORE,\n            Self::FileExtensionClass => APPLICATION_JAVA,\n            Self::FileExtensionClkk => APPLICATION_VND_CRICK_CLICKER_KEYBOARD,\n            Self::FileExtensionClkp => APPLICATION_VND_CRICK_CLICKER_PALETTE,\n            Self::FileExtensionClkt => APPLICATION_VND_CRICK_CLICKER_TEMPLATE,\n            Self::FileExtensionClkw => APPLICATION_VND_CRICK_CLICKER_WORDBANK,\n            Self::FileExtensionClkx => APPLICATION_VND_CRICK_CLICKER,\n            Self::FileExtensionClp => APPLICATION_X_MSCLIP,\n            Self::FileExtensionCmc => APPLICATION_VND_COSMOCALLER,\n            Self::FileExtensionCmdf => CHEMICAL_X_CMDF,\n            Self::FileExtensionCml => CHEMICAL_X_CML,\n            Self::FileExtensionCmp => APPLICATION_VND_YELLOWRIVER_CUSTOM_MENU,\n            Self::FileExtensionCmx => IMAGE_X_CMX,\n            Self::FileExtensionCod => APPLICATION_VND_RIM_COD,\n            Self::FileExtensionCom => APPLICATION_X_MSDOWNLOAD,\n            Self::FileExtensionConf => TEXT_PLAIN,\n            Self::FileExtensionCpio => APPLICATION_X_CPIO,\n            Self::FileExtensionCpp => TEXT_X_C,\n            Self::FileExtensionCpt => APPLICATION_MAC_COMPACTPRO,\n            Self::FileExtensionCrd => APPLICATION_X_MSCARDFILE,\n            Self::FileExtensionCrl => APPLICATION_PKIX_CRL,\n            Self::FileExtensionCrt => APPLICATION_X_X509_CA_CERT,\n            Self::FileExtensionCryptonote => APPLICATION_VND_RIG_CRYPTONOTE,\n            Self::FileExtensionCsh => APPLICATION_X_CSH,\n            Self::FileExtensionCsml => CHEMICAL_X_CSML,\n            Self::FileExtensionCsp => APPLICATION_VND_COMMONSPACE,\n            Self::FileExtensionCss => TEXT_CSS,\n            Self::FileExtensionCst => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionCsv => TEXT_CSV,\n            Self::FileExtensionCu => APPLICATION_CU_SEEME,\n            Self::FileExtensionCurl => TEXT_VND_CURL,\n            Self::FileExtensionCww => APPLICATION_PRS_CWW,\n            Self::FileExtensionCxt => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionCxx => TEXT_X_C,\n            Self::FileExtensionDae => MODEL_VND_COLLADA_XML,\n            Self::FileExtensionDaf => APPLICATION_VND_MOBIUS_DAF,\n            Self::FileExtensionDart => APPLICATION_VND_DART,\n            Self::FileExtensionDataless => APPLICATION_VND_FDSN_SEED,\n            Self::FileExtensionDavmount => APPLICATION_DAVMOUNT_XML,\n            Self::FileExtensionDbk => APPLICATION_DOCBOOK_XML,\n            Self::FileExtensionDcr => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionDcurl => TEXT_VND_CURL_DCURL,\n            Self::FileExtensionDd2 => APPLICATION_VND_OMA_DD2_XML,\n            Self::FileExtensionDdd => APPLICATION_VND_FUJIXEROX_DDD,\n            Self::FileExtensionDeb => APPLICATION_X_DEBIAN_PACKAGE,\n            Self::FileExtensionDef => TEXT_PLAIN,\n            Self::FileExtensionDeploy => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionDer => APPLICATION_X_X509_CA_CERT,\n            Self::FileExtensionDfac => APPLICATION_VND_DREAMFACTORY,\n            Self::FileExtensionDgc => APPLICATION_X_DGC_COMPRESSED,\n            Self::FileExtensionDib => IMAGE_BMP,\n            Self::FileExtensionDic => TEXT_X_C,\n            Self::FileExtensionDir => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionDis => APPLICATION_VND_MOBIUS_DIS,\n            Self::FileExtensionDist => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionDistz => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionDjv => IMAGE_VND_DJVU,\n            Self::FileExtensionDjvu => IMAGE_VND_DJVU,\n            Self::FileExtensionDll => APPLICATION_X_MSDOWNLOAD,\n            Self::FileExtensionDmg => APPLICATION_X_APPLE_DISKIMAGE,\n            Self::FileExtensionDmp => APPLICATION_VND_TCPDUMP_PCAP,\n            Self::FileExtensionDms => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionDna => APPLICATION_VND_DNA,\n            Self::FileExtensionDoc => APPLICATION_MSWORD,\n            Self::FileExtensionDocm => APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12,\n            Self::FileExtensionDocx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT\n            }\n            Self::FileExtensionDot => APPLICATION_MSWORD,\n            Self::FileExtensionDotm => APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12,\n            Self::FileExtensionDotx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE\n            }\n            Self::FileExtensionDp => APPLICATION_VND_OSGI_DP,\n            Self::FileExtensionDpg => APPLICATION_VND_DPGRAPH,\n            Self::FileExtensionDra => AUDIO_VND_DRA,\n            Self::FileExtensionDsc => TEXT_PRS_LINES_TAG,\n            Self::FileExtensionDssc => APPLICATION_DSSC_DER,\n            Self::FileExtensionDtb => APPLICATION_X_DTBOOK_XML,\n            Self::FileExtensionDtd => APPLICATION_XML_DTD,\n            Self::FileExtensionDts => AUDIO_VND_DTS,\n            Self::FileExtensionDtshd => AUDIO_VND_DTS_HD,\n            Self::FileExtensionDump => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionDv => VIDEO_X_DV,\n            Self::FileExtensionDvb => VIDEO_VND_DVB_FILE,\n            Self::FileExtensionDvi => APPLICATION_X_DVI,\n            Self::FileExtensionDwf => MODEL_VND_DWF,\n            Self::FileExtensionDwg => IMAGE_VND_DWG,\n            Self::FileExtensionDxf => IMAGE_VND_DXF,\n            Self::FileExtensionDxp => APPLICATION_VND_SPOTFIRE_DXP,\n            Self::FileExtensionDxr => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionEcelp4800 => AUDIO_VND_NUERA_ECELP4800,\n            Self::FileExtensionEcelp7470 => AUDIO_VND_NUERA_ECELP7470,\n            Self::FileExtensionEcelp9600 => AUDIO_VND_NUERA_ECELP9600,\n            Self::FileExtensionEcma => APPLICATION_ECMASCRIPT,\n            Self::FileExtensionEdm => APPLICATION_VND_NOVADIGM_EDM,\n            Self::FileExtensionEdx => APPLICATION_VND_NOVADIGM_EDX,\n            Self::FileExtensionEfif => APPLICATION_VND_PICSEL,\n            Self::FileExtensionEi6 => APPLICATION_VND_PG_OSASLI,\n            Self::FileExtensionElc => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionEmf => APPLICATION_X_MSMETAFILE,\n            Self::FileExtensionEml => MESSAGE_RFC822,\n            Self::FileExtensionEmma => APPLICATION_EMMA_XML,\n            Self::FileExtensionEmz => APPLICATION_X_MSMETAFILE,\n            Self::FileExtensionEol => AUDIO_VND_DIGITAL_WINDS,\n            Self::FileExtensionEot => APPLICATION_VND_MS_FONTOBJECT,\n            Self::FileExtensionEps => APPLICATION_POSTSCRIPT,\n            Self::FileExtensionEpub => APPLICATION_EPUB_ZIP,\n            Self::FileExtensionEs3 => APPLICATION_VND_ESZIGNO3_XML,\n            Self::FileExtensionEsa => APPLICATION_VND_OSGI_SUBSYSTEM,\n            Self::FileExtensionEsf => APPLICATION_VND_EPSON_ESF,\n            Self::FileExtensionEt3 => APPLICATION_VND_ESZIGNO3_XML,\n            Self::FileExtensionEtx => TEXT_X_SETEXT,\n            Self::FileExtensionEva => APPLICATION_X_EVA,\n            Self::FileExtensionEvy => APPLICATION_X_ENVOY,\n            Self::FileExtensionExe => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionExi => APPLICATION_EXI,\n            Self::FileExtensionExt => APPLICATION_VND_NOVADIGM_EXT,\n            Self::FileExtensionEz => APPLICATION_ANDREW_INSET,\n            Self::FileExtensionEz2 => APPLICATION_VND_EZPIX_ALBUM,\n            Self::FileExtensionEz3 => APPLICATION_VND_EZPIX_PACKAGE,\n            Self::FileExtensionF => TEXT_X_FORTRAN,\n            Self::FileExtensionF4v => VIDEO_X_F4V,\n            Self::FileExtensionF77 => TEXT_X_FORTRAN,\n            Self::FileExtensionF90 => TEXT_X_FORTRAN,\n            Self::FileExtensionFbs => IMAGE_VND_FASTBIDSHEET,\n            Self::FileExtensionFcdt => APPLICATION_VND_ADOBE_FORMSCENTRAL_FCDT,\n            Self::FileExtensionFcs => APPLICATION_VND_ISAC_FCS,\n            Self::FileExtensionFdf => APPLICATION_VND_FDF,\n            Self::FileExtensionFeLaunch => APPLICATION_VND_DENOVO_FCSELAYOUT_LINK,\n            Self::FileExtensionFg5 => APPLICATION_VND_FUJITSU_OASYSGP,\n            Self::FileExtensionFgd => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionFh => IMAGE_X_FREEHAND,\n            Self::FileExtensionFh4 => IMAGE_X_FREEHAND,\n            Self::FileExtensionFh5 => IMAGE_X_FREEHAND,\n            Self::FileExtensionFh7 => IMAGE_X_FREEHAND,\n            Self::FileExtensionFhc => IMAGE_X_FREEHAND,\n            Self::FileExtensionFig => APPLICATION_X_XFIG,\n            Self::FileExtensionFlac => AUDIO_FLAC,\n            Self::FileExtensionFli => VIDEO_X_FLI,\n            Self::FileExtensionFlo => APPLICATION_VND_MICROGRAFX_FLO,\n            Self::FileExtensionFlv => VIDEO_X_FLV,\n            Self::FileExtensionFlw => APPLICATION_VND_KDE_KIVIO,\n            Self::FileExtensionFlx => TEXT_VND_FMI_FLEXSTOR,\n            Self::FileExtensionFly => TEXT_VND_FLY,\n            Self::FileExtensionFm => APPLICATION_VND_FRAMEMAKER,\n            Self::FileExtensionFnc => APPLICATION_VND_FROGANS_FNC,\n            Self::FileExtensionFor => TEXT_X_FORTRAN,\n            Self::FileExtensionFpx => IMAGE_VND_FPX,\n            Self::FileExtensionFrame => APPLICATION_VND_FRAMEMAKER,\n            Self::FileExtensionFsc => APPLICATION_VND_FSC_WEBLAUNCH,\n            Self::FileExtensionFst => IMAGE_VND_FST,\n            Self::FileExtensionFtc => APPLICATION_VND_FLUXTIME_CLIP,\n            Self::FileExtensionFti => APPLICATION_VND_ANSER_WEB_FUNDS_TRANSFER_INITIATION,\n            Self::FileExtensionFvt => VIDEO_VND_FVT,\n            Self::FileExtensionFxp => APPLICATION_VND_ADOBE_FXP,\n            Self::FileExtensionFxpl => APPLICATION_VND_ADOBE_FXP,\n            Self::FileExtensionFzs => APPLICATION_VND_FUZZYSHEET,\n            Self::FileExtensionG2w => APPLICATION_VND_GEOPLAN,\n            Self::FileExtensionG3 => IMAGE_G3FAX,\n            Self::FileExtensionG3w => APPLICATION_VND_GEOSPACE,\n            Self::FileExtensionGac => APPLICATION_VND_GROOVE_ACCOUNT,\n            Self::FileExtensionGam => APPLICATION_X_TADS,\n            Self::FileExtensionGbr => APPLICATION_RPKI_GHOSTBUSTERS,\n            Self::FileExtensionGca => APPLICATION_X_GCA_COMPRESSED,\n            Self::FileExtensionGdl => MODEL_VND_GDL,\n            Self::FileExtensionGeo => APPLICATION_VND_DYNAGEO,\n            Self::FileExtensionGex => APPLICATION_VND_GEOMETRY_EXPLORER,\n            Self::FileExtensionGgb => APPLICATION_VND_GEOGEBRA_FILE,\n            Self::FileExtensionGgt => APPLICATION_VND_GEOGEBRA_TOOL,\n            Self::FileExtensionGhf => APPLICATION_VND_GROOVE_HELP,\n            Self::FileExtensionGif => IMAGE_GIF,\n            Self::FileExtensionGim => APPLICATION_VND_GROOVE_IDENTITY_MESSAGE,\n            Self::FileExtensionGml => APPLICATION_GML_XML,\n            Self::FileExtensionGmx => APPLICATION_VND_GMX,\n            Self::FileExtensionGnumeric => APPLICATION_X_GNUMERIC,\n            Self::FileExtensionGph => APPLICATION_VND_FLOGRAPHIT,\n            Self::FileExtensionGpx => APPLICATION_GPX_XML,\n            Self::FileExtensionGqf => APPLICATION_VND_GRAFEQ,\n            Self::FileExtensionGqs => APPLICATION_VND_GRAFEQ,\n            Self::FileExtensionGram => APPLICATION_SRGS,\n            Self::FileExtensionGramps => APPLICATION_X_GRAMPS_XML,\n            Self::FileExtensionGre => APPLICATION_VND_GEOMETRY_EXPLORER,\n            Self::FileExtensionGrv => APPLICATION_VND_GROOVE_INJECTOR,\n            Self::FileExtensionGrxml => APPLICATION_SRGS_XML,\n            Self::FileExtensionGsf => APPLICATION_X_FONT_GHOSTSCRIPT,\n            Self::FileExtensionGtar => APPLICATION_X_GTAR,\n            Self::FileExtensionGtm => APPLICATION_VND_GROOVE_TOOL_MESSAGE,\n            Self::FileExtensionGtw => MODEL_VND_GTW,\n            Self::FileExtensionGv => TEXT_VND_GRAPHVIZ,\n            Self::FileExtensionGxf => APPLICATION_GXF,\n            Self::FileExtensionGxt => APPLICATION_VND_GEONEXT,\n            Self::FileExtensionGz => APPLICATION_X_GZIP,\n            Self::FileExtensionH => TEXT_X_C,\n            Self::FileExtensionH261 => VIDEO_H261,\n            Self::FileExtensionH263 => VIDEO_H263,\n            Self::FileExtensionH264 => VIDEO_H264,\n            Self::FileExtensionHal => APPLICATION_VND_HAL_XML,\n            Self::FileExtensionHbci => APPLICATION_VND_HBCI,\n            Self::FileExtensionHdf => APPLICATION_X_HDF,\n            Self::FileExtensionHh => TEXT_X_C,\n            Self::FileExtensionHlp => APPLICATION_WINHLP,\n            Self::FileExtensionHpgl => APPLICATION_VND_HP_HPGL,\n            Self::FileExtensionHpid => APPLICATION_VND_HP_HPID,\n            Self::FileExtensionHps => APPLICATION_VND_HP_HPS,\n            Self::FileExtensionHqx => APPLICATION_MAC_BINHEX40,\n            Self::FileExtensionHtc => TEXT_X_COMPONENT,\n            Self::FileExtensionHtke => APPLICATION_VND_KENAMEAAPP,\n            Self::FileExtensionHtm => TEXT_HTML,\n            Self::FileExtensionHtml => TEXT_HTML,\n            Self::FileExtensionHvd => APPLICATION_VND_YAMAHA_HV_DIC,\n            Self::FileExtensionHvp => APPLICATION_VND_YAMAHA_HV_VOICE,\n            Self::FileExtensionHvs => APPLICATION_VND_YAMAHA_HV_SCRIPT,\n            Self::FileExtensionI2g => APPLICATION_VND_INTERGEO,\n            Self::FileExtensionIcc => APPLICATION_VND_ICCPROFILE,\n            Self::FileExtensionIce => X_CONFERENCE_X_COOLTALK,\n            Self::FileExtensionIcm => APPLICATION_VND_ICCPROFILE,\n            Self::FileExtensionIco => IMAGE_X_ICON,\n            Self::FileExtensionIcs => TEXT_CALENDAR,\n            Self::FileExtensionIef => IMAGE_IEF,\n            Self::FileExtensionIfb => TEXT_CALENDAR,\n            Self::FileExtensionIfm => APPLICATION_VND_SHANA_INFORMED_FORMDATA,\n            Self::FileExtensionIges => MODEL_IGES,\n            Self::FileExtensionIgl => APPLICATION_VND_IGLOADER,\n            Self::FileExtensionIgm => APPLICATION_VND_INSORS_IGM,\n            Self::FileExtensionIgs => MODEL_IGES,\n            Self::FileExtensionIgx => APPLICATION_VND_MICROGRAFX_IGX,\n            Self::FileExtensionIif => APPLICATION_VND_SHANA_INFORMED_INTERCHANGE,\n            Self::FileExtensionImp => APPLICATION_VND_ACCPAC_SIMPLY_IMP,\n            Self::FileExtensionIms => APPLICATION_VND_MS_IMS,\n            Self::FileExtensionIn => TEXT_PLAIN,\n            Self::FileExtensionInk => APPLICATION_INKML_XML,\n            Self::FileExtensionInkml => APPLICATION_INKML_XML,\n            Self::FileExtensionInstall => APPLICATION_X_INSTALL_INSTRUCTIONS,\n            Self::FileExtensionIota => APPLICATION_VND_ASTRAEA_SOFTWARE_IOTA,\n            Self::FileExtensionIpfix => APPLICATION_IPFIX,\n            Self::FileExtensionIpk => APPLICATION_VND_SHANA_INFORMED_PACKAGE,\n            Self::FileExtensionIrm => APPLICATION_VND_IBM_RIGHTS_MANAGEMENT,\n            Self::FileExtensionIrp => APPLICATION_VND_IREPOSITORY_PACKAGE_XML,\n            Self::FileExtensionIso => APPLICATION_X_ISO9660_IMAGE,\n            Self::FileExtensionItp => APPLICATION_VND_SHANA_INFORMED_FORMTEMPLATE,\n            Self::FileExtensionIvp => APPLICATION_VND_IMMERVISION_IVP,\n            Self::FileExtensionIvu => APPLICATION_VND_IMMERVISION_IVU,\n            Self::FileExtensionJad => TEXT_VND_SUN_J2ME_APP_DESCRIPTOR,\n            Self::FileExtensionJam => APPLICATION_VND_JAM,\n            Self::FileExtensionJar => APPLICATION_JAVA_ARCHIVE,\n            Self::FileExtensionJava => TEXT_X_JAVA_SOURCE,\n            Self::FileExtensionJisp => APPLICATION_VND_JISP,\n            Self::FileExtensionJlt => APPLICATION_VND_HP_JLYT,\n            Self::FileExtensionJnlp => APPLICATION_X_JAVA_JNLP_FILE,\n            Self::FileExtensionJoda => APPLICATION_VND_JOOST_JODA_ARCHIVE,\n            Self::FileExtensionJpe => IMAGE_JPEG,\n            Self::FileExtensionJpeg => IMAGE_JPEG,\n            Self::FileExtensionJpg => IMAGE_JPEG,\n            Self::FileExtensionJpgm => VIDEO_JPM,\n            Self::FileExtensionJpgv => VIDEO_JPEG,\n            Self::FileExtensionJpm => VIDEO_JPM,\n            Self::FileExtensionJs => APPLICATION_JAVASCRIPT,\n            Self::FileExtensionJsf => TEXT_PLAIN,\n            Self::FileExtensionJson => APPLICATION_JSON,\n            Self::FileExtensionJsonml => APPLICATION_JSONML_JSON,\n            Self::FileExtensionJspf => TEXT_PLAIN,\n            Self::FileExtensionKar => AUDIO_MIDI,\n            Self::FileExtensionKarbon => APPLICATION_VND_KDE_KARBON,\n            Self::FileExtensionKfo => APPLICATION_VND_KDE_KFORMULA,\n            Self::FileExtensionKia => APPLICATION_VND_KIDSPIRATION,\n            Self::FileExtensionKml => APPLICATION_VND_GOOGLE_EARTH_KML_XML,\n            Self::FileExtensionKmz => APPLICATION_VND_GOOGLE_EARTH_KMZ,\n            Self::FileExtensionKne => APPLICATION_VND_KINAR,\n            Self::FileExtensionKnp => APPLICATION_VND_KINAR,\n            Self::FileExtensionKon => APPLICATION_VND_KDE_KONTOUR,\n            Self::FileExtensionKpr => APPLICATION_VND_KDE_KPRESENTER,\n            Self::FileExtensionKpt => APPLICATION_VND_KDE_KPRESENTER,\n            Self::FileExtensionKpxx => APPLICATION_VND_DS_KEYPOINT,\n            Self::FileExtensionKsp => APPLICATION_VND_KDE_KSPREAD,\n            Self::FileExtensionKtr => APPLICATION_VND_KAHOOTZ,\n            Self::FileExtensionKtx => IMAGE_KTX,\n            Self::FileExtensionKtz => APPLICATION_VND_KAHOOTZ,\n            Self::FileExtensionKwd => APPLICATION_VND_KDE_KWORD,\n            Self::FileExtensionKwt => APPLICATION_VND_KDE_KWORD,\n            Self::FileExtensionLasxml => APPLICATION_VND_LAS_LAS_XML,\n            Self::FileExtensionLatex => APPLICATION_X_LATEX,\n            Self::FileExtensionLbd => APPLICATION_VND_LLAMAGRAPHICS_LIFE_BALANCE_DESKTOP,\n            Self::FileExtensionLbe => APPLICATION_VND_LLAMAGRAPHICS_LIFE_BALANCE_EXCHANGE_XML,\n            Self::FileExtensionLes => APPLICATION_VND_HHE_LESSON_PLAYER,\n            Self::FileExtensionLha => APPLICATION_X_LZH_COMPRESSED,\n            Self::FileExtensionLink66 => APPLICATION_VND_ROUTE66_LINK66_XML,\n            Self::FileExtensionList => TEXT_PLAIN,\n            Self::FileExtensionList3820 => APPLICATION_VND_IBM_MODCAP,\n            Self::FileExtensionListafp => APPLICATION_VND_IBM_MODCAP,\n            Self::FileExtensionLnk => APPLICATION_X_MS_SHORTCUT,\n            Self::FileExtensionLog => TEXT_PLAIN,\n            Self::FileExtensionLostxml => APPLICATION_LOST_XML,\n            Self::FileExtensionLrf => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionLrm => APPLICATION_VND_MS_LRM,\n            Self::FileExtensionLtf => APPLICATION_VND_FROGANS_LTF,\n            Self::FileExtensionLvp => AUDIO_VND_LUCENT_VOICE,\n            Self::FileExtensionLwp => APPLICATION_VND_LOTUS_WORDPRO,\n            Self::FileExtensionLzh => APPLICATION_X_LZH_COMPRESSED,\n            Self::FileExtensionM13 => APPLICATION_X_MSMEDIAVIEW,\n            Self::FileExtensionM14 => APPLICATION_X_MSMEDIAVIEW,\n            Self::FileExtensionM1v => VIDEO_MPEG,\n            Self::FileExtensionM21 => APPLICATION_MP21,\n            Self::FileExtensionM2a => AUDIO_MPEG,\n            Self::FileExtensionM2v => VIDEO_MPEG,\n            Self::FileExtensionM3a => AUDIO_MPEG,\n            Self::FileExtensionM3u => AUDIO_X_MPEGURL,\n            Self::FileExtensionM3u8 => APPLICATION_VND_APPLE_MPEGURL,\n            Self::FileExtensionM4a => AUDIO_MP4,\n            Self::FileExtensionM4b => AUDIO_MP4,\n            Self::FileExtensionM4r => AUDIO_MP4,\n            Self::FileExtensionM4u => VIDEO_VND_MPEGURL,\n            Self::FileExtensionM4v => VIDEO_MP4,\n            Self::FileExtensionMarkdown => TEXT_PLAIN,\n            Self::FileExtensionToml => TEXT_PLAIN,\n            Self::FileExtensionYaml => TEXT_PLAIN,\n            Self::FileExtensionYml => TEXT_PLAIN,\n            Self::FileExtensionIni => TEXT_PLAIN,\n            Self::FileExtensionCfg => TEXT_PLAIN,\n            Self::FileExtensionPython => TEXT_PLAIN,\n            Self::FileExtensionGo => TEXT_PLAIN,\n            Self::FileExtensionTypeScript => TEXT_PLAIN,\n            Self::FileExtensionCSharp => TEXT_PLAIN,\n            Self::FileExtensionPhp => TEXT_PLAIN,\n            Self::FileExtensionRuby => TEXT_PLAIN,\n            Self::FileExtensionSwift => TEXT_PLAIN,\n            Self::FileExtensionKotlin => TEXT_PLAIN,\n            Self::FileExtensionKotlinScript => TEXT_PLAIN,\n            Self::FileExtensionScala => TEXT_PLAIN,\n            Self::FileExtensionIbmScOrScalaScript => TEXT_PLAIN,\n            Self::FileExtensionPerl => TEXT_PLAIN,\n            Self::FileExtensionPerlModule => TEXT_PLAIN,\n            Self::FileExtensionLua => TEXT_PLAIN,\n            Self::FileExtensionPowerShell => TEXT_PLAIN,\n            Self::FileExtensionCppHeader => TEXT_PLAIN,\n            Self::FileExtensionObjectiveC => TEXT_PLAIN,\n            Self::FileExtensionObjectiveCpp => TEXT_PLAIN,\n            Self::FileExtensionGroovy => TEXT_PLAIN,\n            Self::FileExtensionR => TEXT_PLAIN,\n            Self::FileExtensionScss => TEXT_PLAIN,\n            Self::FileExtensionSass => TEXT_PLAIN,\n            Self::FileExtensionLess => TEXT_PLAIN,\n            Self::FileExtensionVue => TEXT_PLAIN,\n            Self::FileExtensionJsx => TEXT_PLAIN,\n            Self::FileExtensionTsx => TEXT_PLAIN,\n            Self::FileExtensionDockerfile => TEXT_PLAIN,\n            Self::FileExtensionMakefile => TEXT_PLAIN,\n            Self::FileExtensionRs => TEXT_PLAIN,\n            Self::FileExtensionHaskell => TEXT_PLAIN,\n            Self::FileExtensionErlang => TEXT_PLAIN,\n            Self::FileExtensionElixir => TEXT_PLAIN,\n            Self::FileExtensionElixirScript => TEXT_PLAIN,\n            Self::FileExtensionClojure => TEXT_PLAIN,\n            Self::FileExtensionClojureScript => TEXT_PLAIN,\n            Self::FileExtensionClojureCommon => TEXT_PLAIN,\n            Self::FileExtensionFSharp => TEXT_PLAIN,\n            Self::FileExtensionFSharpScript => TEXT_PLAIN,\n            Self::FileExtensionOCaml => TEXT_PLAIN,\n            Self::FileExtensionOCamlInterface => TEXT_PLAIN,\n            Self::FileExtensionBash => TEXT_PLAIN,\n            Self::FileExtensionZsh => TEXT_PLAIN,\n            Self::FileExtensionEnv => TEXT_PLAIN,\n            Self::FileExtensionCj => TEXT_PLAIN,\n            Self::FileExtensionGitignore => TEXT_PLAIN,\n            Self::FileExtensionMa => APPLICATION_MATHEMATICA,\n            Self::FileExtensionMac => IMAGE_X_MACPAINT,\n            Self::FileExtensionMads => APPLICATION_MADS_XML,\n            Self::FileExtensionMag => APPLICATION_VND_ECOWIN_CHART,\n            Self::FileExtensionMaker => APPLICATION_VND_FRAMEMAKER,\n            Self::FileExtensionMan => TEXT_TROFF,\n            Self::FileExtensionMar => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionMathml => APPLICATION_MATHML_XML,\n            Self::FileExtensionMb => APPLICATION_MATHEMATICA,\n            Self::FileExtensionMbk => APPLICATION_VND_MOBIUS_MBK,\n            Self::FileExtensionMbox => APPLICATION_MBOX,\n            Self::FileExtensionMc1 => APPLICATION_VND_MEDCALCDATA,\n            Self::FileExtensionMcd => APPLICATION_VND_MCD,\n            Self::FileExtensionMcurl => TEXT_VND_CURL_MCURL,\n            Self::FileExtensionMdb => APPLICATION_X_MSACCESS,\n            Self::FileExtensionMdi => IMAGE_VND_MS_MODI,\n            Self::FileExtensionMe => TEXT_TROFF,\n            Self::FileExtensionMesh => MODEL_MESH,\n            Self::FileExtensionMeta4 => APPLICATION_METALINK4_XML,\n            Self::FileExtensionMetalink => APPLICATION_METALINK_XML,\n            Self::FileExtensionMets => APPLICATION_METS_XML,\n            Self::FileExtensionMfm => APPLICATION_VND_MFMP,\n            Self::FileExtensionMft => APPLICATION_RPKI_MANIFEST,\n            Self::FileExtensionMgp => APPLICATION_VND_OSGEO_MAPGUIDE_PACKAGE,\n            Self::FileExtensionMgz => APPLICATION_VND_PROTEUS_MAGAZINE,\n            Self::FileExtensionMid => AUDIO_MIDI,\n            Self::FileExtensionMidi => AUDIO_MIDI,\n            Self::FileExtensionMie => APPLICATION_X_MIE,\n            Self::FileExtensionMif => APPLICATION_X_MIF,\n            Self::FileExtensionMime => MESSAGE_RFC822,\n            Self::FileExtensionMj2 => VIDEO_MJ2,\n            Self::FileExtensionMjp2 => VIDEO_MJ2,\n            Self::FileExtensionMk3d => VIDEO_X_MATROSKA,\n            Self::FileExtensionMka => AUDIO_X_MATROSKA,\n            Self::FileExtensionMks => VIDEO_X_MATROSKA,\n            Self::FileExtensionMkv => VIDEO_X_MATROSKA,\n            Self::FileExtensionMlp => APPLICATION_VND_DOLBY_MLP,\n            Self::FileExtensionMmd => APPLICATION_VND_CHIPNUTS_KARAOKE_MMD,\n            Self::FileExtensionMmf => APPLICATION_VND_SMAF,\n            Self::FileExtensionMmr => IMAGE_VND_FUJIXEROX_EDMICS_MMR,\n            Self::FileExtensionMng => VIDEO_X_MNG,\n            Self::FileExtensionMny => APPLICATION_X_MSMONEY,\n            Self::FileExtensionMobi => APPLICATION_X_MOBIPOCKET_EBOOK,\n            Self::FileExtensionMods => APPLICATION_MODS_XML,\n            Self::FileExtensionMov => VIDEO_QUICKTIME,\n            Self::FileExtensionMovie => VIDEO_X_SGI_MOVIE,\n            Self::FileExtensionMp1 => AUDIO_MPEG,\n            Self::FileExtensionMp2 => AUDIO_MPEG,\n            Self::FileExtensionMp21 => APPLICATION_MP21,\n            Self::FileExtensionMp2a => AUDIO_MPEG,\n            Self::FileExtensionMp3 => AUDIO_MPEG,\n            Self::FileExtensionMp4 => VIDEO_MP4,\n            Self::FileExtensionMp4a => AUDIO_MP4,\n            Self::FileExtensionMp4s => APPLICATION_MP4,\n            Self::FileExtensionMp4v => VIDEO_MP4,\n            Self::FileExtensionMpa => AUDIO_MPEG,\n            Self::FileExtensionMpc => APPLICATION_VND_MOPHUN_CERTIFICATE,\n            Self::FileExtensionMpe => VIDEO_MPEG,\n            Self::FileExtensionMpeg => VIDEO_MPEG,\n            Self::FileExtensionMpega => AUDIO_X_MPEG,\n            Self::FileExtensionMpg => VIDEO_MPEG,\n            Self::FileExtensionMpg4 => VIDEO_MP4,\n            Self::FileExtensionMpga => AUDIO_MPEG,\n            Self::FileExtensionMpkg => APPLICATION_VND_APPLE_INSTALLER_XML,\n            Self::FileExtensionMpm => APPLICATION_VND_BLUEICE_MULTIPASS,\n            Self::FileExtensionMpn => APPLICATION_VND_MOPHUN_APPLICATION,\n            Self::FileExtensionMpp => APPLICATION_VND_MS_PROJECT,\n            Self::FileExtensionMpt => APPLICATION_VND_MS_PROJECT,\n            Self::FileExtensionMpv2 => VIDEO_MPEG2,\n            Self::FileExtensionMpy => APPLICATION_VND_IBM_MINIPAY,\n            Self::FileExtensionMqy => APPLICATION_VND_MOBIUS_MQY,\n            Self::FileExtensionMrc => APPLICATION_MARC,\n            Self::FileExtensionMrcx => APPLICATION_MARCXML_XML,\n            Self::FileExtensionMs => TEXT_TROFF,\n            Self::FileExtensionMscml => APPLICATION_MEDIASERVERCONTROL_XML,\n            Self::FileExtensionMseed => APPLICATION_VND_FDSN_MSEED,\n            Self::FileExtensionMseq => APPLICATION_VND_MSEQ,\n            Self::FileExtensionMsf => APPLICATION_VND_EPSON_MSF,\n            Self::FileExtensionMsh => MODEL_MESH,\n            Self::FileExtensionMsi => APPLICATION_X_MSDOWNLOAD,\n            Self::FileExtensionMsl => APPLICATION_VND_MOBIUS_MSL,\n            Self::FileExtensionMsty => APPLICATION_VND_MUVEE_STYLE,\n            Self::FileExtensionMts => MODEL_VND_MTS,\n            Self::FileExtensionMus => APPLICATION_VND_MUSICIAN,\n            Self::FileExtensionMusicxml => APPLICATION_VND_RECORDARE_MUSICXML_XML,\n            Self::FileExtensionMvb => APPLICATION_X_MSMEDIAVIEW,\n            Self::FileExtensionMwf => APPLICATION_VND_MFER,\n            Self::FileExtensionMxf => APPLICATION_MXF,\n            Self::FileExtensionMxl => APPLICATION_VND_RECORDARE_MUSICXML,\n            Self::FileExtensionMxml => APPLICATION_XV_XML,\n            Self::FileExtensionMxs => APPLICATION_VND_TRISCAPE_MXS,\n            Self::FileExtensionMxu => VIDEO_VND_MPEGURL,\n            Self::FileExtensionNGage => APPLICATION_VND_NOKIA_N_GAGE_SYMBIAN_INSTALL,\n            Self::FileExtensionN3 => TEXT_N3,\n            Self::FileExtensionNb => APPLICATION_MATHEMATICA,\n            Self::FileExtensionNbp => APPLICATION_VND_WOLFRAM_PLAYER,\n            Self::FileExtensionNc => APPLICATION_X_NETCDF,\n            Self::FileExtensionNcx => APPLICATION_X_DTBNCX_XML,\n            Self::FileExtensionNfo => TEXT_X_NFO,\n            Self::FileExtensionNgdat => APPLICATION_VND_NOKIA_N_GAGE_DATA,\n            Self::FileExtensionNitf => APPLICATION_VND_NITF,\n            Self::FileExtensionNlu => APPLICATION_VND_NEUROLANGUAGE_NLU,\n            Self::FileExtensionNml => APPLICATION_VND_ENLIVEN,\n            Self::FileExtensionNnd => APPLICATION_VND_NOBLENET_DIRECTORY,\n            Self::FileExtensionNns => APPLICATION_VND_NOBLENET_SEALER,\n            Self::FileExtensionNnw => APPLICATION_VND_NOBLENET_WEB,\n            Self::FileExtensionNpx => IMAGE_VND_NET_FPX,\n            Self::FileExtensionNsc => APPLICATION_X_CONFERENCE,\n            Self::FileExtensionNsf => APPLICATION_VND_LOTUS_NOTES,\n            Self::FileExtensionNtf => APPLICATION_VND_NITF,\n            Self::FileExtensionNzb => APPLICATION_X_NZB,\n            Self::FileExtensionOa2 => APPLICATION_VND_FUJITSU_OASYS2,\n            Self::FileExtensionOa3 => APPLICATION_VND_FUJITSU_OASYS3,\n            Self::FileExtensionOas => APPLICATION_VND_FUJITSU_OASYS,\n            Self::FileExtensionObd => APPLICATION_X_MSBINDER,\n            Self::FileExtensionObj => APPLICATION_X_TGIF,\n            Self::FileExtensionOda => APPLICATION_ODA,\n            Self::FileExtensionOdb => APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE,\n            Self::FileExtensionOdc => APPLICATION_VND_OASIS_OPENDOCUMENT_CHART,\n            Self::FileExtensionOdf => APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA,\n            Self::FileExtensionOdft => APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA_TEMPLATE,\n            Self::FileExtensionOdg => APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS,\n            Self::FileExtensionOdi => APPLICATION_VND_OASIS_OPENDOCUMENT_IMAGE,\n            Self::FileExtensionOdm => APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_MASTER,\n            Self::FileExtensionOdp => APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION,\n            Self::FileExtensionOds => APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET,\n            Self::FileExtensionOdt => APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT,\n            Self::FileExtensionOga => AUDIO_OGG,\n            Self::FileExtensionOgg => AUDIO_OGG,\n            Self::FileExtensionOgv => VIDEO_OGG,\n            Self::FileExtensionOgx => APPLICATION_OGG,\n            Self::FileExtensionOmdoc => APPLICATION_OMDOC_XML,\n            Self::FileExtensionOnepkg => APPLICATION_ONENOTE,\n            Self::FileExtensionOnetmp => APPLICATION_ONENOTE,\n            Self::FileExtensionOnetoc => APPLICATION_ONENOTE,\n            Self::FileExtensionOnetoc2 => APPLICATION_ONENOTE,\n            Self::FileExtensionOpf => APPLICATION_OEBPS_PACKAGE_XML,\n            Self::FileExtensionOpml => TEXT_X_OPML,\n            Self::FileExtensionOprc => APPLICATION_VND_PALM,\n            Self::FileExtensionOrg => APPLICATION_VND_LOTUS_ORGANIZER,\n            Self::FileExtensionOsf => APPLICATION_VND_YAMAHA_OPENSCOREFORMAT,\n            Self::FileExtensionOsfpvg => APPLICATION_VND_YAMAHA_OPENSCOREFORMAT_OSFPVG_XML,\n            Self::FileExtensionOtc => APPLICATION_VND_OASIS_OPENDOCUMENT_CHART_TEMPLATE,\n            Self::FileExtensionOtf => FONT_OTF,\n            Self::FileExtensionOtg => APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS_TEMPLATE,\n            Self::FileExtensionOth => APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_WEB,\n            Self::FileExtensionOti => APPLICATION_VND_OASIS_OPENDOCUMENT_IMAGE_TEMPLATE,\n            Self::FileExtensionOtp => APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION_TEMPLATE,\n            Self::FileExtensionOts => APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET_TEMPLATE,\n            Self::FileExtensionOtt => APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_TEMPLATE,\n            Self::FileExtensionOxps => APPLICATION_OXPS,\n            Self::FileExtensionOxt => APPLICATION_VND_OPENOFFICEORG_EXTENSION,\n            Self::FileExtensionP => TEXT_X_PASCAL,\n            Self::FileExtensionP10 => APPLICATION_PKCS10,\n            Self::FileExtensionP12 => APPLICATION_X_PKCS12,\n            Self::FileExtensionP7b => APPLICATION_X_PKCS7_CERTIFICATES,\n            Self::FileExtensionP7c => APPLICATION_PKCS7_MIME,\n            Self::FileExtensionP7m => APPLICATION_PKCS7_MIME,\n            Self::FileExtensionP7r => APPLICATION_X_PKCS7_CERTREQRESP,\n            Self::FileExtensionP7s => APPLICATION_PKCS7_SIGNATURE,\n            Self::FileExtensionP8 => APPLICATION_PKCS8,\n            Self::FileExtensionPas => TEXT_X_PASCAL,\n            Self::FileExtensionPaw => APPLICATION_VND_PAWAAFILE,\n            Self::FileExtensionPbd => APPLICATION_VND_POWERBUILDER6,\n            Self::FileExtensionPbm => IMAGE_X_PORTABLE_BITMAP,\n            Self::FileExtensionPcap => APPLICATION_VND_TCPDUMP_PCAP,\n            Self::FileExtensionPcf => APPLICATION_X_FONT_PCF,\n            Self::FileExtensionPcl => APPLICATION_VND_HP_PCL,\n            Self::FileExtensionPclxl => APPLICATION_VND_HP_PCLXL,\n            Self::FileExtensionPct => IMAGE_PICT,\n            Self::FileExtensionPcurl => APPLICATION_VND_CURL_PCURL,\n            Self::FileExtensionPcx => IMAGE_X_PCX,\n            Self::FileExtensionPdb => APPLICATION_VND_PALM,\n            Self::FileExtensionPdf => APPLICATION_PDF,\n            Self::FileExtensionPfa => APPLICATION_X_FONT_TYPE1,\n            Self::FileExtensionPfb => APPLICATION_X_FONT_TYPE1,\n            Self::FileExtensionPfm => APPLICATION_X_FONT_TYPE1,\n            Self::FileExtensionPfr => APPLICATION_FONT_TDPFR,\n            Self::FileExtensionPfx => APPLICATION_X_PKCS12,\n            Self::FileExtensionPgm => IMAGE_X_PORTABLE_GRAYMAP,\n            Self::FileExtensionPgn => APPLICATION_X_CHESS_PGN,\n            Self::FileExtensionPgp => APPLICATION_PGP_ENCRYPTED,\n            Self::FileExtensionPic => IMAGE_PICT,\n            Self::FileExtensionPict => IMAGE_PICT,\n            Self::FileExtensionPkg => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionPki => APPLICATION_PKIXCMP,\n            Self::FileExtensionPkipath => APPLICATION_PKIX_PKIPATH,\n            Self::FileExtensionPlb => APPLICATION_VND_3GPP_PIC_BW_LARGE,\n            Self::FileExtensionPlc => APPLICATION_VND_MOBIUS_PLC,\n            Self::FileExtensionPlf => APPLICATION_VND_POCKETLEARN,\n            Self::FileExtensionPls => AUDIO_X_SCPLS,\n            Self::FileExtensionPml => APPLICATION_VND_CTC_POSML,\n            Self::FileExtensionPng => IMAGE_PNG,\n            Self::FileExtensionPnm => IMAGE_X_PORTABLE_ANYMAP,\n            Self::FileExtensionPnt => IMAGE_X_MACPAINT,\n            Self::FileExtensionPortpkg => APPLICATION_VND_MACPORTS_PORTPKG,\n            Self::FileExtensionPot => APPLICATION_VND_MS_POWERPOINT,\n            Self::FileExtensionPotm => APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12,\n            Self::FileExtensionPotx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE\n            }\n            Self::FileExtensionPpam => APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12,\n            Self::FileExtensionPpd => APPLICATION_VND_CUPS_PPD,\n            Self::FileExtensionPpm => IMAGE_X_PORTABLE_PIXMAP,\n            Self::FileExtensionPps => APPLICATION_VND_MS_POWERPOINT,\n            Self::FileExtensionPpsm => APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12,\n            Self::FileExtensionPpsx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW\n            }\n            Self::FileExtensionPpt => APPLICATION_VND_MS_POWERPOINT,\n            Self::FileExtensionPptm => APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12,\n            Self::FileExtensionPptx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION\n            }\n            Self::FileExtensionPqa => APPLICATION_VND_PALM,\n            Self::FileExtensionPrc => APPLICATION_X_MOBIPOCKET_EBOOK,\n            Self::FileExtensionPre => APPLICATION_VND_LOTUS_FREELANCE,\n            Self::FileExtensionPrf => APPLICATION_PICS_RULES,\n            Self::FileExtensionPs => APPLICATION_POSTSCRIPT,\n            Self::FileExtensionPsb => APPLICATION_VND_3GPP_PIC_BW_SMALL,\n            Self::FileExtensionPsd => IMAGE_VND_ADOBE_PHOTOSHOP,\n            Self::FileExtensionPsf => APPLICATION_X_FONT_LINUX_PSF,\n            Self::FileExtensionPskcxml => APPLICATION_PSKC_XML,\n            Self::FileExtensionPtid => APPLICATION_VND_PVI_PTID1,\n            Self::FileExtensionPub => APPLICATION_X_MSPUBLISHER,\n            Self::FileExtensionPvb => APPLICATION_VND_3GPP_PIC_BW_VAR,\n            Self::FileExtensionPwn => APPLICATION_VND_3M_POST_IT_NOTES,\n            Self::FileExtensionPya => AUDIO_VND_MS_PLAYREADY_MEDIA_PYA,\n            Self::FileExtensionPyv => VIDEO_VND_MS_PLAYREADY_MEDIA_PYV,\n            Self::FileExtensionQam => APPLICATION_VND_EPSON_QUICKANIME,\n            Self::FileExtensionQbo => APPLICATION_VND_INTU_QBO,\n            Self::FileExtensionQfx => APPLICATION_VND_INTU_QFX,\n            Self::FileExtensionQps => APPLICATION_VND_PUBLISHARE_DELTA_TREE,\n            Self::FileExtensionQt => VIDEO_QUICKTIME,\n            Self::FileExtensionQti => IMAGE_X_QUICKTIME,\n            Self::FileExtensionQtif => IMAGE_X_QUICKTIME,\n            Self::FileExtensionQwd => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionQwt => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionQxb => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionQxd => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionQxl => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionQxt => APPLICATION_VND_QUARK_QUARKXPRESS,\n            Self::FileExtensionRa => AUDIO_X_PN_REALAUDIO,\n            Self::FileExtensionRam => AUDIO_X_PN_REALAUDIO,\n            Self::FileExtensionRar => APPLICATION_X_RAR_COMPRESSED,\n            Self::FileExtensionRas => IMAGE_X_CMU_RASTER,\n            Self::FileExtensionRcprofile => APPLICATION_VND_IPUNPLUGGED_RCPROFILE,\n            Self::FileExtensionRdf => APPLICATION_RDF_XML,\n            Self::FileExtensionRdz => APPLICATION_VND_DATA_VISION_RDZ,\n            Self::FileExtensionRep => APPLICATION_VND_BUSINESSOBJECTS,\n            Self::FileExtensionRes => APPLICATION_X_DTBRESOURCE_XML,\n            Self::FileExtensionRgb => IMAGE_X_RGB,\n            Self::FileExtensionRif => APPLICATION_REGINFO_XML,\n            Self::FileExtensionRip => AUDIO_VND_RIP,\n            Self::FileExtensionRis => APPLICATION_X_RESEARCH_INFO_SYSTEMS,\n            Self::FileExtensionRl => APPLICATION_RESOURCE_LISTS_XML,\n            Self::FileExtensionRlc => IMAGE_VND_FUJIXEROX_EDMICS_RLC,\n            Self::FileExtensionRld => APPLICATION_RESOURCE_LISTS_DIFF_XML,\n            Self::FileExtensionRm => APPLICATION_VND_RN_REALMEDIA,\n            Self::FileExtensionRmi => AUDIO_MIDI,\n            Self::FileExtensionRmp => AUDIO_X_PN_REALAUDIO_PLUGIN,\n            Self::FileExtensionRms => APPLICATION_VND_JCP_JAVAME_MIDLET_RMS,\n            Self::FileExtensionRmvb => APPLICATION_VND_RN_REALMEDIA_VBR,\n            Self::FileExtensionRnc => APPLICATION_RELAX_NG_COMPACT_SYNTAX,\n            Self::FileExtensionRoa => APPLICATION_RPKI_ROA,\n            Self::FileExtensionRoff => TEXT_TROFF,\n            Self::FileExtensionRp9 => APPLICATION_VND_CLOANTO_RP9,\n            Self::FileExtensionRpss => APPLICATION_VND_NOKIA_RADIO_PRESETS,\n            Self::FileExtensionRpst => APPLICATION_VND_NOKIA_RADIO_PRESET,\n            Self::FileExtensionRq => APPLICATION_SPARQL_QUERY,\n            Self::FileExtensionRsd => APPLICATION_RSD_XML,\n            Self::FileExtensionRss => APPLICATION_RSS_XML,\n            Self::FileExtensionRtf => APPLICATION_RTF,\n            Self::FileExtensionRtx => TEXT_RICHTEXT,\n            Self::FileExtensionS => TEXT_X_ASM,\n            Self::FileExtensionS3m => AUDIO_S3M,\n            Self::FileExtensionSaf => APPLICATION_VND_YAMAHA_SMAF_AUDIO,\n            Self::FileExtensionSbml => APPLICATION_SBML_XML,\n            Self::FileExtensionSc => APPLICATION_VND_IBM_SECURE_CONTAINER,\n            Self::FileExtensionScd => APPLICATION_X_MSSCHEDULE,\n            Self::FileExtensionScm => APPLICATION_VND_LOTUS_SCREENCAM,\n            Self::FileExtensionScq => APPLICATION_SCVP_CV_REQUEST,\n            Self::FileExtensionScs => APPLICATION_SCVP_CV_RESPONSE,\n            Self::FileExtensionScurl => TEXT_VND_CURL_SCURL,\n            Self::FileExtensionSda => APPLICATION_VND_STARDIVISION_DRAW,\n            Self::FileExtensionSdc => APPLICATION_VND_STARDIVISION_CALC,\n            Self::FileExtensionSdd => APPLICATION_VND_STARDIVISION_IMPRESS,\n            Self::FileExtensionSdkd => APPLICATION_VND_SOLENT_SDKM_XML,\n            Self::FileExtensionSdkm => APPLICATION_VND_SOLENT_SDKM_XML,\n            Self::FileExtensionSdp => APPLICATION_SDP,\n            Self::FileExtensionSdw => APPLICATION_VND_STARDIVISION_WRITER,\n            Self::FileExtensionSee => APPLICATION_VND_SEEMAIL,\n            Self::FileExtensionSeed => APPLICATION_VND_FDSN_SEED,\n            Self::FileExtensionSema => APPLICATION_VND_SEMA,\n            Self::FileExtensionSemd => APPLICATION_VND_SEMD,\n            Self::FileExtensionSemf => APPLICATION_VND_SEMF,\n            Self::FileExtensionSer => APPLICATION_JAVA_SERIALIZED_OBJECT,\n            Self::FileExtensionSetpay => APPLICATION_SET_PAYMENT_INITIATION,\n            Self::FileExtensionSetreg => APPLICATION_SET_REGISTRATION_INITIATION,\n            Self::FileExtensionSfdHdstx => APPLICATION_VND_HYDROSTATIX_SOF_DATA,\n            Self::FileExtensionSfs => APPLICATION_VND_SPOTFIRE_SFS,\n            Self::FileExtensionSfv => TEXT_X_SFV,\n            Self::FileExtensionSgi => IMAGE_SGI,\n            Self::FileExtensionSgl => APPLICATION_VND_STARDIVISION_WRITER_GLOBAL,\n            Self::FileExtensionSgm => TEXT_SGML,\n            Self::FileExtensionSgml => TEXT_SGML,\n            Self::FileExtensionSh => APPLICATION_X_SH,\n            Self::FileExtensionShar => APPLICATION_X_SHAR,\n            Self::FileExtensionShf => APPLICATION_SHF_XML,\n            Self::FileExtensionSid => IMAGE_X_MRSID_IMAGE,\n            Self::FileExtensionSig => APPLICATION_PGP_SIGNATURE,\n            Self::FileExtensionSil => AUDIO_SILK,\n            Self::FileExtensionSilo => MODEL_MESH,\n            Self::FileExtensionSis => APPLICATION_VND_SYMBIAN_INSTALL,\n            Self::FileExtensionSisx => APPLICATION_VND_SYMBIAN_INSTALL,\n            Self::FileExtensionSit => APPLICATION_X_STUFFIT,\n            Self::FileExtensionSitx => APPLICATION_X_STUFFITX,\n            Self::FileExtensionSkd => APPLICATION_VND_KOAN,\n            Self::FileExtensionSkm => APPLICATION_VND_KOAN,\n            Self::FileExtensionSkp => APPLICATION_VND_KOAN,\n            Self::FileExtensionSkt => APPLICATION_VND_KOAN,\n            Self::FileExtensionSldm => APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12,\n            Self::FileExtensionSldx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE\n            }\n            Self::FileExtensionSlt => APPLICATION_VND_EPSON_SALT,\n            Self::FileExtensionSm => APPLICATION_VND_STEPMANIA_STEPCHART,\n            Self::FileExtensionSmf => APPLICATION_VND_STARDIVISION_MATH,\n            Self::FileExtensionSmi => APPLICATION_SMIL_XML,\n            Self::FileExtensionSmil => APPLICATION_SMIL_XML,\n            Self::FileExtensionSmv => VIDEO_X_SMV,\n            Self::FileExtensionSmzip => APPLICATION_VND_STEPMANIA_PACKAGE,\n            Self::FileExtensionSnd => AUDIO_BASIC,\n            Self::FileExtensionSnf => APPLICATION_X_FONT_SNF,\n            Self::FileExtensionSo => APPLICATION_OCTET_STREAM,\n            Self::FileExtensionSpc => APPLICATION_X_PKCS7_CERTIFICATES,\n            Self::FileExtensionSpf => APPLICATION_VND_YAMAHA_SMAF_PHRASE,\n            Self::FileExtensionSpl => APPLICATION_X_FUTURESPLASH,\n            Self::FileExtensionSpot => TEXT_VND_IN3D_SPOT,\n            Self::FileExtensionSpp => APPLICATION_SCVP_VP_RESPONSE,\n            Self::FileExtensionSpq => APPLICATION_SCVP_VP_REQUEST,\n            Self::FileExtensionSpx => AUDIO_OGG,\n            Self::FileExtensionSql => APPLICATION_X_SQL,\n            Self::FileExtensionSrc => APPLICATION_X_WAIS_SOURCE,\n            Self::FileExtensionSrt => APPLICATION_X_SUBRIP,\n            Self::FileExtensionSru => APPLICATION_SRU_XML,\n            Self::FileExtensionSrx => APPLICATION_SPARQL_RESULTS_XML,\n            Self::FileExtensionSsdl => APPLICATION_SSDL_XML,\n            Self::FileExtensionSse => APPLICATION_VND_KODAK_DESCRIPTOR,\n            Self::FileExtensionSsf => APPLICATION_VND_EPSON_SSF,\n            Self::FileExtensionSsml => APPLICATION_SSML_XML,\n            Self::FileExtensionSt => APPLICATION_VND_SAILINGTRACKER_TRACK,\n            Self::FileExtensionStc => APPLICATION_VND_SUN_XML_CALC_TEMPLATE,\n            Self::FileExtensionStd => APPLICATION_VND_SUN_XML_DRAW_TEMPLATE,\n            Self::FileExtensionStf => APPLICATION_VND_WT_STF,\n            Self::FileExtensionSti => APPLICATION_VND_SUN_XML_IMPRESS_TEMPLATE,\n            Self::FileExtensionStk => APPLICATION_HYPERSTUDIO,\n            Self::FileExtensionStl => APPLICATION_VND_MS_PKI_STL,\n            Self::FileExtensionStr => APPLICATION_VND_PG_FORMAT,\n            Self::FileExtensionStw => APPLICATION_VND_SUN_XML_WRITER_TEMPLATE,\n            Self::FileExtensionSub => TEXT_VND_DVB_SUBTITLE,\n            Self::FileExtensionSus => APPLICATION_VND_SUS_CALENDAR,\n            Self::FileExtensionSusp => APPLICATION_VND_SUS_CALENDAR,\n            Self::FileExtensionSv4cpio => APPLICATION_X_SV4CPIO,\n            Self::FileExtensionSv4crc => APPLICATION_X_SV4CRC,\n            Self::FileExtensionSvc => APPLICATION_VND_DVB_SERVICE,\n            Self::FileExtensionSvd => APPLICATION_VND_SVD,\n            Self::FileExtensionSvg => IMAGE_SVG_XML,\n            Self::FileExtensionSvgz => IMAGE_SVG_XML,\n            Self::FileExtensionSwa => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionSwf => APPLICATION_X_SHOCKWAVE_FLASH,\n            Self::FileExtensionSwi => APPLICATION_VND_ARISTANETWORKS_SWI,\n            Self::FileExtensionSxc => APPLICATION_VND_SUN_XML_CALC,\n            Self::FileExtensionSxd => APPLICATION_VND_SUN_XML_DRAW,\n            Self::FileExtensionSxg => APPLICATION_VND_SUN_XML_WRITER_GLOBAL,\n            Self::FileExtensionSxi => APPLICATION_VND_SUN_XML_IMPRESS,\n            Self::FileExtensionSxm => APPLICATION_VND_SUN_XML_MATH,\n            Self::FileExtensionSxw => APPLICATION_VND_SUN_XML_WRITER,\n            Self::FileExtensionT => TEXT_TROFF,\n            Self::FileExtensionT3 => APPLICATION_X_T3VM_IMAGE,\n            Self::FileExtensionTaglet => APPLICATION_VND_MYNFC,\n            Self::FileExtensionTao => APPLICATION_VND_TAO_INTENT_MODULE_ARCHIVE,\n            Self::FileExtensionTar => APPLICATION_X_TAR,\n            Self::FileExtensionTcap => APPLICATION_VND_3GPP2_TCAP,\n            Self::FileExtensionTcl => APPLICATION_X_TCL,\n            Self::FileExtensionTeacher => APPLICATION_VND_SMART_TEACHER,\n            Self::FileExtensionTei => APPLICATION_TEI_XML,\n            Self::FileExtensionTeicorpus => APPLICATION_TEI_XML,\n            Self::FileExtensionTex => APPLICATION_X_TEX,\n            Self::FileExtensionTexi => APPLICATION_X_TEXINFO,\n            Self::FileExtensionTexinfo => APPLICATION_X_TEXINFO,\n            Self::FileExtensionText => TEXT_PLAIN,\n            Self::FileExtensionTfi => APPLICATION_THRAUD_XML,\n            Self::FileExtensionTfm => APPLICATION_X_TEX_TFM,\n            Self::FileExtensionTga => IMAGE_X_TGA,\n            Self::FileExtensionThmx => APPLICATION_VND_MS_OFFICETHEME,\n            Self::FileExtensionTif => IMAGE_TIFF,\n            Self::FileExtensionTiff => IMAGE_TIFF,\n            Self::FileExtensionTmo => APPLICATION_VND_TMOBILE_LIVETV,\n            Self::FileExtensionTorrent => APPLICATION_X_BITTORRENT,\n            Self::FileExtensionTpl => APPLICATION_VND_GROOVE_TOOL_TEMPLATE,\n            Self::FileExtensionTpt => APPLICATION_VND_TRID_TPT,\n            Self::FileExtensionTr => TEXT_TROFF,\n            Self::FileExtensionTra => APPLICATION_VND_TRUEAPP,\n            Self::FileExtensionTrm => APPLICATION_X_MSTERMINAL,\n            Self::FileExtensionTsd => APPLICATION_TIMESTAMPED_DATA,\n            Self::FileExtensionTsv => TEXT_TAB_SEPARATED_VALUES,\n            Self::FileExtensionTtc => FONT_COLLECTION,\n            Self::FileExtensionTtf => FONT_TTF,\n            Self::FileExtensionTtl => TEXT_TURTLE,\n            Self::FileExtensionTwd => APPLICATION_VND_SIMTECH_MINDMAPPER,\n            Self::FileExtensionTwds => APPLICATION_VND_SIMTECH_MINDMAPPER,\n            Self::FileExtensionTxd => APPLICATION_VND_GENOMATIX_TUXEDO,\n            Self::FileExtensionTxf => APPLICATION_VND_MOBIUS_TXF,\n            Self::FileExtensionTxt => TEXT_PLAIN,\n            Self::FileExtensionU32 => APPLICATION_X_AUTHORWARE_BIN,\n            Self::FileExtensionUdeb => APPLICATION_X_DEBIAN_PACKAGE,\n            Self::FileExtensionUfd => APPLICATION_VND_UFDL,\n            Self::FileExtensionUfdl => APPLICATION_VND_UFDL,\n            Self::FileExtensionUlw => AUDIO_BASIC,\n            Self::FileExtensionUlx => APPLICATION_X_GLULX,\n            Self::FileExtensionUmj => APPLICATION_VND_UMAJIN,\n            Self::FileExtensionUnityweb => APPLICATION_VND_UNITY,\n            Self::FileExtensionUoml => APPLICATION_VND_UOML_XML,\n            Self::FileExtensionUri => TEXT_URI_LIST,\n            Self::FileExtensionUris => TEXT_URI_LIST,\n            Self::FileExtensionUrls => TEXT_URI_LIST,\n            Self::FileExtensionUstar => APPLICATION_X_USTAR,\n            Self::FileExtensionUtz => APPLICATION_VND_UIQ_THEME,\n            Self::FileExtensionUu => TEXT_X_UUENCODE,\n            Self::FileExtensionUva => AUDIO_VND_DECE_AUDIO,\n            Self::FileExtensionUvd => APPLICATION_VND_DECE_DATA,\n            Self::FileExtensionUvf => APPLICATION_VND_DECE_DATA,\n            Self::FileExtensionUvg => IMAGE_VND_DECE_GRAPHIC,\n            Self::FileExtensionUvh => VIDEO_VND_DECE_HD,\n            Self::FileExtensionUvi => IMAGE_VND_DECE_GRAPHIC,\n            Self::FileExtensionUvm => VIDEO_VND_DECE_MOBILE,\n            Self::FileExtensionUvp => VIDEO_VND_DECE_PD,\n            Self::FileExtensionUvs => VIDEO_VND_DECE_SD,\n            Self::FileExtensionUvt => APPLICATION_VND_DECE_TTML_XML,\n            Self::FileExtensionUvu => VIDEO_VND_UVVU_MP4,\n            Self::FileExtensionUvv => VIDEO_VND_DECE_VIDEO,\n            Self::FileExtensionUvva => AUDIO_VND_DECE_AUDIO,\n            Self::FileExtensionUvvd => APPLICATION_VND_DECE_DATA,\n            Self::FileExtensionUvvf => APPLICATION_VND_DECE_DATA,\n            Self::FileExtensionUvvg => IMAGE_VND_DECE_GRAPHIC,\n            Self::FileExtensionUvvh => VIDEO_VND_DECE_HD,\n            Self::FileExtensionUvvi => IMAGE_VND_DECE_GRAPHIC,\n            Self::FileExtensionUvvm => VIDEO_VND_DECE_MOBILE,\n            Self::FileExtensionUvvp => VIDEO_VND_DECE_PD,\n            Self::FileExtensionUvvs => VIDEO_VND_DECE_SD,\n            Self::FileExtensionUvvt => APPLICATION_VND_DECE_TTML_XML,\n            Self::FileExtensionUvvu => VIDEO_VND_UVVU_MP4,\n            Self::FileExtensionUvvv => VIDEO_VND_DECE_VIDEO,\n            Self::FileExtensionUvvx => APPLICATION_VND_DECE_UNSPECIFIED,\n            Self::FileExtensionUvvz => APPLICATION_VND_DECE_ZIP,\n            Self::FileExtensionUvx => APPLICATION_VND_DECE_UNSPECIFIED,\n            Self::FileExtensionUvz => APPLICATION_VND_DECE_ZIP,\n            Self::FileExtensionVcard => TEXT_VCARD,\n            Self::FileExtensionVcd => APPLICATION_X_CDLINK,\n            Self::FileExtensionVcf => TEXT_X_VCARD,\n            Self::FileExtensionVcg => APPLICATION_VND_GROOVE_VCARD,\n            Self::FileExtensionVcs => TEXT_X_VCALENDAR,\n            Self::FileExtensionVcx => APPLICATION_VND_VCX,\n            Self::FileExtensionVis => APPLICATION_VND_VISIONARY,\n            Self::FileExtensionViv => VIDEO_VND_VIVO,\n            Self::FileExtensionVob => VIDEO_X_MS_VOB,\n            Self::FileExtensionVor => APPLICATION_VND_STARDIVISION_WRITER,\n            Self::FileExtensionVox => APPLICATION_X_AUTHORWARE_BIN,\n            Self::FileExtensionVrml => MODEL_VRML,\n            Self::FileExtensionVsd => APPLICATION_VND_VISIO,\n            Self::FileExtensionVsf => APPLICATION_VND_VSF,\n            Self::FileExtensionVss => APPLICATION_VND_VISIO,\n            Self::FileExtensionVst => APPLICATION_VND_VISIO,\n            Self::FileExtensionVsw => APPLICATION_VND_VISIO,\n            Self::FileExtensionVtu => MODEL_VND_VTU,\n            Self::FileExtensionVxml => APPLICATION_VOICEXML_XML,\n            Self::FileExtensionW3d => APPLICATION_X_DIRECTOR,\n            Self::FileExtensionWad => APPLICATION_X_DOOM,\n            Self::FileExtensionWav => AUDIO_X_WAV,\n            Self::FileExtensionWax => AUDIO_X_MS_WAX,\n            Self::FileExtensionWbmp => IMAGE_VND_WAP_WBMP,\n            Self::FileExtensionWbs => APPLICATION_VND_CRITICALTOOLS_WBS_XML,\n            Self::FileExtensionWbxml => APPLICATION_VND_WAP_WBXML,\n            Self::FileExtensionWcm => APPLICATION_VND_MS_WORKS,\n            Self::FileExtensionWdb => APPLICATION_VND_MS_WORKS,\n            Self::FileExtensionWdp => IMAGE_VND_MS_PHOTO,\n            Self::FileExtensionWeba => AUDIO_WEBM,\n            Self::FileExtensionWebm => VIDEO_WEBM,\n            Self::FileExtensionWebp => IMAGE_WEBP,\n            Self::FileExtensionWg => APPLICATION_VND_PMI_WIDGET,\n            Self::FileExtensionWgt => APPLICATION_WIDGET,\n            Self::FileExtensionWks => APPLICATION_VND_MS_WORKS,\n            Self::FileExtensionWm => VIDEO_X_MS_WM,\n            Self::FileExtensionWma => AUDIO_X_MS_WMA,\n            Self::FileExtensionWmd => APPLICATION_X_MS_WMD,\n            Self::FileExtensionWmf => APPLICATION_X_MSMETAFILE,\n            Self::FileExtensionWml => TEXT_VND_WAP_WML,\n            Self::FileExtensionWmlc => APPLICATION_VND_WAP_WMLC,\n            Self::FileExtensionWmls => TEXT_VND_WAP_WMLSCRIPT,\n            Self::FileExtensionWmlsc => APPLICATION_VND_WAP_WMLSCRIPTC,\n            Self::FileExtensionWmv => VIDEO_X_MS_WMV,\n            Self::FileExtensionWmx => VIDEO_X_MS_WMX,\n            Self::FileExtensionWmz => APPLICATION_X_MSMETAFILE,\n            Self::FileExtensionWoff => FONT_WOFF,\n            Self::FileExtensionWoff2 => FONT_WOFF2,\n            Self::FileExtensionWpd => APPLICATION_VND_WORDPERFECT,\n            Self::FileExtensionWpl => APPLICATION_VND_MS_WPL,\n            Self::FileExtensionWps => APPLICATION_VND_MS_WORKS,\n            Self::FileExtensionWqd => APPLICATION_VND_WQD,\n            Self::FileExtensionWri => APPLICATION_X_MSWRITE,\n            Self::FileExtensionWrl => MODEL_VRML,\n            Self::FileExtensionWsdl => APPLICATION_WSDL_XML,\n            Self::FileExtensionWspolicy => APPLICATION_WSPOLICY_XML,\n            Self::FileExtensionWtb => APPLICATION_VND_WEBTURBO,\n            Self::FileExtensionWvx => VIDEO_X_MS_WVX,\n            Self::FileExtensionX32 => APPLICATION_X_AUTHORWARE_BIN,\n            Self::FileExtensionX3d => MODEL_X3D_XML,\n            Self::FileExtensionX3db => MODEL_X3D_BINARY,\n            Self::FileExtensionX3dbz => MODEL_X3D_BINARY,\n            Self::FileExtensionX3dv => MODEL_X3D_VRML,\n            Self::FileExtensionX3dvz => MODEL_X3D_VRML,\n            Self::FileExtensionX3dz => MODEL_X3D_XML,\n            Self::FileExtensionXaml => APPLICATION_XAML_XML,\n            Self::FileExtensionXap => APPLICATION_X_SILVERLIGHT_APP,\n            Self::FileExtensionXar => APPLICATION_VND_XARA,\n            Self::FileExtensionXbap => APPLICATION_X_MS_XBAP,\n            Self::FileExtensionXbd => APPLICATION_VND_FUJIXEROX_DOCUWORKS_BINDER,\n            Self::FileExtensionXbm => IMAGE_X_XBITMAP,\n            Self::FileExtensionXdf => APPLICATION_XCAP_DIFF_XML,\n            Self::FileExtensionXdm => APPLICATION_VND_SYNCML_DM_XML,\n            Self::FileExtensionXdp => APPLICATION_VND_ADOBE_XDP_XML,\n            Self::FileExtensionXdssc => APPLICATION_DSSC_XML,\n            Self::FileExtensionXdw => APPLICATION_VND_FUJIXEROX_DOCUWORKS,\n            Self::FileExtensionXenc => APPLICATION_XENC_XML,\n            Self::FileExtensionXer => APPLICATION_PATCH_OPS_ERROR_XML,\n            Self::FileExtensionXfdf => APPLICATION_VND_ADOBE_XFDF,\n            Self::FileExtensionXfdl => APPLICATION_VND_XFDL,\n            Self::FileExtensionXht => APPLICATION_XHTML_XML,\n            Self::FileExtensionXhtml => APPLICATION_XHTML_XML,\n            Self::FileExtensionXhvml => APPLICATION_XV_XML,\n            Self::FileExtensionXif => IMAGE_VND_XIFF,\n            Self::FileExtensionXla => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXlam => APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12,\n            Self::FileExtensionXlc => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXlf => APPLICATION_X_XLIFF_XML,\n            Self::FileExtensionXlm => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXls => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXlsb => APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12,\n            Self::FileExtensionXlsm => APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12,\n            Self::FileExtensionXlsx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET\n            }\n            Self::FileExtensionXlt => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXltm => APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12,\n            Self::FileExtensionXltx => {\n                APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE\n            }\n            Self::FileExtensionXlw => APPLICATION_VND_MS_EXCEL,\n            Self::FileExtensionXm => AUDIO_XM,\n            Self::FileExtensionXml => APPLICATION_XML,\n            Self::FileExtensionXo => APPLICATION_VND_OLPC_SUGAR,\n            Self::FileExtensionXop => APPLICATION_XOP_XML,\n            Self::FileExtensionXpi => APPLICATION_X_XPINSTALL,\n            Self::FileExtensionXpl => APPLICATION_XPROC_XML,\n            Self::FileExtensionXpm => IMAGE_X_XPIXMAP,\n            Self::FileExtensionXpr => APPLICATION_VND_IS_XPR,\n            Self::FileExtensionXps => APPLICATION_VND_MS_XPSDOCUMENT,\n            Self::FileExtensionXpw => APPLICATION_VND_INTERCON_FORMNET,\n            Self::FileExtensionXpx => APPLICATION_VND_INTERCON_FORMNET,\n            Self::FileExtensionXsl => APPLICATION_XML,\n            Self::FileExtensionXslt => APPLICATION_XSLT_XML,\n            Self::FileExtensionXsm => APPLICATION_VND_SYNCML_XML,\n            Self::FileExtensionXspf => APPLICATION_XSPF_XML,\n            Self::FileExtensionXul => APPLICATION_VND_MOZILLA_XUL_XML,\n            Self::FileExtensionXvm => APPLICATION_XV_XML,\n            Self::FileExtensionXvml => APPLICATION_XV_XML,\n            Self::FileExtensionXwd => IMAGE_X_XWINDOWDUMP,\n            Self::FileExtensionXyz => CHEMICAL_X_XYZ,\n            Self::FileExtensionXz => APPLICATION_X_XZ,\n            Self::FileExtensionYang => APPLICATION_YANG,\n            Self::FileExtensionYin => APPLICATION_YIN_XML,\n            Self::FileExtensionZ => APPLICATION_X_COMPRESS,\n            Self::FileExtensionZ1 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ2 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ3 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ4 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ5 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ6 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ7 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZ8 => APPLICATION_X_ZMACHINE,\n            Self::FileExtensionZaz => APPLICATION_VND_ZZAZZ_DECK_XML,\n            Self::FileExtensionZip => APPLICATION_ZIP,\n            Self::FileExtensionZir => APPLICATION_VND_ZUL,\n            Self::FileExtensionZirz => APPLICATION_VND_ZUL,\n            Self::FileExtensionZmm => APPLICATION_VND_HANDHELD_ENTERTAINMENT_XML,\n            Self::FileExtensionEmpty => EMPTY_STR,\n        }\n    }\n}\n\nimpl FromStr for FileExtension {\n    type Err = ();\n\n    /// Parses a string slice into a `FileExtension`.\n    ///\n    /// # Arguments\n    ///\n    /// - `data` - The string slice to parse.\n    ///\n    /// # Returns\n    ///\n    /// A `Result` indicating either the parsed `FileExtension` or an empty error.\n    fn from_str(data: &str) -> Result<Self, Self::Err> {\n        match data.to_ascii_lowercase().as_str() {\n            FILE_EXTENSION_123 => Ok(Self::FileExtension123),\n            FILE_EXTENSION_3DML => Ok(Self::FileExtension3dml),\n            FILE_EXTENSION_3DS => Ok(Self::FileExtension3ds),\n            FILE_EXTENSION_3G2 => Ok(Self::FileExtension3g2),\n            FILE_EXTENSION_3GP => Ok(Self::FileExtension3gp),\n            FILE_EXTENSION_7Z => Ok(Self::FileExtension7z),\n            FILE_EXTENSION_AAB => Ok(Self::FileExtensionAab),\n            FILE_EXTENSION_AAC => Ok(Self::FileExtensionAac),\n            FILE_EXTENSION_AAM => Ok(Self::FileExtensionAam),\n            FILE_EXTENSION_AAS => Ok(Self::FileExtensionAas),\n            FILE_EXTENSION_ABS => Ok(Self::FileExtensionAbs),\n            FILE_EXTENSION_ABW => Ok(Self::FileExtensionAbw),\n            FILE_EXTENSION_AC => Ok(Self::FileExtensionAc),\n            FILE_EXTENSION_ACC => Ok(Self::FileExtensionAcc),\n            FILE_EXTENSION_ACE => Ok(Self::FileExtensionAce),\n            FILE_EXTENSION_ACU => Ok(Self::FileExtensionAcu),\n            FILE_EXTENSION_ACUTC => Ok(Self::FileExtensionAcutc),\n            FILE_EXTENSION_ADP => Ok(Self::FileExtensionAdp),\n            FILE_EXTENSION_AEP => Ok(Self::FileExtensionAep),\n            FILE_EXTENSION_AFM => Ok(Self::FileExtensionAfm),\n            FILE_EXTENSION_AFP => Ok(Self::FileExtensionAfp),\n            FILE_EXTENSION_AHEAD => Ok(Self::FileExtensionAhead),\n            FILE_EXTENSION_AI => Ok(Self::FileExtensionAi),\n            FILE_EXTENSION_AIF => Ok(Self::FileExtensionAif),\n            FILE_EXTENSION_AIFC => Ok(Self::FileExtensionAifc),\n            FILE_EXTENSION_AIFF => Ok(Self::FileExtensionAiff),\n            FILE_EXTENSION_AIM => Ok(Self::FileExtensionAim),\n            FILE_EXTENSION_AIR => Ok(Self::FileExtensionAir),\n            FILE_EXTENSION_AIT => Ok(Self::FileExtensionAit),\n            FILE_EXTENSION_AMI => Ok(Self::FileExtensionAmi),\n            FILE_EXTENSION_ANX => Ok(Self::FileExtensionAnx),\n            FILE_EXTENSION_APK => Ok(Self::FileExtensionApk),\n            FILE_EXTENSION_APPCACHE => Ok(Self::FileExtensionAppcache),\n            FILE_EXTENSION_APPLICATION => Ok(Self::FileExtensionApplication),\n            FILE_EXTENSION_APR => Ok(Self::FileExtensionApr),\n            FILE_EXTENSION_ARC => Ok(Self::FileExtensionArc),\n            FILE_EXTENSION_ART => Ok(Self::FileExtensionArt),\n            FILE_EXTENSION_ASC => Ok(Self::FileExtensionAsc),\n            FILE_EXTENSION_ASF => Ok(Self::FileExtensionAsf),\n            FILE_EXTENSION_ASM => Ok(Self::FileExtensionAsm),\n            FILE_EXTENSION_ASO => Ok(Self::FileExtensionAso),\n            FILE_EXTENSION_ASX => Ok(Self::FileExtensionAsx),\n            FILE_EXTENSION_ATC => Ok(Self::FileExtensionAtc),\n            FILE_EXTENSION_ATOM => Ok(Self::FileExtensionAtom),\n            FILE_EXTENSION_ATOMCAT => Ok(Self::FileExtensionAtomcat),\n            FILE_EXTENSION_ATOMSVC => Ok(Self::FileExtensionAtomsvc),\n            FILE_EXTENSION_ATX => Ok(Self::FileExtensionAtx),\n            FILE_EXTENSION_AU => Ok(Self::FileExtensionAu),\n            FILE_EXTENSION_AVI => Ok(Self::FileExtensionAvi),\n            FILE_EXTENSION_AVX => Ok(Self::FileExtensionAvx),\n            FILE_EXTENSION_AW => Ok(Self::FileExtensionAw),\n            FILE_EXTENSION_AXA => Ok(Self::FileExtensionAxa),\n            FILE_EXTENSION_AXV => Ok(Self::FileExtensionAxv),\n            FILE_EXTENSION_AZF => Ok(Self::FileExtensionAzf),\n            FILE_EXTENSION_AZS => Ok(Self::FileExtensionAzs),\n            FILE_EXTENSION_AZW => Ok(Self::FileExtensionAzw),\n            FILE_EXTENSION_BAT => Ok(Self::FileExtensionBat),\n            FILE_EXTENSION_BCPIO => Ok(Self::FileExtensionBcpio),\n            FILE_EXTENSION_BDF => Ok(Self::FileExtensionBdf),\n            FILE_EXTENSION_BDM => Ok(Self::FileExtensionBdm),\n            FILE_EXTENSION_BED => Ok(Self::FileExtensionBed),\n            FILE_EXTENSION_BH2 => Ok(Self::FileExtensionBh2),\n            FILE_EXTENSION_BIN => Ok(Self::FileExtensionBin),\n            FILE_EXTENSION_BLB => Ok(Self::FileExtensionBlb),\n            FILE_EXTENSION_BLORB => Ok(Self::FileExtensionBlorb),\n            FILE_EXTENSION_BMI => Ok(Self::FileExtensionBmi),\n            FILE_EXTENSION_BMP => Ok(Self::FileExtensionBmp),\n            FILE_EXTENSION_BODY => Ok(Self::FileExtensionBody),\n            FILE_EXTENSION_BOOK => Ok(Self::FileExtensionBook),\n            FILE_EXTENSION_BOX => Ok(Self::FileExtensionBox),\n            FILE_EXTENSION_BOZ => Ok(Self::FileExtensionBoz),\n            FILE_EXTENSION_BPK => Ok(Self::FileExtensionBpk),\n            FILE_EXTENSION_BTIF => Ok(Self::FileExtensionBtif),\n            FILE_EXTENSION_BZ => Ok(Self::FileExtensionBz),\n            FILE_EXTENSION_BZ2 => Ok(Self::FileExtensionBz2),\n            FILE_EXTENSION_C => Ok(Self::FileExtensionC),\n            FILE_EXTENSION_C11AMC => Ok(Self::FileExtensionC11amc),\n            FILE_EXTENSION_C11AMZ => Ok(Self::FileExtensionC11amz),\n            FILE_EXTENSION_C4D => Ok(Self::FileExtensionC4d),\n            FILE_EXTENSION_C4F => Ok(Self::FileExtensionC4f),\n            FILE_EXTENSION_C4G => Ok(Self::FileExtensionC4g),\n            FILE_EXTENSION_C4P => Ok(Self::FileExtensionC4p),\n            FILE_EXTENSION_C4U => Ok(Self::FileExtensionC4u),\n            FILE_EXTENSION_CAB => Ok(Self::FileExtensionCab),\n            FILE_EXTENSION_CAF => Ok(Self::FileExtensionCaf),\n            FILE_EXTENSION_CAP => Ok(Self::FileExtensionCap),\n            FILE_EXTENSION_CAR => Ok(Self::FileExtensionCar),\n            FILE_EXTENSION_CAT => Ok(Self::FileExtensionCat),\n            FILE_EXTENSION_CB7 => Ok(Self::FileExtensionCb7),\n            FILE_EXTENSION_CBA => Ok(Self::FileExtensionCba),\n            FILE_EXTENSION_CBR => Ok(Self::FileExtensionCbr),\n            FILE_EXTENSION_CBT => Ok(Self::FileExtensionCbt),\n            FILE_EXTENSION_CBZ => Ok(Self::FileExtensionCbz),\n            FILE_EXTENSION_CC => Ok(Self::FileExtensionCc),\n            FILE_EXTENSION_CCT => Ok(Self::FileExtensionCct),\n            FILE_EXTENSION_CCXML => Ok(Self::FileExtensionCcxml),\n            FILE_EXTENSION_CDBCMSG => Ok(Self::FileExtensionCdbcmsg),\n            FILE_EXTENSION_CDF => Ok(Self::FileExtensionCdf),\n            FILE_EXTENSION_CDKEY => Ok(Self::FileExtensionCdkey),\n            FILE_EXTENSION_CDMIA => Ok(Self::FileExtensionCdmia),\n            FILE_EXTENSION_CDMIC => Ok(Self::FileExtensionCdmic),\n            FILE_EXTENSION_CDMID => Ok(Self::FileExtensionCdmid),\n            FILE_EXTENSION_CDMIO => Ok(Self::FileExtensionCdmio),\n            FILE_EXTENSION_CDMIQ => Ok(Self::FileExtensionCdmiq),\n            FILE_EXTENSION_CDX => Ok(Self::FileExtensionCdx),\n            FILE_EXTENSION_CDXML => Ok(Self::FileExtensionCdxml),\n            FILE_EXTENSION_CDY => Ok(Self::FileExtensionCdy),\n            FILE_EXTENSION_CER => Ok(Self::FileExtensionCer),\n            FILE_EXTENSION_CFS => Ok(Self::FileExtensionCfs),\n            FILE_EXTENSION_CGM => Ok(Self::FileExtensionCgm),\n            FILE_EXTENSION_CHAT => Ok(Self::FileExtensionChat),\n            FILE_EXTENSION_CHM => Ok(Self::FileExtensionChm),\n            FILE_EXTENSION_CHRT => Ok(Self::FileExtensionChrt),\n            FILE_EXTENSION_CIF => Ok(Self::FileExtensionCif),\n            FILE_EXTENSION_CII => Ok(Self::FileExtensionCii),\n            FILE_EXTENSION_CIL => Ok(Self::FileExtensionCil),\n            FILE_EXTENSION_CLA => Ok(Self::FileExtensionCla),\n            FILE_EXTENSION_CLASS => Ok(Self::FileExtensionClass),\n            FILE_EXTENSION_CLKK => Ok(Self::FileExtensionClkk),\n            FILE_EXTENSION_CLKP => Ok(Self::FileExtensionClkp),\n            FILE_EXTENSION_CLKT => Ok(Self::FileExtensionClkt),\n            FILE_EXTENSION_CLKW => Ok(Self::FileExtensionClkw),\n            FILE_EXTENSION_CLKX => Ok(Self::FileExtensionClkx),\n            FILE_EXTENSION_CLP => Ok(Self::FileExtensionClp),\n            FILE_EXTENSION_CMC => Ok(Self::FileExtensionCmc),\n            FILE_EXTENSION_CMDF => Ok(Self::FileExtensionCmdf),\n            FILE_EXTENSION_CML => Ok(Self::FileExtensionCml),\n            FILE_EXTENSION_CMP => Ok(Self::FileExtensionCmp),\n            FILE_EXTENSION_CMX => Ok(Self::FileExtensionCmx),\n            FILE_EXTENSION_COD => Ok(Self::FileExtensionCod),\n            FILE_EXTENSION_COM => Ok(Self::FileExtensionCom),\n            FILE_EXTENSION_CONF => Ok(Self::FileExtensionConf),\n            FILE_EXTENSION_CPIO => Ok(Self::FileExtensionCpio),\n            FILE_EXTENSION_CPP => Ok(Self::FileExtensionCpp),\n            FILE_EXTENSION_CPT => Ok(Self::FileExtensionCpt),\n            FILE_EXTENSION_CRD => Ok(Self::FileExtensionCrd),\n            FILE_EXTENSION_CRL => Ok(Self::FileExtensionCrl),\n            FILE_EXTENSION_CRT => Ok(Self::FileExtensionCrt),\n            FILE_EXTENSION_CRYPTONOTE => Ok(Self::FileExtensionCryptonote),\n            FILE_EXTENSION_CSH => Ok(Self::FileExtensionCsh),\n            FILE_EXTENSION_CSML => Ok(Self::FileExtensionCsml),\n            FILE_EXTENSION_CSP => Ok(Self::FileExtensionCsp),\n            FILE_EXTENSION_CSS => Ok(Self::FileExtensionCss),\n            FILE_EXTENSION_CST => Ok(Self::FileExtensionCst),\n            FILE_EXTENSION_CSV => Ok(Self::FileExtensionCsv),\n            FILE_EXTENSION_CU => Ok(Self::FileExtensionCu),\n            FILE_EXTENSION_CURL => Ok(Self::FileExtensionCurl),\n            FILE_EXTENSION_CWW => Ok(Self::FileExtensionCww),\n            FILE_EXTENSION_CXT => Ok(Self::FileExtensionCxt),\n            FILE_EXTENSION_CXX => Ok(Self::FileExtensionCxx),\n            FILE_EXTENSION_DAE => Ok(Self::FileExtensionDae),\n            FILE_EXTENSION_DAF => Ok(Self::FileExtensionDaf),\n            FILE_EXTENSION_DART => Ok(Self::FileExtensionDart),\n            FILE_EXTENSION_DATALESS => Ok(Self::FileExtensionDataless),\n            FILE_EXTENSION_DAVMOUNT => Ok(Self::FileExtensionDavmount),\n            FILE_EXTENSION_DBK => Ok(Self::FileExtensionDbk),\n            FILE_EXTENSION_DCR => Ok(Self::FileExtensionDcr),\n            FILE_EXTENSION_DCURL => Ok(Self::FileExtensionDcurl),\n            FILE_EXTENSION_DD2 => Ok(Self::FileExtensionDd2),\n            FILE_EXTENSION_DDD => Ok(Self::FileExtensionDdd),\n            FILE_EXTENSION_DEB => Ok(Self::FileExtensionDeb),\n            FILE_EXTENSION_DEF => Ok(Self::FileExtensionDef),\n            FILE_EXTENSION_DEPLOY => Ok(Self::FileExtensionDeploy),\n            FILE_EXTENSION_DER => Ok(Self::FileExtensionDer),\n            FILE_EXTENSION_DFAC => Ok(Self::FileExtensionDfac),\n            FILE_EXTENSION_DGC => Ok(Self::FileExtensionDgc),\n            FILE_EXTENSION_DIB => Ok(Self::FileExtensionDib),\n            FILE_EXTENSION_DIC => Ok(Self::FileExtensionDic),\n            FILE_EXTENSION_DIR => Ok(Self::FileExtensionDir),\n            FILE_EXTENSION_DIS => Ok(Self::FileExtensionDis),\n            FILE_EXTENSION_DIST => Ok(Self::FileExtensionDist),\n            FILE_EXTENSION_DISTZ => Ok(Self::FileExtensionDistz),\n            FILE_EXTENSION_DJV => Ok(Self::FileExtensionDjv),\n            FILE_EXTENSION_DJVU => Ok(Self::FileExtensionDjvu),\n            FILE_EXTENSION_DLL => Ok(Self::FileExtensionDll),\n            FILE_EXTENSION_DMG => Ok(Self::FileExtensionDmg),\n            FILE_EXTENSION_DMP => Ok(Self::FileExtensionDmp),\n            FILE_EXTENSION_DMS => Ok(Self::FileExtensionDms),\n            FILE_EXTENSION_DNA => Ok(Self::FileExtensionDna),\n            FILE_EXTENSION_DOC => Ok(Self::FileExtensionDoc),\n            FILE_EXTENSION_DOCM => Ok(Self::FileExtensionDocm),\n            FILE_EXTENSION_DOCX => Ok(Self::FileExtensionDocx),\n            FILE_EXTENSION_DOT => Ok(Self::FileExtensionDot),\n            FILE_EXTENSION_DOTM => Ok(Self::FileExtensionDotm),\n            FILE_EXTENSION_DOTX => Ok(Self::FileExtensionDotx),\n            FILE_EXTENSION_DP => Ok(Self::FileExtensionDp),\n            FILE_EXTENSION_DPG => Ok(Self::FileExtensionDpg),\n            FILE_EXTENSION_DRA => Ok(Self::FileExtensionDra),\n            FILE_EXTENSION_DSC => Ok(Self::FileExtensionDsc),\n            FILE_EXTENSION_DSSC => Ok(Self::FileExtensionDssc),\n            FILE_EXTENSION_DTB => Ok(Self::FileExtensionDtb),\n            FILE_EXTENSION_DTD => Ok(Self::FileExtensionDtd),\n            FILE_EXTENSION_DTS => Ok(Self::FileExtensionDts),\n            FILE_EXTENSION_DTSHD => Ok(Self::FileExtensionDtshd),\n            FILE_EXTENSION_DUMP => Ok(Self::FileExtensionDump),\n            FILE_EXTENSION_DV => Ok(Self::FileExtensionDv),\n            FILE_EXTENSION_DVB => Ok(Self::FileExtensionDvb),\n            FILE_EXTENSION_DVI => Ok(Self::FileExtensionDvi),\n            FILE_EXTENSION_DWF => Ok(Self::FileExtensionDwf),\n            FILE_EXTENSION_DWG => Ok(Self::FileExtensionDwg),\n            FILE_EXTENSION_DXF => Ok(Self::FileExtensionDxf),\n            FILE_EXTENSION_DXP => Ok(Self::FileExtensionDxp),\n            FILE_EXTENSION_DXR => Ok(Self::FileExtensionDxr),\n            FILE_EXTENSION_ECELP4800 => Ok(Self::FileExtensionEcelp4800),\n            FILE_EXTENSION_ECELP7470 => Ok(Self::FileExtensionEcelp7470),\n            FILE_EXTENSION_ECELP9600 => Ok(Self::FileExtensionEcelp9600),\n            FILE_EXTENSION_ECMA => Ok(Self::FileExtensionEcma),\n            FILE_EXTENSION_EDM => Ok(Self::FileExtensionEdm),\n            FILE_EXTENSION_EDX => Ok(Self::FileExtensionEdx),\n            FILE_EXTENSION_EFIF => Ok(Self::FileExtensionEfif),\n            FILE_EXTENSION_EI6 => Ok(Self::FileExtensionEi6),\n            FILE_EXTENSION_ELC => Ok(Self::FileExtensionElc),\n            FILE_EXTENSION_EMF => Ok(Self::FileExtensionEmf),\n            FILE_EXTENSION_EML => Ok(Self::FileExtensionEml),\n            FILE_EXTENSION_EMMA => Ok(Self::FileExtensionEmma),\n            FILE_EXTENSION_EMZ => Ok(Self::FileExtensionEmz),\n            FILE_EXTENSION_EOL => Ok(Self::FileExtensionEol),\n            FILE_EXTENSION_EOT => Ok(Self::FileExtensionEot),\n            FILE_EXTENSION_EPS => Ok(Self::FileExtensionEps),\n            FILE_EXTENSION_EPUB => Ok(Self::FileExtensionEpub),\n            FILE_EXTENSION_ES3 => Ok(Self::FileExtensionEs3),\n            FILE_EXTENSION_ESA => Ok(Self::FileExtensionEsa),\n            FILE_EXTENSION_ESF => Ok(Self::FileExtensionEsf),\n            FILE_EXTENSION_ET3 => Ok(Self::FileExtensionEt3),\n            FILE_EXTENSION_ETX => Ok(Self::FileExtensionEtx),\n            FILE_EXTENSION_EVA => Ok(Self::FileExtensionEva),\n            FILE_EXTENSION_EVY => Ok(Self::FileExtensionEvy),\n            FILE_EXTENSION_EXE => Ok(Self::FileExtensionExe),\n            FILE_EXTENSION_EXI => Ok(Self::FileExtensionExi),\n            FILE_EXTENSION_EXT => Ok(Self::FileExtensionExt),\n            FILE_EXTENSION_EZ => Ok(Self::FileExtensionEz),\n            FILE_EXTENSION_EZ2 => Ok(Self::FileExtensionEz2),\n            FILE_EXTENSION_EZ3 => Ok(Self::FileExtensionEz3),\n            FILE_EXTENSION_F => Ok(Self::FileExtensionF),\n            FILE_EXTENSION_F4V => Ok(Self::FileExtensionF4v),\n            FILE_EXTENSION_F77 => Ok(Self::FileExtensionF77),\n            FILE_EXTENSION_F90 => Ok(Self::FileExtensionF90),\n            FILE_EXTENSION_FBS => Ok(Self::FileExtensionFbs),\n            FILE_EXTENSION_FCDT => Ok(Self::FileExtensionFcdt),\n            FILE_EXTENSION_FCS => Ok(Self::FileExtensionFcs),\n            FILE_EXTENSION_FDF => Ok(Self::FileExtensionFdf),\n            FILE_EXTENSION_FE_LAUNCH => Ok(Self::FileExtensionFeLaunch),\n            FILE_EXTENSION_FG5 => Ok(Self::FileExtensionFg5),\n            FILE_EXTENSION_FGD => Ok(Self::FileExtensionFgd),\n            FILE_EXTENSION_FH => Ok(Self::FileExtensionFh),\n            FILE_EXTENSION_FH4 => Ok(Self::FileExtensionFh4),\n            FILE_EXTENSION_FH5 => Ok(Self::FileExtensionFh5),\n            FILE_EXTENSION_FH7 => Ok(Self::FileExtensionFh7),\n            FILE_EXTENSION_FHC => Ok(Self::FileExtensionFhc),\n            FILE_EXTENSION_FIG => Ok(Self::FileExtensionFig),\n            FILE_EXTENSION_FLAC => Ok(Self::FileExtensionFlac),\n            FILE_EXTENSION_FLI => Ok(Self::FileExtensionFli),\n            FILE_EXTENSION_FLO => Ok(Self::FileExtensionFlo),\n            FILE_EXTENSION_FLV => Ok(Self::FileExtensionFlv),\n            FILE_EXTENSION_FLW => Ok(Self::FileExtensionFlw),\n            FILE_EXTENSION_FLX => Ok(Self::FileExtensionFlx),\n            FILE_EXTENSION_FLY => Ok(Self::FileExtensionFly),\n            FILE_EXTENSION_FM => Ok(Self::FileExtensionFm),\n            FILE_EXTENSION_FNC => Ok(Self::FileExtensionFnc),\n            FILE_EXTENSION_FOR => Ok(Self::FileExtensionFor),\n            FILE_EXTENSION_FPX => Ok(Self::FileExtensionFpx),\n            FILE_EXTENSION_FRAME => Ok(Self::FileExtensionFrame),\n            FILE_EXTENSION_FSC => Ok(Self::FileExtensionFsc),\n            FILE_EXTENSION_FST => Ok(Self::FileExtensionFst),\n            FILE_EXTENSION_FTC => Ok(Self::FileExtensionFtc),\n            FILE_EXTENSION_FTI => Ok(Self::FileExtensionFti),\n            FILE_EXTENSION_FVT => Ok(Self::FileExtensionFvt),\n            FILE_EXTENSION_FXP => Ok(Self::FileExtensionFxp),\n            FILE_EXTENSION_FXPL => Ok(Self::FileExtensionFxpl),\n            FILE_EXTENSION_FZS => Ok(Self::FileExtensionFzs),\n            FILE_EXTENSION_G2W => Ok(Self::FileExtensionG2w),\n            FILE_EXTENSION_G3 => Ok(Self::FileExtensionG3),\n            FILE_EXTENSION_G3W => Ok(Self::FileExtensionG3w),\n            FILE_EXTENSION_GAC => Ok(Self::FileExtensionGac),\n            FILE_EXTENSION_GAM => Ok(Self::FileExtensionGam),\n            FILE_EXTENSION_GBR => Ok(Self::FileExtensionGbr),\n            FILE_EXTENSION_GCA => Ok(Self::FileExtensionGca),\n            FILE_EXTENSION_GDL => Ok(Self::FileExtensionGdl),\n            FILE_EXTENSION_GEO => Ok(Self::FileExtensionGeo),\n            FILE_EXTENSION_GEX => Ok(Self::FileExtensionGex),\n            FILE_EXTENSION_GGB => Ok(Self::FileExtensionGgb),\n            FILE_EXTENSION_GGT => Ok(Self::FileExtensionGgt),\n            FILE_EXTENSION_GHF => Ok(Self::FileExtensionGhf),\n            FILE_EXTENSION_GIF => Ok(Self::FileExtensionGif),\n            FILE_EXTENSION_GIM => Ok(Self::FileExtensionGim),\n            FILE_EXTENSION_GML => Ok(Self::FileExtensionGml),\n            FILE_EXTENSION_GMX => Ok(Self::FileExtensionGmx),\n            FILE_EXTENSION_GNUMERIC => Ok(Self::FileExtensionGnumeric),\n            FILE_EXTENSION_GPH => Ok(Self::FileExtensionGph),\n            FILE_EXTENSION_GPX => Ok(Self::FileExtensionGpx),\n            FILE_EXTENSION_GQF => Ok(Self::FileExtensionGqf),\n            FILE_EXTENSION_GQS => Ok(Self::FileExtensionGqs),\n            FILE_EXTENSION_GRAM => Ok(Self::FileExtensionGram),\n            FILE_EXTENSION_GRAMPS => Ok(Self::FileExtensionGramps),\n            FILE_EXTENSION_GRE => Ok(Self::FileExtensionGre),\n            FILE_EXTENSION_GRV => Ok(Self::FileExtensionGrv),\n            FILE_EXTENSION_GRXML => Ok(Self::FileExtensionGrxml),\n            FILE_EXTENSION_GSF => Ok(Self::FileExtensionGsf),\n            FILE_EXTENSION_GTAR => Ok(Self::FileExtensionGtar),\n            FILE_EXTENSION_GTM => Ok(Self::FileExtensionGtm),\n            FILE_EXTENSION_GTW => Ok(Self::FileExtensionGtw),\n            FILE_EXTENSION_GV => Ok(Self::FileExtensionGv),\n            FILE_EXTENSION_GXF => Ok(Self::FileExtensionGxf),\n            FILE_EXTENSION_GXT => Ok(Self::FileExtensionGxt),\n            FILE_EXTENSION_GZ => Ok(Self::FileExtensionGz),\n            FILE_EXTENSION_H => Ok(Self::FileExtensionH),\n            FILE_EXTENSION_H261 => Ok(Self::FileExtensionH261),\n            FILE_EXTENSION_H263 => Ok(Self::FileExtensionH263),\n            FILE_EXTENSION_H264 => Ok(Self::FileExtensionH264),\n            FILE_EXTENSION_HAL => Ok(Self::FileExtensionHal),\n            FILE_EXTENSION_HBCI => Ok(Self::FileExtensionHbci),\n            FILE_EXTENSION_HDF => Ok(Self::FileExtensionHdf),\n            FILE_EXTENSION_HH => Ok(Self::FileExtensionHh),\n            FILE_EXTENSION_HLP => Ok(Self::FileExtensionHlp),\n            FILE_EXTENSION_HPGL => Ok(Self::FileExtensionHpgl),\n            FILE_EXTENSION_HPID => Ok(Self::FileExtensionHpid),\n            FILE_EXTENSION_HPS => Ok(Self::FileExtensionHps),\n            FILE_EXTENSION_HQX => Ok(Self::FileExtensionHqx),\n            FILE_EXTENSION_HTC => Ok(Self::FileExtensionHtc),\n            FILE_EXTENSION_HTKE => Ok(Self::FileExtensionHtke),\n            FILE_EXTENSION_HTM => Ok(Self::FileExtensionHtm),\n            FILE_EXTENSION_HTML => Ok(Self::FileExtensionHtml),\n            FILE_EXTENSION_HVD => Ok(Self::FileExtensionHvd),\n            FILE_EXTENSION_HVP => Ok(Self::FileExtensionHvp),\n            FILE_EXTENSION_HVS => Ok(Self::FileExtensionHvs),\n            FILE_EXTENSION_I2G => Ok(Self::FileExtensionI2g),\n            FILE_EXTENSION_ICC => Ok(Self::FileExtensionIcc),\n            FILE_EXTENSION_ICE => Ok(Self::FileExtensionIce),\n            FILE_EXTENSION_ICM => Ok(Self::FileExtensionIcm),\n            FILE_EXTENSION_ICO => Ok(Self::FileExtensionIco),\n            FILE_EXTENSION_ICS => Ok(Self::FileExtensionIcs),\n            FILE_EXTENSION_IEF => Ok(Self::FileExtensionIef),\n            FILE_EXTENSION_IFB => Ok(Self::FileExtensionIfb),\n            FILE_EXTENSION_IFM => Ok(Self::FileExtensionIfm),\n            FILE_EXTENSION_IGES => Ok(Self::FileExtensionIges),\n            FILE_EXTENSION_IGL => Ok(Self::FileExtensionIgl),\n            FILE_EXTENSION_IGM => Ok(Self::FileExtensionIgm),\n            FILE_EXTENSION_IGS => Ok(Self::FileExtensionIgs),\n            FILE_EXTENSION_IGX => Ok(Self::FileExtensionIgx),\n            FILE_EXTENSION_IIF => Ok(Self::FileExtensionIif),\n            FILE_EXTENSION_IMP => Ok(Self::FileExtensionImp),\n            FILE_EXTENSION_IMS => Ok(Self::FileExtensionIms),\n            FILE_EXTENSION_IN => Ok(Self::FileExtensionIn),\n            FILE_EXTENSION_INK => Ok(Self::FileExtensionInk),\n            FILE_EXTENSION_INKML => Ok(Self::FileExtensionInkml),\n            FILE_EXTENSION_INSTALL => Ok(Self::FileExtensionInstall),\n            FILE_EXTENSION_IOTA => Ok(Self::FileExtensionIota),\n            FILE_EXTENSION_IPFIX => Ok(Self::FileExtensionIpfix),\n            FILE_EXTENSION_IPK => Ok(Self::FileExtensionIpk),\n            FILE_EXTENSION_IRM => Ok(Self::FileExtensionIrm),\n            FILE_EXTENSION_IRP => Ok(Self::FileExtensionIrp),\n            FILE_EXTENSION_ISO => Ok(Self::FileExtensionIso),\n            FILE_EXTENSION_ITP => Ok(Self::FileExtensionItp),\n            FILE_EXTENSION_IVP => Ok(Self::FileExtensionIvp),\n            FILE_EXTENSION_IVU => Ok(Self::FileExtensionIvu),\n            FILE_EXTENSION_JAD => Ok(Self::FileExtensionJad),\n            FILE_EXTENSION_JAM => Ok(Self::FileExtensionJam),\n            FILE_EXTENSION_JAR => Ok(Self::FileExtensionJar),\n            FILE_EXTENSION_JAVA => Ok(Self::FileExtensionJava),\n            FILE_EXTENSION_JISP => Ok(Self::FileExtensionJisp),\n            FILE_EXTENSION_JLT => Ok(Self::FileExtensionJlt),\n            FILE_EXTENSION_JNLP => Ok(Self::FileExtensionJnlp),\n            FILE_EXTENSION_JODA => Ok(Self::FileExtensionJoda),\n            FILE_EXTENSION_JPE => Ok(Self::FileExtensionJpe),\n            FILE_EXTENSION_JPEG => Ok(Self::FileExtensionJpeg),\n            FILE_EXTENSION_JPG => Ok(Self::FileExtensionJpg),\n            FILE_EXTENSION_JPGM => Ok(Self::FileExtensionJpgm),\n            FILE_EXTENSION_JPGV => Ok(Self::FileExtensionJpgv),\n            FILE_EXTENSION_JPM => Ok(Self::FileExtensionJpm),\n            FILE_EXTENSION_JS => Ok(Self::FileExtensionJs),\n            FILE_EXTENSION_JSF => Ok(Self::FileExtensionJsf),\n            FILE_EXTENSION_JSON => Ok(Self::FileExtensionJson),\n            FILE_EXTENSION_JSONML => Ok(Self::FileExtensionJsonml),\n            FILE_EXTENSION_JSPF => Ok(Self::FileExtensionJspf),\n            FILE_EXTENSION_KAR => Ok(Self::FileExtensionKar),\n            FILE_EXTENSION_KARBON => Ok(Self::FileExtensionKarbon),\n            FILE_EXTENSION_KFO => Ok(Self::FileExtensionKfo),\n            FILE_EXTENSION_KIA => Ok(Self::FileExtensionKia),\n            FILE_EXTENSION_KML => Ok(Self::FileExtensionKml),\n            FILE_EXTENSION_KMZ => Ok(Self::FileExtensionKmz),\n            FILE_EXTENSION_KNE => Ok(Self::FileExtensionKne),\n            FILE_EXTENSION_KNP => Ok(Self::FileExtensionKnp),\n            FILE_EXTENSION_KON => Ok(Self::FileExtensionKon),\n            FILE_EXTENSION_KPR => Ok(Self::FileExtensionKpr),\n            FILE_EXTENSION_KPT => Ok(Self::FileExtensionKpt),\n            FILE_EXTENSION_KPXX => Ok(Self::FileExtensionKpxx),\n            FILE_EXTENSION_KSP => Ok(Self::FileExtensionKsp),\n            FILE_EXTENSION_KTR => Ok(Self::FileExtensionKtr),\n            FILE_EXTENSION_KTX => Ok(Self::FileExtensionKtx),\n            FILE_EXTENSION_KTZ => Ok(Self::FileExtensionKtz),\n            FILE_EXTENSION_KWD => Ok(Self::FileExtensionKwd),\n            FILE_EXTENSION_KWT => Ok(Self::FileExtensionKwt),\n            FILE_EXTENSION_LASXML => Ok(Self::FileExtensionLasxml),\n            FILE_EXTENSION_LATEX => Ok(Self::FileExtensionLatex),\n            FILE_EXTENSION_LBD => Ok(Self::FileExtensionLbd),\n            FILE_EXTENSION_LBE => Ok(Self::FileExtensionLbe),\n            FILE_EXTENSION_LES => Ok(Self::FileExtensionLes),\n            FILE_EXTENSION_LHA => Ok(Self::FileExtensionLha),\n            FILE_EXTENSION_LINK66 => Ok(Self::FileExtensionLink66),\n            FILE_EXTENSION_LIST => Ok(Self::FileExtensionList),\n            FILE_EXTENSION_LIST3820 => Ok(Self::FileExtensionList3820),\n            FILE_EXTENSION_LISTAFP => Ok(Self::FileExtensionListafp),\n            FILE_EXTENSION_LNK => Ok(Self::FileExtensionLnk),\n            FILE_EXTENSION_LOG => Ok(Self::FileExtensionLog),\n            FILE_EXTENSION_LOSTXML => Ok(Self::FileExtensionLostxml),\n            FILE_EXTENSION_LRF => Ok(Self::FileExtensionLrf),\n            FILE_EXTENSION_LRM => Ok(Self::FileExtensionLrm),\n            FILE_EXTENSION_LTF => Ok(Self::FileExtensionLtf),\n            FILE_EXTENSION_LVP => Ok(Self::FileExtensionLvp),\n            FILE_EXTENSION_LWP => Ok(Self::FileExtensionLwp),\n            FILE_EXTENSION_LZH => Ok(Self::FileExtensionLzh),\n            FILE_EXTENSION_M13 => Ok(Self::FileExtensionM13),\n            FILE_EXTENSION_M14 => Ok(Self::FileExtensionM14),\n            FILE_EXTENSION_M1V => Ok(Self::FileExtensionM1v),\n            FILE_EXTENSION_M21 => Ok(Self::FileExtensionM21),\n            FILE_EXTENSION_M2A => Ok(Self::FileExtensionM2a),\n            FILE_EXTENSION_M2V => Ok(Self::FileExtensionM2v),\n            FILE_EXTENSION_M3A => Ok(Self::FileExtensionM3a),\n            FILE_EXTENSION_M3U => Ok(Self::FileExtensionM3u),\n            FILE_EXTENSION_M3U8 => Ok(Self::FileExtensionM3u8),\n            FILE_EXTENSION_M4A => Ok(Self::FileExtensionM4a),\n            FILE_EXTENSION_M4B => Ok(Self::FileExtensionM4b),\n            FILE_EXTENSION_M4R => Ok(Self::FileExtensionM4r),\n            FILE_EXTENSION_M4U => Ok(Self::FileExtensionM4u),\n            FILE_EXTENSION_M4V => Ok(Self::FileExtensionM4v),\n            FILE_EXTENSION_MARKDOWN => Ok(Self::FileExtensionMarkdown),\n            FILE_EXTENSION_TOML => Ok(Self::FileExtensionToml),\n            FILE_EXTENSION_YAML => Ok(Self::FileExtensionYaml),\n            FILE_EXTENSION_YML => Ok(Self::FileExtensionYml),\n            FILE_EXTENSION_INI => Ok(Self::FileExtensionIni),\n            FILE_EXTENSION_CFG => Ok(Self::FileExtensionCfg),\n            FILE_EXTENSION_PY => Ok(Self::FileExtensionPython),\n            FILE_EXTENSION_GO => Ok(Self::FileExtensionGo),\n            FILE_EXTENSION_TS => Ok(Self::FileExtensionTypeScript),\n            FILE_EXTENSION_CS => Ok(Self::FileExtensionCSharp),\n            FILE_EXTENSION_PHP => Ok(Self::FileExtensionPhp),\n            FILE_EXTENSION_RB => Ok(Self::FileExtensionRuby),\n            FILE_EXTENSION_SWIFT => Ok(Self::FileExtensionSwift),\n            FILE_EXTENSION_KT => Ok(Self::FileExtensionKotlin),\n            FILE_EXTENSION_KTS => Ok(Self::FileExtensionKotlinScript),\n            FILE_EXTENSION_SCALA => Ok(Self::FileExtensionScala),\n            FILE_EXTENSION_SC => Ok(Self::FileExtensionIbmScOrScalaScript),\n            FILE_EXTENSION_PL => Ok(Self::FileExtensionPerl),\n            FILE_EXTENSION_PM => Ok(Self::FileExtensionPerlModule),\n            FILE_EXTENSION_LUA => Ok(Self::FileExtensionLua),\n            FILE_EXTENSION_PS1 => Ok(Self::FileExtensionPowerShell),\n            FILE_EXTENSION_HPP => Ok(Self::FileExtensionCppHeader),\n            FILE_EXTENSION_M => Ok(Self::FileExtensionObjectiveC),\n            FILE_EXTENSION_MM => Ok(Self::FileExtensionObjectiveCpp),\n            FILE_EXTENSION_GROOVY => Ok(Self::FileExtensionGroovy),\n            FILE_EXTENSION_R => Ok(Self::FileExtensionR),\n            FILE_EXTENSION_SCSS => Ok(Self::FileExtensionScss),\n            FILE_EXTENSION_SASS => Ok(Self::FileExtensionSass),\n            FILE_EXTENSION_LESS => Ok(Self::FileExtensionLess),\n            FILE_EXTENSION_VUE => Ok(Self::FileExtensionVue),\n            FILE_EXTENSION_JSX => Ok(Self::FileExtensionJsx),\n            FILE_EXTENSION_TSX => Ok(Self::FileExtensionTsx),\n            FILE_EXTENSION_DOCKERFILE => Ok(Self::FileExtensionDockerfile),\n            FILE_EXTENSION_MAKEFILE => Ok(Self::FileExtensionMakefile),\n            FILE_EXTENSION_RS => Ok(Self::FileExtensionRs),\n            FILE_EXTENSION_HS => Ok(Self::FileExtensionHaskell),\n            FILE_EXTENSION_ERL => Ok(Self::FileExtensionErlang),\n            FILE_EXTENSION_EX => Ok(Self::FileExtensionElixir),\n            FILE_EXTENSION_EXS => Ok(Self::FileExtensionElixirScript),\n            FILE_EXTENSION_CLJ => Ok(Self::FileExtensionClojure),\n            FILE_EXTENSION_CLJS => Ok(Self::FileExtensionClojureScript),\n            FILE_EXTENSION_CLJC => Ok(Self::FileExtensionClojureCommon),\n            FILE_EXTENSION_FS => Ok(Self::FileExtensionFSharp),\n            FILE_EXTENSION_FSX => Ok(Self::FileExtensionFSharpScript),\n            FILE_EXTENSION_ML => Ok(Self::FileExtensionOCaml),\n            FILE_EXTENSION_MLI => Ok(Self::FileExtensionOCamlInterface),\n            FILE_EXTENSION_BASH => Ok(Self::FileExtensionBash),\n            FILE_EXTENSION_ZSH => Ok(Self::FileExtensionZsh),\n            FILE_EXTENSION_ENV => Ok(Self::FileExtensionEnv),\n            FILE_EXTENSION_CJ => Ok(Self::FileExtensionCj),\n            FILE_EXTENSION_GITIGNORE => Ok(Self::FileExtensionGitignore),\n            FILE_EXTENSION_MA => Ok(Self::FileExtensionMa),\n            FILE_EXTENSION_MAC => Ok(Self::FileExtensionMac),\n            FILE_EXTENSION_MADS => Ok(Self::FileExtensionMads),\n            FILE_EXTENSION_MAG => Ok(Self::FileExtensionMag),\n            FILE_EXTENSION_MAKER => Ok(Self::FileExtensionMaker),\n            FILE_EXTENSION_MAN => Ok(Self::FileExtensionMan),\n            FILE_EXTENSION_MAR => Ok(Self::FileExtensionMar),\n            FILE_EXTENSION_MATHML => Ok(Self::FileExtensionMathml),\n            FILE_EXTENSION_MB => Ok(Self::FileExtensionMb),\n            FILE_EXTENSION_MBK => Ok(Self::FileExtensionMbk),\n            FILE_EXTENSION_MBOX => Ok(Self::FileExtensionMbox),\n            FILE_EXTENSION_MC1 => Ok(Self::FileExtensionMc1),\n            FILE_EXTENSION_MCD => Ok(Self::FileExtensionMcd),\n            FILE_EXTENSION_MCURL => Ok(Self::FileExtensionMcurl),\n            FILE_EXTENSION_MDB => Ok(Self::FileExtensionMdb),\n            FILE_EXTENSION_MDI => Ok(Self::FileExtensionMdi),\n            FILE_EXTENSION_ME => Ok(Self::FileExtensionMe),\n            FILE_EXTENSION_MESH => Ok(Self::FileExtensionMesh),\n            FILE_EXTENSION_META4 => Ok(Self::FileExtensionMeta4),\n            FILE_EXTENSION_METALINK => Ok(Self::FileExtensionMetalink),\n            FILE_EXTENSION_METS => Ok(Self::FileExtensionMets),\n            FILE_EXTENSION_MFM => Ok(Self::FileExtensionMfm),\n            FILE_EXTENSION_MFT => Ok(Self::FileExtensionMft),\n            FILE_EXTENSION_MGP => Ok(Self::FileExtensionMgp),\n            FILE_EXTENSION_MGZ => Ok(Self::FileExtensionMgz),\n            FILE_EXTENSION_MID => Ok(Self::FileExtensionMid),\n            FILE_EXTENSION_MIDI => Ok(Self::FileExtensionMidi),\n            FILE_EXTENSION_MIE => Ok(Self::FileExtensionMie),\n            FILE_EXTENSION_MIF => Ok(Self::FileExtensionMif),\n            FILE_EXTENSION_MIME => Ok(Self::FileExtensionMime),\n            FILE_EXTENSION_MJ2 => Ok(Self::FileExtensionMj2),\n            FILE_EXTENSION_MJP2 => Ok(Self::FileExtensionMjp2),\n            FILE_EXTENSION_MK3D => Ok(Self::FileExtensionMk3d),\n            FILE_EXTENSION_MKA => Ok(Self::FileExtensionMka),\n            FILE_EXTENSION_MKS => Ok(Self::FileExtensionMks),\n            FILE_EXTENSION_MKV => Ok(Self::FileExtensionMkv),\n            FILE_EXTENSION_MLP => Ok(Self::FileExtensionMlp),\n            FILE_EXTENSION_MMD => Ok(Self::FileExtensionMmd),\n            FILE_EXTENSION_MMF => Ok(Self::FileExtensionMmf),\n            FILE_EXTENSION_MMR => Ok(Self::FileExtensionMmr),\n            FILE_EXTENSION_MNG => Ok(Self::FileExtensionMng),\n            FILE_EXTENSION_MNY => Ok(Self::FileExtensionMny),\n            FILE_EXTENSION_MOBI => Ok(Self::FileExtensionMobi),\n            FILE_EXTENSION_MODS => Ok(Self::FileExtensionMods),\n            FILE_EXTENSION_MOV => Ok(Self::FileExtensionMov),\n            FILE_EXTENSION_MOVIE => Ok(Self::FileExtensionMovie),\n            FILE_EXTENSION_MP1 => Ok(Self::FileExtensionMp1),\n            FILE_EXTENSION_MP2 => Ok(Self::FileExtensionMp2),\n            FILE_EXTENSION_MP21 => Ok(Self::FileExtensionMp21),\n            FILE_EXTENSION_MP2A => Ok(Self::FileExtensionMp2a),\n            FILE_EXTENSION_MP3 => Ok(Self::FileExtensionMp3),\n            FILE_EXTENSION_MP4 => Ok(Self::FileExtensionMp4),\n            FILE_EXTENSION_MP4A => Ok(Self::FileExtensionMp4a),\n            FILE_EXTENSION_MP4S => Ok(Self::FileExtensionMp4s),\n            FILE_EXTENSION_MP4V => Ok(Self::FileExtensionMp4v),\n            FILE_EXTENSION_MPA => Ok(Self::FileExtensionMpa),\n            FILE_EXTENSION_MPC => Ok(Self::FileExtensionMpc),\n            FILE_EXTENSION_MPE => Ok(Self::FileExtensionMpe),\n            FILE_EXTENSION_MPEG => Ok(Self::FileExtensionMpeg),\n            FILE_EXTENSION_MPEGA => Ok(Self::FileExtensionMpega),\n            FILE_EXTENSION_MPG => Ok(Self::FileExtensionMpg),\n            FILE_EXTENSION_MPG4 => Ok(Self::FileExtensionMpg4),\n            FILE_EXTENSION_MPGA => Ok(Self::FileExtensionMpga),\n            FILE_EXTENSION_MPKG => Ok(Self::FileExtensionMpkg),\n            FILE_EXTENSION_MPM => Ok(Self::FileExtensionMpm),\n            FILE_EXTENSION_MPN => Ok(Self::FileExtensionMpn),\n            FILE_EXTENSION_MPP => Ok(Self::FileExtensionMpp),\n            FILE_EXTENSION_MPT => Ok(Self::FileExtensionMpt),\n            FILE_EXTENSION_MPV2 => Ok(Self::FileExtensionMpv2),\n            FILE_EXTENSION_MPY => Ok(Self::FileExtensionMpy),\n            FILE_EXTENSION_MQY => Ok(Self::FileExtensionMqy),\n            FILE_EXTENSION_MRC => Ok(Self::FileExtensionMrc),\n            FILE_EXTENSION_MRCX => Ok(Self::FileExtensionMrcx),\n            FILE_EXTENSION_MS => Ok(Self::FileExtensionMs),\n            FILE_EXTENSION_MSCML => Ok(Self::FileExtensionMscml),\n            FILE_EXTENSION_MSEED => Ok(Self::FileExtensionMseed),\n            FILE_EXTENSION_MSEQ => Ok(Self::FileExtensionMseq),\n            FILE_EXTENSION_MSF => Ok(Self::FileExtensionMsf),\n            FILE_EXTENSION_MSH => Ok(Self::FileExtensionMsh),\n            FILE_EXTENSION_MSI => Ok(Self::FileExtensionMsi),\n            FILE_EXTENSION_MSL => Ok(Self::FileExtensionMsl),\n            FILE_EXTENSION_MSTY => Ok(Self::FileExtensionMsty),\n            FILE_EXTENSION_MTS => Ok(Self::FileExtensionMts),\n            FILE_EXTENSION_MUS => Ok(Self::FileExtensionMus),\n            FILE_EXTENSION_MUSICXML => Ok(Self::FileExtensionMusicxml),\n            FILE_EXTENSION_MVB => Ok(Self::FileExtensionMvb),\n            FILE_EXTENSION_MWF => Ok(Self::FileExtensionMwf),\n            FILE_EXTENSION_MXF => Ok(Self::FileExtensionMxf),\n            FILE_EXTENSION_MXL => Ok(Self::FileExtensionMxl),\n            FILE_EXTENSION_MXML => Ok(Self::FileExtensionMxml),\n            FILE_EXTENSION_MXS => Ok(Self::FileExtensionMxs),\n            FILE_EXTENSION_MXU => Ok(Self::FileExtensionMxu),\n            FILE_EXTENSION_N_GAGE => Ok(Self::FileExtensionNGage),\n            FILE_EXTENSION_N3 => Ok(Self::FileExtensionN3),\n            FILE_EXTENSION_NB => Ok(Self::FileExtensionNb),\n            FILE_EXTENSION_NBP => Ok(Self::FileExtensionNbp),\n            FILE_EXTENSION_NC => Ok(Self::FileExtensionNc),\n            FILE_EXTENSION_NCX => Ok(Self::FileExtensionNcx),\n            FILE_EXTENSION_NFO => Ok(Self::FileExtensionNfo),\n            FILE_EXTENSION_NGDAT => Ok(Self::FileExtensionNgdat),\n            FILE_EXTENSION_NITF => Ok(Self::FileExtensionNitf),\n            FILE_EXTENSION_NLU => Ok(Self::FileExtensionNlu),\n            FILE_EXTENSION_NML => Ok(Self::FileExtensionNml),\n            FILE_EXTENSION_NND => Ok(Self::FileExtensionNnd),\n            FILE_EXTENSION_NNS => Ok(Self::FileExtensionNns),\n            FILE_EXTENSION_NNW => Ok(Self::FileExtensionNnw),\n            FILE_EXTENSION_NPX => Ok(Self::FileExtensionNpx),\n            FILE_EXTENSION_NSC => Ok(Self::FileExtensionNsc),\n            FILE_EXTENSION_NSF => Ok(Self::FileExtensionNsf),\n            FILE_EXTENSION_NTF => Ok(Self::FileExtensionNtf),\n            FILE_EXTENSION_NZB => Ok(Self::FileExtensionNzb),\n            FILE_EXTENSION_OA2 => Ok(Self::FileExtensionOa2),\n            FILE_EXTENSION_OA3 => Ok(Self::FileExtensionOa3),\n            FILE_EXTENSION_OAS => Ok(Self::FileExtensionOas),\n            FILE_EXTENSION_OBD => Ok(Self::FileExtensionObd),\n            FILE_EXTENSION_OBJ => Ok(Self::FileExtensionObj),\n            FILE_EXTENSION_ODA => Ok(Self::FileExtensionOda),\n            FILE_EXTENSION_ODB => Ok(Self::FileExtensionOdb),\n            FILE_EXTENSION_ODC => Ok(Self::FileExtensionOdc),\n            FILE_EXTENSION_ODF => Ok(Self::FileExtensionOdf),\n            FILE_EXTENSION_ODFT => Ok(Self::FileExtensionOdft),\n            FILE_EXTENSION_ODG => Ok(Self::FileExtensionOdg),\n            FILE_EXTENSION_ODI => Ok(Self::FileExtensionOdi),\n            FILE_EXTENSION_ODM => Ok(Self::FileExtensionOdm),\n            FILE_EXTENSION_ODP => Ok(Self::FileExtensionOdp),\n            FILE_EXTENSION_ODS => Ok(Self::FileExtensionOds),\n            FILE_EXTENSION_ODT => Ok(Self::FileExtensionOdt),\n            FILE_EXTENSION_OGA => Ok(Self::FileExtensionOga),\n            FILE_EXTENSION_OGG => Ok(Self::FileExtensionOgg),\n            FILE_EXTENSION_OGV => Ok(Self::FileExtensionOgv),\n            FILE_EXTENSION_OGX => Ok(Self::FileExtensionOgx),\n            FILE_EXTENSION_OMDOC => Ok(Self::FileExtensionOmdoc),\n            FILE_EXTENSION_ONEPKG => Ok(Self::FileExtensionOnepkg),\n            FILE_EXTENSION_ONETMP => Ok(Self::FileExtensionOnetmp),\n            FILE_EXTENSION_ONETOC => Ok(Self::FileExtensionOnetoc),\n            FILE_EXTENSION_ONETOC2 => Ok(Self::FileExtensionOnetoc2),\n            FILE_EXTENSION_OPF => Ok(Self::FileExtensionOpf),\n            FILE_EXTENSION_OPML => Ok(Self::FileExtensionOpml),\n            FILE_EXTENSION_OPRC => Ok(Self::FileExtensionOprc),\n            FILE_EXTENSION_ORG => Ok(Self::FileExtensionOrg),\n            FILE_EXTENSION_OSF => Ok(Self::FileExtensionOsf),\n            FILE_EXTENSION_OSFPVG => Ok(Self::FileExtensionOsfpvg),\n            FILE_EXTENSION_OTC => Ok(Self::FileExtensionOtc),\n            FILE_EXTENSION_OTF => Ok(Self::FileExtensionOtf),\n            FILE_EXTENSION_OTG => Ok(Self::FileExtensionOtg),\n            FILE_EXTENSION_OTH => Ok(Self::FileExtensionOth),\n            FILE_EXTENSION_OTI => Ok(Self::FileExtensionOti),\n            FILE_EXTENSION_OTP => Ok(Self::FileExtensionOtp),\n            FILE_EXTENSION_OTS => Ok(Self::FileExtensionOts),\n            FILE_EXTENSION_OTT => Ok(Self::FileExtensionOtt),\n            FILE_EXTENSION_OXPS => Ok(Self::FileExtensionOxps),\n            FILE_EXTENSION_OXT => Ok(Self::FileExtensionOxt),\n            FILE_EXTENSION_P => Ok(Self::FileExtensionP),\n            FILE_EXTENSION_P10 => Ok(Self::FileExtensionP10),\n            FILE_EXTENSION_P12 => Ok(Self::FileExtensionP12),\n            FILE_EXTENSION_P7B => Ok(Self::FileExtensionP7b),\n            FILE_EXTENSION_P7C => Ok(Self::FileExtensionP7c),\n            FILE_EXTENSION_P7M => Ok(Self::FileExtensionP7m),\n            FILE_EXTENSION_P7R => Ok(Self::FileExtensionP7r),\n            FILE_EXTENSION_P7S => Ok(Self::FileExtensionP7s),\n            FILE_EXTENSION_P8 => Ok(Self::FileExtensionP8),\n            FILE_EXTENSION_PAS => Ok(Self::FileExtensionPas),\n            FILE_EXTENSION_PAW => Ok(Self::FileExtensionPaw),\n            FILE_EXTENSION_PBD => Ok(Self::FileExtensionPbd),\n            FILE_EXTENSION_PBM => Ok(Self::FileExtensionPbm),\n            FILE_EXTENSION_PCAP => Ok(Self::FileExtensionPcap),\n            FILE_EXTENSION_PCF => Ok(Self::FileExtensionPcf),\n            FILE_EXTENSION_PCL => Ok(Self::FileExtensionPcl),\n            FILE_EXTENSION_PCLXL => Ok(Self::FileExtensionPclxl),\n            FILE_EXTENSION_PCT => Ok(Self::FileExtensionPct),\n            FILE_EXTENSION_PCURL => Ok(Self::FileExtensionPcurl),\n            FILE_EXTENSION_PCX => Ok(Self::FileExtensionPcx),\n            FILE_EXTENSION_PDB => Ok(Self::FileExtensionPdb),\n            FILE_EXTENSION_PDF => Ok(Self::FileExtensionPdf),\n            FILE_EXTENSION_PFA => Ok(Self::FileExtensionPfa),\n            FILE_EXTENSION_PFB => Ok(Self::FileExtensionPfb),\n            FILE_EXTENSION_PFM => Ok(Self::FileExtensionPfm),\n            FILE_EXTENSION_PFR => Ok(Self::FileExtensionPfr),\n            FILE_EXTENSION_PFX => Ok(Self::FileExtensionPfx),\n            FILE_EXTENSION_PGM => Ok(Self::FileExtensionPgm),\n            FILE_EXTENSION_PGN => Ok(Self::FileExtensionPgn),\n            FILE_EXTENSION_PGP => Ok(Self::FileExtensionPgp),\n            FILE_EXTENSION_PIC => Ok(Self::FileExtensionPic),\n            FILE_EXTENSION_PICT => Ok(Self::FileExtensionPict),\n            FILE_EXTENSION_PKG => Ok(Self::FileExtensionPkg),\n            FILE_EXTENSION_PKI => Ok(Self::FileExtensionPki),\n            FILE_EXTENSION_PKIPATH => Ok(Self::FileExtensionPkipath),\n            FILE_EXTENSION_PLB => Ok(Self::FileExtensionPlb),\n            FILE_EXTENSION_PLC => Ok(Self::FileExtensionPlc),\n            FILE_EXTENSION_PLF => Ok(Self::FileExtensionPlf),\n            FILE_EXTENSION_PLS => Ok(Self::FileExtensionPls),\n            FILE_EXTENSION_PML => Ok(Self::FileExtensionPml),\n            FILE_EXTENSION_PNG => Ok(Self::FileExtensionPng),\n            FILE_EXTENSION_PNM => Ok(Self::FileExtensionPnm),\n            FILE_EXTENSION_PNT => Ok(Self::FileExtensionPnt),\n            FILE_EXTENSION_PORTPKG => Ok(Self::FileExtensionPortpkg),\n            FILE_EXTENSION_POT => Ok(Self::FileExtensionPot),\n            FILE_EXTENSION_POTM => Ok(Self::FileExtensionPotm),\n            FILE_EXTENSION_POTX => Ok(Self::FileExtensionPotx),\n            FILE_EXTENSION_PPAM => Ok(Self::FileExtensionPpam),\n            FILE_EXTENSION_PPD => Ok(Self::FileExtensionPpd),\n            FILE_EXTENSION_PPM => Ok(Self::FileExtensionPpm),\n            FILE_EXTENSION_PPS => Ok(Self::FileExtensionPps),\n            FILE_EXTENSION_PPSM => Ok(Self::FileExtensionPpsm),\n            FILE_EXTENSION_PPSX => Ok(Self::FileExtensionPpsx),\n            FILE_EXTENSION_PPT => Ok(Self::FileExtensionPpt),\n            FILE_EXTENSION_PPTM => Ok(Self::FileExtensionPptm),\n            FILE_EXTENSION_PPTX => Ok(Self::FileExtensionPptx),\n            FILE_EXTENSION_PQA => Ok(Self::FileExtensionPqa),\n            FILE_EXTENSION_PRC => Ok(Self::FileExtensionPrc),\n            FILE_EXTENSION_PRE => Ok(Self::FileExtensionPre),\n            FILE_EXTENSION_PRF => Ok(Self::FileExtensionPrf),\n            FILE_EXTENSION_PS => Ok(Self::FileExtensionPs),\n            FILE_EXTENSION_PSB => Ok(Self::FileExtensionPsb),\n            FILE_EXTENSION_PSD => Ok(Self::FileExtensionPsd),\n            FILE_EXTENSION_PSF => Ok(Self::FileExtensionPsf),\n            FILE_EXTENSION_PSKCXML => Ok(Self::FileExtensionPskcxml),\n            FILE_EXTENSION_PTID => Ok(Self::FileExtensionPtid),\n            FILE_EXTENSION_PUB => Ok(Self::FileExtensionPub),\n            FILE_EXTENSION_PVB => Ok(Self::FileExtensionPvb),\n            FILE_EXTENSION_PWN => Ok(Self::FileExtensionPwn),\n            FILE_EXTENSION_PYA => Ok(Self::FileExtensionPya),\n            FILE_EXTENSION_PYV => Ok(Self::FileExtensionPyv),\n            FILE_EXTENSION_QAM => Ok(Self::FileExtensionQam),\n            FILE_EXTENSION_QBO => Ok(Self::FileExtensionQbo),\n            FILE_EXTENSION_QFX => Ok(Self::FileExtensionQfx),\n            FILE_EXTENSION_QPS => Ok(Self::FileExtensionQps),\n            FILE_EXTENSION_QT => Ok(Self::FileExtensionQt),\n            FILE_EXTENSION_QTI => Ok(Self::FileExtensionQti),\n            FILE_EXTENSION_QTIF => Ok(Self::FileExtensionQtif),\n            FILE_EXTENSION_QWD => Ok(Self::FileExtensionQwd),\n            FILE_EXTENSION_QWT => Ok(Self::FileExtensionQwt),\n            FILE_EXTENSION_QXB => Ok(Self::FileExtensionQxb),\n            FILE_EXTENSION_QXD => Ok(Self::FileExtensionQxd),\n            FILE_EXTENSION_QXL => Ok(Self::FileExtensionQxl),\n            FILE_EXTENSION_QXT => Ok(Self::FileExtensionQxt),\n            FILE_EXTENSION_RA => Ok(Self::FileExtensionRa),\n            FILE_EXTENSION_RAM => Ok(Self::FileExtensionRam),\n            FILE_EXTENSION_RAR => Ok(Self::FileExtensionRar),\n            FILE_EXTENSION_RAS => Ok(Self::FileExtensionRas),\n            FILE_EXTENSION_RCPROFILE => Ok(Self::FileExtensionRcprofile),\n            FILE_EXTENSION_RDF => Ok(Self::FileExtensionRdf),\n            FILE_EXTENSION_RDZ => Ok(Self::FileExtensionRdz),\n            FILE_EXTENSION_REP => Ok(Self::FileExtensionRep),\n            FILE_EXTENSION_RES => Ok(Self::FileExtensionRes),\n            FILE_EXTENSION_RGB => Ok(Self::FileExtensionRgb),\n            FILE_EXTENSION_RIF => Ok(Self::FileExtensionRif),\n            FILE_EXTENSION_RIP => Ok(Self::FileExtensionRip),\n            FILE_EXTENSION_RIS => Ok(Self::FileExtensionRis),\n            FILE_EXTENSION_RL => Ok(Self::FileExtensionRl),\n            FILE_EXTENSION_RLC => Ok(Self::FileExtensionRlc),\n            FILE_EXTENSION_RLD => Ok(Self::FileExtensionRld),\n            FILE_EXTENSION_RM => Ok(Self::FileExtensionRm),\n            FILE_EXTENSION_RMI => Ok(Self::FileExtensionRmi),\n            FILE_EXTENSION_RMP => Ok(Self::FileExtensionRmp),\n            FILE_EXTENSION_RMS => Ok(Self::FileExtensionRms),\n            FILE_EXTENSION_RMVB => Ok(Self::FileExtensionRmvb),\n            FILE_EXTENSION_RNC => Ok(Self::FileExtensionRnc),\n            FILE_EXTENSION_ROA => Ok(Self::FileExtensionRoa),\n            FILE_EXTENSION_ROFF => Ok(Self::FileExtensionRoff),\n            FILE_EXTENSION_RP9 => Ok(Self::FileExtensionRp9),\n            FILE_EXTENSION_RPSS => Ok(Self::FileExtensionRpss),\n            FILE_EXTENSION_RPST => Ok(Self::FileExtensionRpst),\n            FILE_EXTENSION_RQ => Ok(Self::FileExtensionRq),\n            FILE_EXTENSION_RSD => Ok(Self::FileExtensionRsd),\n            FILE_EXTENSION_RSS => Ok(Self::FileExtensionRss),\n            FILE_EXTENSION_RTF => Ok(Self::FileExtensionRtf),\n            FILE_EXTENSION_RTX => Ok(Self::FileExtensionRtx),\n            FILE_EXTENSION_S => Ok(Self::FileExtensionS),\n            FILE_EXTENSION_S3M => Ok(Self::FileExtensionS3m),\n            FILE_EXTENSION_SAF => Ok(Self::FileExtensionSaf),\n            FILE_EXTENSION_SBML => Ok(Self::FileExtensionSbml),\n            FILE_EXTENSION_SCD => Ok(Self::FileExtensionScd),\n            FILE_EXTENSION_SCM => Ok(Self::FileExtensionScm),\n            FILE_EXTENSION_SCQ => Ok(Self::FileExtensionScq),\n            FILE_EXTENSION_SCS => Ok(Self::FileExtensionScs),\n            FILE_EXTENSION_SCURL => Ok(Self::FileExtensionScurl),\n            FILE_EXTENSION_SDA => Ok(Self::FileExtensionSda),\n            FILE_EXTENSION_SDC => Ok(Self::FileExtensionSdc),\n            FILE_EXTENSION_SDD => Ok(Self::FileExtensionSdd),\n            FILE_EXTENSION_SDKD => Ok(Self::FileExtensionSdkd),\n            FILE_EXTENSION_SDKM => Ok(Self::FileExtensionSdkm),\n            FILE_EXTENSION_SDP => Ok(Self::FileExtensionSdp),\n            FILE_EXTENSION_SDW => Ok(Self::FileExtensionSdw),\n            FILE_EXTENSION_SEE => Ok(Self::FileExtensionSee),\n            FILE_EXTENSION_SEED => Ok(Self::FileExtensionSeed),\n            FILE_EXTENSION_SEMA => Ok(Self::FileExtensionSema),\n            FILE_EXTENSION_SEMD => Ok(Self::FileExtensionSemd),\n            FILE_EXTENSION_SEMF => Ok(Self::FileExtensionSemf),\n            FILE_EXTENSION_SER => Ok(Self::FileExtensionSer),\n            FILE_EXTENSION_SETPAY => Ok(Self::FileExtensionSetpay),\n            FILE_EXTENSION_SETREG => Ok(Self::FileExtensionSetreg),\n            FILE_EXTENSION_SFD_HDSTX => Ok(Self::FileExtensionSfdHdstx),\n            FILE_EXTENSION_SFS => Ok(Self::FileExtensionSfs),\n            FILE_EXTENSION_SFV => Ok(Self::FileExtensionSfv),\n            FILE_EXTENSION_SGI => Ok(Self::FileExtensionSgi),\n            FILE_EXTENSION_SGL => Ok(Self::FileExtensionSgl),\n            FILE_EXTENSION_SGM => Ok(Self::FileExtensionSgm),\n            FILE_EXTENSION_SGML => Ok(Self::FileExtensionSgml),\n            FILE_EXTENSION_SH => Ok(Self::FileExtensionSh),\n            FILE_EXTENSION_SHAR => Ok(Self::FileExtensionShar),\n            FILE_EXTENSION_SHF => Ok(Self::FileExtensionShf),\n            FILE_EXTENSION_SID => Ok(Self::FileExtensionSid),\n            FILE_EXTENSION_SIG => Ok(Self::FileExtensionSig),\n            FILE_EXTENSION_SIL => Ok(Self::FileExtensionSil),\n            FILE_EXTENSION_SILO => Ok(Self::FileExtensionSilo),\n            FILE_EXTENSION_SIS => Ok(Self::FileExtensionSis),\n            FILE_EXTENSION_SISX => Ok(Self::FileExtensionSisx),\n            FILE_EXTENSION_SIT => Ok(Self::FileExtensionSit),\n            FILE_EXTENSION_SITX => Ok(Self::FileExtensionSitx),\n            FILE_EXTENSION_SKD => Ok(Self::FileExtensionSkd),\n            FILE_EXTENSION_SKM => Ok(Self::FileExtensionSkm),\n            FILE_EXTENSION_SKP => Ok(Self::FileExtensionSkp),\n            FILE_EXTENSION_SKT => Ok(Self::FileExtensionSkt),\n            FILE_EXTENSION_SLDM => Ok(Self::FileExtensionSldm),\n            FILE_EXTENSION_SLDX => Ok(Self::FileExtensionSldx),\n            FILE_EXTENSION_SLT => Ok(Self::FileExtensionSlt),\n            FILE_EXTENSION_SM => Ok(Self::FileExtensionSm),\n            FILE_EXTENSION_SMF => Ok(Self::FileExtensionSmf),\n            FILE_EXTENSION_SMI => Ok(Self::FileExtensionSmi),\n            FILE_EXTENSION_SMIL => Ok(Self::FileExtensionSmil),\n            FILE_EXTENSION_SMV => Ok(Self::FileExtensionSmv),\n            FILE_EXTENSION_SMZIP => Ok(Self::FileExtensionSmzip),\n            FILE_EXTENSION_SND => Ok(Self::FileExtensionSnd),\n            FILE_EXTENSION_SNF => Ok(Self::FileExtensionSnf),\n            FILE_EXTENSION_SO => Ok(Self::FileExtensionSo),\n            FILE_EXTENSION_SPC => Ok(Self::FileExtensionSpc),\n            FILE_EXTENSION_SPF => Ok(Self::FileExtensionSpf),\n            FILE_EXTENSION_SPL => Ok(Self::FileExtensionSpl),\n            FILE_EXTENSION_SPOT => Ok(Self::FileExtensionSpot),\n            FILE_EXTENSION_SPP => Ok(Self::FileExtensionSpp),\n            FILE_EXTENSION_SPQ => Ok(Self::FileExtensionSpq),\n            FILE_EXTENSION_SPX => Ok(Self::FileExtensionSpx),\n            FILE_EXTENSION_SQL => Ok(Self::FileExtensionSql),\n            FILE_EXTENSION_SRC => Ok(Self::FileExtensionSrc),\n            FILE_EXTENSION_SRT => Ok(Self::FileExtensionSrt),\n            FILE_EXTENSION_SRU => Ok(Self::FileExtensionSru),\n            FILE_EXTENSION_SRX => Ok(Self::FileExtensionSrx),\n            FILE_EXTENSION_SSDL => Ok(Self::FileExtensionSsdl),\n            FILE_EXTENSION_SSE => Ok(Self::FileExtensionSse),\n            FILE_EXTENSION_SSF => Ok(Self::FileExtensionSsf),\n            FILE_EXTENSION_SSML => Ok(Self::FileExtensionSsml),\n            FILE_EXTENSION_ST => Ok(Self::FileExtensionSt),\n            FILE_EXTENSION_STC => Ok(Self::FileExtensionStc),\n            FILE_EXTENSION_STD => Ok(Self::FileExtensionStd),\n            FILE_EXTENSION_STF => Ok(Self::FileExtensionStf),\n            FILE_EXTENSION_STI => Ok(Self::FileExtensionSti),\n            FILE_EXTENSION_STK => Ok(Self::FileExtensionStk),\n            FILE_EXTENSION_STL => Ok(Self::FileExtensionStl),\n            FILE_EXTENSION_STR => Ok(Self::FileExtensionStr),\n            FILE_EXTENSION_STW => Ok(Self::FileExtensionStw),\n            FILE_EXTENSION_SUB => Ok(Self::FileExtensionSub),\n            FILE_EXTENSION_SUS => Ok(Self::FileExtensionSus),\n            FILE_EXTENSION_SUSP => Ok(Self::FileExtensionSusp),\n            FILE_EXTENSION_SV4CPIO => Ok(Self::FileExtensionSv4cpio),\n            FILE_EXTENSION_SV4CRC => Ok(Self::FileExtensionSv4crc),\n            FILE_EXTENSION_SVC => Ok(Self::FileExtensionSvc),\n            FILE_EXTENSION_SVD => Ok(Self::FileExtensionSvd),\n            FILE_EXTENSION_SVG => Ok(Self::FileExtensionSvg),\n            FILE_EXTENSION_SVGZ => Ok(Self::FileExtensionSvgz),\n            FILE_EXTENSION_SWA => Ok(Self::FileExtensionSwa),\n            FILE_EXTENSION_SWF => Ok(Self::FileExtensionSwf),\n            FILE_EXTENSION_SWI => Ok(Self::FileExtensionSwi),\n            FILE_EXTENSION_SXC => Ok(Self::FileExtensionSxc),\n            FILE_EXTENSION_SXD => Ok(Self::FileExtensionSxd),\n            FILE_EXTENSION_SXG => Ok(Self::FileExtensionSxg),\n            FILE_EXTENSION_SXI => Ok(Self::FileExtensionSxi),\n            FILE_EXTENSION_SXM => Ok(Self::FileExtensionSxm),\n            FILE_EXTENSION_SXW => Ok(Self::FileExtensionSxw),\n            FILE_EXTENSION_T => Ok(Self::FileExtensionT),\n            FILE_EXTENSION_T3 => Ok(Self::FileExtensionT3),\n            FILE_EXTENSION_TAGLET => Ok(Self::FileExtensionTaglet),\n            FILE_EXTENSION_TAO => Ok(Self::FileExtensionTao),\n            FILE_EXTENSION_TAR => Ok(Self::FileExtensionTar),\n            FILE_EXTENSION_TCAP => Ok(Self::FileExtensionTcap),\n            FILE_EXTENSION_TCL => Ok(Self::FileExtensionTcl),\n            FILE_EXTENSION_TEACHER => Ok(Self::FileExtensionTeacher),\n            FILE_EXTENSION_TEI => Ok(Self::FileExtensionTei),\n            FILE_EXTENSION_TEICORPUS => Ok(Self::FileExtensionTeicorpus),\n            FILE_EXTENSION_TEX => Ok(Self::FileExtensionTex),\n            FILE_EXTENSION_TEXI => Ok(Self::FileExtensionTexi),\n            FILE_EXTENSION_TEXINFO => Ok(Self::FileExtensionTexinfo),\n            FILE_EXTENSION_TEXT => Ok(Self::FileExtensionText),\n            FILE_EXTENSION_TFI => Ok(Self::FileExtensionTfi),\n            FILE_EXTENSION_TFM => Ok(Self::FileExtensionTfm),\n            FILE_EXTENSION_TGA => Ok(Self::FileExtensionTga),\n            FILE_EXTENSION_THMX => Ok(Self::FileExtensionThmx),\n            FILE_EXTENSION_TIF => Ok(Self::FileExtensionTif),\n            FILE_EXTENSION_TIFF => Ok(Self::FileExtensionTiff),\n            FILE_EXTENSION_TMO => Ok(Self::FileExtensionTmo),\n            FILE_EXTENSION_TORRENT => Ok(Self::FileExtensionTorrent),\n            FILE_EXTENSION_TPL => Ok(Self::FileExtensionTpl),\n            FILE_EXTENSION_TPT => Ok(Self::FileExtensionTpt),\n            FILE_EXTENSION_TR => Ok(Self::FileExtensionTr),\n            FILE_EXTENSION_TRA => Ok(Self::FileExtensionTra),\n            FILE_EXTENSION_TRM => Ok(Self::FileExtensionTrm),\n            FILE_EXTENSION_TSD => Ok(Self::FileExtensionTsd),\n            FILE_EXTENSION_TSV => Ok(Self::FileExtensionTsv),\n            FILE_EXTENSION_TTC => Ok(Self::FileExtensionTtc),\n            FILE_EXTENSION_TTF => Ok(Self::FileExtensionTtf),\n            FILE_EXTENSION_TTL => Ok(Self::FileExtensionTtl),\n            FILE_EXTENSION_TWD => Ok(Self::FileExtensionTwd),\n            FILE_EXTENSION_TWDS => Ok(Self::FileExtensionTwds),\n            FILE_EXTENSION_TXD => Ok(Self::FileExtensionTxd),\n            FILE_EXTENSION_TXF => Ok(Self::FileExtensionTxf),\n            FILE_EXTENSION_TXT => Ok(Self::FileExtensionTxt),\n            FILE_EXTENSION_U32 => Ok(Self::FileExtensionU32),\n            FILE_EXTENSION_UDEB => Ok(Self::FileExtensionUdeb),\n            FILE_EXTENSION_UFD => Ok(Self::FileExtensionUfd),\n            FILE_EXTENSION_UFDL => Ok(Self::FileExtensionUfdl),\n            FILE_EXTENSION_ULW => Ok(Self::FileExtensionUlw),\n            FILE_EXTENSION_ULX => Ok(Self::FileExtensionUlx),\n            FILE_EXTENSION_UMJ => Ok(Self::FileExtensionUmj),\n            FILE_EXTENSION_UNITYWEB => Ok(Self::FileExtensionUnityweb),\n            FILE_EXTENSION_UOML => Ok(Self::FileExtensionUoml),\n            FILE_EXTENSION_URI => Ok(Self::FileExtensionUri),\n            FILE_EXTENSION_URIS => Ok(Self::FileExtensionUris),\n            FILE_EXTENSION_URLS => Ok(Self::FileExtensionUrls),\n            FILE_EXTENSION_USTAR => Ok(Self::FileExtensionUstar),\n            FILE_EXTENSION_UTZ => Ok(Self::FileExtensionUtz),\n            FILE_EXTENSION_UU => Ok(Self::FileExtensionUu),\n            FILE_EXTENSION_UVA => Ok(Self::FileExtensionUva),\n            FILE_EXTENSION_UVD => Ok(Self::FileExtensionUvd),\n            FILE_EXTENSION_UVF => Ok(Self::FileExtensionUvf),\n            FILE_EXTENSION_UVG => Ok(Self::FileExtensionUvg),\n            FILE_EXTENSION_UVH => Ok(Self::FileExtensionUvh),\n            FILE_EXTENSION_UVI => Ok(Self::FileExtensionUvi),\n            FILE_EXTENSION_UVM => Ok(Self::FileExtensionUvm),\n            FILE_EXTENSION_UVP => Ok(Self::FileExtensionUvp),\n            FILE_EXTENSION_UVS => Ok(Self::FileExtensionUvs),\n            FILE_EXTENSION_UVT => Ok(Self::FileExtensionUvt),\n            FILE_EXTENSION_UVU => Ok(Self::FileExtensionUvu),\n            FILE_EXTENSION_UVV => Ok(Self::FileExtensionUvv),\n            FILE_EXTENSION_UVVA => Ok(Self::FileExtensionUvva),\n            FILE_EXTENSION_UVVD => Ok(Self::FileExtensionUvvd),\n            FILE_EXTENSION_UVVF => Ok(Self::FileExtensionUvvf),\n            FILE_EXTENSION_UVVG => Ok(Self::FileExtensionUvvg),\n            FILE_EXTENSION_UVVH => Ok(Self::FileExtensionUvvh),\n            FILE_EXTENSION_UVVI => Ok(Self::FileExtensionUvvi),\n            FILE_EXTENSION_UVVM => Ok(Self::FileExtensionUvvm),\n            FILE_EXTENSION_UVVP => Ok(Self::FileExtensionUvvp),\n            FILE_EXTENSION_UVVS => Ok(Self::FileExtensionUvvs),\n            FILE_EXTENSION_UVVT => Ok(Self::FileExtensionUvvt),\n            FILE_EXTENSION_UVVU => Ok(Self::FileExtensionUvvu),\n            FILE_EXTENSION_UVVV => Ok(Self::FileExtensionUvvv),\n            FILE_EXTENSION_UVVX => Ok(Self::FileExtensionUvvx),\n            FILE_EXTENSION_UVVZ => Ok(Self::FileExtensionUvvz),\n            FILE_EXTENSION_UVX => Ok(Self::FileExtensionUvx),\n            FILE_EXTENSION_UVZ => Ok(Self::FileExtensionUvz),\n            FILE_EXTENSION_VCARD => Ok(Self::FileExtensionVcard),\n            FILE_EXTENSION_VCD => Ok(Self::FileExtensionVcd),\n            FILE_EXTENSION_VCF => Ok(Self::FileExtensionVcf),\n            FILE_EXTENSION_VCG => Ok(Self::FileExtensionVcg),\n            FILE_EXTENSION_VCS => Ok(Self::FileExtensionVcs),\n            FILE_EXTENSION_VCX => Ok(Self::FileExtensionVcx),\n            FILE_EXTENSION_VIS => Ok(Self::FileExtensionVis),\n            FILE_EXTENSION_VIV => Ok(Self::FileExtensionViv),\n            FILE_EXTENSION_VOB => Ok(Self::FileExtensionVob),\n            FILE_EXTENSION_VOR => Ok(Self::FileExtensionVor),\n            FILE_EXTENSION_VOX => Ok(Self::FileExtensionVox),\n            FILE_EXTENSION_VRML => Ok(Self::FileExtensionVrml),\n            FILE_EXTENSION_VSD => Ok(Self::FileExtensionVsd),\n            FILE_EXTENSION_VSF => Ok(Self::FileExtensionVsf),\n            FILE_EXTENSION_VSS => Ok(Self::FileExtensionVss),\n            FILE_EXTENSION_VST => Ok(Self::FileExtensionVst),\n            FILE_EXTENSION_VSW => Ok(Self::FileExtensionVsw),\n            FILE_EXTENSION_VTU => Ok(Self::FileExtensionVtu),\n            FILE_EXTENSION_VXML => Ok(Self::FileExtensionVxml),\n            FILE_EXTENSION_W3D => Ok(Self::FileExtensionW3d),\n            FILE_EXTENSION_WAD => Ok(Self::FileExtensionWad),\n            FILE_EXTENSION_WAV => Ok(Self::FileExtensionWav),\n            FILE_EXTENSION_WAX => Ok(Self::FileExtensionWax),\n            FILE_EXTENSION_WBMP => Ok(Self::FileExtensionWbmp),\n            FILE_EXTENSION_WBS => Ok(Self::FileExtensionWbs),\n            FILE_EXTENSION_WBXML => Ok(Self::FileExtensionWbxml),\n            FILE_EXTENSION_WCM => Ok(Self::FileExtensionWcm),\n            FILE_EXTENSION_WDB => Ok(Self::FileExtensionWdb),\n            FILE_EXTENSION_WDP => Ok(Self::FileExtensionWdp),\n            FILE_EXTENSION_WEBA => Ok(Self::FileExtensionWeba),\n            FILE_EXTENSION_WEBM => Ok(Self::FileExtensionWebm),\n            FILE_EXTENSION_WEBP => Ok(Self::FileExtensionWebp),\n            FILE_EXTENSION_WG => Ok(Self::FileExtensionWg),\n            FILE_EXTENSION_WGT => Ok(Self::FileExtensionWgt),\n            FILE_EXTENSION_WKS => Ok(Self::FileExtensionWks),\n            FILE_EXTENSION_WM => Ok(Self::FileExtensionWm),\n            FILE_EXTENSION_WMA => Ok(Self::FileExtensionWma),\n            FILE_EXTENSION_WMD => Ok(Self::FileExtensionWmd),\n            FILE_EXTENSION_WMF => Ok(Self::FileExtensionWmf),\n            FILE_EXTENSION_WML => Ok(Self::FileExtensionWml),\n            FILE_EXTENSION_WMLC => Ok(Self::FileExtensionWmlc),\n            FILE_EXTENSION_WMLS => Ok(Self::FileExtensionWmls),\n            FILE_EXTENSION_WMLSC => Ok(Self::FileExtensionWmlsc),\n            FILE_EXTENSION_WMV => Ok(Self::FileExtensionWmv),\n            FILE_EXTENSION_WMX => Ok(Self::FileExtensionWmx),\n            FILE_EXTENSION_WMZ => Ok(Self::FileExtensionWmz),\n            FILE_EXTENSION_WOFF => Ok(Self::FileExtensionWoff),\n            FILE_EXTENSION_WOFF2 => Ok(Self::FileExtensionWoff2),\n            FILE_EXTENSION_WPD => Ok(Self::FileExtensionWpd),\n            FILE_EXTENSION_WPL => Ok(Self::FileExtensionWpl),\n            FILE_EXTENSION_WPS => Ok(Self::FileExtensionWps),\n            FILE_EXTENSION_WQD => Ok(Self::FileExtensionWqd),\n            FILE_EXTENSION_WRI => Ok(Self::FileExtensionWri),\n            FILE_EXTENSION_WRL => Ok(Self::FileExtensionWrl),\n            FILE_EXTENSION_WSDL => Ok(Self::FileExtensionWsdl),\n            FILE_EXTENSION_WSPOLICY => Ok(Self::FileExtensionWspolicy),\n            FILE_EXTENSION_WTB => Ok(Self::FileExtensionWtb),\n            FILE_EXTENSION_WVX => Ok(Self::FileExtensionWvx),\n            FILE_EXTENSION_X32 => Ok(Self::FileExtensionX32),\n            FILE_EXTENSION_X3D => Ok(Self::FileExtensionX3d),\n            FILE_EXTENSION_X3DB => Ok(Self::FileExtensionX3db),\n            FILE_EXTENSION_X3DBZ => Ok(Self::FileExtensionX3dbz),\n            FILE_EXTENSION_X3DV => Ok(Self::FileExtensionX3dv),\n            FILE_EXTENSION_X3DVZ => Ok(Self::FileExtensionX3dvz),\n            FILE_EXTENSION_X3DZ => Ok(Self::FileExtensionX3dz),\n            FILE_EXTENSION_XAML => Ok(Self::FileExtensionXaml),\n            FILE_EXTENSION_XAP => Ok(Self::FileExtensionXap),\n            FILE_EXTENSION_XAR => Ok(Self::FileExtensionXar),\n            FILE_EXTENSION_XBAP => Ok(Self::FileExtensionXbap),\n            FILE_EXTENSION_XBD => Ok(Self::FileExtensionXbd),\n            FILE_EXTENSION_XBM => Ok(Self::FileExtensionXbm),\n            FILE_EXTENSION_XDF => Ok(Self::FileExtensionXdf),\n            FILE_EXTENSION_XDM => Ok(Self::FileExtensionXdm),\n            FILE_EXTENSION_XDP => Ok(Self::FileExtensionXdp),\n            FILE_EXTENSION_XDSSC => Ok(Self::FileExtensionXdssc),\n            FILE_EXTENSION_XDW => Ok(Self::FileExtensionXdw),\n            FILE_EXTENSION_XENC => Ok(Self::FileExtensionXenc),\n            FILE_EXTENSION_XER => Ok(Self::FileExtensionXer),\n            FILE_EXTENSION_XFDF => Ok(Self::FileExtensionXfdf),\n            FILE_EXTENSION_XFDL => Ok(Self::FileExtensionXfdl),\n            FILE_EXTENSION_XHT => Ok(Self::FileExtensionXht),\n            FILE_EXTENSION_XHTML => Ok(Self::FileExtensionXhtml),\n            FILE_EXTENSION_XHVML => Ok(Self::FileExtensionXhvml),\n            FILE_EXTENSION_XIF => Ok(Self::FileExtensionXif),\n            FILE_EXTENSION_XLA => Ok(Self::FileExtensionXla),\n            FILE_EXTENSION_XLAM => Ok(Self::FileExtensionXlam),\n            FILE_EXTENSION_XLC => Ok(Self::FileExtensionXlc),\n            FILE_EXTENSION_XLF => Ok(Self::FileExtensionXlf),\n            FILE_EXTENSION_XLM => Ok(Self::FileExtensionXlm),\n            FILE_EXTENSION_XLS => Ok(Self::FileExtensionXls),\n            FILE_EXTENSION_XLSB => Ok(Self::FileExtensionXlsb),\n            FILE_EXTENSION_XLSM => Ok(Self::FileExtensionXlsm),\n            FILE_EXTENSION_XLSX => Ok(Self::FileExtensionXlsx),\n            FILE_EXTENSION_XLT => Ok(Self::FileExtensionXlt),\n            FILE_EXTENSION_XLTM => Ok(Self::FileExtensionXltm),\n            FILE_EXTENSION_XLTX => Ok(Self::FileExtensionXltx),\n            FILE_EXTENSION_XLW => Ok(Self::FileExtensionXlw),\n            FILE_EXTENSION_XM => Ok(Self::FileExtensionXm),\n            FILE_EXTENSION_XML => Ok(Self::FileExtensionXml),\n            FILE_EXTENSION_XO => Ok(Self::FileExtensionXo),\n            FILE_EXTENSION_XOP => Ok(Self::FileExtensionXop),\n            FILE_EXTENSION_XPI => Ok(Self::FileExtensionXpi),\n            FILE_EXTENSION_XPL => Ok(Self::FileExtensionXpl),\n            FILE_EXTENSION_XPM => Ok(Self::FileExtensionXpm),\n            FILE_EXTENSION_XPR => Ok(Self::FileExtensionXpr),\n            FILE_EXTENSION_XPS => Ok(Self::FileExtensionXps),\n            FILE_EXTENSION_XPW => Ok(Self::FileExtensionXpw),\n            FILE_EXTENSION_XPX => Ok(Self::FileExtensionXpx),\n            FILE_EXTENSION_XSL => Ok(Self::FileExtensionXsl),\n            FILE_EXTENSION_XSLT => Ok(Self::FileExtensionXslt),\n            FILE_EXTENSION_XSM => Ok(Self::FileExtensionXsm),\n            FILE_EXTENSION_XSPF => Ok(Self::FileExtensionXspf),\n            FILE_EXTENSION_XUL => Ok(Self::FileExtensionXul),\n            FILE_EXTENSION_XVM => Ok(Self::FileExtensionXvm),\n            FILE_EXTENSION_XVML => Ok(Self::FileExtensionXvml),\n            FILE_EXTENSION_XWD => Ok(Self::FileExtensionXwd),\n            FILE_EXTENSION_XYZ => Ok(Self::FileExtensionXyz),\n            FILE_EXTENSION_XZ => Ok(Self::FileExtensionXz),\n            FILE_EXTENSION_YANG => Ok(Self::FileExtensionYang),\n            FILE_EXTENSION_YIN => Ok(Self::FileExtensionYin),\n            FILE_EXTENSION_Z => Ok(Self::FileExtensionZ),\n            FILE_EXTENSION_Z1 => Ok(Self::FileExtensionZ1),\n            FILE_EXTENSION_Z2 => Ok(Self::FileExtensionZ2),\n            FILE_EXTENSION_Z3 => Ok(Self::FileExtensionZ3),\n            FILE_EXTENSION_Z4 => Ok(Self::FileExtensionZ4),\n            FILE_EXTENSION_Z5 => Ok(Self::FileExtensionZ5),\n            FILE_EXTENSION_Z6 => Ok(Self::FileExtensionZ6),\n            FILE_EXTENSION_Z7 => Ok(Self::FileExtensionZ7),\n            FILE_EXTENSION_Z8 => Ok(Self::FileExtensionZ8),\n            FILE_EXTENSION_ZAZ => Ok(Self::FileExtensionZaz),\n            FILE_EXTENSION_ZIP => Ok(Self::FileExtensionZip),\n            FILE_EXTENSION_ZIR => Ok(Self::FileExtensionZir),\n            FILE_EXTENSION_ZIRZ => Ok(Self::FileExtensionZirz),\n            FILE_EXTENSION_ZMM => Ok(Self::FileExtensionZmm),\n            _ => Ok(Self::default()),\n        }\n    }\n}\n\nimpl Display for FileExtension {\n    /// Formats the `FileExtension` into a string.\n    ///\n    /// # Arguments\n    ///\n    /// - `f` - The formatter to write into.\n    ///\n    /// # Returns\n    ///\n    /// A `Result` indicating success or failure of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let version_str: &str = match self {\n            Self::FileExtension123 => FILE_EXTENSION_123,\n            Self::FileExtension3dml => FILE_EXTENSION_3DML,\n            Self::FileExtension3ds => FILE_EXTENSION_3DS,\n            Self::FileExtension3g2 => FILE_EXTENSION_3G2,\n            Self::FileExtension3gp => FILE_EXTENSION_3GP,\n            Self::FileExtension7z => FILE_EXTENSION_7Z,\n            Self::FileExtensionAab => FILE_EXTENSION_AAB,\n            Self::FileExtensionAac => FILE_EXTENSION_AAC,\n            Self::FileExtensionAam => FILE_EXTENSION_AAM,\n            Self::FileExtensionAas => FILE_EXTENSION_AAS,\n            Self::FileExtensionAbs => FILE_EXTENSION_ABS,\n            Self::FileExtensionAbw => FILE_EXTENSION_ABW,\n            Self::FileExtensionAc => FILE_EXTENSION_AC,\n            Self::FileExtensionAcc => FILE_EXTENSION_ACC,\n            Self::FileExtensionAce => FILE_EXTENSION_ACE,\n            Self::FileExtensionAcu => FILE_EXTENSION_ACU,\n            Self::FileExtensionAcutc => FILE_EXTENSION_ACUTC,\n            Self::FileExtensionAdp => FILE_EXTENSION_ADP,\n            Self::FileExtensionAep => FILE_EXTENSION_AEP,\n            Self::FileExtensionAfm => FILE_EXTENSION_AFM,\n            Self::FileExtensionAfp => FILE_EXTENSION_AFP,\n            Self::FileExtensionAhead => FILE_EXTENSION_AHEAD,\n            Self::FileExtensionAi => FILE_EXTENSION_AI,\n            Self::FileExtensionAif => FILE_EXTENSION_AIF,\n            Self::FileExtensionAifc => FILE_EXTENSION_AIFC,\n            Self::FileExtensionAiff => FILE_EXTENSION_AIFF,\n            Self::FileExtensionAim => FILE_EXTENSION_AIM,\n            Self::FileExtensionAir => FILE_EXTENSION_AIR,\n            Self::FileExtensionAit => FILE_EXTENSION_AIT,\n            Self::FileExtensionAmi => FILE_EXTENSION_AMI,\n            Self::FileExtensionAnx => FILE_EXTENSION_ANX,\n            Self::FileExtensionApk => FILE_EXTENSION_APK,\n            Self::FileExtensionAppcache => FILE_EXTENSION_APPCACHE,\n            Self::FileExtensionApplication => FILE_EXTENSION_APPLICATION,\n            Self::FileExtensionApr => FILE_EXTENSION_APR,\n            Self::FileExtensionArc => FILE_EXTENSION_ARC,\n            Self::FileExtensionArt => FILE_EXTENSION_ART,\n            Self::FileExtensionAsc => FILE_EXTENSION_ASC,\n            Self::FileExtensionAsf => FILE_EXTENSION_ASF,\n            Self::FileExtensionAsm => FILE_EXTENSION_ASM,\n            Self::FileExtensionAso => FILE_EXTENSION_ASO,\n            Self::FileExtensionAsx => FILE_EXTENSION_ASX,\n            Self::FileExtensionAtc => FILE_EXTENSION_ATC,\n            Self::FileExtensionAtom => FILE_EXTENSION_ATOM,\n            Self::FileExtensionAtomcat => FILE_EXTENSION_ATOMCAT,\n            Self::FileExtensionAtomsvc => FILE_EXTENSION_ATOMSVC,\n            Self::FileExtensionAtx => FILE_EXTENSION_ATX,\n            Self::FileExtensionAu => FILE_EXTENSION_AU,\n            Self::FileExtensionAvi => FILE_EXTENSION_AVI,\n            Self::FileExtensionAvx => FILE_EXTENSION_AVX,\n            Self::FileExtensionAw => FILE_EXTENSION_AW,\n            Self::FileExtensionAxa => FILE_EXTENSION_AXA,\n            Self::FileExtensionAxv => FILE_EXTENSION_AXV,\n            Self::FileExtensionAzf => FILE_EXTENSION_AZF,\n            Self::FileExtensionAzs => FILE_EXTENSION_AZS,\n            Self::FileExtensionAzw => FILE_EXTENSION_AZW,\n            Self::FileExtensionBat => FILE_EXTENSION_BAT,\n            Self::FileExtensionBcpio => FILE_EXTENSION_BCPIO,\n            Self::FileExtensionBdf => FILE_EXTENSION_BDF,\n            Self::FileExtensionBdm => FILE_EXTENSION_BDM,\n            Self::FileExtensionBed => FILE_EXTENSION_BED,\n            Self::FileExtensionBh2 => FILE_EXTENSION_BH2,\n            Self::FileExtensionBin => FILE_EXTENSION_BIN,\n            Self::FileExtensionBlb => FILE_EXTENSION_BLB,\n            Self::FileExtensionBlorb => FILE_EXTENSION_BLORB,\n            Self::FileExtensionBmi => FILE_EXTENSION_BMI,\n            Self::FileExtensionBmp => FILE_EXTENSION_BMP,\n            Self::FileExtensionBody => FILE_EXTENSION_BODY,\n            Self::FileExtensionBook => FILE_EXTENSION_BOOK,\n            Self::FileExtensionBox => FILE_EXTENSION_BOX,\n            Self::FileExtensionBoz => FILE_EXTENSION_BOZ,\n            Self::FileExtensionBpk => FILE_EXTENSION_BPK,\n            Self::FileExtensionBtif => FILE_EXTENSION_BTIF,\n            Self::FileExtensionBz => FILE_EXTENSION_BZ,\n            Self::FileExtensionBz2 => FILE_EXTENSION_BZ2,\n            Self::FileExtensionC => FILE_EXTENSION_C,\n            Self::FileExtensionC11amc => FILE_EXTENSION_C11AMC,\n            Self::FileExtensionC11amz => FILE_EXTENSION_C11AMZ,\n            Self::FileExtensionC4d => FILE_EXTENSION_C4D,\n            Self::FileExtensionC4f => FILE_EXTENSION_C4F,\n            Self::FileExtensionC4g => FILE_EXTENSION_C4G,\n            Self::FileExtensionC4p => FILE_EXTENSION_C4P,\n            Self::FileExtensionC4u => FILE_EXTENSION_C4U,\n            Self::FileExtensionCab => FILE_EXTENSION_CAB,\n            Self::FileExtensionCaf => FILE_EXTENSION_CAF,\n            Self::FileExtensionCap => FILE_EXTENSION_CAP,\n            Self::FileExtensionCar => FILE_EXTENSION_CAR,\n            Self::FileExtensionCat => FILE_EXTENSION_CAT,\n            Self::FileExtensionCb7 => FILE_EXTENSION_CB7,\n            Self::FileExtensionCba => FILE_EXTENSION_CBA,\n            Self::FileExtensionCbr => FILE_EXTENSION_CBR,\n            Self::FileExtensionCbt => FILE_EXTENSION_CBT,\n            Self::FileExtensionCbz => FILE_EXTENSION_CBZ,\n            Self::FileExtensionCc => FILE_EXTENSION_CC,\n            Self::FileExtensionCct => FILE_EXTENSION_CCT,\n            Self::FileExtensionCcxml => FILE_EXTENSION_CCXML,\n            Self::FileExtensionCdbcmsg => FILE_EXTENSION_CDBCMSG,\n            Self::FileExtensionCdf => FILE_EXTENSION_CDF,\n            Self::FileExtensionCdkey => FILE_EXTENSION_CDKEY,\n            Self::FileExtensionCdmia => FILE_EXTENSION_CDMIA,\n            Self::FileExtensionCdmic => FILE_EXTENSION_CDMIC,\n            Self::FileExtensionCdmid => FILE_EXTENSION_CDMID,\n            Self::FileExtensionCdmio => FILE_EXTENSION_CDMIO,\n            Self::FileExtensionCdmiq => FILE_EXTENSION_CDMIQ,\n            Self::FileExtensionCdx => FILE_EXTENSION_CDX,\n            Self::FileExtensionCdxml => FILE_EXTENSION_CDXML,\n            Self::FileExtensionCdy => FILE_EXTENSION_CDY,\n            Self::FileExtensionCer => FILE_EXTENSION_CER,\n            Self::FileExtensionCfs => FILE_EXTENSION_CFS,\n            Self::FileExtensionCgm => FILE_EXTENSION_CGM,\n            Self::FileExtensionChat => FILE_EXTENSION_CHAT,\n            Self::FileExtensionChm => FILE_EXTENSION_CHM,\n            Self::FileExtensionChrt => FILE_EXTENSION_CHRT,\n            Self::FileExtensionCif => FILE_EXTENSION_CIF,\n            Self::FileExtensionCii => FILE_EXTENSION_CII,\n            Self::FileExtensionCil => FILE_EXTENSION_CIL,\n            Self::FileExtensionCla => FILE_EXTENSION_CLA,\n            Self::FileExtensionClass => FILE_EXTENSION_CLASS,\n            Self::FileExtensionClkk => FILE_EXTENSION_CLKK,\n            Self::FileExtensionClkp => FILE_EXTENSION_CLKP,\n            Self::FileExtensionClkt => FILE_EXTENSION_CLKT,\n            Self::FileExtensionClkw => FILE_EXTENSION_CLKW,\n            Self::FileExtensionClkx => FILE_EXTENSION_CLKX,\n            Self::FileExtensionClp => FILE_EXTENSION_CLP,\n            Self::FileExtensionCmc => FILE_EXTENSION_CMC,\n            Self::FileExtensionCmdf => FILE_EXTENSION_CMDF,\n            Self::FileExtensionCml => FILE_EXTENSION_CML,\n            Self::FileExtensionCmp => FILE_EXTENSION_CMP,\n            Self::FileExtensionCmx => FILE_EXTENSION_CMX,\n            Self::FileExtensionCod => FILE_EXTENSION_COD,\n            Self::FileExtensionCom => FILE_EXTENSION_COM,\n            Self::FileExtensionConf => FILE_EXTENSION_CONF,\n            Self::FileExtensionCpio => FILE_EXTENSION_CPIO,\n            Self::FileExtensionCpp => FILE_EXTENSION_CPP,\n            Self::FileExtensionCpt => FILE_EXTENSION_CPT,\n            Self::FileExtensionCrd => FILE_EXTENSION_CRD,\n            Self::FileExtensionCrl => FILE_EXTENSION_CRL,\n            Self::FileExtensionCrt => FILE_EXTENSION_CRT,\n            Self::FileExtensionCryptonote => FILE_EXTENSION_CRYPTONOTE,\n            Self::FileExtensionCsh => FILE_EXTENSION_CSH,\n            Self::FileExtensionCsml => FILE_EXTENSION_CSML,\n            Self::FileExtensionCsp => FILE_EXTENSION_CSP,\n            Self::FileExtensionCss => FILE_EXTENSION_CSS,\n            Self::FileExtensionCst => FILE_EXTENSION_CST,\n            Self::FileExtensionCsv => FILE_EXTENSION_CSV,\n            Self::FileExtensionCu => FILE_EXTENSION_CU,\n            Self::FileExtensionCurl => FILE_EXTENSION_CURL,\n            Self::FileExtensionCww => FILE_EXTENSION_CWW,\n            Self::FileExtensionCxt => FILE_EXTENSION_CXT,\n            Self::FileExtensionCxx => FILE_EXTENSION_CXX,\n            Self::FileExtensionDae => FILE_EXTENSION_DAE,\n            Self::FileExtensionDaf => FILE_EXTENSION_DAF,\n            Self::FileExtensionDart => FILE_EXTENSION_DART,\n            Self::FileExtensionDataless => FILE_EXTENSION_DATALESS,\n            Self::FileExtensionDavmount => FILE_EXTENSION_DAVMOUNT,\n            Self::FileExtensionDbk => FILE_EXTENSION_DBK,\n            Self::FileExtensionDcr => FILE_EXTENSION_DCR,\n            Self::FileExtensionDcurl => FILE_EXTENSION_DCURL,\n            Self::FileExtensionDd2 => FILE_EXTENSION_DD2,\n            Self::FileExtensionDdd => FILE_EXTENSION_DDD,\n            Self::FileExtensionDeb => FILE_EXTENSION_DEB,\n            Self::FileExtensionDef => FILE_EXTENSION_DEF,\n            Self::FileExtensionDeploy => FILE_EXTENSION_DEPLOY,\n            Self::FileExtensionDer => FILE_EXTENSION_DER,\n            Self::FileExtensionDfac => FILE_EXTENSION_DFAC,\n            Self::FileExtensionDgc => FILE_EXTENSION_DGC,\n            Self::FileExtensionDib => FILE_EXTENSION_DIB,\n            Self::FileExtensionDic => FILE_EXTENSION_DIC,\n            Self::FileExtensionDir => FILE_EXTENSION_DIR,\n            Self::FileExtensionDis => FILE_EXTENSION_DIS,\n            Self::FileExtensionDist => FILE_EXTENSION_DIST,\n            Self::FileExtensionDistz => FILE_EXTENSION_DISTZ,\n            Self::FileExtensionDjv => FILE_EXTENSION_DJV,\n            Self::FileExtensionDjvu => FILE_EXTENSION_DJVU,\n            Self::FileExtensionDll => FILE_EXTENSION_DLL,\n            Self::FileExtensionDmg => FILE_EXTENSION_DMG,\n            Self::FileExtensionDmp => FILE_EXTENSION_DMP,\n            Self::FileExtensionDms => FILE_EXTENSION_DMS,\n            Self::FileExtensionDna => FILE_EXTENSION_DNA,\n            Self::FileExtensionDoc => FILE_EXTENSION_DOC,\n            Self::FileExtensionDocm => FILE_EXTENSION_DOCM,\n            Self::FileExtensionDocx => FILE_EXTENSION_DOCX,\n            Self::FileExtensionDot => FILE_EXTENSION_DOT,\n            Self::FileExtensionDotm => FILE_EXTENSION_DOTM,\n            Self::FileExtensionDotx => FILE_EXTENSION_DOTX,\n            Self::FileExtensionDp => FILE_EXTENSION_DP,\n            Self::FileExtensionDpg => FILE_EXTENSION_DPG,\n            Self::FileExtensionDra => FILE_EXTENSION_DRA,\n            Self::FileExtensionDsc => FILE_EXTENSION_DSC,\n            Self::FileExtensionDssc => FILE_EXTENSION_DSSC,\n            Self::FileExtensionDtb => FILE_EXTENSION_DTB,\n            Self::FileExtensionDtd => FILE_EXTENSION_DTD,\n            Self::FileExtensionDts => FILE_EXTENSION_DTS,\n            Self::FileExtensionDtshd => FILE_EXTENSION_DTSHD,\n            Self::FileExtensionDump => FILE_EXTENSION_DUMP,\n            Self::FileExtensionDv => FILE_EXTENSION_DV,\n            Self::FileExtensionDvb => FILE_EXTENSION_DVB,\n            Self::FileExtensionDvi => FILE_EXTENSION_DVI,\n            Self::FileExtensionDwf => FILE_EXTENSION_DWF,\n            Self::FileExtensionDwg => FILE_EXTENSION_DWG,\n            Self::FileExtensionDxf => FILE_EXTENSION_DXF,\n            Self::FileExtensionDxp => FILE_EXTENSION_DXP,\n            Self::FileExtensionDxr => FILE_EXTENSION_DXR,\n            Self::FileExtensionEcelp4800 => FILE_EXTENSION_ECELP4800,\n            Self::FileExtensionEcelp7470 => FILE_EXTENSION_ECELP7470,\n            Self::FileExtensionEcelp9600 => FILE_EXTENSION_ECELP9600,\n            Self::FileExtensionEcma => FILE_EXTENSION_ECMA,\n            Self::FileExtensionEdm => FILE_EXTENSION_EDM,\n            Self::FileExtensionEdx => FILE_EXTENSION_EDX,\n            Self::FileExtensionEfif => FILE_EXTENSION_EFIF,\n            Self::FileExtensionEi6 => FILE_EXTENSION_EI6,\n            Self::FileExtensionElc => FILE_EXTENSION_ELC,\n            Self::FileExtensionEmf => FILE_EXTENSION_EMF,\n            Self::FileExtensionEml => FILE_EXTENSION_EML,\n            Self::FileExtensionEmma => FILE_EXTENSION_EMMA,\n            Self::FileExtensionEmz => FILE_EXTENSION_EMZ,\n            Self::FileExtensionEol => FILE_EXTENSION_EOL,\n            Self::FileExtensionEot => FILE_EXTENSION_EOT,\n            Self::FileExtensionEps => FILE_EXTENSION_EPS,\n            Self::FileExtensionEpub => FILE_EXTENSION_EPUB,\n            Self::FileExtensionEs3 => FILE_EXTENSION_ES3,\n            Self::FileExtensionEsa => FILE_EXTENSION_ESA,\n            Self::FileExtensionEsf => FILE_EXTENSION_ESF,\n            Self::FileExtensionEt3 => FILE_EXTENSION_ET3,\n            Self::FileExtensionEtx => FILE_EXTENSION_ETX,\n            Self::FileExtensionEva => FILE_EXTENSION_EVA,\n            Self::FileExtensionEvy => FILE_EXTENSION_EVY,\n            Self::FileExtensionExe => FILE_EXTENSION_EXE,\n            Self::FileExtensionExi => FILE_EXTENSION_EXI,\n            Self::FileExtensionExt => FILE_EXTENSION_EXT,\n            Self::FileExtensionEz => FILE_EXTENSION_EZ,\n            Self::FileExtensionEz2 => FILE_EXTENSION_EZ2,\n            Self::FileExtensionEz3 => FILE_EXTENSION_EZ3,\n            Self::FileExtensionF => FILE_EXTENSION_F,\n            Self::FileExtensionF4v => FILE_EXTENSION_F4V,\n            Self::FileExtensionF77 => FILE_EXTENSION_F77,\n            Self::FileExtensionF90 => FILE_EXTENSION_F90,\n            Self::FileExtensionFbs => FILE_EXTENSION_FBS,\n            Self::FileExtensionFcdt => FILE_EXTENSION_FCDT,\n            Self::FileExtensionFcs => FILE_EXTENSION_FCS,\n            Self::FileExtensionFdf => FILE_EXTENSION_FDF,\n            Self::FileExtensionFeLaunch => FILE_EXTENSION_FE_LAUNCH,\n            Self::FileExtensionFg5 => FILE_EXTENSION_FG5,\n            Self::FileExtensionFgd => FILE_EXTENSION_FGD,\n            Self::FileExtensionFh => FILE_EXTENSION_FH,\n            Self::FileExtensionFh4 => FILE_EXTENSION_FH4,\n            Self::FileExtensionFh5 => FILE_EXTENSION_FH5,\n            Self::FileExtensionFh7 => FILE_EXTENSION_FH7,\n            Self::FileExtensionFhc => FILE_EXTENSION_FHC,\n            Self::FileExtensionFig => FILE_EXTENSION_FIG,\n            Self::FileExtensionFlac => FILE_EXTENSION_FLAC,\n            Self::FileExtensionFli => FILE_EXTENSION_FLI,\n            Self::FileExtensionFlo => FILE_EXTENSION_FLO,\n            Self::FileExtensionFlv => FILE_EXTENSION_FLV,\n            Self::FileExtensionFlw => FILE_EXTENSION_FLW,\n            Self::FileExtensionFlx => FILE_EXTENSION_FLX,\n            Self::FileExtensionFly => FILE_EXTENSION_FLY,\n            Self::FileExtensionFm => FILE_EXTENSION_FM,\n            Self::FileExtensionFnc => FILE_EXTENSION_FNC,\n            Self::FileExtensionFor => FILE_EXTENSION_FOR,\n            Self::FileExtensionFpx => FILE_EXTENSION_FPX,\n            Self::FileExtensionFrame => FILE_EXTENSION_FRAME,\n            Self::FileExtensionFsc => FILE_EXTENSION_FSC,\n            Self::FileExtensionFst => FILE_EXTENSION_FST,\n            Self::FileExtensionFtc => FILE_EXTENSION_FTC,\n            Self::FileExtensionFti => FILE_EXTENSION_FTI,\n            Self::FileExtensionFvt => FILE_EXTENSION_FVT,\n            Self::FileExtensionFxp => FILE_EXTENSION_FXP,\n            Self::FileExtensionFxpl => FILE_EXTENSION_FXPL,\n            Self::FileExtensionFzs => FILE_EXTENSION_FZS,\n            Self::FileExtensionG2w => FILE_EXTENSION_G2W,\n            Self::FileExtensionG3 => FILE_EXTENSION_G3,\n            Self::FileExtensionG3w => FILE_EXTENSION_G3W,\n            Self::FileExtensionGac => FILE_EXTENSION_GAC,\n            Self::FileExtensionGam => FILE_EXTENSION_GAM,\n            Self::FileExtensionGbr => FILE_EXTENSION_GBR,\n            Self::FileExtensionGca => FILE_EXTENSION_GCA,\n            Self::FileExtensionGdl => FILE_EXTENSION_GDL,\n            Self::FileExtensionGeo => FILE_EXTENSION_GEO,\n            Self::FileExtensionGex => FILE_EXTENSION_GEX,\n            Self::FileExtensionGgb => FILE_EXTENSION_GGB,\n            Self::FileExtensionGgt => FILE_EXTENSION_GGT,\n            Self::FileExtensionGhf => FILE_EXTENSION_GHF,\n            Self::FileExtensionGif => FILE_EXTENSION_GIF,\n            Self::FileExtensionGim => FILE_EXTENSION_GIM,\n            Self::FileExtensionGml => FILE_EXTENSION_GML,\n            Self::FileExtensionGmx => FILE_EXTENSION_GMX,\n            Self::FileExtensionGnumeric => FILE_EXTENSION_GNUMERIC,\n            Self::FileExtensionGph => FILE_EXTENSION_GPH,\n            Self::FileExtensionGpx => FILE_EXTENSION_GPX,\n            Self::FileExtensionGqf => FILE_EXTENSION_GQF,\n            Self::FileExtensionGqs => FILE_EXTENSION_GQS,\n            Self::FileExtensionGram => FILE_EXTENSION_GRAM,\n            Self::FileExtensionGramps => FILE_EXTENSION_GRAMPS,\n            Self::FileExtensionGre => FILE_EXTENSION_GRE,\n            Self::FileExtensionGrv => FILE_EXTENSION_GRV,\n            Self::FileExtensionGrxml => FILE_EXTENSION_GRXML,\n            Self::FileExtensionGsf => FILE_EXTENSION_GSF,\n            Self::FileExtensionGtar => FILE_EXTENSION_GTAR,\n            Self::FileExtensionGtm => FILE_EXTENSION_GTM,\n            Self::FileExtensionGtw => FILE_EXTENSION_GTW,\n            Self::FileExtensionGv => FILE_EXTENSION_GV,\n            Self::FileExtensionGxf => FILE_EXTENSION_GXF,\n            Self::FileExtensionGxt => FILE_EXTENSION_GXT,\n            Self::FileExtensionGz => FILE_EXTENSION_GZ,\n            Self::FileExtensionH => FILE_EXTENSION_H,\n            Self::FileExtensionH261 => FILE_EXTENSION_H261,\n            Self::FileExtensionH263 => FILE_EXTENSION_H263,\n            Self::FileExtensionH264 => FILE_EXTENSION_H264,\n            Self::FileExtensionHal => FILE_EXTENSION_HAL,\n            Self::FileExtensionHbci => FILE_EXTENSION_HBCI,\n            Self::FileExtensionHdf => FILE_EXTENSION_HDF,\n            Self::FileExtensionHh => FILE_EXTENSION_HH,\n            Self::FileExtensionHlp => FILE_EXTENSION_HLP,\n            Self::FileExtensionHpgl => FILE_EXTENSION_HPGL,\n            Self::FileExtensionHpid => FILE_EXTENSION_HPID,\n            Self::FileExtensionHps => FILE_EXTENSION_HPS,\n            Self::FileExtensionHqx => FILE_EXTENSION_HQX,\n            Self::FileExtensionHtc => FILE_EXTENSION_HTC,\n            Self::FileExtensionHtke => FILE_EXTENSION_HTKE,\n            Self::FileExtensionHtm => FILE_EXTENSION_HTM,\n            Self::FileExtensionHtml => FILE_EXTENSION_HTML,\n            Self::FileExtensionHvd => FILE_EXTENSION_HVD,\n            Self::FileExtensionHvp => FILE_EXTENSION_HVP,\n            Self::FileExtensionHvs => FILE_EXTENSION_HVS,\n            Self::FileExtensionI2g => FILE_EXTENSION_I2G,\n            Self::FileExtensionIcc => FILE_EXTENSION_ICC,\n            Self::FileExtensionIce => FILE_EXTENSION_ICE,\n            Self::FileExtensionIcm => FILE_EXTENSION_ICM,\n            Self::FileExtensionIco => FILE_EXTENSION_ICO,\n            Self::FileExtensionIcs => FILE_EXTENSION_ICS,\n            Self::FileExtensionIef => FILE_EXTENSION_IEF,\n            Self::FileExtensionIfb => FILE_EXTENSION_IFB,\n            Self::FileExtensionIfm => FILE_EXTENSION_IFM,\n            Self::FileExtensionIges => FILE_EXTENSION_IGES,\n            Self::FileExtensionIgl => FILE_EXTENSION_IGL,\n            Self::FileExtensionIgm => FILE_EXTENSION_IGM,\n            Self::FileExtensionIgs => FILE_EXTENSION_IGS,\n            Self::FileExtensionIgx => FILE_EXTENSION_IGX,\n            Self::FileExtensionIif => FILE_EXTENSION_IIF,\n            Self::FileExtensionImp => FILE_EXTENSION_IMP,\n            Self::FileExtensionIms => FILE_EXTENSION_IMS,\n            Self::FileExtensionIn => FILE_EXTENSION_IN,\n            Self::FileExtensionInk => FILE_EXTENSION_INK,\n            Self::FileExtensionInkml => FILE_EXTENSION_INKML,\n            Self::FileExtensionInstall => FILE_EXTENSION_INSTALL,\n            Self::FileExtensionIota => FILE_EXTENSION_IOTA,\n            Self::FileExtensionIpfix => FILE_EXTENSION_IPFIX,\n            Self::FileExtensionIpk => FILE_EXTENSION_IPK,\n            Self::FileExtensionIrm => FILE_EXTENSION_IRM,\n            Self::FileExtensionIrp => FILE_EXTENSION_IRP,\n            Self::FileExtensionIso => FILE_EXTENSION_ISO,\n            Self::FileExtensionItp => FILE_EXTENSION_ITP,\n            Self::FileExtensionIvp => FILE_EXTENSION_IVP,\n            Self::FileExtensionIvu => FILE_EXTENSION_IVU,\n            Self::FileExtensionJad => FILE_EXTENSION_JAD,\n            Self::FileExtensionJam => FILE_EXTENSION_JAM,\n            Self::FileExtensionJar => FILE_EXTENSION_JAR,\n            Self::FileExtensionJava => FILE_EXTENSION_JAVA,\n            Self::FileExtensionJisp => FILE_EXTENSION_JISP,\n            Self::FileExtensionJlt => FILE_EXTENSION_JLT,\n            Self::FileExtensionJnlp => FILE_EXTENSION_JNLP,\n            Self::FileExtensionJoda => FILE_EXTENSION_JODA,\n            Self::FileExtensionJpe => FILE_EXTENSION_JPE,\n            Self::FileExtensionJpeg => FILE_EXTENSION_JPEG,\n            Self::FileExtensionJpg => FILE_EXTENSION_JPG,\n            Self::FileExtensionJpgm => FILE_EXTENSION_JPGM,\n            Self::FileExtensionJpgv => FILE_EXTENSION_JPGV,\n            Self::FileExtensionJpm => FILE_EXTENSION_JPM,\n            Self::FileExtensionJs => FILE_EXTENSION_JS,\n            Self::FileExtensionJsf => FILE_EXTENSION_JSF,\n            Self::FileExtensionJson => FILE_EXTENSION_JSON,\n            Self::FileExtensionJsonml => FILE_EXTENSION_JSONML,\n            Self::FileExtensionJspf => FILE_EXTENSION_JSPF,\n            Self::FileExtensionKar => FILE_EXTENSION_KAR,\n            Self::FileExtensionKarbon => FILE_EXTENSION_KARBON,\n            Self::FileExtensionKfo => FILE_EXTENSION_KFO,\n            Self::FileExtensionKia => FILE_EXTENSION_KIA,\n            Self::FileExtensionKml => FILE_EXTENSION_KML,\n            Self::FileExtensionKmz => FILE_EXTENSION_KMZ,\n            Self::FileExtensionKne => FILE_EXTENSION_KNE,\n            Self::FileExtensionKnp => FILE_EXTENSION_KNP,\n            Self::FileExtensionKon => FILE_EXTENSION_KON,\n            Self::FileExtensionKpr => FILE_EXTENSION_KPR,\n            Self::FileExtensionKpt => FILE_EXTENSION_KPT,\n            Self::FileExtensionKpxx => FILE_EXTENSION_KPXX,\n            Self::FileExtensionKsp => FILE_EXTENSION_KSP,\n            Self::FileExtensionKtr => FILE_EXTENSION_KTR,\n            Self::FileExtensionKtx => FILE_EXTENSION_KTX,\n            Self::FileExtensionKtz => FILE_EXTENSION_KTZ,\n            Self::FileExtensionKwd => FILE_EXTENSION_KWD,\n            Self::FileExtensionKwt => FILE_EXTENSION_KWT,\n            Self::FileExtensionLasxml => FILE_EXTENSION_LASXML,\n            Self::FileExtensionLatex => FILE_EXTENSION_LATEX,\n            Self::FileExtensionLbd => FILE_EXTENSION_LBD,\n            Self::FileExtensionLbe => FILE_EXTENSION_LBE,\n            Self::FileExtensionLes => FILE_EXTENSION_LES,\n            Self::FileExtensionLha => FILE_EXTENSION_LHA,\n            Self::FileExtensionLink66 => FILE_EXTENSION_LINK66,\n            Self::FileExtensionList => FILE_EXTENSION_LIST,\n            Self::FileExtensionList3820 => FILE_EXTENSION_LIST3820,\n            Self::FileExtensionListafp => FILE_EXTENSION_LISTAFP,\n            Self::FileExtensionLnk => FILE_EXTENSION_LNK,\n            Self::FileExtensionLog => FILE_EXTENSION_LOG,\n            Self::FileExtensionLostxml => FILE_EXTENSION_LOSTXML,\n            Self::FileExtensionLrf => FILE_EXTENSION_LRF,\n            Self::FileExtensionLrm => FILE_EXTENSION_LRM,\n            Self::FileExtensionLtf => FILE_EXTENSION_LTF,\n            Self::FileExtensionLvp => FILE_EXTENSION_LVP,\n            Self::FileExtensionLwp => FILE_EXTENSION_LWP,\n            Self::FileExtensionLzh => FILE_EXTENSION_LZH,\n            Self::FileExtensionM13 => FILE_EXTENSION_M13,\n            Self::FileExtensionM14 => FILE_EXTENSION_M14,\n            Self::FileExtensionM1v => FILE_EXTENSION_M1V,\n            Self::FileExtensionM21 => FILE_EXTENSION_M21,\n            Self::FileExtensionM2a => FILE_EXTENSION_M2A,\n            Self::FileExtensionM2v => FILE_EXTENSION_M2V,\n            Self::FileExtensionM3a => FILE_EXTENSION_M3A,\n            Self::FileExtensionM3u => FILE_EXTENSION_M3U,\n            Self::FileExtensionM3u8 => FILE_EXTENSION_M3U8,\n            Self::FileExtensionM4a => FILE_EXTENSION_M4A,\n            Self::FileExtensionM4b => FILE_EXTENSION_M4B,\n            Self::FileExtensionM4r => FILE_EXTENSION_M4R,\n            Self::FileExtensionM4u => FILE_EXTENSION_M4U,\n            Self::FileExtensionM4v => FILE_EXTENSION_M4V,\n            Self::FileExtensionMarkdown => FILE_EXTENSION_MARKDOWN,\n            Self::FileExtensionToml => FILE_EXTENSION_TOML,\n            Self::FileExtensionYaml => FILE_EXTENSION_YAML,\n            Self::FileExtensionYml => FILE_EXTENSION_YML,\n            Self::FileExtensionIni => FILE_EXTENSION_INI,\n            Self::FileExtensionCfg => FILE_EXTENSION_CFG,\n            Self::FileExtensionPython => FILE_EXTENSION_PY,\n            Self::FileExtensionGo => FILE_EXTENSION_GO,\n            Self::FileExtensionTypeScript => FILE_EXTENSION_TS,\n            Self::FileExtensionCSharp => FILE_EXTENSION_CS,\n            Self::FileExtensionPhp => FILE_EXTENSION_PHP,\n            Self::FileExtensionRuby => FILE_EXTENSION_RB,\n            Self::FileExtensionSwift => FILE_EXTENSION_SWIFT,\n            Self::FileExtensionKotlin => FILE_EXTENSION_KT,\n            Self::FileExtensionKotlinScript => FILE_EXTENSION_KTS,\n            Self::FileExtensionScala => FILE_EXTENSION_SCALA,\n            Self::FileExtensionIbmScOrScalaScript => FILE_EXTENSION_SC,\n            Self::FileExtensionPerl => FILE_EXTENSION_PL,\n            Self::FileExtensionPerlModule => FILE_EXTENSION_PM,\n            Self::FileExtensionLua => FILE_EXTENSION_LUA,\n            Self::FileExtensionPowerShell => FILE_EXTENSION_PS1,\n            Self::FileExtensionCppHeader => FILE_EXTENSION_HPP,\n            Self::FileExtensionObjectiveC => FILE_EXTENSION_M,\n            Self::FileExtensionObjectiveCpp => FILE_EXTENSION_MM,\n            Self::FileExtensionGroovy => FILE_EXTENSION_GROOVY,\n            Self::FileExtensionR => FILE_EXTENSION_R,\n            Self::FileExtensionScss => FILE_EXTENSION_SCSS,\n            Self::FileExtensionSass => FILE_EXTENSION_SASS,\n            Self::FileExtensionLess => FILE_EXTENSION_LESS,\n            Self::FileExtensionVue => FILE_EXTENSION_VUE,\n            Self::FileExtensionJsx => FILE_EXTENSION_JSX,\n            Self::FileExtensionTsx => FILE_EXTENSION_TSX,\n            Self::FileExtensionDockerfile => FILE_EXTENSION_DOCKERFILE,\n            Self::FileExtensionMakefile => FILE_EXTENSION_MAKEFILE,\n            Self::FileExtensionRs => FILE_EXTENSION_RS,\n            Self::FileExtensionHaskell => FILE_EXTENSION_HS,\n            Self::FileExtensionErlang => FILE_EXTENSION_ERL,\n            Self::FileExtensionElixir => FILE_EXTENSION_EX,\n            Self::FileExtensionElixirScript => FILE_EXTENSION_EXS,\n            Self::FileExtensionClojure => FILE_EXTENSION_CLJ,\n            Self::FileExtensionClojureScript => FILE_EXTENSION_CLJS,\n            Self::FileExtensionClojureCommon => FILE_EXTENSION_CLJC,\n            Self::FileExtensionFSharp => FILE_EXTENSION_FS,\n            Self::FileExtensionFSharpScript => FILE_EXTENSION_FSX,\n            Self::FileExtensionOCaml => FILE_EXTENSION_ML,\n            Self::FileExtensionOCamlInterface => FILE_EXTENSION_MLI,\n            Self::FileExtensionBash => FILE_EXTENSION_BASH,\n            Self::FileExtensionZsh => FILE_EXTENSION_ZSH,\n            Self::FileExtensionEnv => FILE_EXTENSION_ENV,\n            Self::FileExtensionCj => FILE_EXTENSION_CJ,\n            Self::FileExtensionGitignore => FILE_EXTENSION_GITIGNORE,\n            Self::FileExtensionMa => FILE_EXTENSION_MA,\n            Self::FileExtensionMac => FILE_EXTENSION_MAC,\n            Self::FileExtensionMads => FILE_EXTENSION_MADS,\n            Self::FileExtensionMag => FILE_EXTENSION_MAG,\n            Self::FileExtensionMaker => FILE_EXTENSION_MAKER,\n            Self::FileExtensionMan => FILE_EXTENSION_MAN,\n            Self::FileExtensionMar => FILE_EXTENSION_MAR,\n            Self::FileExtensionMathml => FILE_EXTENSION_MATHML,\n            Self::FileExtensionMb => FILE_EXTENSION_MB,\n            Self::FileExtensionMbk => FILE_EXTENSION_MBK,\n            Self::FileExtensionMbox => FILE_EXTENSION_MBOX,\n            Self::FileExtensionMc1 => FILE_EXTENSION_MC1,\n            Self::FileExtensionMcd => FILE_EXTENSION_MCD,\n            Self::FileExtensionMcurl => FILE_EXTENSION_MCURL,\n            Self::FileExtensionMdb => FILE_EXTENSION_MDB,\n            Self::FileExtensionMdi => FILE_EXTENSION_MDI,\n            Self::FileExtensionMe => FILE_EXTENSION_ME,\n            Self::FileExtensionMesh => FILE_EXTENSION_MESH,\n            Self::FileExtensionMeta4 => FILE_EXTENSION_META4,\n            Self::FileExtensionMetalink => FILE_EXTENSION_METALINK,\n            Self::FileExtensionMets => FILE_EXTENSION_METS,\n            Self::FileExtensionMfm => FILE_EXTENSION_MFM,\n            Self::FileExtensionMft => FILE_EXTENSION_MFT,\n            Self::FileExtensionMgp => FILE_EXTENSION_MGP,\n            Self::FileExtensionMgz => FILE_EXTENSION_MGZ,\n            Self::FileExtensionMid => FILE_EXTENSION_MID,\n            Self::FileExtensionMidi => FILE_EXTENSION_MIDI,\n            Self::FileExtensionMie => FILE_EXTENSION_MIE,\n            Self::FileExtensionMif => FILE_EXTENSION_MIF,\n            Self::FileExtensionMime => FILE_EXTENSION_MIME,\n            Self::FileExtensionMj2 => FILE_EXTENSION_MJ2,\n            Self::FileExtensionMjp2 => FILE_EXTENSION_MJP2,\n            Self::FileExtensionMk3d => FILE_EXTENSION_MK3D,\n            Self::FileExtensionMka => FILE_EXTENSION_MKA,\n            Self::FileExtensionMks => FILE_EXTENSION_MKS,\n            Self::FileExtensionMkv => FILE_EXTENSION_MKV,\n            Self::FileExtensionMlp => FILE_EXTENSION_MLP,\n            Self::FileExtensionMmd => FILE_EXTENSION_MMD,\n            Self::FileExtensionMmf => FILE_EXTENSION_MMF,\n            Self::FileExtensionMmr => FILE_EXTENSION_MMR,\n            Self::FileExtensionMng => FILE_EXTENSION_MNG,\n            Self::FileExtensionMny => FILE_EXTENSION_MNY,\n            Self::FileExtensionMobi => FILE_EXTENSION_MOBI,\n            Self::FileExtensionMods => FILE_EXTENSION_MODS,\n            Self::FileExtensionMov => FILE_EXTENSION_MOV,\n            Self::FileExtensionMovie => FILE_EXTENSION_MOVIE,\n            Self::FileExtensionMp1 => FILE_EXTENSION_MP1,\n            Self::FileExtensionMp2 => FILE_EXTENSION_MP2,\n            Self::FileExtensionMp21 => FILE_EXTENSION_MP21,\n            Self::FileExtensionMp2a => FILE_EXTENSION_MP2A,\n            Self::FileExtensionMp3 => FILE_EXTENSION_MP3,\n            Self::FileExtensionMp4 => FILE_EXTENSION_MP4,\n            Self::FileExtensionMp4a => FILE_EXTENSION_MP4A,\n            Self::FileExtensionMp4s => FILE_EXTENSION_MP4S,\n            Self::FileExtensionMp4v => FILE_EXTENSION_MP4V,\n            Self::FileExtensionMpa => FILE_EXTENSION_MPA,\n            Self::FileExtensionMpc => FILE_EXTENSION_MPC,\n            Self::FileExtensionMpe => FILE_EXTENSION_MPE,\n            Self::FileExtensionMpeg => FILE_EXTENSION_MPEG,\n            Self::FileExtensionMpega => FILE_EXTENSION_MPEGA,\n            Self::FileExtensionMpg => FILE_EXTENSION_MPG,\n            Self::FileExtensionMpg4 => FILE_EXTENSION_MPG4,\n            Self::FileExtensionMpga => FILE_EXTENSION_MPGA,\n            Self::FileExtensionMpkg => FILE_EXTENSION_MPKG,\n            Self::FileExtensionMpm => FILE_EXTENSION_MPM,\n            Self::FileExtensionMpn => FILE_EXTENSION_MPN,\n            Self::FileExtensionMpp => FILE_EXTENSION_MPP,\n            Self::FileExtensionMpt => FILE_EXTENSION_MPT,\n            Self::FileExtensionMpv2 => FILE_EXTENSION_MPV2,\n            Self::FileExtensionMpy => FILE_EXTENSION_MPY,\n            Self::FileExtensionMqy => FILE_EXTENSION_MQY,\n            Self::FileExtensionMrc => FILE_EXTENSION_MRC,\n            Self::FileExtensionMrcx => FILE_EXTENSION_MRCX,\n            Self::FileExtensionMs => FILE_EXTENSION_MS,\n            Self::FileExtensionMscml => FILE_EXTENSION_MSCML,\n            Self::FileExtensionMseed => FILE_EXTENSION_MSEED,\n            Self::FileExtensionMseq => FILE_EXTENSION_MSEQ,\n            Self::FileExtensionMsf => FILE_EXTENSION_MSF,\n            Self::FileExtensionMsh => FILE_EXTENSION_MSH,\n            Self::FileExtensionMsi => FILE_EXTENSION_MSI,\n            Self::FileExtensionMsl => FILE_EXTENSION_MSL,\n            Self::FileExtensionMsty => FILE_EXTENSION_MSTY,\n            Self::FileExtensionMts => FILE_EXTENSION_MTS,\n            Self::FileExtensionMus => FILE_EXTENSION_MUS,\n            Self::FileExtensionMusicxml => FILE_EXTENSION_MUSICXML,\n            Self::FileExtensionMvb => FILE_EXTENSION_MVB,\n            Self::FileExtensionMwf => FILE_EXTENSION_MWF,\n            Self::FileExtensionMxf => FILE_EXTENSION_MXF,\n            Self::FileExtensionMxl => FILE_EXTENSION_MXL,\n            Self::FileExtensionMxml => FILE_EXTENSION_MXML,\n            Self::FileExtensionMxs => FILE_EXTENSION_MXS,\n            Self::FileExtensionMxu => FILE_EXTENSION_MXU,\n            Self::FileExtensionNGage => FILE_EXTENSION_N_GAGE,\n            Self::FileExtensionN3 => FILE_EXTENSION_N3,\n            Self::FileExtensionNb => FILE_EXTENSION_NB,\n            Self::FileExtensionNbp => FILE_EXTENSION_NBP,\n            Self::FileExtensionNc => FILE_EXTENSION_NC,\n            Self::FileExtensionNcx => FILE_EXTENSION_NCX,\n            Self::FileExtensionNfo => FILE_EXTENSION_NFO,\n            Self::FileExtensionNgdat => FILE_EXTENSION_NGDAT,\n            Self::FileExtensionNitf => FILE_EXTENSION_NITF,\n            Self::FileExtensionNlu => FILE_EXTENSION_NLU,\n            Self::FileExtensionNml => FILE_EXTENSION_NML,\n            Self::FileExtensionNnd => FILE_EXTENSION_NND,\n            Self::FileExtensionNns => FILE_EXTENSION_NNS,\n            Self::FileExtensionNnw => FILE_EXTENSION_NNW,\n            Self::FileExtensionNpx => FILE_EXTENSION_NPX,\n            Self::FileExtensionNsc => FILE_EXTENSION_NSC,\n            Self::FileExtensionNsf => FILE_EXTENSION_NSF,\n            Self::FileExtensionNtf => FILE_EXTENSION_NTF,\n            Self::FileExtensionNzb => FILE_EXTENSION_NZB,\n            Self::FileExtensionOa2 => FILE_EXTENSION_OA2,\n            Self::FileExtensionOa3 => FILE_EXTENSION_OA3,\n            Self::FileExtensionOas => FILE_EXTENSION_OAS,\n            Self::FileExtensionObd => FILE_EXTENSION_OBD,\n            Self::FileExtensionObj => FILE_EXTENSION_OBJ,\n            Self::FileExtensionOda => FILE_EXTENSION_ODA,\n            Self::FileExtensionOdb => FILE_EXTENSION_ODB,\n            Self::FileExtensionOdc => FILE_EXTENSION_ODC,\n            Self::FileExtensionOdf => FILE_EXTENSION_ODF,\n            Self::FileExtensionOdft => FILE_EXTENSION_ODFT,\n            Self::FileExtensionOdg => FILE_EXTENSION_ODG,\n            Self::FileExtensionOdi => FILE_EXTENSION_ODI,\n            Self::FileExtensionOdm => FILE_EXTENSION_ODM,\n            Self::FileExtensionOdp => FILE_EXTENSION_ODP,\n            Self::FileExtensionOds => FILE_EXTENSION_ODS,\n            Self::FileExtensionOdt => FILE_EXTENSION_ODT,\n            Self::FileExtensionOga => FILE_EXTENSION_OGA,\n            Self::FileExtensionOgg => FILE_EXTENSION_OGG,\n            Self::FileExtensionOgv => FILE_EXTENSION_OGV,\n            Self::FileExtensionOgx => FILE_EXTENSION_OGX,\n            Self::FileExtensionOmdoc => FILE_EXTENSION_OMDOC,\n            Self::FileExtensionOnepkg => FILE_EXTENSION_ONEPKG,\n            Self::FileExtensionOnetmp => FILE_EXTENSION_ONETMP,\n            Self::FileExtensionOnetoc => FILE_EXTENSION_ONETOC,\n            Self::FileExtensionOnetoc2 => FILE_EXTENSION_ONETOC2,\n            Self::FileExtensionOpf => FILE_EXTENSION_OPF,\n            Self::FileExtensionOpml => FILE_EXTENSION_OPML,\n            Self::FileExtensionOprc => FILE_EXTENSION_OPRC,\n            Self::FileExtensionOrg => FILE_EXTENSION_ORG,\n            Self::FileExtensionOsf => FILE_EXTENSION_OSF,\n            Self::FileExtensionOsfpvg => FILE_EXTENSION_OSFPVG,\n            Self::FileExtensionOtc => FILE_EXTENSION_OTC,\n            Self::FileExtensionOtf => FILE_EXTENSION_OTF,\n            Self::FileExtensionOtg => FILE_EXTENSION_OTG,\n            Self::FileExtensionOth => FILE_EXTENSION_OTH,\n            Self::FileExtensionOti => FILE_EXTENSION_OTI,\n            Self::FileExtensionOtp => FILE_EXTENSION_OTP,\n            Self::FileExtensionOts => FILE_EXTENSION_OTS,\n            Self::FileExtensionOtt => FILE_EXTENSION_OTT,\n            Self::FileExtensionOxps => FILE_EXTENSION_OXPS,\n            Self::FileExtensionOxt => FILE_EXTENSION_OXT,\n            Self::FileExtensionP => FILE_EXTENSION_P,\n            Self::FileExtensionP10 => FILE_EXTENSION_P10,\n            Self::FileExtensionP12 => FILE_EXTENSION_P12,\n            Self::FileExtensionP7b => FILE_EXTENSION_P7B,\n            Self::FileExtensionP7c => FILE_EXTENSION_P7C,\n            Self::FileExtensionP7m => FILE_EXTENSION_P7M,\n            Self::FileExtensionP7r => FILE_EXTENSION_P7R,\n            Self::FileExtensionP7s => FILE_EXTENSION_P7S,\n            Self::FileExtensionP8 => FILE_EXTENSION_P8,\n            Self::FileExtensionPas => FILE_EXTENSION_PAS,\n            Self::FileExtensionPaw => FILE_EXTENSION_PAW,\n            Self::FileExtensionPbd => FILE_EXTENSION_PBD,\n            Self::FileExtensionPbm => FILE_EXTENSION_PBM,\n            Self::FileExtensionPcap => FILE_EXTENSION_PCAP,\n            Self::FileExtensionPcf => FILE_EXTENSION_PCF,\n            Self::FileExtensionPcl => FILE_EXTENSION_PCL,\n            Self::FileExtensionPclxl => FILE_EXTENSION_PCLXL,\n            Self::FileExtensionPct => FILE_EXTENSION_PCT,\n            Self::FileExtensionPcurl => FILE_EXTENSION_PCURL,\n            Self::FileExtensionPcx => FILE_EXTENSION_PCX,\n            Self::FileExtensionPdb => FILE_EXTENSION_PDB,\n            Self::FileExtensionPdf => FILE_EXTENSION_PDF,\n            Self::FileExtensionPfa => FILE_EXTENSION_PFA,\n            Self::FileExtensionPfb => FILE_EXTENSION_PFB,\n            Self::FileExtensionPfm => FILE_EXTENSION_PFM,\n            Self::FileExtensionPfr => FILE_EXTENSION_PFR,\n            Self::FileExtensionPfx => FILE_EXTENSION_PFX,\n            Self::FileExtensionPgm => FILE_EXTENSION_PGM,\n            Self::FileExtensionPgn => FILE_EXTENSION_PGN,\n            Self::FileExtensionPgp => FILE_EXTENSION_PGP,\n            Self::FileExtensionPic => FILE_EXTENSION_PIC,\n            Self::FileExtensionPict => FILE_EXTENSION_PICT,\n            Self::FileExtensionPkg => FILE_EXTENSION_PKG,\n            Self::FileExtensionPki => FILE_EXTENSION_PKI,\n            Self::FileExtensionPkipath => FILE_EXTENSION_PKIPATH,\n            Self::FileExtensionPlb => FILE_EXTENSION_PLB,\n            Self::FileExtensionPlc => FILE_EXTENSION_PLC,\n            Self::FileExtensionPlf => FILE_EXTENSION_PLF,\n            Self::FileExtensionPls => FILE_EXTENSION_PLS,\n            Self::FileExtensionPml => FILE_EXTENSION_PML,\n            Self::FileExtensionPng => FILE_EXTENSION_PNG,\n            Self::FileExtensionPnm => FILE_EXTENSION_PNM,\n            Self::FileExtensionPnt => FILE_EXTENSION_PNT,\n            Self::FileExtensionPortpkg => FILE_EXTENSION_PORTPKG,\n            Self::FileExtensionPot => FILE_EXTENSION_POT,\n            Self::FileExtensionPotm => FILE_EXTENSION_POTM,\n            Self::FileExtensionPotx => FILE_EXTENSION_POTX,\n            Self::FileExtensionPpam => FILE_EXTENSION_PPAM,\n            Self::FileExtensionPpd => FILE_EXTENSION_PPD,\n            Self::FileExtensionPpm => FILE_EXTENSION_PPM,\n            Self::FileExtensionPps => FILE_EXTENSION_PPS,\n            Self::FileExtensionPpsm => FILE_EXTENSION_PPSM,\n            Self::FileExtensionPpsx => FILE_EXTENSION_PPSX,\n            Self::FileExtensionPpt => FILE_EXTENSION_PPT,\n            Self::FileExtensionPptm => FILE_EXTENSION_PPTM,\n            Self::FileExtensionPptx => FILE_EXTENSION_PPTX,\n            Self::FileExtensionPqa => FILE_EXTENSION_PQA,\n            Self::FileExtensionPrc => FILE_EXTENSION_PRC,\n            Self::FileExtensionPre => FILE_EXTENSION_PRE,\n            Self::FileExtensionPrf => FILE_EXTENSION_PRF,\n            Self::FileExtensionPs => FILE_EXTENSION_PS,\n            Self::FileExtensionPsb => FILE_EXTENSION_PSB,\n            Self::FileExtensionPsd => FILE_EXTENSION_PSD,\n            Self::FileExtensionPsf => FILE_EXTENSION_PSF,\n            Self::FileExtensionPskcxml => FILE_EXTENSION_PSKCXML,\n            Self::FileExtensionPtid => FILE_EXTENSION_PTID,\n            Self::FileExtensionPub => FILE_EXTENSION_PUB,\n            Self::FileExtensionPvb => FILE_EXTENSION_PVB,\n            Self::FileExtensionPwn => FILE_EXTENSION_PWN,\n            Self::FileExtensionPya => FILE_EXTENSION_PYA,\n            Self::FileExtensionPyv => FILE_EXTENSION_PYV,\n            Self::FileExtensionQam => FILE_EXTENSION_QAM,\n            Self::FileExtensionQbo => FILE_EXTENSION_QBO,\n            Self::FileExtensionQfx => FILE_EXTENSION_QFX,\n            Self::FileExtensionQps => FILE_EXTENSION_QPS,\n            Self::FileExtensionQt => FILE_EXTENSION_QT,\n            Self::FileExtensionQti => FILE_EXTENSION_QTI,\n            Self::FileExtensionQtif => FILE_EXTENSION_QTIF,\n            Self::FileExtensionQwd => FILE_EXTENSION_QWD,\n            Self::FileExtensionQwt => FILE_EXTENSION_QWT,\n            Self::FileExtensionQxb => FILE_EXTENSION_QXB,\n            Self::FileExtensionQxd => FILE_EXTENSION_QXD,\n            Self::FileExtensionQxl => FILE_EXTENSION_QXL,\n            Self::FileExtensionQxt => FILE_EXTENSION_QXT,\n            Self::FileExtensionRa => FILE_EXTENSION_RA,\n            Self::FileExtensionRam => FILE_EXTENSION_RAM,\n            Self::FileExtensionRar => FILE_EXTENSION_RAR,\n            Self::FileExtensionRas => FILE_EXTENSION_RAS,\n            Self::FileExtensionRcprofile => FILE_EXTENSION_RCPROFILE,\n            Self::FileExtensionRdf => FILE_EXTENSION_RDF,\n            Self::FileExtensionRdz => FILE_EXTENSION_RDZ,\n            Self::FileExtensionRep => FILE_EXTENSION_REP,\n            Self::FileExtensionRes => FILE_EXTENSION_RES,\n            Self::FileExtensionRgb => FILE_EXTENSION_RGB,\n            Self::FileExtensionRif => FILE_EXTENSION_RIF,\n            Self::FileExtensionRip => FILE_EXTENSION_RIP,\n            Self::FileExtensionRis => FILE_EXTENSION_RIS,\n            Self::FileExtensionRl => FILE_EXTENSION_RL,\n            Self::FileExtensionRlc => FILE_EXTENSION_RLC,\n            Self::FileExtensionRld => FILE_EXTENSION_RLD,\n            Self::FileExtensionRm => FILE_EXTENSION_RM,\n            Self::FileExtensionRmi => FILE_EXTENSION_RMI,\n            Self::FileExtensionRmp => FILE_EXTENSION_RMP,\n            Self::FileExtensionRms => FILE_EXTENSION_RMS,\n            Self::FileExtensionRmvb => FILE_EXTENSION_RMVB,\n            Self::FileExtensionRnc => FILE_EXTENSION_RNC,\n            Self::FileExtensionRoa => FILE_EXTENSION_ROA,\n            Self::FileExtensionRoff => FILE_EXTENSION_ROFF,\n            Self::FileExtensionRp9 => FILE_EXTENSION_RP9,\n            Self::FileExtensionRpss => FILE_EXTENSION_RPSS,\n            Self::FileExtensionRpst => FILE_EXTENSION_RPST,\n            Self::FileExtensionRq => FILE_EXTENSION_RQ,\n            Self::FileExtensionRsd => FILE_EXTENSION_RSD,\n            Self::FileExtensionRss => FILE_EXTENSION_RSS,\n            Self::FileExtensionRtf => FILE_EXTENSION_RTF,\n            Self::FileExtensionRtx => FILE_EXTENSION_RTX,\n            Self::FileExtensionS => FILE_EXTENSION_S,\n            Self::FileExtensionS3m => FILE_EXTENSION_S3M,\n            Self::FileExtensionSaf => FILE_EXTENSION_SAF,\n            Self::FileExtensionSbml => FILE_EXTENSION_SBML,\n            Self::FileExtensionSc => FILE_EXTENSION_SC,\n            Self::FileExtensionScd => FILE_EXTENSION_SCD,\n            Self::FileExtensionScm => FILE_EXTENSION_SCM,\n            Self::FileExtensionScq => FILE_EXTENSION_SCQ,\n            Self::FileExtensionScs => FILE_EXTENSION_SCS,\n            Self::FileExtensionScurl => FILE_EXTENSION_SCURL,\n            Self::FileExtensionSda => FILE_EXTENSION_SDA,\n            Self::FileExtensionSdc => FILE_EXTENSION_SDC,\n            Self::FileExtensionSdd => FILE_EXTENSION_SDD,\n            Self::FileExtensionSdkd => FILE_EXTENSION_SDKD,\n            Self::FileExtensionSdkm => FILE_EXTENSION_SDKM,\n            Self::FileExtensionSdp => FILE_EXTENSION_SDP,\n            Self::FileExtensionSdw => FILE_EXTENSION_SDW,\n            Self::FileExtensionSee => FILE_EXTENSION_SEE,\n            Self::FileExtensionSeed => FILE_EXTENSION_SEED,\n            Self::FileExtensionSema => FILE_EXTENSION_SEMA,\n            Self::FileExtensionSemd => FILE_EXTENSION_SEMD,\n            Self::FileExtensionSemf => FILE_EXTENSION_SEMF,\n            Self::FileExtensionSer => FILE_EXTENSION_SER,\n            Self::FileExtensionSetpay => FILE_EXTENSION_SETPAY,\n            Self::FileExtensionSetreg => FILE_EXTENSION_SETREG,\n            Self::FileExtensionSfdHdstx => FILE_EXTENSION_SFD_HDSTX,\n            Self::FileExtensionSfs => FILE_EXTENSION_SFS,\n            Self::FileExtensionSfv => FILE_EXTENSION_SFV,\n            Self::FileExtensionSgi => FILE_EXTENSION_SGI,\n            Self::FileExtensionSgl => FILE_EXTENSION_SGL,\n            Self::FileExtensionSgm => FILE_EXTENSION_SGM,\n            Self::FileExtensionSgml => FILE_EXTENSION_SGML,\n            Self::FileExtensionSh => FILE_EXTENSION_SH,\n            Self::FileExtensionShar => FILE_EXTENSION_SHAR,\n            Self::FileExtensionShf => FILE_EXTENSION_SHF,\n            Self::FileExtensionSid => FILE_EXTENSION_SID,\n            Self::FileExtensionSig => FILE_EXTENSION_SIG,\n            Self::FileExtensionSil => FILE_EXTENSION_SIL,\n            Self::FileExtensionSilo => FILE_EXTENSION_SILO,\n            Self::FileExtensionSis => FILE_EXTENSION_SIS,\n            Self::FileExtensionSisx => FILE_EXTENSION_SISX,\n            Self::FileExtensionSit => FILE_EXTENSION_SIT,\n            Self::FileExtensionSitx => FILE_EXTENSION_SITX,\n            Self::FileExtensionSkd => FILE_EXTENSION_SKD,\n            Self::FileExtensionSkm => FILE_EXTENSION_SKM,\n            Self::FileExtensionSkp => FILE_EXTENSION_SKP,\n            Self::FileExtensionSkt => FILE_EXTENSION_SKT,\n            Self::FileExtensionSldm => FILE_EXTENSION_SLDM,\n            Self::FileExtensionSldx => FILE_EXTENSION_SLDX,\n            Self::FileExtensionSlt => FILE_EXTENSION_SLT,\n            Self::FileExtensionSm => FILE_EXTENSION_SM,\n            Self::FileExtensionSmf => FILE_EXTENSION_SMF,\n            Self::FileExtensionSmi => FILE_EXTENSION_SMI,\n            Self::FileExtensionSmil => FILE_EXTENSION_SMIL,\n            Self::FileExtensionSmv => FILE_EXTENSION_SMV,\n            Self::FileExtensionSmzip => FILE_EXTENSION_SMZIP,\n            Self::FileExtensionSnd => FILE_EXTENSION_SND,\n            Self::FileExtensionSnf => FILE_EXTENSION_SNF,\n            Self::FileExtensionSo => FILE_EXTENSION_SO,\n            Self::FileExtensionSpc => FILE_EXTENSION_SPC,\n            Self::FileExtensionSpf => FILE_EXTENSION_SPF,\n            Self::FileExtensionSpl => FILE_EXTENSION_SPL,\n            Self::FileExtensionSpot => FILE_EXTENSION_SPOT,\n            Self::FileExtensionSpp => FILE_EXTENSION_SPP,\n            Self::FileExtensionSpq => FILE_EXTENSION_SPQ,\n            Self::FileExtensionSpx => FILE_EXTENSION_SPX,\n            Self::FileExtensionSql => FILE_EXTENSION_SQL,\n            Self::FileExtensionSrc => FILE_EXTENSION_SRC,\n            Self::FileExtensionSrt => FILE_EXTENSION_SRT,\n            Self::FileExtensionSru => FILE_EXTENSION_SRU,\n            Self::FileExtensionSrx => FILE_EXTENSION_SRX,\n            Self::FileExtensionSsdl => FILE_EXTENSION_SSDL,\n            Self::FileExtensionSse => FILE_EXTENSION_SSE,\n            Self::FileExtensionSsf => FILE_EXTENSION_SSF,\n            Self::FileExtensionSsml => FILE_EXTENSION_SSML,\n            Self::FileExtensionSt => FILE_EXTENSION_ST,\n            Self::FileExtensionStc => FILE_EXTENSION_STC,\n            Self::FileExtensionStd => FILE_EXTENSION_STD,\n            Self::FileExtensionStf => FILE_EXTENSION_STF,\n            Self::FileExtensionSti => FILE_EXTENSION_STI,\n            Self::FileExtensionStk => FILE_EXTENSION_STK,\n            Self::FileExtensionStl => FILE_EXTENSION_STL,\n            Self::FileExtensionStr => FILE_EXTENSION_STR,\n            Self::FileExtensionStw => FILE_EXTENSION_STW,\n            Self::FileExtensionSub => FILE_EXTENSION_SUB,\n            Self::FileExtensionSus => FILE_EXTENSION_SUS,\n            Self::FileExtensionSusp => FILE_EXTENSION_SUSP,\n            Self::FileExtensionSv4cpio => FILE_EXTENSION_SV4CPIO,\n            Self::FileExtensionSv4crc => FILE_EXTENSION_SV4CRC,\n            Self::FileExtensionSvc => FILE_EXTENSION_SVC,\n            Self::FileExtensionSvd => FILE_EXTENSION_SVD,\n            Self::FileExtensionSvg => FILE_EXTENSION_SVG,\n            Self::FileExtensionSvgz => FILE_EXTENSION_SVGZ,\n            Self::FileExtensionSwa => FILE_EXTENSION_SWA,\n            Self::FileExtensionSwf => FILE_EXTENSION_SWF,\n            Self::FileExtensionSwi => FILE_EXTENSION_SWI,\n            Self::FileExtensionSxc => FILE_EXTENSION_SXC,\n            Self::FileExtensionSxd => FILE_EXTENSION_SXD,\n            Self::FileExtensionSxg => FILE_EXTENSION_SXG,\n            Self::FileExtensionSxi => FILE_EXTENSION_SXI,\n            Self::FileExtensionSxm => FILE_EXTENSION_SXM,\n            Self::FileExtensionSxw => FILE_EXTENSION_SXW,\n            Self::FileExtensionT => FILE_EXTENSION_T,\n            Self::FileExtensionT3 => FILE_EXTENSION_T3,\n            Self::FileExtensionTaglet => FILE_EXTENSION_TAGLET,\n            Self::FileExtensionTao => FILE_EXTENSION_TAO,\n            Self::FileExtensionTar => FILE_EXTENSION_TAR,\n            Self::FileExtensionTcap => FILE_EXTENSION_TCAP,\n            Self::FileExtensionTcl => FILE_EXTENSION_TCL,\n            Self::FileExtensionTeacher => FILE_EXTENSION_TEACHER,\n            Self::FileExtensionTei => FILE_EXTENSION_TEI,\n            Self::FileExtensionTeicorpus => FILE_EXTENSION_TEICORPUS,\n            Self::FileExtensionTex => FILE_EXTENSION_TEX,\n            Self::FileExtensionTexi => FILE_EXTENSION_TEXI,\n            Self::FileExtensionTexinfo => FILE_EXTENSION_TEXINFO,\n            Self::FileExtensionText => FILE_EXTENSION_TEXT,\n            Self::FileExtensionTfi => FILE_EXTENSION_TFI,\n            Self::FileExtensionTfm => FILE_EXTENSION_TFM,\n            Self::FileExtensionTga => FILE_EXTENSION_TGA,\n            Self::FileExtensionThmx => FILE_EXTENSION_THMX,\n            Self::FileExtensionTif => FILE_EXTENSION_TIF,\n            Self::FileExtensionTiff => FILE_EXTENSION_TIFF,\n            Self::FileExtensionTmo => FILE_EXTENSION_TMO,\n            Self::FileExtensionTorrent => FILE_EXTENSION_TORRENT,\n            Self::FileExtensionTpl => FILE_EXTENSION_TPL,\n            Self::FileExtensionTpt => FILE_EXTENSION_TPT,\n            Self::FileExtensionTr => FILE_EXTENSION_TR,\n            Self::FileExtensionTra => FILE_EXTENSION_TRA,\n            Self::FileExtensionTrm => FILE_EXTENSION_TRM,\n            Self::FileExtensionTsd => FILE_EXTENSION_TSD,\n            Self::FileExtensionTsv => FILE_EXTENSION_TSV,\n            Self::FileExtensionTtc => FILE_EXTENSION_TTC,\n            Self::FileExtensionTtf => FILE_EXTENSION_TTF,\n            Self::FileExtensionTtl => FILE_EXTENSION_TTL,\n            Self::FileExtensionTwd => FILE_EXTENSION_TWD,\n            Self::FileExtensionTwds => FILE_EXTENSION_TWDS,\n            Self::FileExtensionTxd => FILE_EXTENSION_TXD,\n            Self::FileExtensionTxf => FILE_EXTENSION_TXF,\n            Self::FileExtensionTxt => FILE_EXTENSION_TXT,\n            Self::FileExtensionU32 => FILE_EXTENSION_U32,\n            Self::FileExtensionUdeb => FILE_EXTENSION_UDEB,\n            Self::FileExtensionUfd => FILE_EXTENSION_UFD,\n            Self::FileExtensionUfdl => FILE_EXTENSION_UFDL,\n            Self::FileExtensionUlw => FILE_EXTENSION_ULW,\n            Self::FileExtensionUlx => FILE_EXTENSION_ULX,\n            Self::FileExtensionUmj => FILE_EXTENSION_UMJ,\n            Self::FileExtensionUnityweb => FILE_EXTENSION_UNITYWEB,\n            Self::FileExtensionUoml => FILE_EXTENSION_UOML,\n            Self::FileExtensionUri => FILE_EXTENSION_URI,\n            Self::FileExtensionUris => FILE_EXTENSION_URIS,\n            Self::FileExtensionUrls => FILE_EXTENSION_URLS,\n            Self::FileExtensionUstar => FILE_EXTENSION_USTAR,\n            Self::FileExtensionUtz => FILE_EXTENSION_UTZ,\n            Self::FileExtensionUu => FILE_EXTENSION_UU,\n            Self::FileExtensionUva => FILE_EXTENSION_UVA,\n            Self::FileExtensionUvd => FILE_EXTENSION_UVD,\n            Self::FileExtensionUvf => FILE_EXTENSION_UVF,\n            Self::FileExtensionUvg => FILE_EXTENSION_UVG,\n            Self::FileExtensionUvh => FILE_EXTENSION_UVH,\n            Self::FileExtensionUvi => FILE_EXTENSION_UVI,\n            Self::FileExtensionUvm => FILE_EXTENSION_UVM,\n            Self::FileExtensionUvp => FILE_EXTENSION_UVP,\n            Self::FileExtensionUvs => FILE_EXTENSION_UVS,\n            Self::FileExtensionUvt => FILE_EXTENSION_UVT,\n            Self::FileExtensionUvu => FILE_EXTENSION_UVU,\n            Self::FileExtensionUvv => FILE_EXTENSION_UVV,\n            Self::FileExtensionUvva => FILE_EXTENSION_UVVA,\n            Self::FileExtensionUvvd => FILE_EXTENSION_UVVD,\n            Self::FileExtensionUvvf => FILE_EXTENSION_UVVF,\n            Self::FileExtensionUvvg => FILE_EXTENSION_UVVG,\n            Self::FileExtensionUvvh => FILE_EXTENSION_UVVH,\n            Self::FileExtensionUvvi => FILE_EXTENSION_UVVI,\n            Self::FileExtensionUvvm => FILE_EXTENSION_UVVM,\n            Self::FileExtensionUvvp => FILE_EXTENSION_UVVP,\n            Self::FileExtensionUvvs => FILE_EXTENSION_UVVS,\n            Self::FileExtensionUvvt => FILE_EXTENSION_UVVT,\n            Self::FileExtensionUvvu => FILE_EXTENSION_UVVU,\n            Self::FileExtensionUvvv => FILE_EXTENSION_UVVV,\n            Self::FileExtensionUvvx => FILE_EXTENSION_UVVX,\n            Self::FileExtensionUvvz => FILE_EXTENSION_UVVZ,\n            Self::FileExtensionUvx => FILE_EXTENSION_UVX,\n            Self::FileExtensionUvz => FILE_EXTENSION_UVZ,\n            Self::FileExtensionVcard => FILE_EXTENSION_VCARD,\n            Self::FileExtensionVcd => FILE_EXTENSION_VCD,\n            Self::FileExtensionVcf => FILE_EXTENSION_VCF,\n            Self::FileExtensionVcg => FILE_EXTENSION_VCG,\n            Self::FileExtensionVcs => FILE_EXTENSION_VCS,\n            Self::FileExtensionVcx => FILE_EXTENSION_VCX,\n            Self::FileExtensionVis => FILE_EXTENSION_VIS,\n            Self::FileExtensionViv => FILE_EXTENSION_VIV,\n            Self::FileExtensionVob => FILE_EXTENSION_VOB,\n            Self::FileExtensionVor => FILE_EXTENSION_VOR,\n            Self::FileExtensionVox => FILE_EXTENSION_VOX,\n            Self::FileExtensionVrml => FILE_EXTENSION_VRML,\n            Self::FileExtensionVsd => FILE_EXTENSION_VSD,\n            Self::FileExtensionVsf => FILE_EXTENSION_VSF,\n            Self::FileExtensionVss => FILE_EXTENSION_VSS,\n            Self::FileExtensionVst => FILE_EXTENSION_VST,\n            Self::FileExtensionVsw => FILE_EXTENSION_VSW,\n            Self::FileExtensionVtu => FILE_EXTENSION_VTU,\n            Self::FileExtensionVxml => FILE_EXTENSION_VXML,\n            Self::FileExtensionW3d => FILE_EXTENSION_W3D,\n            Self::FileExtensionWad => FILE_EXTENSION_WAD,\n            Self::FileExtensionWav => FILE_EXTENSION_WAV,\n            Self::FileExtensionWax => FILE_EXTENSION_WAX,\n            Self::FileExtensionWbmp => FILE_EXTENSION_WBMP,\n            Self::FileExtensionWbs => FILE_EXTENSION_WBS,\n            Self::FileExtensionWbxml => FILE_EXTENSION_WBXML,\n            Self::FileExtensionWcm => FILE_EXTENSION_WCM,\n            Self::FileExtensionWdb => FILE_EXTENSION_WDB,\n            Self::FileExtensionWdp => FILE_EXTENSION_WDP,\n            Self::FileExtensionWeba => FILE_EXTENSION_WEBA,\n            Self::FileExtensionWebm => FILE_EXTENSION_WEBM,\n            Self::FileExtensionWebp => FILE_EXTENSION_WEBP,\n            Self::FileExtensionWg => FILE_EXTENSION_WG,\n            Self::FileExtensionWgt => FILE_EXTENSION_WGT,\n            Self::FileExtensionWks => FILE_EXTENSION_WKS,\n            Self::FileExtensionWm => FILE_EXTENSION_WM,\n            Self::FileExtensionWma => FILE_EXTENSION_WMA,\n            Self::FileExtensionWmd => FILE_EXTENSION_WMD,\n            Self::FileExtensionWmf => FILE_EXTENSION_WMF,\n            Self::FileExtensionWml => FILE_EXTENSION_WML,\n            Self::FileExtensionWmlc => FILE_EXTENSION_WMLC,\n            Self::FileExtensionWmls => FILE_EXTENSION_WMLS,\n            Self::FileExtensionWmlsc => FILE_EXTENSION_WMLSC,\n            Self::FileExtensionWmv => FILE_EXTENSION_WMV,\n            Self::FileExtensionWmx => FILE_EXTENSION_WMX,\n            Self::FileExtensionWmz => FILE_EXTENSION_WMZ,\n            Self::FileExtensionWoff => FILE_EXTENSION_WOFF,\n            Self::FileExtensionWoff2 => FILE_EXTENSION_WOFF2,\n            Self::FileExtensionWpd => FILE_EXTENSION_WPD,\n            Self::FileExtensionWpl => FILE_EXTENSION_WPL,\n            Self::FileExtensionWps => FILE_EXTENSION_WPS,\n            Self::FileExtensionWqd => FILE_EXTENSION_WQD,\n            Self::FileExtensionWri => FILE_EXTENSION_WRI,\n            Self::FileExtensionWrl => FILE_EXTENSION_WRL,\n            Self::FileExtensionWsdl => FILE_EXTENSION_WSDL,\n            Self::FileExtensionWspolicy => FILE_EXTENSION_WSPOLICY,\n            Self::FileExtensionWtb => FILE_EXTENSION_WTB,\n            Self::FileExtensionWvx => FILE_EXTENSION_WVX,\n            Self::FileExtensionX32 => FILE_EXTENSION_X32,\n            Self::FileExtensionX3d => FILE_EXTENSION_X3D,\n            Self::FileExtensionX3db => FILE_EXTENSION_X3DB,\n            Self::FileExtensionX3dbz => FILE_EXTENSION_X3DBZ,\n            Self::FileExtensionX3dv => FILE_EXTENSION_X3DV,\n            Self::FileExtensionX3dvz => FILE_EXTENSION_X3DVZ,\n            Self::FileExtensionX3dz => FILE_EXTENSION_X3DZ,\n            Self::FileExtensionXaml => FILE_EXTENSION_XAML,\n            Self::FileExtensionXap => FILE_EXTENSION_XAP,\n            Self::FileExtensionXar => FILE_EXTENSION_XAR,\n            Self::FileExtensionXbap => FILE_EXTENSION_XBAP,\n            Self::FileExtensionXbd => FILE_EXTENSION_XBD,\n            Self::FileExtensionXbm => FILE_EXTENSION_XBM,\n            Self::FileExtensionXdf => FILE_EXTENSION_XDF,\n            Self::FileExtensionXdm => FILE_EXTENSION_XDM,\n            Self::FileExtensionXdp => FILE_EXTENSION_XDP,\n            Self::FileExtensionXdssc => FILE_EXTENSION_XDSSC,\n            Self::FileExtensionXdw => FILE_EXTENSION_XDW,\n            Self::FileExtensionXenc => FILE_EXTENSION_XENC,\n            Self::FileExtensionXer => FILE_EXTENSION_XER,\n            Self::FileExtensionXfdf => FILE_EXTENSION_XFDF,\n            Self::FileExtensionXfdl => FILE_EXTENSION_XFDL,\n            Self::FileExtensionXht => FILE_EXTENSION_XHT,\n            Self::FileExtensionXhtml => FILE_EXTENSION_XHTML,\n            Self::FileExtensionXhvml => FILE_EXTENSION_XHVML,\n            Self::FileExtensionXif => FILE_EXTENSION_XIF,\n            Self::FileExtensionXla => FILE_EXTENSION_XLA,\n            Self::FileExtensionXlam => FILE_EXTENSION_XLAM,\n            Self::FileExtensionXlc => FILE_EXTENSION_XLC,\n            Self::FileExtensionXlf => FILE_EXTENSION_XLF,\n            Self::FileExtensionXlm => FILE_EXTENSION_XLM,\n            Self::FileExtensionXls => FILE_EXTENSION_XLS,\n            Self::FileExtensionXlsb => FILE_EXTENSION_XLSB,\n            Self::FileExtensionXlsm => FILE_EXTENSION_XLSM,\n            Self::FileExtensionXlsx => FILE_EXTENSION_XLSX,\n            Self::FileExtensionXlt => FILE_EXTENSION_XLT,\n            Self::FileExtensionXltm => FILE_EXTENSION_XLTM,\n            Self::FileExtensionXltx => FILE_EXTENSION_XLTX,\n            Self::FileExtensionXlw => FILE_EXTENSION_XLW,\n            Self::FileExtensionXm => FILE_EXTENSION_XM,\n            Self::FileExtensionXml => FILE_EXTENSION_XML,\n            Self::FileExtensionXo => FILE_EXTENSION_XO,\n            Self::FileExtensionXop => FILE_EXTENSION_XOP,\n            Self::FileExtensionXpi => FILE_EXTENSION_XPI,\n            Self::FileExtensionXpl => FILE_EXTENSION_XPL,\n            Self::FileExtensionXpm => FILE_EXTENSION_XPM,\n            Self::FileExtensionXpr => FILE_EXTENSION_XPR,\n            Self::FileExtensionXps => FILE_EXTENSION_XPS,\n            Self::FileExtensionXpw => FILE_EXTENSION_XPW,\n            Self::FileExtensionXpx => FILE_EXTENSION_XPX,\n            Self::FileExtensionXsl => FILE_EXTENSION_XSL,\n            Self::FileExtensionXslt => FILE_EXTENSION_XSLT,\n            Self::FileExtensionXsm => FILE_EXTENSION_XSM,\n            Self::FileExtensionXspf => FILE_EXTENSION_XSPF,\n            Self::FileExtensionXul => FILE_EXTENSION_XUL,\n            Self::FileExtensionXvm => FILE_EXTENSION_XVM,\n            Self::FileExtensionXvml => FILE_EXTENSION_XVML,\n            Self::FileExtensionXwd => FILE_EXTENSION_XWD,\n            Self::FileExtensionXyz => FILE_EXTENSION_XYZ,\n            Self::FileExtensionXz => FILE_EXTENSION_XZ,\n            Self::FileExtensionYang => FILE_EXTENSION_YANG,\n            Self::FileExtensionYin => FILE_EXTENSION_YIN,\n            Self::FileExtensionZ => FILE_EXTENSION_Z,\n            Self::FileExtensionZ1 => FILE_EXTENSION_Z1,\n            Self::FileExtensionZ2 => FILE_EXTENSION_Z2,\n            Self::FileExtensionZ3 => FILE_EXTENSION_Z3,\n            Self::FileExtensionZ4 => FILE_EXTENSION_Z4,\n            Self::FileExtensionZ5 => FILE_EXTENSION_Z5,\n            Self::FileExtensionZ6 => FILE_EXTENSION_Z6,\n            Self::FileExtensionZ7 => FILE_EXTENSION_Z7,\n            Self::FileExtensionZ8 => FILE_EXTENSION_Z8,\n            Self::FileExtensionZaz => FILE_EXTENSION_ZAZ,\n            Self::FileExtensionZip => FILE_EXTENSION_ZIP,\n            Self::FileExtensionZir => FILE_EXTENSION_ZIR,\n            Self::FileExtensionZirz => FILE_EXTENSION_ZIRZ,\n            Self::FileExtensionZmm => FILE_EXTENSION_ZMM,\n            Self::FileExtensionEmpty => EMPTY_STR,\n        };\n        write!(f, \"{}\", version_str)\n    }\n}", "file_size": 198617, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\cookie\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Builder for constructing HTTP cookies.\n///\n/// Provides methods to set various cookie attributes like expiration,\n/// domain, path, and security flags before building the final cookie string.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct CookieBuilder {\n    /// Cookie name identifier.\n    pub(super) name: CookieKey,\n    /// Cookie value content.\n    pub(super) value: CookieValue,\n    /// Optional expiration date/time string.\n    pub(super) expires: OptionCookieExpires,\n    /// Optional maximum age in seconds.\n    pub(super) max_age: OptionCookieMaxAge,\n    /// Optional domain scope for the cookie.\n    pub(super) domain: OptionCookieDomain,\n    /// Optional path scope for the cookie.\n    pub(super) path: OptionCookiePath,\n    /// Flag indicating secure (HTTPS-only) transmission.\n    pub(super) secure: bool,\n    /// Flag preventing JavaScript access.\n    pub(super) http_only: bool,\n    /// Optional SameSite policy setting.\n    pub(super) same_site: OptionCookieSameSite,\n}\n\n/// Parser for HTTP Cookie headers.\n///\n/// Provides functionality to parse Cookie header strings into key-value pairs.\n#[derive(Debug, Clone, Default, PartialEq, Eq)]\npub struct Cookie;", "file_size": 1204, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\cookie\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_cookie_builder_new() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_default() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::default();\n    assert_eq!(cookie.name, \"\");\n    assert_eq!(cookie.value, \"\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_basic() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_expires() {\n    use super::*;\n    let cookie: CookieBuilder =\n        CookieBuilder::parse(\"session_id=abc123; expires=Wed, 21 Oct 2015 07:28:00 GMT\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(\n        cookie.expires,\n        Some(\"Wed, 21 Oct 2015 07:28:00 GMT\".to_string())\n    );\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_max_age() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; max-age=3600\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, Some(3600));\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_domain() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; domain=example.com\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_path() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; path=/admin\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, Some(\"/admin\".to_string()));\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_secure() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; secure\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, true);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_httponly() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; httponly\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, true);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_samesite() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; samesite=Strict\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, Some(\"Strict\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_parse_complex() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\n        \"session_id=abc123; expires=Wed, 21 Oct 2015 07:28:00 GMT; max-age=3600; domain=example.com; path=/admin; secure; httponly; samesite=Strict\",\n    );\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(\n        cookie.expires,\n        Some(\"Wed, 21 Oct 2015 07:28:00 GMT\".to_string())\n    );\n    assert_eq!(cookie.max_age, Some(3600));\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, Some(\"/admin\".to_string()));\n    assert_eq!(cookie.secure, true);\n    assert_eq!(cookie.http_only, true);\n    assert_eq!(cookie.same_site, Some(\"Strict\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_parse_empty_string() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"\");\n    assert_eq!(cookie.name, \"\");\n    assert_eq!(cookie.value, \"\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_name_only() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_spaces() {\n    use super::*;\n    let cookie: CookieBuilder =\n        CookieBuilder::parse(\"  session_id  =  abc123  ;  domain  =  example.com  ;  secure  \");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, true);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_invalid_max_age() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; max-age=invalid\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_case_insensitive() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\n        \"session_id=abc123; DOMAIN=example.com; SECURE; HTTPONLY; SAMESITE=Strict\",\n    );\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, true);\n    assert_eq!(cookie.http_only, true);\n    assert_eq!(cookie.same_site, Some(\"Strict\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_expires() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.expires(\"Wed, 21 Oct 2015 07:28:00 GMT\");\n    assert_eq!(\n        cookie.expires,\n        Some(\"Wed, 21 Oct 2015 07:28:00 GMT\".to_string())\n    );\n}\n\n#[test]\nfn test_cookie_builder_max_age() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.max_age(3600);\n    assert_eq!(cookie.max_age, Some(3600));\n}\n\n#[test]\nfn test_cookie_builder_domain() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.domain(\"example.com\");\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_path() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.path(\"/admin\");\n    assert_eq!(cookie.path, Some(\"/admin\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_secure() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.secure();\n    assert_eq!(cookie.secure, true);\n}\n\n#[test]\nfn test_cookie_builder_http_only() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.http_only();\n    assert_eq!(cookie.http_only, true);\n}\n\n#[test]\nfn test_cookie_builder_same_site() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"test\", \"value\");\n    cookie.same_site(\"Strict\");\n    assert_eq!(cookie.same_site, Some(\"Strict\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_chaining() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie\n        .expires(\"Wed, 21 Oct 2015 07:28:00 GMT\")\n        .max_age(3600)\n        .domain(\"example.com\")\n        .path(\"/admin\")\n        .secure()\n        .http_only()\n        .same_site(\"Strict\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(\n        cookie.expires,\n        Some(\"Wed, 21 Oct 2015 07:28:00 GMT\".to_string())\n    );\n    assert_eq!(cookie.max_age, Some(3600));\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, Some(\"/admin\".to_string()));\n    assert_eq!(cookie.secure, true);\n    assert_eq!(cookie.http_only, true);\n    assert_eq!(cookie.same_site, Some(\"Strict\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_build_basic() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123\");\n}\n\n#[test]\nfn test_cookie_builder_build_empty_name() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::new(\"\", \"abc123\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_expires() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.expires(\"Wed, 21 Oct 2015 07:28:00 GMT\");\n    let result: String = cookie.build();\n    assert_eq!(\n        result,\n        \"session_id=abc123; expires=Wed, 21 Oct 2015 07:28:00 GMT\"\n    );\n}\n\n#[test]\nfn test_cookie_builder_build_with_max_age() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.max_age(3600);\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; max-age=3600\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_domain() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.domain(\"example.com\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; domain=example.com\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_path() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.path(\"/admin\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; path=/admin\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_secure() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.secure();\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; secure\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_http_only() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.http_only();\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; httponly\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_same_site() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie.same_site(\"Strict\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123; samesite=Strict\");\n}\n\n#[test]\nfn test_cookie_builder_build_complex() {\n    use super::*;\n    let mut cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123\");\n    cookie\n        .expires(\"Wed, 21 Oct 2015 07:28:00 GMT\")\n        .max_age(3600)\n        .domain(\"example.com\")\n        .path(\"/admin\")\n        .secure()\n        .http_only()\n        .same_site(\"Strict\");\n    let result: String = cookie.build();\n    assert_eq!(\n        result,\n        \"session_id=abc123; expires=Wed, 21 Oct 2015 07:28:00 GMT; max-age=3600; domain=example.com; path=/admin; secure; httponly; samesite=Strict\"\n    );\n}\n\n#[test]\nfn test_cookie_builder_parse_with_semicolon_only() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\";\");\n    assert_eq!(cookie.name, \"\");\n    assert_eq!(cookie.value, \"\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_multiple_semicolons() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123;;;domain=example.com;;\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_with_unknown_attributes() {\n    use super::*;\n    let cookie: CookieBuilder =\n        CookieBuilder::parse(\"session_id=abc123; unknown=value; anotherflag; domain=example.com\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"example.com\".to_string()));\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_negative_max_age() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; max-age=-1\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, Some(-1));\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_zero_max_age() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; max-age=0\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, Some(0));\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_large_max_age() {\n    use super::*;\n    let cookie: CookieBuilder =\n        CookieBuilder::parse(\"session_id=abc123; max-age=9223372036854775807\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, Some(9223372036854775807));\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_empty_value() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, None);\n    assert_eq!(cookie.path, None);\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_empty_attribute_value() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\"session_id=abc123; domain=; path=\");\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"\".to_string()));\n    assert_eq!(cookie.path, Some(\"\".to_string()));\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_builder_parse_special_characters() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::parse(\n        \"session_id=abc123!@#$%^&*(); domain=sub.example.com; path=/admin/users\",\n    );\n    assert_eq!(cookie.name, \"session_id\");\n    assert_eq!(cookie.value, \"abc123!@#$%^&*()\");\n    assert_eq!(cookie.expires, None);\n    assert_eq!(cookie.max_age, None);\n    assert_eq!(cookie.domain, Some(\"sub.example.com\".to_string()));\n    assert_eq!(cookie.path, Some(\"/admin/users\".to_string()));\n    assert_eq!(cookie.secure, false);\n    assert_eq!(cookie.http_only, false);\n    assert_eq!(cookie.same_site, None);\n}\n\n#[test]\nfn test_cookie_parse_empty() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"\");\n    assert!(cookies.is_empty());\n}\n\n#[test]\nfn test_cookie_parse_single() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id=abc123\");\n    assert_eq!(cookies.len(), 1);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"abc123\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_multiple() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id=abc123; user_id=456; theme=dark\");\n    assert_eq!(cookies.len(), 3);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"abc123\".to_string()));\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n    assert_eq!(cookies.get(\"theme\"), Some(&\"dark\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_with_spaces() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"  session_id  =  abc123  ;  user_id  =  456  \");\n    assert_eq!(cookies.len(), 2);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"abc123\".to_string()));\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_empty_value() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id=; user_id=456\");\n    assert_eq!(cookies.len(), 2);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"\".to_string()));\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_no_value() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id; user_id=456\");\n    assert_eq!(cookies.len(), 2);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"\".to_string()));\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_multiple_semicolons() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id=abc123;;;user_id=456;;\");\n    assert_eq!(cookies.len(), 2);\n    assert_eq!(cookies.get(\"session_id\"), Some(&\"abc123\".to_string()));\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n}\n\n#[test]\nfn test_cookie_parse_special_characters() {\n    use super::*;\n    let cookies: Cookies = Cookie::parse(\"session_id=abc123!@#$%^&*(); user_id=456\");\n    assert_eq!(cookies.len(), 2);\n    assert_eq!(\n        cookies.get(\"session_id\"),\n        Some(&\"abc123!@#$%^&*()\".to_string())\n    );\n    assert_eq!(cookies.get(\"user_id\"), Some(&\"456\".to_string()));\n}\n\n#[test]\nfn test_cookie_builder_build_with_empty_value() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=\");\n}\n\n#[test]\nfn test_cookie_builder_build_with_special_characters() {\n    use super::*;\n    let cookie: CookieBuilder = CookieBuilder::new(\"session_id\", \"abc123!@#$%^&*()\");\n    let result: String = cookie.build();\n    assert_eq!(result, \"session_id=abc123!@#$%^&*()\");\n}", "file_size": 21927, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\file_extension\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_enum_to_string() {\n    use super::r#enum::*;\n    use http_constant::*;\n    assert_eq!(\n        FileExtension::FileExtension123.to_string(),\n        FILE_EXTENSION_123\n    )\n}\n\n#[test]\nfn test_get_content_type() {\n    use super::r#enum::*;\n    use http_constant::*;\n    assert_eq!(\n        FileExtension::FileExtension123.get_content_type(),\n        APPLICATION_VND_LOTUS_1_2_3\n    )\n}\n\n#[test]\nfn test_parse() {\n    use super::r#enum::*;\n    use http_constant::*;\n    assert_eq!(\n        FileExtension::parse(FILE_EXTENSION_123),\n        FileExtension::FileExtension123,\n    )\n}", "file_size": 594, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_status\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// The `HttpStatus` enum represents the HTTP status codes.\n///\n/// It maps common HTTP status codes to their respective meanings. It provides methods to retrieve\n/// the corresponding numeric code as well as the associated status text. Additionally, it implements\n/// conversion from a string representation of the status code.\nimpl HttpStatus {\n    /// Gets the numeric HTTP status code.\n    ///\n    /// Returns the corresponding HTTP status code number for the enum variant.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - The HttpStatus instance.\n    ///\n    /// # Returns\n    ///\n    /// - `u16` - The numeric status code.\n    pub fn code(&self) -> ResponseStatusCode {\n        match self {\n            Self::Continue => 100,\n            Self::SwitchingProtocols => 101,\n            Self::Processing => 102,\n            Self::EarlyHints => 103,\n            Self::Ok => 200,\n            Self::Created => 201,\n            Self::Accepted => 202,\n            Self::NonAuthoritativeInformation => 203,\n            Self::NoContent => 204,\n            Self::ResetContent => 205,\n            Self::PartialContent => 206,\n            Self::MultiStatus => 207,\n            Self::AlreadyReported => 208,\n            Self::IMUsed => 226,\n            Self::MultipleChoices => 300,\n            Self::MovedPermanently => 301,\n            Self::Found => 302,\n            Self::SeeOther => 303,\n            Self::NotModified => 304,\n            Self::UseProxy => 305,\n            Self::TemporaryRedirect => 307,\n            Self::PermanentRedirect => 308,\n            Self::BadRequest => 400,\n            Self::Unauthorized => 401,\n            Self::PaymentRequired => 402,\n            Self::Forbidden => 403,\n            Self::NotFound => 404,\n            Self::MethodNotAllowed => 405,\n            Self::NotAcceptable => 406,\n            Self::ProxyAuthenticationRequired => 407,\n            Self::RequestTimeout => 408,\n            Self::Conflict => 409,\n            Self::Gone => 410,\n            Self::LengthRequired => 411,\n            Self::PreconditionFailed => 412,\n            Self::PayloadTooLarge => 413,\n            Self::URITooLong => 414,\n            Self::UnsupportedMediaType => 415,\n            Self::RangeNotSatisfiable => 416,\n            Self::ExpectationFailed => 417,\n            Self::ImATeapot => 418,\n            Self::MisdirectedRequest => 421,\n            Self::UnprocessableEntity => 422,\n            Self::Locked => 423,\n            Self::FailedDependency => 424,\n            Self::TooEarly => 425,\n            Self::UpgradeRequired => 426,\n            Self::PreconditionRequired => 428,\n            Self::TooManyRequests => 429,\n            Self::RequestHeaderFieldsTooLarge => 431,\n            Self::UnavailableForLegalReasons => 451,\n            Self::InternalServerError => 500,\n            Self::NotImplemented => 501,\n            Self::BadGateway => 502,\n            Self::ServiceUnavailable => 503,\n            Self::GatewayTimeout => 504,\n            Self::HTTPVersionNotSupported => 505,\n            Self::VariantAlsoNegotiates => 506,\n            Self::InsufficientStorage => 507,\n            Self::LoopDetected => 508,\n            Self::NotExtended => 510,\n            Self::NetworkAuthenticationRequired => 511,\n            Self::Unknown => 0,\n        }\n    }\n\n    /// Gets the textual description for a status code.\n    ///\n    /// Returns the standard HTTP status text for the given numeric code.\n    ///\n    /// # Arguments\n    ///\n    /// - `u16` - The numeric HTTP status code.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The standard status text description.\n    pub fn phrase(code: ResponseStatusCode) -> String {\n        match code {\n            100 => Self::Continue.to_string(),\n            101 => Self::SwitchingProtocols.to_string(),\n            102 => Self::Processing.to_string(),\n            103 => Self::EarlyHints.to_string(),\n            200 => Self::Ok.to_string(),\n            201 => Self::Created.to_string(),\n            202 => Self::Accepted.to_string(),\n            203 => Self::NonAuthoritativeInformation.to_string(),\n            204 => Self::NoContent.to_string(),\n            205 => Self::ResetContent.to_string(),\n            206 => Self::PartialContent.to_string(),\n            207 => Self::MultiStatus.to_string(),\n            208 => Self::AlreadyReported.to_string(),\n            226 => Self::IMUsed.to_string(),\n            300 => Self::MultipleChoices.to_string(),\n            301 => Self::MovedPermanently.to_string(),\n            302 => Self::Found.to_string(),\n            303 => Self::SeeOther.to_string(),\n            304 => Self::NotModified.to_string(),\n            305 => Self::UseProxy.to_string(),\n            307 => Self::TemporaryRedirect.to_string(),\n            308 => Self::PermanentRedirect.to_string(),\n            400 => Self::BadRequest.to_string(),\n            401 => Self::Unauthorized.to_string(),\n            402 => Self::PaymentRequired.to_string(),\n            403 => Self::Forbidden.to_string(),\n            404 => Self::NotFound.to_string(),\n            405 => Self::MethodNotAllowed.to_string(),\n            406 => Self::NotAcceptable.to_string(),\n            407 => Self::ProxyAuthenticationRequired.to_string(),\n            408 => Self::RequestTimeout.to_string(),\n            409 => Self::Conflict.to_string(),\n            410 => Self::Gone.to_string(),\n            411 => Self::LengthRequired.to_string(),\n            412 => Self::PreconditionFailed.to_string(),\n            413 => Self::PayloadTooLarge.to_string(),\n            414 => Self::URITooLong.to_string(),\n            415 => Self::UnsupportedMediaType.to_string(),\n            416 => Self::RangeNotSatisfiable.to_string(),\n            417 => Self::ExpectationFailed.to_string(),\n            418 => Self::ImATeapot.to_string(),\n            421 => Self::MisdirectedRequest.to_string(),\n            422 => Self::UnprocessableEntity.to_string(),\n            423 => Self::Locked.to_string(),\n            424 => Self::FailedDependency.to_string(),\n            425 => Self::TooEarly.to_string(),\n            426 => Self::UpgradeRequired.to_string(),\n            428 => Self::PreconditionRequired.to_string(),\n            429 => Self::TooManyRequests.to_string(),\n            431 => Self::RequestHeaderFieldsTooLarge.to_string(),\n            451 => Self::UnavailableForLegalReasons.to_string(),\n            500 => Self::InternalServerError.to_string(),\n            501 => Self::NotImplemented.to_string(),\n            502 => Self::BadGateway.to_string(),\n            503 => Self::ServiceUnavailable.to_string(),\n            504 => Self::GatewayTimeout.to_string(),\n            505 => Self::HTTPVersionNotSupported.to_string(),\n            506 => Self::VariantAlsoNegotiates.to_string(),\n            507 => Self::InsufficientStorage.to_string(),\n            508 => Self::LoopDetected.to_string(),\n            510 => Self::NotExtended.to_string(),\n            511 => Self::NetworkAuthenticationRequired.to_string(),\n            _ => Self::Unknown.to_string(),\n        }\n    }\n\n    /// Checks if status matches a string representation.\n    ///\n    /// Compares case-insensitively against both numeric code and text description.\n    ///\n    /// # Arguments\n    ///\n    /// - `&self` - The HttpStatus instance.\n    /// - `&str` - The string to compare against.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if the string matches either code or description.\n    pub fn same(&self, code_str: &str) -> bool {\n        self.to_string().eq_ignore_ascii_case(code_str)\n    }\n}\n\n/// Implements the `Display` trait for `HttpStatus`, allowing it to be formatted as a string.\nimpl Display for HttpStatus {\n    /// Formats the status code as text.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter` - The formatter to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - The formatting result.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let res: &str = match self {\n            Self::Continue => CONTINUE,\n            Self::SwitchingProtocols => SWITCHING_PROTOCOLS,\n            Self::Processing => PROCESSING,\n            Self::EarlyHints => EARLY_HINTS,\n            Self::Ok => OK,\n            Self::Created => CREATED,\n            Self::Accepted => ACCEPTED,\n            Self::NonAuthoritativeInformation => NON_AUTHORITATIVE_INFORMATION,\n            Self::NoContent => NO_CONTENT,\n            Self::ResetContent => RESET_CONTENT,\n            Self::PartialContent => PARTIAL_CONTENT,\n            Self::MultiStatus => MULTI_STATUS,\n            Self::AlreadyReported => ALREADY_REPORTED,\n            Self::IMUsed => IM_USED,\n            Self::MultipleChoices => MULTIPLE_CHOICES,\n            Self::MovedPermanently => MOVED_PERMANENTLY,\n            Self::Found => FOUND,\n            Self::SeeOther => SEE_OTHER,\n            Self::NotModified => NOT_MODIFIED,\n            Self::UseProxy => USE_PROXY,\n            Self::TemporaryRedirect => TEMPORARY_REDIRECT,\n            Self::PermanentRedirect => PERMANENT_REDIRECT,\n            Self::BadRequest => BAD_REQUEST,\n            Self::Unauthorized => UNAUTHORIZED,\n            Self::PaymentRequired => PAYMENT_REQUIRED,\n            Self::Forbidden => FORBIDDEN,\n            Self::NotFound => NOT_FOUND,\n            Self::MethodNotAllowed => METHOD_NOT_ALLOWED,\n            Self::NotAcceptable => NOT_ACCEPTABLE,\n            Self::ProxyAuthenticationRequired => PROXY_AUTHENTICATION_REQUIRED,\n            Self::RequestTimeout => REQUEST_TIMEOUT,\n            Self::Conflict => CONFLICT,\n            Self::Gone => GONE,\n            Self::LengthRequired => LENGTH_REQUIRED,\n            Self::PreconditionFailed => PRECONDITION_FAILED,\n            Self::PayloadTooLarge => PAYLOAD_TOO_LARGE,\n            Self::URITooLong => URI_TOO_LONG,\n            Self::UnsupportedMediaType => UNSUPPORTED_MEDIA_TYPE,\n            Self::RangeNotSatisfiable => RANGE_NOT_SATISFIABLE,\n            Self::ExpectationFailed => EXPECTATION_FAILED,\n            Self::ImATeapot => IM_A_TEAPOT,\n            Self::MisdirectedRequest => MISDIRECTED_REQUEST,\n            Self::UnprocessableEntity => UNPROCESSABLE_ENTITY,\n            Self::Locked => LOCKED,\n            Self::FailedDependency => FAILED_DEPENDENCY,\n            Self::TooEarly => TOO_EARLY,\n            Self::UpgradeRequired => UPGRADE_REQUIRED,\n            Self::PreconditionRequired => PRECONDITION_REQUIRED,\n            Self::TooManyRequests => TOO_MANY_REQUESTS,\n            Self::RequestHeaderFieldsTooLarge => REQUEST_HEADER_FIELDS_TOO_LARGE,\n            Self::UnavailableForLegalReasons => UNAVAILABLE_FOR_LEGAL_REASONS,\n            Self::InternalServerError => INTERNAL_SERVER_ERROR,\n            Self::NotImplemented => NOT_IMPLEMENTED,\n            Self::BadGateway => BAD_GATEWAY,\n            Self::ServiceUnavailable => SERVICE_UNAVAILABLE,\n            Self::GatewayTimeout => GATEWAY_TIMEOUT,\n            Self::HTTPVersionNotSupported => HTTP_VERSION_NOT_SUPPORTED,\n            Self::VariantAlsoNegotiates => VARIANT_ALSO_NEGOTIATES,\n            Self::InsufficientStorage => INSUFFICIENT_STORAGE,\n            Self::LoopDetected => LOOP_DETECTED,\n            Self::NotExtended => NOT_EXTENDED,\n            Self::NetworkAuthenticationRequired => NETWORK_AUTHENTICATION_REQUIRED,\n            Self::Unknown => UNKNOWN,\n        };\n        write!(f, \"{}\", res)\n    }\n}\n\n/// Implements the `FromStr` trait for `HttpStatus`, allowing conversion from a string slice.\nimpl FromStr for HttpStatus {\n    /// The error type returned when conversion fails.\n    type Err = ();\n\n    /// Parses a string into an HttpStatus.\n    ///\n    /// Attempts to convert the string to a numeric code and match known status codes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The string to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<HttpStatus, ()>` - The parsed status or error.\n    fn from_str(code_str: &str) -> Result<Self, Self::Err> {\n        if let Ok(code) = code_str.parse::<ResponseStatusCode>() {\n            match code {\n                100 => Ok(Self::Continue),\n                101 => Ok(Self::SwitchingProtocols),\n                102 => Ok(Self::Processing),\n                103 => Ok(Self::EarlyHints),\n                200 => Ok(Self::Ok),\n                201 => Ok(Self::Created),\n                202 => Ok(Self::Accepted),\n                203 => Ok(Self::NonAuthoritativeInformation),\n                204 => Ok(Self::NoContent),\n                205 => Ok(Self::ResetContent),\n                206 => Ok(Self::PartialContent),\n                207 => Ok(Self::MultiStatus),\n                208 => Ok(Self::AlreadyReported),\n                226 => Ok(Self::IMUsed),\n                300 => Ok(Self::MultipleChoices),\n                301 => Ok(Self::MovedPermanently),\n                302 => Ok(Self::Found),\n                303 => Ok(Self::SeeOther),\n                304 => Ok(Self::NotModified),\n                305 => Ok(Self::UseProxy),\n                307 => Ok(Self::TemporaryRedirect),\n                308 => Ok(Self::PermanentRedirect),\n                400 => Ok(Self::BadRequest),\n                401 => Ok(Self::Unauthorized),\n                402 => Ok(Self::PaymentRequired),\n                403 => Ok(Self::Forbidden),\n                404 => Ok(Self::NotFound),\n                405 => Ok(Self::MethodNotAllowed),\n                406 => Ok(Self::NotAcceptable),\n                407 => Ok(Self::ProxyAuthenticationRequired),\n                408 => Ok(Self::RequestTimeout),\n                409 => Ok(Self::Conflict),\n                410 => Ok(Self::Gone),\n                411 => Ok(Self::LengthRequired),\n                412 => Ok(Self::PreconditionFailed),\n                413 => Ok(Self::PayloadTooLarge),\n                414 => Ok(Self::URITooLong),\n                415 => Ok(Self::UnsupportedMediaType),\n                416 => Ok(Self::RangeNotSatisfiable),\n                417 => Ok(Self::ExpectationFailed),\n                418 => Ok(Self::ImATeapot),\n                421 => Ok(Self::MisdirectedRequest),\n                422 => Ok(Self::UnprocessableEntity),\n                423 => Ok(Self::Locked),\n                424 => Ok(Self::FailedDependency),\n                425 => Ok(Self::TooEarly),\n                426 => Ok(Self::UpgradeRequired),\n                428 => Ok(Self::PreconditionRequired),\n                429 => Ok(Self::TooManyRequests),\n                431 => Ok(Self::RequestHeaderFieldsTooLarge),\n                451 => Ok(Self::UnavailableForLegalReasons),\n                500 => Ok(Self::InternalServerError),\n                501 => Ok(Self::NotImplemented),\n                502 => Ok(Self::BadGateway),\n                503 => Ok(Self::ServiceUnavailable),\n                504 => Ok(Self::GatewayTimeout),\n                505 => Ok(Self::HTTPVersionNotSupported),\n                506 => Ok(Self::VariantAlsoNegotiates),\n                507 => Ok(Self::InsufficientStorage),\n                508 => Ok(Self::LoopDetected),\n                510 => Ok(Self::NotExtended),\n                511 => Ok(Self::NetworkAuthenticationRequired),\n                _ => Ok(Self::Unknown),\n            }\n        } else {\n            Ok(Self::Unknown)\n        }\n    }\n}\n\n/// Implements the `Default` trait for `HttpStatus`.\nimpl Default for HttpStatus {\n    /// Gets the default HTTP status code.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpStatus` - The default status.\n    fn default() -> Self {\n        Self::Unknown\n    }\n}", "file_size": 15483, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_status\\enum.rs", "language": "rust", "content": "/// Standard HTTP status codes.\n///\n/// Includes informational, success, redirection, client and server error codes.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpStatus {\n    /// HTTP 100 Continue\n    Continue,\n    /// HTTP 101 Switching Protocols\n    SwitchingProtocols,\n    /// HTTP 102 Processing (WebDAV)\n    Processing,\n    /// HTTP 103 Early Hints\n    EarlyHints,\n    /// HTTP 200 OK\n    Ok,\n    /// HTTP 201 Created\n    Created,\n    /// HTTP 202 Accepted\n    Accepted,\n    /// HTTP 203 Non-Authoritative Information\n    NonAuthoritativeInformation,\n    /// HTTP 204 No Content\n    NoContent,\n    /// HTTP 205 Reset Content\n    ResetContent,\n    /// HTTP 206 Partial Content\n    PartialContent,\n    /// HTTP 207 Multi-Status (WebDAV)\n    MultiStatus,\n    /// HTTP 208 Already Reported (WebDAV)\n    AlreadyReported,\n    /// HTTP 226 IM Used\n    IMUsed,\n    /// HTTP 300 Multiple Choices\n    MultipleChoices,\n    /// HTTP 301 Moved Permanently\n    MovedPermanently,\n    /// HTTP 302 Found\n    Found,\n    /// HTTP 303 See Other\n    SeeOther,\n    /// HTTP 304 Not Modified\n    NotModified,\n    /// HTTP 305 Use Proxy\n    UseProxy,\n    /// HTTP 307 Temporary Redirect\n    TemporaryRedirect,\n    /// HTTP 308 Permanent Redirect\n    PermanentRedirect,\n    /// HTTP 400 Bad Request\n    BadRequest,\n    /// HTTP 401 Unauthorized\n    Unauthorized,\n    /// HTTP 402 Payment Required\n    PaymentRequired,\n    /// HTTP 403 Forbidden\n    Forbidden,\n    /// HTTP 404 Not Found\n    NotFound,\n    /// HTTP 405 Method Not Allowed\n    MethodNotAllowed,\n    /// HTTP 406 Not Acceptable\n    NotAcceptable,\n    /// HTTP 407 Proxy Authentication Required\n    ProxyAuthenticationRequired,\n    /// HTTP 408 Request Timeout\n    RequestTimeout,\n    /// HTTP 409 Conflict\n    Conflict,\n    /// HTTP 410 Gone\n    Gone,\n    /// HTTP 411 Length Required\n    LengthRequired,\n    /// HTTP 412 Precondition Failed\n    PreconditionFailed,\n    /// HTTP 413 Payload Too Large\n    PayloadTooLarge,\n    /// HTTP 414 URI Too Long\n    URITooLong,\n    /// HTTP 415 Unsupported Media Type\n    UnsupportedMediaType,\n    /// HTTP 416 Range Not Satisfiable\n    RangeNotSatisfiable,\n    /// HTTP 417 Expectation Failed\n    ExpectationFailed,\n    /// HTTP 418 I'm a teapot\n    ImATeapot,\n    /// HTTP 421 Misdirected Request\n    MisdirectedRequest,\n    /// HTTP 422 Unprocessable Entity (WebDAV)\n    UnprocessableEntity,\n    /// HTTP 423 Locked (WebDAV)\n    Locked,\n    /// HTTP 424 Failed Dependency (WebDAV)\n    FailedDependency,\n    /// HTTP 425 Too Early\n    TooEarly,\n    /// HTTP 426 Upgrade Required\n    UpgradeRequired,\n    /// HTTP 428 Precondition Required\n    PreconditionRequired,\n    /// HTTP 429 Too Many Requests\n    TooManyRequests,\n    /// HTTP 431 Request Header Fields Too Large\n    RequestHeaderFieldsTooLarge,\n    /// HTTP 451 Unavailable For Legal Reasons\n    UnavailableForLegalReasons,\n    /// HTTP 500 Internal Server Error\n    InternalServerError,\n    /// HTTP 501 Not Implemented\n    NotImplemented,\n    /// HTTP 502 Bad Gateway\n    BadGateway,\n    /// HTTP 503 Service Unavailable\n    ServiceUnavailable,\n    /// HTTP 504 Gateway Timeout\n    GatewayTimeout,\n    /// HTTP 505 HTTP Version Not Supported\n    HTTPVersionNotSupported,\n    /// HTTP 506 Variant Also Negotiates\n    VariantAlsoNegotiates,\n    /// HTTP 507 Insufficient Storage (WebDAV)\n    InsufficientStorage,\n    /// HTTP 508 Loop Detected (WebDAV)\n    LoopDetected,\n    /// HTTP 510 Not Extended\n    NotExtended,\n    /// HTTP 511 Network Authentication Required\n    NetworkAuthenticationRequired,\n    /// HTTP Unknown status code\n    Unknown,\n}", "file_size": 3600, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\hash_set_xx_hash3_64\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `HashSet` using `XxHash3_64` as the hasher.\npub type HashSetXxHash3_64<K> = HashSet<K, BuildHasherDefault<XxHash3_64>>;", "file_size": 155, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\hash_set_xx_hash3_64\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new `HashSetXxHash3_64` with the default hasher.\n///\n/// # Arguments\n///\n/// - `K` - The type of the elements in the hash set.\n///\n/// # Returns\n///\n/// A new `HashSetXxHash3_64` instance.\npub fn hash_set_xx_hash3_64<K: Eq + Hash>() -> HashSetXxHash3_64<K> {\n    HashSet::with_hasher(BuildHasherDefault::default())\n}", "file_size": 345, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\hash_map_xx_hash3_64\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new `HashMapXxHash3_64` with the default hasher.\n///\n/// This function initializes a hash map that uses `xxHash3_64` as its hashing algorithm,\n/// providing efficient hashing for keys.\n///\n/// # Returns\n///\n/// A new `HashMapXxHash3_64` instance.\npub fn hash_map_xx_hash3_64<K: Eq + Hash, V>() -> HashMapXxHash3_64<K, V> {\n    HashMap::with_hasher(BuildHasherDefault::default())\n}", "file_size": 409, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_version\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `HttpVersion`.\nimpl Default for HttpVersion {\n    /// Returns the default `HttpVersion` variant, which is `Unknown` with an empty string.\n    ///\n    /// # Returns\n    ///\n    /// The default `HttpVersion` variant.\n    fn default() -> Self {\n        Self::Unknown(String::new())\n    }\n}\n\n/// Implements the `Display` trait for `HttpVersion`, allowing it to be formatted as a string.\nimpl fmt::Display for HttpVersion {\n    /// Formats the `HttpVersion` variant into its string representation.\n    ///\n    /// # Arguments\n    ///\n    /// - `f` - The formatter to write the string into.\n    ///\n    /// # Returns\n    ///\n    /// A `fmt::Result` indicating success or failure of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let version_str: &str = match self {\n            Self::HTTP0_9 => HTTP_VERSION_0_9,\n            Self::HTTP1_0 => HTTP_VERSION_1_0,\n            Self::HTTP1_1 => HTTP_VERSION_1_1,\n            Self::HTTP2 => HTTP_VERSION_2,\n            Self::HTTP3 => HTTP_VERSION_3,\n            Self::Unknown(version) => version,\n        };\n        write!(f, \"{}\", version_str)\n    }\n}\n\n/// Implements the `FromStr` trait for `HttpVersion`, allowing conversion from a string slice.\nimpl FromStr for HttpVersion {\n    /// The error type returned when conversion fails.\n    type Err = String;\n\n    /// Converts a string slice into an `HttpVersion` variant.\n    ///\n    /// This method attempts to parse the input string into a known `HttpVersion` variant.\n    /// If the string does not match any known version, it returns an `Unknown` variant\n    /// containing the original string.\n    ///\n    /// # Arguments\n    ///\n    /// - `version_str` - The string slice to convert.\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing the `HttpVersion` variant if successful, or `Self::Err` on failure.\n    #[allow(warnings)]\n    fn from_str(version_str: &str) -> Result<Self, Self::Err> {\n        match version_str {\n            HTTP_VERSION_0_9 => Ok(Self::HTTP0_9),\n            HTTP_VERSION_1_0 => Ok(Self::HTTP1_0),\n            HTTP_VERSION_1_1 => Ok(Self::HTTP1_1),\n            HTTP_VERSION_2 => Ok(Self::HTTP2),\n            HTTP_VERSION_3 => Ok(Self::HTTP3),\n            _ => Ok(Self::Unknown(version_str.to_string())),\n        }\n    }\n}\n\nimpl HttpVersion {\n    /// Checks if the current version is HTTP/0.9.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/0.9, `false` otherwise.\n    pub fn is_http0_9(&self) -> bool {\n        matches!(self, Self::HTTP0_9)\n    }\n\n    /// Checks if the current version is HTTP/1.0.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/1.0, `false` otherwise.\n    pub fn is_http1_0(&self) -> bool {\n        matches!(self, Self::HTTP1_0)\n    }\n\n    /// Checks if the current version is HTTP/1.1.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/1.1, `false` otherwise.\n    pub fn is_http1_1(&self) -> bool {\n        matches!(self, Self::HTTP1_1)\n    }\n\n    /// Checks if the current version is HTTP/2.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/2, `false` otherwise.\n    pub fn is_http2(&self) -> bool {\n        matches!(self, Self::HTTP2)\n    }\n\n    /// Checks if the current version is HTTP/3.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/3, `false` otherwise.\n    pub fn is_http3(&self) -> bool {\n        matches!(self, Self::HTTP3)\n    }\n\n    /// Checks if the current version is unknown.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is unknown, `false` otherwise.\n    pub fn is_unknown(&self) -> bool {\n        matches!(self, Self::Unknown(_))\n    }\n\n    /// Checks if the current version is HTTP/1.1 or higher.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is HTTP/1.1, HTTP/2, or HTTP/3, `false` otherwise.\n    pub fn is_http1_1_or_higher(&self) -> bool {\n        match self {\n            Self::HTTP1_1 | Self::HTTP2 | Self::HTTP3 => true,\n            _ => false,\n        }\n    }\n\n    /// Checks if the current version is a recognized HTTP version (not unknown).\n    ///\n    /// # Returns\n    ///\n    /// `true` if the version is a known HTTP version, `false` otherwise.\n    pub fn is_http(&self) -> bool {\n        !self.is_unknown()\n    }\n}", "file_size": 4355, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\methods\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_method_display() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(Method::GET.to_string(), GET);\n    assert_eq!(Method::POST.to_string(), POST);\n    assert_eq!(Method::PUT.to_string(), PUT);\n    assert_eq!(Method::DELETE.to_string(), DELETE);\n    assert_eq!(Method::PATCH.to_string(), PATCH);\n    assert_eq!(Method::HEAD.to_string(), HEAD);\n    assert_eq!(Method::OPTIONS.to_string(), OPTIONS);\n    assert_eq!(Method::CONNECT.to_string(), CONNECT);\n    assert_eq!(Method::TRACE.to_string(), TRACE);\n    assert_eq!(Method::UNKNOWN(\"CUSTOM\".to_string()).to_string(), \"CUSTOM\");\n}\n\n#[test]\nfn test_method_from_str() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(GET.parse::<Method>().unwrap(), Method::GET);\n    assert_eq!(POST.parse::<Method>().unwrap(), Method::POST);\n    assert_eq!(PUT.parse::<Method>().unwrap(), Method::PUT);\n    assert_eq!(DELETE.parse::<Method>().unwrap(), Method::DELETE);\n    assert_eq!(PATCH.parse::<Method>().unwrap(), Method::PATCH);\n    assert_eq!(HEAD.parse::<Method>().unwrap(), Method::HEAD);\n    assert_eq!(OPTIONS.parse::<Method>().unwrap(), Method::OPTIONS);\n    assert_eq!(CONNECT.parse::<Method>().unwrap(), Method::CONNECT);\n    assert_eq!(TRACE.parse::<Method>().unwrap(), Method::TRACE);\n    assert_eq!(\n        \"CUSTOM\".parse::<Method>().unwrap(),\n        Method::UNKNOWN(\"CUSTOM\".to_string())\n    );\n    assert_eq!(\n        \"\".parse::<Method>().unwrap(),\n        Method::UNKNOWN(\"\".to_string())\n    );\n}\n\n#[test]\nfn test_method_default() {\n    use super::*;\n    assert_eq!(Method::default(), Method::UNKNOWN(String::new()));\n}\n\n#[test]\nfn test_method_new() {\n    use super::*;\n    assert_eq!(Method::new(), Method::default());\n}\n\n#[test]\nfn test_method_is_get() {\n    use super::*;\n    assert!(Method::GET.is_get());\n    assert!(!Method::POST.is_get());\n    assert!(!Method::PUT.is_get());\n    assert!(!Method::DELETE.is_get());\n    assert!(!Method::PATCH.is_get());\n    assert!(!Method::HEAD.is_get());\n    assert!(!Method::OPTIONS.is_get());\n    assert!(!Method::CONNECT.is_get());\n    assert!(!Method::TRACE.is_get());\n    assert!(!Method::UNKNOWN(\"GET\".to_string()).is_get());\n}\n\n#[test]\nfn test_method_is_post() {\n    use super::*;\n    assert!(!Method::GET.is_post());\n    assert!(Method::POST.is_post());\n    assert!(!Method::PUT.is_post());\n    assert!(!Method::DELETE.is_post());\n    assert!(!Method::PATCH.is_post());\n    assert!(!Method::HEAD.is_post());\n    assert!(!Method::OPTIONS.is_post());\n    assert!(!Method::CONNECT.is_post());\n    assert!(!Method::TRACE.is_post());\n    assert!(!Method::UNKNOWN(\"POST\".to_string()).is_post());\n}\n\n#[test]\nfn test_method_is_put() {\n    use super::*;\n    assert!(!Method::GET.is_put());\n    assert!(!Method::POST.is_put());\n    assert!(Method::PUT.is_put());\n    assert!(!Method::DELETE.is_put());\n    assert!(!Method::PATCH.is_put());\n    assert!(!Method::HEAD.is_put());\n    assert!(!Method::OPTIONS.is_put());\n    assert!(!Method::CONNECT.is_put());\n    assert!(!Method::TRACE.is_put());\n    assert!(!Method::UNKNOWN(\"PUT\".to_string()).is_put());\n}\n\n#[test]\nfn test_method_is_delete() {\n    use super::*;\n    assert!(!Method::GET.is_delete());\n    assert!(!Method::POST.is_delete());\n    assert!(!Method::PUT.is_delete());\n    assert!(Method::DELETE.is_delete());\n    assert!(!Method::PATCH.is_delete());\n    assert!(!Method::HEAD.is_delete());\n    assert!(!Method::OPTIONS.is_delete());\n    assert!(!Method::CONNECT.is_delete());\n    assert!(!Method::TRACE.is_delete());\n    assert!(!Method::UNKNOWN(\"DELETE\".to_string()).is_delete());\n}\n\n#[test]\nfn test_method_is_patch() {\n    use super::*;\n    assert!(!Method::GET.is_patch());\n    assert!(!Method::POST.is_patch());\n    assert!(!Method::PUT.is_patch());\n    assert!(!Method::DELETE.is_patch());\n    assert!(Method::PATCH.is_patch());\n    assert!(!Method::HEAD.is_patch());\n    assert!(!Method::OPTIONS.is_patch());\n    assert!(!Method::CONNECT.is_patch());\n    assert!(!Method::TRACE.is_patch());\n    assert!(!Method::UNKNOWN(\"PATCH\".to_string()).is_patch());\n}\n\n#[test]\nfn test_method_is_head() {\n    use super::*;\n    assert!(!Method::GET.is_head());\n    assert!(!Method::POST.is_head());\n    assert!(!Method::PUT.is_head());\n    assert!(!Method::DELETE.is_head());\n    assert!(!Method::PATCH.is_head());\n    assert!(Method::HEAD.is_head());\n    assert!(!Method::OPTIONS.is_head());\n    assert!(!Method::CONNECT.is_head());\n    assert!(!Method::TRACE.is_head());\n    assert!(!Method::UNKNOWN(\"HEAD\".to_string()).is_head());\n}\n\n#[test]\nfn test_method_is_options() {\n    use super::*;\n    assert!(!Method::GET.is_options());\n    assert!(!Method::POST.is_options());\n    assert!(!Method::PUT.is_options());\n    assert!(!Method::DELETE.is_options());\n    assert!(!Method::PATCH.is_options());\n    assert!(!Method::HEAD.is_options());\n    assert!(Method::OPTIONS.is_options());\n    assert!(!Method::CONNECT.is_options());\n    assert!(!Method::TRACE.is_options());\n    assert!(!Method::UNKNOWN(\"OPTIONS\".to_string()).is_options());\n}\n\n#[test]\nfn test_method_is_connect() {\n    use super::*;\n    assert!(!Method::GET.is_connect());\n    assert!(!Method::POST.is_connect());\n    assert!(!Method::PUT.is_connect());\n    assert!(!Method::DELETE.is_connect());\n    assert!(!Method::PATCH.is_connect());\n    assert!(!Method::HEAD.is_connect());\n    assert!(!Method::OPTIONS.is_connect());\n    assert!(Method::CONNECT.is_connect());\n    assert!(!Method::TRACE.is_connect());\n    assert!(!Method::UNKNOWN(\"CONNECT\".to_string()).is_connect());\n}\n\n#[test]\nfn test_method_is_trace() {\n    use super::*;\n    assert!(!Method::GET.is_trace());\n    assert!(!Method::POST.is_trace());\n    assert!(!Method::PUT.is_trace());\n    assert!(!Method::DELETE.is_trace());\n    assert!(!Method::PATCH.is_trace());\n    assert!(!Method::HEAD.is_trace());\n    assert!(!Method::OPTIONS.is_trace());\n    assert!(!Method::CONNECT.is_trace());\n    assert!(Method::TRACE.is_trace());\n    assert!(!Method::UNKNOWN(\"TRACE\".to_string()).is_trace());\n}\n\n#[test]\nfn test_method_is_unknown() {\n    use super::*;\n    assert!(!Method::GET.is_unknown());\n    assert!(!Method::POST.is_unknown());\n    assert!(!Method::PUT.is_unknown());\n    assert!(!Method::DELETE.is_unknown());\n    assert!(!Method::PATCH.is_unknown());\n    assert!(!Method::HEAD.is_unknown());\n    assert!(!Method::OPTIONS.is_unknown());\n    assert!(!Method::CONNECT.is_unknown());\n    assert!(!Method::TRACE.is_unknown());\n    assert!(Method::UNKNOWN(\"CUSTOM\".to_string()).is_unknown());\n    assert!(Method::UNKNOWN(\"\".to_string()).is_unknown());\n}\n\n#[test]\nfn test_method_clone() {\n    use super::*;\n    let method: Method = Method::GET;\n    let cloned_method: Method = method.clone();\n    assert_eq!(method, cloned_method);\n    let unknown_method: Method = Method::UNKNOWN(\"CUSTOM\".to_string());\n    let cloned_unknown: Method = unknown_method.clone();\n    assert_eq!(unknown_method, cloned_unknown);\n}\n\n#[test]\nfn test_method_debug() {\n    use super::*;\n    let method: Method = Method::GET;\n    let debug_str: String = format!(\"{:?}\", method);\n    assert_eq!(debug_str, \"GET\");\n    let unknown_method: Method = Method::UNKNOWN(\"CUSTOM\".to_string());\n    let unknown_debug_str: String = format!(\"{:?}\", unknown_method);\n    assert_eq!(unknown_debug_str, \"UNKNOWN(\\\"CUSTOM\\\")\");\n}\n\n#[test]\nfn test_method_equality() {\n    use super::*;\n    assert_eq!(Method::GET, Method::GET);\n    assert_ne!(Method::GET, Method::POST);\n    assert_eq!(\n        Method::UNKNOWN(\"CUSTOM\".to_string()),\n        Method::UNKNOWN(\"CUSTOM\".to_string())\n    );\n    assert_ne!(\n        Method::UNKNOWN(\"CUSTOM1\".to_string()),\n        Method::UNKNOWN(\"CUSTOM2\".to_string())\n    );\n    assert_ne!(Method::GET, Method::UNKNOWN(\"GET\".to_string()));\n}\n\n#[test]\nfn test_method_case_sensitivity() {\n    use super::*;\n    assert_eq!(\n        \"get\".parse::<Method>().unwrap(),\n        Method::UNKNOWN(\"get\".to_string())\n    );\n    assert_eq!(\n        \"Get\".parse::<Method>().unwrap(),\n        Method::UNKNOWN(\"Get\".to_string())\n    );\n    assert_eq!(\"POST\".parse::<Method>().unwrap(), Method::POST);\n    assert_eq!(\n        \"post\".parse::<Method>().unwrap(),\n        Method::UNKNOWN(\"post\".to_string())\n    );\n}\n\n#[test]\nfn test_method_all_variants() {\n    use super::*;\n    let methods: Vec<Method> = vec![\n        Method::GET,\n        Method::POST,\n        Method::PUT,\n        Method::DELETE,\n        Method::PATCH,\n        Method::HEAD,\n        Method::OPTIONS,\n        Method::CONNECT,\n        Method::TRACE,\n        Method::UNKNOWN(\"CUSTOM\".to_string()),\n    ];\n    for method in methods {\n        let display_str: String = method.to_string();\n        assert!(!display_str.is_empty());\n        let debug_str: String = format!(\"{:?}\", method);\n        assert!(!debug_str.is_empty());\n    }\n}\n\n#[test]\nfn test_method_unknown_with_empty_string() {\n    use super::*;\n    let method: Method = Method::UNKNOWN(\"\".to_string());\n    assert_eq!(method.to_string(), \"\");\n    assert!(method.is_unknown());\n    assert_eq!(format!(\"{:?}\", method), \"UNKNOWN(\\\"\\\")\");\n}\n\n#[test]\nfn test_method_unknown_with_special_characters() {\n    use super::*;\n    let method: Method = Method::UNKNOWN(\"CUSTOM-METHOD\".to_string());\n    assert_eq!(method.to_string(), \"CUSTOM-METHOD\");\n    assert!(method.is_unknown());\n    assert_eq!(format!(\"{:?}\", method), \"UNKNOWN(\\\"CUSTOM-METHOD\\\")\");\n}", "file_size": 9351, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\methods\\enum.rs", "language": "rust", "content": "/// Defines the `Method` enum, representing HTTP request methods.\n///\n/// This enum provides a comprehensive list of standard HTTP methods,\n/// such as GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT, and TRACE.\n/// It also includes an `UNKNOWN` variant for unrecognized methods.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Method {\n    /// Represents the HTTP `GET` method.\n    GET,\n    /// Represents the HTTP `POST` method.\n    POST,\n    /// Represents the HTTP `PUT` method.\n    PUT,\n    /// Represents the HTTP `DELETE` method.\n    DELETE,\n    /// Represents the HTTP `PATCH` method.\n    PATCH,\n    /// Represents the HTTP `HEAD` method.\n    HEAD,\n    /// Represents the HTTP `OPTIONS` method.\n    OPTIONS,\n    /// Represents the HTTP `CONNECT` method.\n    CONNECT,\n    /// Represents the HTTP `TRACE` method.\n    TRACE,\n    /// Unknown\n    UNKNOWN(String),\n}", "file_size": 874, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_url\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the components of a parsed HTTP URL.\n///\n/// This struct holds various parts of a URL, including the protocol, host, port,\n/// path, query, and fragment, allowing for structured access to URL information.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub struct HttpUrlComponents {\n    /// The URL scheme, such as \"http\" or \"https\".\n    pub protocol: Protocol,\n    /// The host part of the URL.\n    pub host: OptionString,\n    /// The port number in the URL, if specified.\n    pub port: OptionU16,\n    /// The path in the URL.\n    pub path: OptionString,\n    /// The query string in the URL.\n    pub query: OptionString,\n    /// The fragment identifier.\n    pub fragment: OptionString,\n}", "file_size": 710, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_status\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_http_status_code() {\n    use super::*;\n    assert_eq!(HttpStatus::Continue.code(), 100);\n    assert_eq!(HttpStatus::SwitchingProtocols.code(), 101);\n    assert_eq!(HttpStatus::Processing.code(), 102);\n    assert_eq!(HttpStatus::EarlyHints.code(), 103);\n    assert_eq!(HttpStatus::Ok.code(), 200);\n    assert_eq!(HttpStatus::Created.code(), 201);\n    assert_eq!(HttpStatus::Accepted.code(), 202);\n    assert_eq!(HttpStatus::NonAuthoritativeInformation.code(), 203);\n    assert_eq!(HttpStatus::NoContent.code(), 204);\n    assert_eq!(HttpStatus::ResetContent.code(), 205);\n    assert_eq!(HttpStatus::PartialContent.code(), 206);\n    assert_eq!(HttpStatus::MultiStatus.code(), 207);\n    assert_eq!(HttpStatus::AlreadyReported.code(), 208);\n    assert_eq!(HttpStatus::IMUsed.code(), 226);\n    assert_eq!(HttpStatus::MultipleChoices.code(), 300);\n    assert_eq!(HttpStatus::MovedPermanently.code(), 301);\n    assert_eq!(HttpStatus::Found.code(), 302);\n    assert_eq!(HttpStatus::SeeOther.code(), 303);\n    assert_eq!(HttpStatus::NotModified.code(), 304);\n    assert_eq!(HttpStatus::UseProxy.code(), 305);\n    assert_eq!(HttpStatus::TemporaryRedirect.code(), 307);\n    assert_eq!(HttpStatus::PermanentRedirect.code(), 308);\n    assert_eq!(HttpStatus::BadRequest.code(), 400);\n    assert_eq!(HttpStatus::Unauthorized.code(), 401);\n    assert_eq!(HttpStatus::PaymentRequired.code(), 402);\n    assert_eq!(HttpStatus::Forbidden.code(), 403);\n    assert_eq!(HttpStatus::NotFound.code(), 404);\n    assert_eq!(HttpStatus::MethodNotAllowed.code(), 405);\n    assert_eq!(HttpStatus::NotAcceptable.code(), 406);\n    assert_eq!(HttpStatus::ProxyAuthenticationRequired.code(), 407);\n    assert_eq!(HttpStatus::RequestTimeout.code(), 408);\n    assert_eq!(HttpStatus::Conflict.code(), 409);\n    assert_eq!(HttpStatus::Gone.code(), 410);\n    assert_eq!(HttpStatus::LengthRequired.code(), 411);\n    assert_eq!(HttpStatus::PreconditionFailed.code(), 412);\n    assert_eq!(HttpStatus::PayloadTooLarge.code(), 413);\n    assert_eq!(HttpStatus::URITooLong.code(), 414);\n    assert_eq!(HttpStatus::UnsupportedMediaType.code(), 415);\n    assert_eq!(HttpStatus::RangeNotSatisfiable.code(), 416);\n    assert_eq!(HttpStatus::ExpectationFailed.code(), 417);\n    assert_eq!(HttpStatus::ImATeapot.code(), 418);\n    assert_eq!(HttpStatus::MisdirectedRequest.code(), 421);\n    assert_eq!(HttpStatus::UnprocessableEntity.code(), 422);\n    assert_eq!(HttpStatus::Locked.code(), 423);\n    assert_eq!(HttpStatus::FailedDependency.code(), 424);\n    assert_eq!(HttpStatus::TooEarly.code(), 425);\n    assert_eq!(HttpStatus::UpgradeRequired.code(), 426);\n    assert_eq!(HttpStatus::PreconditionRequired.code(), 428);\n    assert_eq!(HttpStatus::TooManyRequests.code(), 429);\n    assert_eq!(HttpStatus::RequestHeaderFieldsTooLarge.code(), 431);\n    assert_eq!(HttpStatus::UnavailableForLegalReasons.code(), 451);\n    assert_eq!(HttpStatus::InternalServerError.code(), 500);\n    assert_eq!(HttpStatus::NotImplemented.code(), 501);\n    assert_eq!(HttpStatus::BadGateway.code(), 502);\n    assert_eq!(HttpStatus::ServiceUnavailable.code(), 503);\n    assert_eq!(HttpStatus::GatewayTimeout.code(), 504);\n    assert_eq!(HttpStatus::HTTPVersionNotSupported.code(), 505);\n    assert_eq!(HttpStatus::VariantAlsoNegotiates.code(), 506);\n    assert_eq!(HttpStatus::InsufficientStorage.code(), 507);\n    assert_eq!(HttpStatus::LoopDetected.code(), 508);\n    assert_eq!(HttpStatus::NotExtended.code(), 510);\n    assert_eq!(HttpStatus::NetworkAuthenticationRequired.code(), 511);\n    assert_eq!(HttpStatus::Unknown.code(), 0);\n}\n\n#[test]\nfn test_http_status_phrase() {\n    use super::*;\n    assert_eq!(HttpStatus::phrase(100), \"Continue\");\n    assert_eq!(HttpStatus::phrase(101), \"Switching Protocols\");\n    assert_eq!(HttpStatus::phrase(102), \"Processing\");\n    assert_eq!(HttpStatus::phrase(103), \"Early Hints\");\n    assert_eq!(HttpStatus::phrase(200), \"OK\");\n    assert_eq!(HttpStatus::phrase(201), \"Created\");\n    assert_eq!(HttpStatus::phrase(202), \"Accepted\");\n    assert_eq!(HttpStatus::phrase(203), \"Non-Authoritative Information\");\n    assert_eq!(HttpStatus::phrase(204), \"No Content\");\n    assert_eq!(HttpStatus::phrase(205), \"Reset Content\");\n    assert_eq!(HttpStatus::phrase(206), \"Partial Content\");\n    assert_eq!(HttpStatus::phrase(207), \"Multi-Status\");\n    assert_eq!(HttpStatus::phrase(208), \"Already Reported\");\n    assert_eq!(HttpStatus::phrase(226), \"IM Used\");\n    assert_eq!(HttpStatus::phrase(300), \"Multiple Choices\");\n    assert_eq!(HttpStatus::phrase(301), \"Moved Permanently\");\n    assert_eq!(HttpStatus::phrase(302), \"Found\");\n    assert_eq!(HttpStatus::phrase(303), \"See Other\");\n    assert_eq!(HttpStatus::phrase(304), \"Not Modified\");\n    assert_eq!(HttpStatus::phrase(305), \"Use Proxy\");\n    assert_eq!(HttpStatus::phrase(307), \"Temporary Redirect\");\n    assert_eq!(HttpStatus::phrase(308), \"Permanent Redirect\");\n    assert_eq!(HttpStatus::phrase(400), \"Bad Request\");\n    assert_eq!(HttpStatus::phrase(401), \"Unauthorized\");\n    assert_eq!(HttpStatus::phrase(402), \"Payment Required\");\n    assert_eq!(HttpStatus::phrase(403), \"Forbidden\");\n    assert_eq!(HttpStatus::phrase(404), \"Not Found\");\n    assert_eq!(HttpStatus::phrase(405), \"Method Not Allowed\");\n    assert_eq!(HttpStatus::phrase(406), \"Not Acceptable\");\n    assert_eq!(HttpStatus::phrase(407), \"Proxy Authentication Required\");\n    assert_eq!(HttpStatus::phrase(408), \"Request Timeout\");\n    assert_eq!(HttpStatus::phrase(409), \"Conflict\");\n    assert_eq!(HttpStatus::phrase(410), \"Gone\");\n    assert_eq!(HttpStatus::phrase(411), \"Length Required\");\n    assert_eq!(HttpStatus::phrase(412), \"Precondition Failed\");\n    assert_eq!(HttpStatus::phrase(413), \"Payload Too Large\");\n    assert_eq!(HttpStatus::phrase(414), \"URI Too Long\");\n    assert_eq!(HttpStatus::phrase(415), \"Unsupported Media Type\");\n    assert_eq!(HttpStatus::phrase(416), \"Range Not Satisfiable\");\n    assert_eq!(HttpStatus::phrase(417), \"Expectation Failed\");\n    assert_eq!(HttpStatus::phrase(418), \"I'm a teapot\");\n    assert_eq!(HttpStatus::phrase(421), \"Misdirected Request\");\n    assert_eq!(HttpStatus::phrase(422), \"Unprocessable Entity\");\n    assert_eq!(HttpStatus::phrase(423), \"Locked\");\n    assert_eq!(HttpStatus::phrase(424), \"Failed Dependency\");\n    assert_eq!(HttpStatus::phrase(425), \"Too Early\");\n    assert_eq!(HttpStatus::phrase(426), \"Upgrade Required\");\n    assert_eq!(HttpStatus::phrase(428), \"Precondition Required\");\n    assert_eq!(HttpStatus::phrase(429), \"Too Many Requests\");\n    assert_eq!(HttpStatus::phrase(431), \"Request Header Fields Too Large\");\n    assert_eq!(HttpStatus::phrase(451), \"Unavailable For Legal Reasons\");\n    assert_eq!(HttpStatus::phrase(500), \"Internal Server Error\");\n    assert_eq!(HttpStatus::phrase(501), \"Not Implemented\");\n    assert_eq!(HttpStatus::phrase(502), \"Bad Gateway\");\n    assert_eq!(HttpStatus::phrase(503), \"Service Unavailable\");\n    assert_eq!(HttpStatus::phrase(504), \"Gateway Timeout\");\n    assert_eq!(HttpStatus::phrase(505), \"HTTP Version Not Supported\");\n    assert_eq!(HttpStatus::phrase(506), \"Variant Also Negotiates\");\n    assert_eq!(HttpStatus::phrase(507), \"Insufficient Storage\");\n    assert_eq!(HttpStatus::phrase(508), \"Loop Detected\");\n    assert_eq!(HttpStatus::phrase(510), \"Not Extended\");\n    assert_eq!(HttpStatus::phrase(511), \"Network Authentication Required\");\n    assert_eq!(HttpStatus::phrase(999), \"Unknown\");\n}\n\n#[test]\nfn test_http_status_display() {\n    use super::*;\n    assert_eq!(HttpStatus::Ok.to_string(), \"OK\");\n    assert_eq!(HttpStatus::NotFound.to_string(), \"Not Found\");\n    assert_eq!(\n        HttpStatus::InternalServerError.to_string(),\n        \"Internal Server Error\"\n    );\n    assert_eq!(HttpStatus::Continue.to_string(), \"Continue\");\n    assert_eq!(HttpStatus::BadRequest.to_string(), \"Bad Request\");\n    assert_eq!(HttpStatus::Unknown.to_string(), \"Unknown\");\n}\n\n#[test]\nfn test_http_status_same() {\n    use super::*;\n    assert!(HttpStatus::Ok.same(\"OK\"));\n    assert!(HttpStatus::Ok.same(\"ok\"));\n    assert!(HttpStatus::Ok.same(\"Ok\"));\n    assert!(HttpStatus::NotFound.same(\"Not Found\"));\n    assert!(HttpStatus::NotFound.same(\"not found\"));\n    assert!(HttpStatus::NotFound.same(\"NOT FOUND\"));\n    assert!(!HttpStatus::Ok.same(\"Bad Request\"));\n    assert!(!HttpStatus::NotFound.same(\"OK\"));\n}\n\n#[test]\nfn test_http_status_from_str() {\n    use super::*;\n    assert_eq!(\"100\".parse::<HttpStatus>().unwrap(), HttpStatus::Continue);\n    assert_eq!(\"200\".parse::<HttpStatus>().unwrap(), HttpStatus::Ok);\n    assert_eq!(\"404\".parse::<HttpStatus>().unwrap(), HttpStatus::NotFound);\n    assert_eq!(\n        \"500\".parse::<HttpStatus>().unwrap(),\n        HttpStatus::InternalServerError\n    );\n    assert_eq!(\"400\".parse::<HttpStatus>().unwrap(), HttpStatus::BadRequest);\n    assert_eq!(\"666\".parse::<HttpStatus>().unwrap(), HttpStatus::Unknown);\n    assert_eq!(\"\".parse::<HttpStatus>().unwrap(), HttpStatus::Unknown);\n}\n\n#[test]\nfn test_http_status_default() {\n    use super::*;\n    assert_eq!(HttpStatus::default(), HttpStatus::Unknown);\n}\n\n#[test]\nfn test_http_status_clone() {\n    use super::*;\n    let status: HttpStatus = HttpStatus::Ok;\n    let cloned_status: HttpStatus = status.clone();\n    assert_eq!(status, cloned_status);\n}\n\n#[test]\nfn test_http_status_debug() {\n    use super::*;\n    let status: HttpStatus = HttpStatus::Ok;\n    let debug_str: String = format!(\"{:?}\", status);\n    assert_eq!(debug_str, \"Ok\");\n}\n\n#[test]\nfn test_http_status_equality() {\n    use super::*;\n    assert_eq!(HttpStatus::Ok, HttpStatus::Ok);\n    assert_ne!(HttpStatus::Ok, HttpStatus::NotFound);\n    assert_eq!(\n        HttpStatus::InternalServerError,\n        HttpStatus::InternalServerError\n    );\n    assert_ne!(HttpStatus::BadRequest, HttpStatus::Unauthorized);\n}\n\n#[test]\nfn test_http_status_informational() {\n    use super::*;\n    assert_eq!(HttpStatus::Continue.code(), 100);\n    assert_eq!(HttpStatus::SwitchingProtocols.code(), 101);\n    assert_eq!(HttpStatus::Processing.code(), 102);\n    assert_eq!(HttpStatus::EarlyHints.code(), 103);\n}\n\n#[test]\nfn test_http_status_success() {\n    use super::*;\n    assert_eq!(HttpStatus::Ok.code(), 200);\n    assert_eq!(HttpStatus::Created.code(), 201);\n    assert_eq!(HttpStatus::Accepted.code(), 202);\n    assert_eq!(HttpStatus::NoContent.code(), 204);\n}\n\n#[test]\nfn test_http_status_redirection() {\n    use super::*;\n    assert_eq!(HttpStatus::MultipleChoices.code(), 300);\n    assert_eq!(HttpStatus::MovedPermanently.code(), 301);\n    assert_eq!(HttpStatus::Found.code(), 302);\n    assert_eq!(HttpStatus::NotModified.code(), 304);\n}\n\n#[test]\nfn test_http_status_client_error() {\n    use super::*;\n    assert_eq!(HttpStatus::BadRequest.code(), 400);\n    assert_eq!(HttpStatus::Unauthorized.code(), 401);\n    assert_eq!(HttpStatus::Forbidden.code(), 403);\n    assert_eq!(HttpStatus::NotFound.code(), 404);\n    assert_eq!(HttpStatus::MethodNotAllowed.code(), 405);\n}\n\n#[test]\nfn test_http_status_server_error() {\n    use super::*;\n    assert_eq!(HttpStatus::InternalServerError.code(), 500);\n    assert_eq!(HttpStatus::NotImplemented.code(), 501);\n    assert_eq!(HttpStatus::BadGateway.code(), 502);\n    assert_eq!(HttpStatus::ServiceUnavailable.code(), 503);\n    assert_eq!(HttpStatus::GatewayTimeout.code(), 504);\n}\n\n#[test]\nfn test_http_status_special_codes() {\n    use super::*;\n    assert_eq!(HttpStatus::ImATeapot.code(), 418);\n    assert_eq!(HttpStatus::ImATeapot.to_string(), \"I'm a teapot\");\n    assert_eq!(HttpStatus::Unknown.code(), 0);\n    assert_eq!(HttpStatus::Unknown.to_string(), \"Unknown\");\n}", "file_size": 11577, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\json\\mod.rs", "language": "rust", "content": "pub(crate) mod serde_json;\npub(crate) mod r#type;\n\npub use serde_json::*;\npub use r#type::*;", "file_size": 92, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_url\\mod.rs", "language": "rust", "content": "pub(crate) mod error;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub use r#error::*;\npub use r#struct::*;", "file_size": 111, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\methods\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `Method`.\nimpl Default for Method {\n    /// Returns the default `Method` variant, which is `UNKNOWN` with an empty string.\n    ///\n    /// # Returns\n    ///\n    /// The default `Method` variant.\n    fn default() -> Self {\n        Self::UNKNOWN(String::new())\n    }\n}\n\n/// Implements the `Display` trait for `Method`, allowing it to be formatted as a string.\nimpl Display for Method {\n    /// Formats the `Method` variant into its string representation.\n    ///\n    /// # Arguments\n    ///\n    /// - `f` - The formatter to write the string into.\n    ///\n    /// # Returns\n    ///\n    /// A `fmt::Result` indicating success or failure of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let res: &str = match self {\n            Self::GET => GET,\n            Self::POST => POST,\n            Self::CONNECT => CONNECT,\n            Self::DELETE => DELETE,\n            Self::HEAD => HEAD,\n            Self::PATCH => PATCH,\n            Self::TRACE => TRACE,\n            Self::PUT => PUT,\n            Self::OPTIONS => OPTIONS,\n            Self::UNKNOWN(methods) => methods,\n        };\n        write!(f, \"{}\", res)\n    }\n}\n\n/// Implements the `FromStr` trait for `Method`, allowing conversion from a string slice.\nimpl FromStr for Method {\n    /// The error type returned when conversion fails.\n    type Err = ();\n\n    /// Converts a string slice into a `Method` variant.\n    ///\n    /// This method attempts to parse the input string into a known `Method` variant.\n    /// If the string does not match any known method, it returns an `UNKNOWN` variant\n    /// containing the original string.\n    ///\n    /// # Arguments\n    ///\n    /// - `methods_str` - The string slice to convert.\n    ///\n    /// # Returns\n    ///\n    /// A `Result` containing the `Method` variant if successful, or `Self::Err` on failure.\n    fn from_str(methods_str: &str) -> Result<Self, Self::Err> {\n        match methods_str {\n            GET => Ok(Self::GET),\n            POST => Ok(Self::POST),\n            PUT => Ok(Self::PUT),\n            DELETE => Ok(Self::DELETE),\n            PATCH => Ok(Self::PATCH),\n            HEAD => Ok(Self::HEAD),\n            OPTIONS => Ok(Self::OPTIONS),\n            CONNECT => Ok(Self::CONNECT),\n            TRACE => Ok(Self::TRACE),\n            _ => Ok(Self::UNKNOWN(methods_str.to_string())),\n        }\n    }\n}\n\nimpl Method {\n    /// Creates a new instance of `Method` with the default value of `Self::GET`.\n    ///\n    /// This is a shorthand for using the `default` method.\n    ///\n    /// # Returns\n    ///\n    /// A new `Method` instance.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Checks if the current method is `GET`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `GET`, `false` otherwise.\n    pub fn is_get(&self) -> bool {\n        matches!(self, Self::GET)\n    }\n\n    /// Checks if the current method is `POST`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `POST`, `false` otherwise.\n    pub fn is_post(&self) -> bool {\n        matches!(self, Self::POST)\n    }\n\n    /// Checks if the current method is `PUT`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `PUT`, `false` otherwise.\n    pub fn is_put(&self) -> bool {\n        matches!(self, Self::PUT)\n    }\n\n    /// Checks if the current method is `DELETE`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `DELETE`, `false` otherwise.\n    pub fn is_delete(&self) -> bool {\n        matches!(self, Self::DELETE)\n    }\n\n    /// Checks if the current method is `PATCH`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `PATCH`, `false` otherwise.\n    pub fn is_patch(&self) -> bool {\n        matches!(self, Self::PATCH)\n    }\n\n    /// Checks if the current method is `HEAD`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `HEAD`, `false` otherwise.\n    pub fn is_head(&self) -> bool {\n        matches!(self, Self::HEAD)\n    }\n\n    /// Checks if the current method is `OPTIONS`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `OPTIONS`, `false` otherwise.\n    pub fn is_options(&self) -> bool {\n        matches!(self, Self::OPTIONS)\n    }\n\n    /// Checks if the current method is `CONNECT`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `CONNECT`, `false` otherwise.\n    pub fn is_connect(&self) -> bool {\n        matches!(self, Self::CONNECT)\n    }\n\n    /// Checks if the current method is `TRACE`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `TRACE`, `false` otherwise.\n    pub fn is_trace(&self) -> bool {\n        matches!(self, Self::TRACE)\n    }\n\n    /// Checks if the current method is `UNKNOWN`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the method is `UNKNOWN`, `false` otherwise.\n    pub fn is_unknown(&self) -> bool {\n        matches!(self, Self::UNKNOWN(_))\n    }\n}", "file_size": 4941, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_url\\impl.rs", "language": "rust", "content": "use crate::*;\nuse url::Url as UrlParser;\n\n/// Implements the `Default` trait for `HttpUrlComponents`.\nimpl Default for HttpUrlComponents {\n    /// Returns a default `HttpUrlComponents` instance with all fields set to their default or empty values.\n    ///\n    /// # Returns\n    ///\n    /// A default `HttpUrlComponents` instance.\n    fn default() -> Self {\n        HttpUrlComponents {\n            protocol: Protocol::Unknown(String::new()),\n            host: None,\n            port: None,\n            path: None,\n            query: None,\n            fragment: None,\n        }\n    }\n}\n\nimpl HttpUrlComponents {\n    /// Parses a URL string into its components.\n    ///\n    /// Extracts protocol, host, port, path, query and fragment from the URL string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The URL string to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<HttpUrlComponents, HttpUrlError>` - Either the parsed components or an error.\n    pub fn parse(url_str: &str) -> Result<Self, HttpUrlError> {\n        let parsed_url: UrlParser =\n            UrlParser::parse(url_str).map_err(|_| HttpUrlError::InvalidUrl)?;\n        let res: Self = Self {\n            protocol: parsed_url\n                .scheme()\n                .to_string()\n                .parse::<Protocol>()\n                .unwrap_or_default(),\n            host: parsed_url.host_str().map(|h| h.to_string()),\n            port: parsed_url.port(),\n            path: Some(parsed_url.path().to_string()),\n            query: parsed_url.query().map(|q| q.to_string()),\n            fragment: parsed_url.fragment().map(|f| f.to_string()),\n        };\n        Ok(res)\n    }\n}", "file_size": 1654, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\json\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `Result` with `JsonError` as the error type.\npub type ResultJsonError<T> = Result<T, JsonError>;", "file_size": 132, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\hash_map_xx_hash3_64\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type HashMapXxHash3_64<K, V> = HashMap<K, V, BuildHasherDefault<XxHash3_64>>;", "file_size": 96, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_bool\\type.rs", "language": "rust", "content": "/// A type alias for `Option<bool>`.\npub type OptionBool = Option<bool>;", "file_size": 72, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_version\\enum.rs", "language": "rust", "content": "/// Represents the HTTP version used in the request or response.\n///\n/// This enum defines the various HTTP protocol versions supported,\n/// including HTTP/0.9, HTTP/1.0, HTTP/1.1, HTTP/2, and HTTP/3.\n/// It also includes an `Unknown` variant for unrecognized versions.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpVersion {\n    /// HTTP version 0.9\n    HTTP0_9,\n    /// HTTP version 1.0\n    HTTP1_0,\n    /// HTTP version 1.1\n    HTTP1_1,\n    /// HTTP version 2.0\n    HTTP2,\n    /// HTTP version 3.0\n    HTTP3,\n    /// Unknown version\n    Unknown(String),\n}", "file_size": 564, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_compress\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `Option<Compress>`.\npub type OptionCompress = Option<Compress>;", "file_size": 99, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_duration\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for `Option<Duration>`.\npub type OptionDuration = Option<Duration>;", "file_size": 99, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_version\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_http_version_display() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(HttpVersion::HTTP0_9.to_string(), HTTP_VERSION_0_9);\n    assert_eq!(HttpVersion::HTTP1_0.to_string(), HTTP_VERSION_1_0);\n    assert_eq!(HttpVersion::HTTP1_1.to_string(), HTTP_VERSION_1_1);\n    assert_eq!(HttpVersion::HTTP2.to_string(), HTTP_VERSION_2);\n    assert_eq!(HttpVersion::HTTP3.to_string(), HTTP_VERSION_3);\n    assert_eq!(\n        HttpVersion::Unknown(\"HTTP/4.0\".to_string()).to_string(),\n        \"HTTP/4.0\"\n    );\n}\n\n#[test]\nfn test_http_version_default() {\n    use super::*;\n    assert_eq!(HttpVersion::default(), HttpVersion::Unknown(String::new()));\n}\n\n#[test]\nfn test_http_version_clone() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::HTTP1_1;\n    let cloned_version: HttpVersion = version.clone();\n    assert_eq!(version, cloned_version);\n}\n\n#[test]\nfn test_http_version_debug() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::HTTP1_1;\n    let debug_str: String = format!(\"{:?}\", version);\n    assert_eq!(debug_str, \"HTTP1_1\");\n}\n\n#[test]\nfn test_http_version_equality() {\n    use super::*;\n    assert_eq!(HttpVersion::HTTP1_1, HttpVersion::HTTP1_1);\n    assert_ne!(HttpVersion::HTTP1_1, HttpVersion::HTTP2);\n    assert_eq!(HttpVersion::HTTP0_9, HttpVersion::HTTP0_9);\n    assert_ne!(HttpVersion::HTTP1_0, HttpVersion::HTTP1_1);\n    assert_eq!(\n        HttpVersion::Unknown(\"test\".to_string()),\n        HttpVersion::Unknown(\"test\".to_string())\n    );\n    assert_ne!(\n        HttpVersion::Unknown(\"test1\".to_string()),\n        HttpVersion::Unknown(\"test2\".to_string())\n    );\n}\n\n#[test]\nfn test_http_version_all_variants() {\n    use super::*;\n    let versions: Vec<HttpVersion> = vec![\n        HttpVersion::HTTP0_9,\n        HttpVersion::HTTP1_0,\n        HttpVersion::HTTP1_1,\n        HttpVersion::HTTP2,\n        HttpVersion::HTTP3,\n        HttpVersion::Unknown(\"HTTP/4.0\".to_string()),\n    ];\n    for version in versions {\n        let display_str: String = version.to_string();\n        assert!(!display_str.is_empty());\n        let debug_str: String = format!(\"{:?}\", version);\n        assert!(!debug_str.is_empty());\n    }\n}\n\n#[test]\nfn test_http_version_unknown_with_empty_string() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::Unknown(\"\".to_string());\n    assert_eq!(version.to_string(), \"\");\n    assert_eq!(format!(\"{:?}\", version), \"Unknown(\\\"\\\")\");\n}\n\n#[test]\nfn test_http_version_unknown_with_special_characters() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::Unknown(\"HTTP/1.1-custom\".to_string());\n    assert_eq!(version.to_string(), \"HTTP/1.1-custom\");\n    assert_eq!(format!(\"{:?}\", version), \"Unknown(\\\"HTTP/1.1-custom\\\")\");\n}\n\n#[test]\nfn test_http_version_pattern_matching() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::HTTP1_1;\n    match version {\n        HttpVersion::HTTP0_9 => panic!(\"Should not match HTTP0_9\"),\n        HttpVersion::HTTP1_0 => panic!(\"Should not match HTTP1_0\"),\n        HttpVersion::HTTP1_1 => assert!(true),\n        HttpVersion::HTTP2 => panic!(\"Should not match HTTP2\"),\n        HttpVersion::HTTP3 => panic!(\"Should not match HTTP3\"),\n        HttpVersion::Unknown(_) => panic!(\"Should not match Unknown\"),\n    }\n}\n\n#[test]\nfn test_http_version_unknown_pattern_matching() {\n    use super::*;\n    let version: HttpVersion = HttpVersion::Unknown(\"custom\".to_string());\n    match version {\n        HttpVersion::HTTP0_9 => panic!(\"Should not match HTTP0_9\"),\n        HttpVersion::HTTP1_0 => panic!(\"Should not match HTTP1_0\"),\n        HttpVersion::HTTP1_1 => panic!(\"Should not match HTTP1_1\"),\n        HttpVersion::HTTP2 => panic!(\"Should not match HTTP2\"),\n        HttpVersion::HTTP3 => panic!(\"Should not match HTTP3\"),\n        HttpVersion::Unknown(ref custom_version) => {\n            assert_eq!(custom_version, \"custom\");\n        }\n    }\n}\n\n#[test]\nfn test_http_version_is_http1() {\n    use super::*;\n    assert!(matches!(HttpVersion::HTTP1_0, HttpVersion::HTTP1_0));\n    assert!(matches!(HttpVersion::HTTP1_1, HttpVersion::HTTP1_1));\n    assert!(!matches!(\n        HttpVersion::HTTP0_9,\n        HttpVersion::HTTP1_0 | HttpVersion::HTTP1_1\n    ));\n    assert!(!matches!(\n        HttpVersion::HTTP2,\n        HttpVersion::HTTP1_0 | HttpVersion::HTTP1_1\n    ));\n    assert!(!matches!(\n        HttpVersion::HTTP3,\n        HttpVersion::HTTP1_0 | HttpVersion::HTTP1_1\n    ));\n}\n\n#[test]\nfn test_http_version_is_modern() {\n    use super::*;\n    assert!(matches!(\n        HttpVersion::HTTP2,\n        HttpVersion::HTTP2 | HttpVersion::HTTP3\n    ));\n    assert!(matches!(\n        HttpVersion::HTTP3,\n        HttpVersion::HTTP2 | HttpVersion::HTTP3\n    ));\n    assert!(!matches!(\n        HttpVersion::HTTP0_9,\n        HttpVersion::HTTP2 | HttpVersion::HTTP3\n    ));\n    assert!(!matches!(\n        HttpVersion::HTTP1_0,\n        HttpVersion::HTTP2 | HttpVersion::HTTP3\n    ));\n    assert!(!matches!(\n        HttpVersion::HTTP1_1,\n        HttpVersion::HTTP2 | HttpVersion::HTTP3\n    ));\n}\n\n#[test]\nfn test_http_version_ordering() {\n    use super::*;\n    let mut versions: Vec<HttpVersion> = vec![\n        HttpVersion::HTTP3,\n        HttpVersion::HTTP1_0,\n        HttpVersion::HTTP2,\n        HttpVersion::HTTP0_9,\n        HttpVersion::HTTP1_1,\n    ];\n    versions.sort_by(|a, b| {\n        let order_a: u8 = match a {\n            HttpVersion::HTTP0_9 => 0,\n            HttpVersion::HTTP1_0 => 1,\n            HttpVersion::HTTP1_1 => 2,\n            HttpVersion::HTTP2 => 3,\n            HttpVersion::HTTP3 => 4,\n            HttpVersion::Unknown(_) => 255,\n        };\n        let order_b: u8 = match b {\n            HttpVersion::HTTP0_9 => 0,\n            HttpVersion::HTTP1_0 => 1,\n            HttpVersion::HTTP1_1 => 2,\n            HttpVersion::HTTP2 => 3,\n            HttpVersion::HTTP3 => 4,\n            HttpVersion::Unknown(_) => 255,\n        };\n        order_a.cmp(&order_b)\n    });\n    assert_eq!(versions[0], HttpVersion::HTTP0_9);\n    assert_eq!(versions[1], HttpVersion::HTTP1_0);\n    assert_eq!(versions[2], HttpVersion::HTTP1_1);\n    assert_eq!(versions[3], HttpVersion::HTTP2);\n    assert_eq!(versions[4], HttpVersion::HTTP3);\n}\n\n#[test]\nfn test_http_version_memory_size() {\n    use super::*;\n    use std::mem;\n    let size: usize = mem::size_of::<HttpVersion>();\n    assert!(size > 0);\n    let http11_size: usize = mem::size_of_val(&HttpVersion::HTTP1_1);\n    let unknown_size: usize = mem::size_of_val(&HttpVersion::Unknown(\"test\".to_string()));\n    assert_eq!(http11_size, unknown_size);\n}", "file_size": 6526, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\json\\serde_json.rs", "language": "rust", "content": "pub use serde_json::{\n    Deserializer as JsonDeserializer, Error as JsonError, Map as JsonMap, Number as JsonNumber,\n    Result as JsonResult, Serializer as JsonSerializer,\n    StreamDeserializer as JsonStreamDeserializer, Value as JsonValue,\n    from_reader as json_from_reader, from_slice as json_from_slice, from_str as json_from_str,\n    from_value as json_from_value, json as json_value, to_string as json_to_string,\n    to_string_pretty as json_to_string_pretty, to_value as json_to_value, to_vec as json_to_vec,\n    to_vec_pretty as json_to_vec_pretty, to_writer as json_to_writer,\n    to_writer_pretty as json_to_writer_pretty,\n};", "file_size": 639, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_string\\type.rs", "language": "rust", "content": "/// A type alias for `Option<String>`.\npub type OptionString = Option<String>;", "file_size": 78, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_i64\\type.rs", "language": "rust", "content": "/// A type alias for `Option<i64>`.\npub type OptionI64 = Option<i64>;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_u16\\type.rs", "language": "rust", "content": "/// A type alias for `Option<u16>`.\npub type OptionU16 = Option<u16>;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_i32\\type.rs", "language": "rust", "content": "/// A type alias for `Option<i32>`.\npub type OptionI32 = Option<i32>;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_u32\\type.rs", "language": "rust", "content": "/// A type alias for `Option<u32>`.\npub type OptionU32 = Option<u32>;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_i128\\type.rs", "language": "rust", "content": "/// A type alias for `Option<i128>`.\npub type OptionI128 = Option<i128>;", "file_size": 72, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\protocol\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_protocol_display() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(Protocol::HTTP.to_string(), HTTP_LOWERCASE);\n    assert_eq!(Protocol::HTTPS.to_string(), HTTPS_LOWERCASE);\n    assert_eq!(Protocol::Unknown(\"ftp\".to_string()).to_string(), \"ftp\");\n}\n\n#[test]\nfn test_protocol_from_str() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(HTTP_LOWERCASE.parse::<Protocol>().unwrap(), Protocol::HTTP);\n    assert_eq!(\n        HTTPS_LOWERCASE.parse::<Protocol>().unwrap(),\n        Protocol::HTTPS\n    );\n    assert_eq!(\n        \"ftp\".parse::<Protocol>().unwrap(),\n        Protocol::Unknown(\"ftp\".to_string())\n    );\n    assert_eq!(\n        \"\".parse::<Protocol>().unwrap(),\n        Protocol::Unknown(\"\".to_string())\n    );\n    assert_eq!(\"HTTP\".parse::<Protocol>().unwrap(), Protocol::HTTP);\n    assert_eq!(\"HTTPS\".parse::<Protocol>().unwrap(), Protocol::HTTPS);\n}\n\n#[test]\nfn test_protocol_default() {\n    use super::*;\n    assert_eq!(Protocol::default(), Protocol::Unknown(String::new()));\n}\n\n#[test]\nfn test_protocol_new() {\n    use super::*;\n    assert_eq!(Protocol::new(), Protocol::default());\n    assert_eq!(Protocol::new(), Protocol::default());\n}\n\n#[test]\nfn test_protocol_is_http() {\n    use super::*;\n    assert!(Protocol::HTTP.is_http());\n    assert!(!Protocol::HTTPS.is_http());\n    assert!(!Protocol::Unknown(\"http\".to_string()).is_http());\n    assert!(!Protocol::Unknown(\"HTTP\".to_string()).is_http());\n    assert!(!Protocol::Unknown(\"ftp\".to_string()).is_http());\n}\n\n#[test]\nfn test_protocol_is_https() {\n    use super::*;\n    assert!(!Protocol::HTTP.is_https());\n    assert!(Protocol::HTTPS.is_https());\n    assert!(!Protocol::Unknown(\"https\".to_string()).is_https());\n    assert!(!Protocol::Unknown(\"HTTPS\".to_string()).is_https());\n    assert!(!Protocol::Unknown(\"ftp\".to_string()).is_https());\n}\n\n#[test]\nfn test_protocol_get_port() {\n    use super::*;\n    assert_eq!(Protocol::HTTP.get_port(), 80);\n    assert_eq!(Protocol::HTTPS.get_port(), 443);\n    assert_eq!(Protocol::Unknown(\"ftp\".to_string()).get_port(), 80);\n    assert_eq!(Protocol::Unknown(\"custom\".to_string()).get_port(), 80);\n}\n\n#[test]\nfn test_protocol_clone() {\n    use super::*;\n    let protocol: Protocol = Protocol::HTTP;\n    let cloned_protocol: Protocol = protocol.clone();\n    assert_eq!(protocol, cloned_protocol);\n    let unknown_protocol: Protocol = Protocol::Unknown(\"custom\".to_string());\n    let cloned_unknown: Protocol = unknown_protocol.clone();\n    assert_eq!(unknown_protocol, cloned_unknown);\n}\n\n#[test]\nfn test_protocol_debug() {\n    use super::*;\n    let protocol: Protocol = Protocol::HTTP;\n    let debug_str: String = format!(\"{:?}\", protocol);\n    assert_eq!(debug_str, \"HTTP\");\n    let unknown_protocol: Protocol = Protocol::Unknown(\"custom\".to_string());\n    let unknown_debug_str: String = format!(\"{:?}\", unknown_protocol);\n    assert_eq!(unknown_debug_str, \"Unknown(\\\"custom\\\")\");\n}\n\n#[test]\nfn test_protocol_equality() {\n    use super::*;\n    assert_eq!(Protocol::HTTP, Protocol::HTTP);\n    assert_ne!(Protocol::HTTP, Protocol::HTTPS);\n    assert_eq!(\n        Protocol::Unknown(\"custom\".to_string()),\n        Protocol::Unknown(\"custom\".to_string())\n    );\n    assert_ne!(\n        Protocol::Unknown(\"custom1\".to_string()),\n        Protocol::Unknown(\"custom2\".to_string())\n    );\n    assert_ne!(Protocol::HTTP, Protocol::Unknown(\"http\".to_string()));\n}\n\n#[test]\nfn test_protocol_case_sensitivity() {\n    use super::*;\n    use http_constant::*;\n    assert_eq!(HTTP_LOWERCASE.parse::<Protocol>().unwrap(), Protocol::HTTP);\n    assert_eq!(\"HTTP\".parse::<Protocol>().unwrap(), Protocol::HTTP);\n    assert_eq!(\n        HTTPS_LOWERCASE.parse::<Protocol>().unwrap(),\n        Protocol::HTTPS\n    );\n    assert_eq!(\"HTTPS\".parse::<Protocol>().unwrap(), Protocol::HTTPS);\n}\n\n#[test]\nfn test_protocol_all_variants() {\n    use super::*;\n    let protocols: Vec<Protocol> = vec![\n        Protocol::HTTP,\n        Protocol::HTTPS,\n        Protocol::Unknown(\"ftp\".to_string()),\n        Protocol::Unknown(\"custom\".to_string()),\n    ];\n    for protocol in protocols {\n        let display_str: String = protocol.to_string();\n        assert!(\n            !display_str.is_empty() || matches!(protocol, Protocol::Unknown(ref s) if s.is_empty())\n        );\n        let debug_str: String = format!(\"{:?}\", protocol);\n        assert!(!debug_str.is_empty());\n        let port: u16 = protocol.get_port();\n        assert!(port == 80 || port == 443);\n    }\n}\n\n#[test]\nfn test_protocol_unknown_with_empty_string() {\n    use super::*;\n    let protocol: Protocol = Protocol::Unknown(\"\".to_string());\n    assert_eq!(protocol.to_string(), \"\");\n    assert!(!protocol.is_http());\n    assert!(!protocol.is_https());\n    assert_eq!(protocol.get_port(), 80);\n    assert_eq!(format!(\"{:?}\", protocol), \"Unknown(\\\"\\\")\");\n}\n\n#[test]\nfn test_protocol_unknown_with_special_characters() {\n    use super::*;\n    let protocol: Protocol = Protocol::Unknown(\"custom-protocol\".to_string());\n    assert_eq!(protocol.to_string(), \"custom-protocol\");\n    assert!(!protocol.is_http());\n    assert!(!protocol.is_https());\n    assert_eq!(protocol.get_port(), 80);\n    assert_eq!(format!(\"{:?}\", protocol), \"Unknown(\\\"custom-protocol\\\")\");\n}\n\n#[test]\nfn test_protocol_pattern_matching() {\n    use super::*;\n    let protocol: Protocol = Protocol::HTTP;\n    match protocol {\n        Protocol::HTTP => assert!(true),\n        Protocol::HTTPS => panic!(\"Should not match HTTPS\"),\n        Protocol::Unknown(_) => panic!(\"Should not match Unknown\"),\n    }\n}\n\n#[test]\nfn test_protocol_unknown_pattern_matching() {\n    use super::*;\n    let protocol: Protocol = Protocol::Unknown(\"custom\".to_string());\n    match protocol {\n        Protocol::HTTP => panic!(\"Should not match HTTP\"),\n        Protocol::HTTPS => panic!(\"Should not match HTTPS\"),\n        Protocol::Unknown(ref custom_protocol) => {\n            assert_eq!(custom_protocol, \"custom\");\n        }\n    }\n}\n\n#[test]\nfn test_protocol_secure_check() {\n    use super::*;\n    assert!(!Protocol::HTTP.is_https());\n    assert!(Protocol::HTTPS.is_https());\n    assert!(!Protocol::Unknown(\"http\".to_string()).is_https());\n    assert!(!Protocol::Unknown(\"https\".to_string()).is_https());\n}\n\n#[test]\nfn test_protocol_port_mapping() {\n    use super::*;\n    let http_port: u16 = Protocol::HTTP.get_port();\n    let https_port: u16 = Protocol::HTTPS.get_port();\n    let unknown_port: u16 = Protocol::Unknown(\"custom\".to_string()).get_port();\n    assert_eq!(http_port, 80);\n    assert_eq!(https_port, 443);\n    assert_eq!(unknown_port, 80);\n    assert_ne!(http_port, https_port);\n}\n\n#[test]\nfn test_protocol_ordering() {\n    use super::*;\n    let mut protocols: Vec<Protocol> = vec![\n        Protocol::Unknown(\"z\".to_string()),\n        Protocol::HTTPS,\n        Protocol::HTTP,\n        Protocol::Unknown(\"a\".to_string()),\n    ];\n    protocols.sort_by(|a, b| {\n        let order_a: u8 = match a {\n            Protocol::HTTP => 0,\n            Protocol::HTTPS => 1,\n            Protocol::Unknown(_) => 2,\n        };\n        let order_b: u8 = match b {\n            Protocol::HTTP => 0,\n            Protocol::HTTPS => 1,\n            Protocol::Unknown(_) => 2,\n        };\n        order_a\n            .cmp(&order_b)\n            .then_with(|| a.to_string().cmp(&b.to_string()))\n    });\n    assert_eq!(protocols[0], Protocol::HTTP);\n    assert_eq!(protocols[1], Protocol::HTTPS);\n    assert!(matches!(protocols[2], Protocol::Unknown(_)));\n    assert!(matches!(protocols[3], Protocol::Unknown(_)));\n}\n\n#[test]\nfn test_protocol_memory_size() {\n    use super::*;\n    use std::mem;\n    let size: usize = mem::size_of::<Protocol>();\n    assert!(size > 0);\n    let http_size: usize = mem::size_of_val(&Protocol::HTTP);\n    let unknown_size: usize = mem::size_of_val(&Protocol::Unknown(\"test\".to_string()));\n    assert_eq!(http_size, unknown_size);\n}\n\n#[test]\nfn test_protocol_from_str_error_type() {\n    use super::*;\n    let result: Result<Protocol, &'static str> = \"invalid\".parse();\n    assert!(result.is_ok());\n    assert_eq!(result.unwrap(), Protocol::Unknown(\"invalid\".to_string()));\n}\n\n#[test]\nfn test_protocol_common_protocols() {\n    use super::*;\n    let common_protocols: Vec<&str> = vec![\"ftp\", \"ssh\", \"telnet\", \"smtp\", \"pop3\", \"imap\"];\n    for proto_str in common_protocols {\n        let protocol: Protocol = proto_str.parse().unwrap();\n        assert_eq!(protocol, Protocol::Unknown(proto_str.to_string()));\n        assert_eq!(protocol.to_string(), proto_str);\n        assert_eq!(protocol.get_port(), 80);\n    }\n}", "file_size": 8534, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_str\\type.rs", "language": "rust", "content": "/// A type alias for `Option<&'a str>`.\npub type OptionStr<'a> = Option<&'a str>;", "file_size": 81, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\protocol\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default value for `Protocol`.\n///\n/// The default `Protocol` is `Protocol::Unknown` with an empty string.\nimpl Default for Protocol {\n    fn default() -> Self {\n        Self::Unknown(String::new())\n    }\n}\n\n/// Provides utility methods for the `Protocol` type.\nimpl Protocol {\n    /// Creates a new instance of `Protocol` with the default value of `Self::HTTP`.\n    ///\n    /// # Returns\n    ///\n    /// A new `Protocol` instance, defaulting to `Protocol::HTTP`.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Checks if the current protocol is `HTTP`.\n    ///\n    /// # Arguments\n    ///\n    /// - `self` - A reference to the `Protocol` instance.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the protocol is `HTTP`, otherwise returns `false`.\n    pub fn is_http(&self) -> bool {\n        self.to_owned() == Self::HTTP.to_owned()\n    }\n\n    /// Checks if the current protocol is `HTTPS`.\n    ///\n    /// # Arguments\n    ///\n    /// - `self` - A reference to the `Protocol` instance.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the protocol is `HTTPS`, otherwise returns `false`.\n    pub fn is_https(&self) -> bool {\n        self.to_owned() == Self::HTTPS.to_owned()\n    }\n\n    /// Returns the default port associated with the protocol.\n    ///\n    /// # Arguments\n    ///\n    /// - `self` - A reference to the `Protocol` instance.\n    ///\n    /// # Returns\n    ///\n    /// The default port number for the protocol. Returns `80` for `HTTP` and unknown protocols,\n    /// and `443` for `HTTPS`.\n    pub fn get_port(&self) -> u16 {\n        match self {\n            Self::HTTP => 80,\n            Self::HTTPS => 443,\n            Self::Unknown(_) => 80,\n        }\n    }\n}\n\nimpl Display for Protocol {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let res: &str = match self {\n            Self::HTTP => HTTP_LOWERCASE,\n            Self::HTTPS => HTTPS_LOWERCASE,\n            Self::Unknown(protocol) => protocol,\n        };\n        write!(f, \"{}\", res)\n    }\n}\n\nimpl FromStr for Protocol {\n    type Err = &'static str;\n\n    fn from_str(data: &str) -> Result<Self, Self::Err> {\n        match data.to_ascii_lowercase().as_str() {\n            HTTP_LOWERCASE => Ok(Self::HTTP),\n            HTTPS_LOWERCASE => Ok(Self::HTTPS),\n            _ => Ok(Self::Unknown(data.to_string())),\n        }\n    }\n}", "file_size": 2372, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_u64\\type.rs", "language": "rust", "content": "/// A type alias for `Option<u64>`.\npub type OptionU64 = Option<u64>;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_vec_u8\\type.rs", "language": "rust", "content": "/// A type alias for `Option<Vec<u8>>`.\npub type OptionVecU8 = Option<Vec<u8>>;", "file_size": 79, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\request\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// An alias for `Method`, representing the HTTP request method.\npub type RequestMethod = Method;\n/// An alias for `String`, representing the host part of an HTTP request.\npub type RequestHost = String;\n/// An alias for `HttpVersion`, representing the HTTP version.\npub type RequestVersion = HttpVersion;\n/// An alias for `String`, representing the path portion of the request URL.\npub type RequestPath = String;\n/// An alias for `String`, representing the key type for request query parameters.\npub type RequestQuerysKey = String;\n/// An alias for `String`, representing the value type for request query parameters.\npub type RequestQuerysValue = String;\n/// An alias for `Option<RequestQuerysValue>`, representing an optional query parameter value.\npub type OptionRequestQuerysValue = Option<RequestQuerysValue>;\n/// An alias for `HashMapXxHash3_64<RequestQuerysKey, RequestQuerysValue>`, representing all query parameters parsed from the request URL.\npub type RequestQuerys = HashMapXxHash3_64<RequestQuerysKey, RequestQuerysValue>;\n/// An alias for `Vec<u8>`, representing the raw binary body of the request.\npub type RequestBody = Vec<u8>;\n/// An alias for `String`, representing the request body as a UTF-8 encoded string.\npub type RequestBodyString = String;\n/// An alias for `String`, representing the key type for request headers.\npub type RequestHeadersKey = String;\n/// An alias for `String`, representing a single value for an HTTP request header.\npub type RequestHeadersValueItem = String;\n/// An alias for `Option<RequestHeadersValueItem>`, representing an optional header value item.\npub type OptionRequestHeadersValueItem = Option<RequestHeadersValueItem>;\n/// An alias for `VecDeque<RequestHeadersValueItem>`, representing a collection of values for a single HTTP request header.\npub type RequestHeadersValue = VecDeque<RequestHeadersValueItem>;\n/// An alias for `Option<RequestHeadersValue>`, representing an optional collection of header values.\npub type OptionRequestHeadersValue = Option<RequestHeadersValue>;\n/// An alias for `HashMapXxHash3_64<RequestHeadersKey, RequestHeadersValue>`, representing all headers sent with the HTTP request.\npub type RequestHeaders = HashMapXxHash3_64<RequestHeadersKey, RequestHeadersValue>;\n/// An alias for `Result<Request, RequestError>`, representing the result type returned from a request reader handler.\npub type RequestReaderHandleResult = Result<Request, RequestError>;\n/// An alias for `RwLockReadGuard<'a, Request>`, representing a read guard for a `Request` wrapped in a `RwLock`.\npub type RwLockReadGuardRequest<'a> = RwLockReadGuard<'a, Request>;\n/// An alias for `RwLockWriteGuard<'a, Request>`, representing a write guard for a `Request` wrapped in a `RwLock`.\npub type RwLockWriteGuardRequest<'a> = RwLockWriteGuard<'a, Request>;", "file_size": 2815, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\protocol\\enum.rs", "language": "rust", "content": "/// Represents HTTP-related protocols.\n///\n/// This enum defines the different protocols that can be used in HTTP communication.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum Protocol {\n    /// Represents the HTTP protocol.\n    ///\n    /// This is the standard protocol for unencrypted communication over the web.\n    HTTP,\n    /// Represents the HTTPS protocol.\n    ///\n    /// This is the secure version of HTTP, using encryption for communication.\n    HTTPS,\n    /// Represents an unknown or custom protocol.\n    ///\n    /// This variant is used for protocols that are not explicitly defined as HTTP or HTTPS,\n    /// or when the protocol string is not recognized.\n    Unknown(String),\n}", "file_size": 692, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_u128\\type.rs", "language": "rust", "content": "/// A type alias for `Option<u128>`.\npub type OptionU128 = Option<u128>;", "file_size": 72, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\rc_rwlock\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a reference-counted, read-write locked value.\n///\n/// This alias simplifies the use of `Rc<RwLock<T>>`, providing a convenient way to manage shared mutable data across multiple owners.\npub type RcRwLock<T> = Rc<RwLock<T>>;", "file_size": 258, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\stream\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe TCP stream wrapper.\n///\n/// Provides shared access to a TcpStream using Arc and RwLock.\n///\n/// # Fields\n///\n/// - `Arc<RwLock<TcpStream>>` - The protected TCP stream.\n#[derive(Clone, Debug, Getter)]\npub struct ArcRwLockStream(#[get(pub(super))] pub(super) ArcRwLock<TcpStream>);", "file_size": 310, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\option_usize\\type.rs", "language": "rust", "content": "/// A type alias for `Option<usize>`.\npub type OptionUsize = Option<usize>;", "file_size": 75, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\request\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// HTTP request representation.\n///\n/// Contains all components of an HTTP request.\n#[derive(Debug, Clone, PartialEq, Eq, Getter, DisplayDebug)]\npub struct Request {\n    /// HTTP request method.\n    pub(super) method: RequestMethod,\n    /// Request host.\n    pub(super) host: RequestHost,\n    /// HTTP protocol version.\n    pub(super) version: RequestVersion,\n    /// Request path.\n    pub(super) path: RequestPath,\n    /// URL query parameters.\n    pub(super) querys: RequestQuerys,\n    /// HTTP headers collection.\n    pub(super) headers: RequestHeaders,\n    /// Request body content.\n    pub(super) body: RequestBody,\n}", "file_size": 638, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\websocket_frame\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `WebSocketFrame`.\n///\n/// Provides a default `WebSocketFrame` with `fin: false`, `opcode: WebSocketOpcode::Text`,\n/// `mask: false`, and an empty `payload_data`.\nimpl Default for WebSocketFrame {\n    /// Returns the default `WebSocketFrame`.\n    ///\n    /// # Returns\n    ///\n    /// A default `WebSocketFrame` instance.\n    fn default() -> Self {\n        Self {\n            fin: false,\n            opcode: WebSocketOpcode::Text,\n            mask: false,\n            payload_data: Vec::new(),\n        }\n    }\n}\n\nimpl WebSocketOpcode {\n    /// Creates a `WebSocketOpcode` from a raw u8 value.\n    ///\n    /// # Arguments\n    ///\n    /// - `opcode`: The raw opcode value.\n    ///\n    /// # Returns\n    ///\n    /// A `WebSocketOpcode` enum variant corresponding to the raw value.\n    pub fn from_u8(opcode: u8) -> Self {\n        match opcode {\n            0x0 => Self::Continuation,\n            0x1 => Self::Text,\n            0x2 => Self::Binary,\n            0x8 => Self::Close,\n            0x9 => Self::Ping,\n            0xA => Self::Pong,\n            _ => Self::Reserved(opcode),\n        }\n    }\n\n    /// Converts the `WebSocketOpcode` to its raw u8 value.\n    ///\n    /// # Returns\n    ///\n    /// The raw u8 value of the opcode.\n    pub fn to_u8(&self) -> u8 {\n        match self {\n            Self::Continuation => 0x0,\n            Self::Text => 0x1,\n            Self::Binary => 0x2,\n            Self::Close => 0x8,\n            Self::Ping => 0x9,\n            Self::Pong => 0xA,\n            Self::Reserved(code) => *code,\n        }\n    }\n\n    /// Checks if the opcode is a control frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode represents a control frame (Close, Ping, Pong), otherwise `false`.\n    pub fn is_control(&self) -> bool {\n        matches!(self, Self::Close | Self::Ping | Self::Pong)\n    }\n\n    /// Checks if the opcode is a data frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode represents a data frame (Text, Binary, Continuation), otherwise `false`.\n    pub fn is_data(&self) -> bool {\n        matches!(self, Self::Text | Self::Binary | Self::Continuation)\n    }\n\n    /// Checks if the opcode is a continuation frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Continuation`, otherwise `false`.\n    pub fn is_continuation(&self) -> bool {\n        matches!(self, Self::Continuation)\n    }\n\n    /// Checks if the opcode is a text frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Text`, otherwise `false`.\n    pub fn is_text(&self) -> bool {\n        matches!(self, Self::Text)\n    }\n\n    /// Checks if the opcode is a binary frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Binary`, otherwise `false`.\n    pub fn is_binary(&self) -> bool {\n        matches!(self, Self::Binary)\n    }\n\n    /// Checks if the opcode is a close frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Close`, otherwise `false`.\n    pub fn is_close(&self) -> bool {\n        matches!(self, Self::Close)\n    }\n\n    /// Checks if the opcode is a ping frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Ping`, otherwise `false`.\n    pub fn is_ping(&self) -> bool {\n        matches!(self, Self::Ping)\n    }\n\n    /// Checks if the opcode is a pong frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Pong`, otherwise `false`.\n    pub fn is_pong(&self) -> bool {\n        matches!(self, Self::Pong)\n    }\n\n    /// Checks if the opcode is a reserved frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Reserved(_)`, otherwise `false`.\n    pub fn is_reserved(&self) -> bool {\n        matches!(self, Self::Reserved(_))\n    }\n}\n\nimpl WebSocketFrame {\n    /// Decodes a WebSocket frame from the provided data slice.\n    ///\n    /// This function parses the raw bytes from a WebSocket stream according to the WebSocket protocol\n    /// specification to reconstruct a `WebSocketFrame`. It handles FIN bit, opcode, mask bit,\n    /// payload length (including extended lengths), mask key, and the payload data itself.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw data slice from the WebSocket stream.\n    ///\n    /// # Returns\n    ///\n    /// - `Some((WebSocketFrame, usize))`: If the frame is successfully decoded, returns the decoded frame\n    ///   and the number of bytes consumed from the input slice.\n    /// - `None`: If the frame is incomplete or malformed.\n    pub fn decode_ws_frame(data: &[u8]) -> WebsocketFrameWithLengthOption {\n        if data.len() < 2 {\n            return None;\n        }\n        let mut index: usize = 0;\n        let fin: bool = (data[index] & 0b1000_0000) != 0;\n        let opcode: WebSocketOpcode = WebSocketOpcode::from_u8(data[index] & 0b0000_1111);\n        index += 1;\n        let mask: bool = (data[index] & 0b1000_0000) != 0;\n        let mut payload_len: usize = (data[index] & 0b0111_1111) as usize;\n        index += 1;\n        if payload_len == 126 {\n            if data.len() < index + 2 {\n                return None;\n            }\n            payload_len = u16::from_be_bytes(data[index..index + 2].try_into().ok()?) as usize;\n            index += 2;\n        } else if payload_len == 127 {\n            if data.len() < index + 8 {\n                return None;\n            }\n            payload_len = u64::from_be_bytes(data[index..index + 8].try_into().ok()?) as usize;\n            index += 8;\n        }\n        let mask_key: Option<[u8; 4]> = if mask {\n            if data.len() < index + 4 {\n                return None;\n            }\n            let key: [u8; 4] = data[index..index + 4].try_into().ok()?;\n            index += 4;\n            Some(key)\n        } else {\n            None\n        };\n        if data.len() < index + payload_len {\n            return None;\n        }\n        let mut payload: Vec<u8> = data[index..index + payload_len].to_vec();\n        if let Some(mask_key) = mask_key {\n            for (i, byte) in payload.iter_mut().enumerate() {\n                *byte ^= mask_key[i % 4];\n            }\n        }\n        index += payload_len;\n        let frame: WebSocketFrame = WebSocketFrame {\n            fin,\n            opcode,\n            mask,\n            payload_data: payload,\n        };\n        Some((frame, index))\n    }\n\n    /// Creates a list of response frames from the provided body.\n    ///\n    /// This method segments the response body into WebSocket frames, respecting the maximum frame size\n    /// and handling UTF-8 character boundaries for text frames. It determines the appropriate opcode\n    /// (Text or Binary) based on the body's content.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ResponseBody` - A reference to a response body (payload) as a byte slice.\n    ///\n    /// # Returns\n    ///\n    /// - A vector of `ResponseBody` (byte vectors), where each element represents a framed WebSocket message.\n    pub fn create_response_frame_list(body: &ResponseBody) -> Vec<ResponseBody> {\n        let total_len: usize = body.len();\n        let mut offset: usize = 0;\n        let mut frames_list: Vec<ResponseBody> =\n            Vec::with_capacity((total_len / MAX_FRAME_SIZE) + 1);\n        let mut is_first_frame: bool = true;\n        let is_valid_utf8: bool = std::str::from_utf8(body).is_ok();\n        let base_opcode: WebSocketOpcode = if is_valid_utf8 {\n            WebSocketOpcode::Text\n        } else {\n            WebSocketOpcode::Binary\n        };\n        while offset < total_len {\n            let remaining: usize = total_len - offset;\n            let mut frame_size: usize = remaining.min(MAX_FRAME_SIZE);\n            if is_valid_utf8 && frame_size < remaining {\n                while frame_size > 0 && (body[offset + frame_size] & 0xC0) == 0x80 {\n                    frame_size -= 1;\n                }\n                if frame_size == 0 {\n                    frame_size = remaining.min(MAX_FRAME_SIZE);\n                }\n            }\n            let mut frame: ResponseBody = Vec::with_capacity(frame_size + 10);\n            let opcode: WebSocketOpcode = if is_first_frame {\n                base_opcode\n            } else {\n                WebSocketOpcode::Continuation\n            };\n            let fin: u8 = if remaining > frame_size { 0x00 } else { 0x80 };\n            let opcode_byte: u8 = opcode.to_u8() & 0x0F;\n            frame.push(fin | opcode_byte);\n            if frame_size < 126 {\n                frame.push(frame_size as u8);\n            } else if frame_size <= MAX_FRAME_SIZE {\n                frame.push(126);\n                frame.extend_from_slice(&(frame_size as u16).to_be_bytes());\n            } else {\n                frame.push(127);\n                frame.extend_from_slice(&(frame_size as u16).to_be_bytes());\n            }\n            let end: usize = offset + frame_size;\n            frame.extend_from_slice(&body[offset..end]);\n            frames_list.push(frame);\n            offset = end;\n            is_first_frame = false;\n        }\n        frames_list\n    }\n\n    /// Calculates the SHA-1 hash of the input data.\n    ///\n    /// This function implements the SHA-1 cryptographic hash algorithm according to RFC 3174.\n    /// It processes the input data in 512-bit (64-byte) blocks and produces a 160-bit (20-byte) hash.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - A byte slice containing the input data to be hashed.\n    ///\n    /// # Returns\n    ///\n    /// - A 20-byte array representing the SHA-1 hash of the input data.\n    pub fn sha1(data: &[u8]) -> [u8; 20] {\n        let mut hash_state: [u32; 5] = HASH_STATE;\n        let mut padded_data: Vec<u8> = Vec::from(data);\n        let original_length_bits: u64 = (padded_data.len() * 8) as u64;\n        padded_data.push(0x80);\n        while (padded_data.len() + 8) % 64 != 0 {\n            padded_data.push(0);\n        }\n        padded_data.extend_from_slice(&original_length_bits.to_be_bytes());\n        for block in padded_data.chunks_exact(64) {\n            let mut message_schedule: [u32; 80] = [0u32; 80];\n            for (i, block_chunk) in block.chunks_exact(4).enumerate().take(16) {\n                message_schedule[i] = u32::from_be_bytes([\n                    block_chunk[0],\n                    block_chunk[1],\n                    block_chunk[2],\n                    block_chunk[3],\n                ]);\n            }\n            for i in 16..80 {\n                message_schedule[i] = (message_schedule[i - 3]\n                    ^ message_schedule[i - 8]\n                    ^ message_schedule[i - 14]\n                    ^ message_schedule[i - 16])\n                    .rotate_left(1);\n            }\n            let [mut a, mut b, mut c, mut d, mut e] = hash_state;\n            for (i, &word) in message_schedule.iter().enumerate() {\n                let (f, k) = match i {\n                    0..=19 => ((b & c) | (!b & d), 0x5A827999),\n                    20..=39 => (b ^ c ^ d, 0x6ED9EBA1),\n                    40..=59 => ((b & c) | (b & d) | (c & d), 0x8F1BBCDC),\n                    _ => (b ^ c ^ d, 0xCA62C1D6),\n                };\n                let temp: u32 = a\n                    .rotate_left(5)\n                    .wrapping_add(f)\n                    .wrapping_add(e)\n                    .wrapping_add(k)\n                    .wrapping_add(word);\n                e = d;\n                d = c;\n                c = b.rotate_left(30);\n                b = a;\n                a = temp;\n            }\n            hash_state[0] = hash_state[0].wrapping_add(a);\n            hash_state[1] = hash_state[1].wrapping_add(b);\n            hash_state[2] = hash_state[2].wrapping_add(c);\n            hash_state[3] = hash_state[3].wrapping_add(d);\n            hash_state[4] = hash_state[4].wrapping_add(e);\n        }\n        let mut result: [u8; 20] = [0u8; 20];\n        for (i, &val) in hash_state.iter().enumerate() {\n            result[i * 4..(i + 1) * 4].copy_from_slice(&val.to_be_bytes());\n        }\n        result\n    }\n\n    /// Generates a WebSocket accept key from the client-provided key.\n    ///\n    /// This function is used during the WebSocket handshake to validate the client's request.\n    /// It concatenates the client's key with a specific GUID, calculates the SHA-1 hash of the result,\n    /// and then encodes the hash in base64.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - A string slice containing the client-provided key (typically from the `Sec-WebSocket-Key` header).\n    ///\n    /// # Returns\n    ///\n    /// - A string representing the generated WebSocket accept key (typically for the `Sec-WebSocket-Accept` header).\n    pub fn generate_accept_key(key: &str) -> String {\n        let mut data: [u8; 60] = [0u8; 60];\n        data[..24].copy_from_slice(&key.as_bytes()[..24.min(key.len())]);\n        data[24..].copy_from_slice(GUID);\n        let hash: [u8; 20] = Self::sha1(&data);\n        Self::base64_encode(&hash)\n    }\n\n    /// Encodes the input data as a base64 string.\n    ///\n    /// This function implements the Base64 encoding scheme, converting binary data into an ASCII string format.\n    /// It processes the input data in chunks of 3 bytes and encodes them into 4 base64 characters.\n    /// Padding with '=' characters is applied if necessary.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - A byte slice containing the data to encode in base64.\n    ///\n    /// # Returns\n    ///\n    /// - A string with the base64 encoded representation of the input data.\n    pub fn base64_encode(data: &[u8]) -> String {\n        let mut encoded_data: Vec<u8> = Vec::with_capacity((data.len() + 2) / 3 * 4);\n        for chunk in data.chunks(3) {\n            let mut buffer: [u8; 3] = [0u8; 3];\n            buffer[..chunk.len()].copy_from_slice(chunk);\n            let indices: [u8; 4] = [\n                buffer[0] >> 2,\n                ((buffer[0] & 0b11) << 4) | (buffer[1] >> 4),\n                ((buffer[1] & 0b1111) << 2) | (buffer[2] >> 6),\n                buffer[2] & 0b111111,\n            ];\n            for &idx in &indices[..chunk.len() + 1] {\n                encoded_data.push(BASE64_CHARSET_TABLE[idx as usize]);\n            }\n            while encoded_data.len() % 4 != 0 {\n                encoded_data.push(EQUAL_BYTES[0]);\n            }\n        }\n        String::from_utf8(encoded_data).unwrap()\n    }\n\n    /// Checks if the opcode is a continuation frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Continuation`, otherwise `false`.\n    pub fn is_continuation_opcode(&self) -> bool {\n        self.opcode.is_continuation()\n    }\n\n    /// Checks if the opcode is a text frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Text`, otherwise `false`.\n    pub fn is_text_opcode(&self) -> bool {\n        self.opcode.is_text()\n    }\n\n    /// Checks if the opcode is a binary frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Binary`, otherwise `false`.\n    pub fn is_binary_opcode(&self) -> bool {\n        self.opcode.is_binary()\n    }\n\n    /// Checks if the opcode is a close frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Close`, otherwise `false`.\n    pub fn is_close_opcode(&self) -> bool {\n        self.opcode.is_close()\n    }\n\n    /// Checks if the opcode is a ping frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Ping`, otherwise `false`.\n    pub fn is_ping_opcode(&self) -> bool {\n        self.opcode.is_ping()\n    }\n\n    /// Checks if the opcode is a pong frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Pong`, otherwise `false`.\n    pub fn is_pong_opcode(&self) -> bool {\n        self.opcode.is_pong()\n    }\n\n    /// Checks if the opcode is a reserved frame.\n    ///\n    /// # Returns\n    ///\n    /// `true` if the opcode is `Reserved(_)`, otherwise `false`.\n    pub fn is_reserved_opcode(&self) -> bool {\n        self.opcode.is_reserved()\n    }\n}", "file_size": 15909, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\response\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a parsed HTTP response.\n#[derive(Debug, Clone, PartialEq, Eq, Data, DisplayDebug)]\npub struct Response {\n    /// The HTTP version used in the response.\n    pub(super) version: ResponseVersion,\n    /// The HTTP status code.\n    pub(super) status_code: ResponseStatusCode,\n    /// The reason phrase associated with the status code.\n    #[set(skip)]\n    pub(super) reason_phrase: ResponseReasonPhrase,\n    /// The response headers as key-value pairs.\n    #[set(skip)]\n    pub(super) headers: ResponseHeaders,\n    /// The binary body content of the response.\n    #[set(skip)]\n    pub(super) body: ResponseBody,\n}", "file_size": 638, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\rc_rwlock\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Creates a new `RcRwLock` instance.\n///\n/// This function wraps a given data of type T in an `Rc` and `RwLock` to provide shared mutable access.\n///\n/// # Arguments\n///\n/// - `data` - The data of type T to be wrapped.\n///\n/// # Returns\n///\n/// A new `RcRwLock<T>` instance.\npub fn rc_rwlock<T>(data: T) -> RcRwLock<T> {\n    Rc::new(RwLock::new(data))\n}", "file_size": 370, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\response\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default value for `Response`.\n///\n/// Returns a new `Response` instance with all fields initialized to their default values.\nimpl Default for Response {\n    fn default() -> Self {\n        Self {\n            version: HttpVersion::default(),\n            status_code: ResponseStatusCode::default(),\n            reason_phrase: ResponseReasonPhrase::default(),\n            headers: hash_map_xx_hash3_64(),\n            body: Vec::new(),\n        }\n    }\n}\n\nimpl Response {\n    /// Creates a new instance of `Response`.\n    ///\n    /// # Returns\n    ///\n    /// - `Response` - A new response instance with default values.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Retrieves the value of a response header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValue` - The optional header values.\n    pub fn get_header<K>(&self, key: K) -> OptionResponseHeadersValue\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .and_then(|data| Some(data.clone()))\n    }\n\n    /// Retrieves the first value of a response header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValueItem` - The first header value if exists.\n    pub fn get_header_front<K>(&self, key: K) -> OptionResponseHeadersValueItem\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .and_then(|values| values.front().cloned())\n    }\n\n    /// Retrieves the last value of a response header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionResponseHeadersValueItem` - The last header value if exists.\n    pub fn get_header_back<K>(&self, key: K) -> OptionResponseHeadersValueItem\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .and_then(|values| values.back().cloned())\n    }\n\n    /// Checks if a header exists in the response.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to check (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the header exists.\n    pub fn has_header<K>(&self, key: K) -> bool\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        self.headers.contains_key(&key)\n    }\n\n    /// Checks if a header contains a specific value.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to check (must implement Into<ResponseHeadersKey>).\n    /// - `V` - The value to search for (must implement Into<ResponseHeadersValueItem>).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the header contains the value.\n    pub fn has_header_value<K, V>(&self, key: K, value: V) -> bool\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<ResponseHeadersValueItem>,\n    {\n        let key: ResponseHeadersKey = key.into();\n        let value: ResponseHeadersValueItem = value.into();\n        if let Some(values) = self.headers.get(&key) {\n            values.contains(&value)\n        } else {\n            false\n        }\n    }\n\n    /// Gets the number of headers in the response.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The count of unique header keys.\n    pub fn get_headers_length(&self) -> usize {\n        self.headers.len()\n    }\n\n    /// Gets the number of values for a specific header key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to count (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The count of values for the header.\n    pub fn get_header_length<K>(&self, key: K) -> usize\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        self.headers.get(&key).map_or(0, |values| values.len())\n    }\n\n    /// Gets the total number of header values in the response.\n    ///\n    /// This counts all values across all headers, so a header with multiple values\n    /// will contribute more than one to the total count.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total count of all header values.\n    pub fn get_headers_values_length(&self) -> usize {\n        self.headers.values().map(|values| values.len()).sum()\n    }\n\n    /// Retrieves the body content of the response as a UTF-8 encoded string.\n    ///\n    /// This method uses `String::from_utf8_lossy` to convert the byte slice returned by `self.get_body()` into a string.\n    /// If the byte slice contains invalid UTF-8 sequences, they will be replaced with the Unicode replacement character ().\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The body content as a string.\n    pub fn get_body_string(&self) -> String {\n        String::from_utf8_lossy(self.get_body()).into_owned()\n    }\n\n    /// Deserializes the body content of the response into a specified type `T`.\n    ///\n    /// This method first retrieves the body content as a byte slice using `self.get_body()`.\n    /// It then attempts to deserialize the byte slice into the specified type `T` using `json_from_slice`.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `T` - The target type to deserialize into (must implement DeserializeOwned).\n    ///\n    /// # Returns\n    ///\n    /// - `ResultJsonError<T>` - The deserialization result.\n    pub fn get_body_json<T>(&self) -> ResultJsonError<T>\n    where\n        T: DeserializeOwned,\n    {\n        json_from_slice(self.get_body())\n    }\n\n    /// Determines whether the header should be skipped during setting.\n    ///\n    /// - Returns `true` if the header is empty or not allowed.\n    /// - Returns `false` if the header can be set.\n    fn should_skip_header(&self, key: &ResponseHeadersKey) -> bool {\n        key.trim().is_empty() || *key == CONTENT_LENGTH\n    }\n\n    /// Sets a header in the response, replacing any existing values.\n    ///\n    /// This function replaces all existing values for a header with a single new value.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key (must implement Into<ResponseHeadersKey>).\n    /// - `V` - The header value (must implement Into<String>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn set_header<K, V>(&mut self, key: K, value: V) -> &mut Self\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<String>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        if self.should_skip_header(&key) {\n            return self;\n        }\n        let value: String = value.into();\n        let mut deque: VecDeque<String> = VecDeque::new();\n        deque.push_back(value);\n        self.headers.insert(key, deque);\n        self\n    }\n\n    /// Adds a header to the response.\n    ///\n    /// This function appends a value to the response headers.\n    /// If the header already exists, the new value will be added to the existing values.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key (must implement Into<ResponseHeadersKey>).\n    /// - `V` - The header value (must implement Into<String>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn add_header<K, V>(&mut self, key: K, value: V) -> &mut Self\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<String>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        if self.should_skip_header(&key) {\n            return self;\n        }\n        let value: String = value.into();\n        self.headers\n            .entry(key)\n            .or_insert_with(VecDeque::new)\n            .push_back(value);\n        self\n    }\n\n    /// Removes a header from the response.\n    ///\n    /// This function removes all values for the specified header key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to remove (must implement Into<ResponseHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn remove_header<K>(&mut self, key: K) -> &mut Self\n    where\n        K: Into<ResponseHeadersKey>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        let _ = self.headers.remove(&key).is_some();\n        self\n    }\n\n    /// Removes a specific value from a header in the response.\n    ///\n    /// This function removes only the specified value from the header.\n    /// If the header has multiple values, only the matching value is removed.\n    /// If this was the last value for the header, the entire header is removed.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key (must implement Into<ResponseHeadersKey>).\n    /// - `V` - The value to remove (must implement Into<String>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn remove_header_value<K, V>(&mut self, key: K, value: V) -> &mut Self\n    where\n        K: Into<ResponseHeadersKey>,\n        V: Into<String>,\n    {\n        let key: ResponseHeadersKey = key.into().to_lowercase();\n        let value: String = value.into();\n        if let Some(values) = self.headers.get_mut(&key) {\n            values.retain(|v| v != &value);\n            if values.is_empty() {\n                self.headers.remove(&key);\n            }\n        }\n        self\n    }\n\n    /// Clears all headers from the response.\n    ///\n    /// This function removes all headers, leaving the headers map empty.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn clear_headers(&mut self) -> &mut Self {\n        self.headers.clear();\n        self\n    }\n\n    /// Sets the body of the response.\n    ///\n    /// This method allows you to set the body of the response by converting the provided\n    /// value into a `ResponseBody` type. The `body` is updated with the converted value.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The body content (must implement Into<ResponseBody>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn set_body<T>(&mut self, body: T) -> &mut Self\n    where\n        T: Into<ResponseBody>,\n    {\n        self.body = body.into();\n        self\n    }\n\n    /// Sets the reason phrase of the response.\n    ///\n    /// This method allows you to set the reason phrase of the response by converting the\n    /// provided value into a `ResponseReasonPhrase` type. The `reason_phrase` is updated\n    /// with the converted value.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The reason phrase (must implement Into<ResponseReasonPhrase>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - A mutable reference to self for chaining.\n    pub fn set_reason_phrase<T>(&mut self, reason_phrase: T) -> &mut Self\n    where\n        T: Into<ResponseReasonPhrase>,\n    {\n        self.reason_phrase = reason_phrase.into();\n        self\n    }\n\n    /// Pushes a header with a key and value into the response string.\n    ///\n    /// # Arguments\n    ///\n    /// - `response_string`: A mutable reference to the string where the header will be added.\n    /// - `key`: The header key as a string slice (`&str`).\n    /// - `value`: The header value as a string slice (`&str`).\n    fn push_header(response_string: &mut String, key: &str, value: &str) {\n        response_string.push_str(key);\n        response_string.push_str(COLON_SPACE);\n        response_string.push_str(value);\n        response_string.push_str(HTTP_BR);\n    }\n\n    /// Pushes the first line of an HTTP response (version, status code, and reason phrase) into the response string.\n    /// This corresponds to the status line of the HTTP response.\n    ///\n    /// # Arguments\n    ///\n    /// - `response_string`: A mutable reference to the string where the first line will be added.\n    fn push_http_first_line(&self, response_string: &mut String) {\n        response_string.push_str(&self.get_version().to_string());\n        response_string.push_str(SPACE);\n        response_string.push_str(&self.get_status_code().to_string());\n        response_string.push_str(SPACE);\n        response_string.push_str(self.get_reason_phrase());\n        response_string.push_str(HTTP_BR);\n    }\n\n    /// Builds the full HTTP response as a byte vector.\n    ///\n    /// This method constructs the complete HTTP response, including the status line,\n    /// headers, and body. It handles content encoding, content type, connection\n    /// management, and content length.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseData` - The complete HTTP response bytes.\n    pub fn build(&mut self) -> ResponseData {\n        if self.reason_phrase.is_empty() {\n            self.set_reason_phrase(HttpStatus::phrase(*self.get_status_code()));\n        }\n        let mut response_string: String = String::new();\n        self.push_http_first_line(&mut response_string);\n        let mut compress_type_opt: OptionCompress = None;\n        let mut connection_opt: OptionString = None;\n        let mut content_type_opt: OptionString = None;\n        let headers: ResponseHeaders = self\n            .get_mut_headers()\n            .drain()\n            .map(|(key, value)| (key.to_lowercase(), value))\n            .collect();\n        let mut unset_content_length: bool = false;\n        for (key, values) in headers.iter() {\n            for value in values.iter() {\n                if key == CONTENT_ENCODING {\n                    compress_type_opt = Some(value.parse::<Compress>().unwrap_or_default());\n                } else if key == CONNECTION {\n                    connection_opt = Some(value.to_owned());\n                } else if key == CONTENT_TYPE {\n                    content_type_opt = Some(value.to_owned());\n                    if value.eq_ignore_ascii_case(TEXT_EVENT_STREAM) {\n                        unset_content_length = true;\n                    }\n                }\n                Self::push_header(&mut response_string, key, value);\n            }\n        }\n        if connection_opt.is_none() {\n            Self::push_header(&mut response_string, CONNECTION, KEEP_ALIVE);\n        }\n        if content_type_opt.is_none() {\n            let mut content_type: String = String::with_capacity(\n                TEXT_HTML.len() + SEMICOLON_SPACE.len() + CHARSET_UTF_8.len(),\n            );\n            content_type.push_str(TEXT_HTML);\n            content_type.push_str(SEMICOLON_SPACE);\n            content_type.push_str(CHARSET_UTF_8);\n            Self::push_header(&mut response_string, CONTENT_TYPE, &content_type);\n        }\n        let mut body: Cow<Vec<u8>> = Cow::Borrowed(self.get_body());\n        if !unset_content_length {\n            if let Some(compress_type) = compress_type_opt {\n                if !compress_type.is_unknown() {\n                    let tmp_body: Cow<'_, Vec<u8>> =\n                        compress_type.encode(&body, DEFAULT_BUFFER_SIZE);\n                    body = Cow::Owned(tmp_body.into_owned());\n                }\n            }\n            let len_string: String = body.len().to_string();\n            Self::push_header(&mut response_string, CONTENT_LENGTH, &len_string);\n        }\n        response_string.push_str(HTTP_BR);\n        let mut response_bytes: Vec<u8> = response_string.into_bytes();\n        response_bytes.extend_from_slice(&body);\n        response_bytes\n    }\n\n    /// Converts the response to a formatted string representation.\n    ///\n    /// This method provides a human-readable summary of the response, including its version,\n    /// status code, reason phrase, headers, and body information.\n    ///\n    /// # Returns\n    ///\n    /// A `String` containing formatted response details.\n    pub fn get_string(&self) -> String {\n        let body: &Vec<u8> = self.get_body();\n        let body_type: &'static str = if std::str::from_utf8(body).is_ok() {\n            PLAIN\n        } else {\n            BINARY\n        };\n        format!(\n            \"[Response] => [version]: {}; [status code]: {}; [reason]: {}; [headers]: {:?}; [body]: {} bytes {};\",\n            self.get_version(),\n            self.get_status_code(),\n            self.get_reason_phrase(),\n            self.get_headers(),\n            body.len(),\n            body_type\n        )\n    }\n}", "file_size": 16638, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\request\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides a default value for `Request`.\n///\n/// Returns a new `Request` instance with all fields initialized to their default values.\nimpl Default for Request {\n    fn default() -> Self {\n        Self {\n            method: Method::default(),\n            host: String::new(),\n            version: HttpVersion::default(),\n            path: String::new(),\n            querys: hash_map_xx_hash3_64(),\n            headers: hash_map_xx_hash3_64(),\n            body: Vec::new(),\n        }\n    }\n}\n\nimpl Request {\n    /// Creates a new instance of `Request`.\n    ///\n    /// # Returns\n    ///\n    /// - `Request` - A new request instance with default values.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Parses an HTTP request from a buffered TCP stream reader.\n    ///\n    /// Reads request line, headers and body from the stream and constructs a Request object.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut BufReader<&mut TcpStream>` - The buffered TCP stream reader.\n    /// - `usize` - The buffer size for reading.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Request, RequestError>` - The parsed request or an error.\n    pub async fn http_from_reader(\n        reader: &mut BufReader<&mut TcpStream>,\n        buffer_size: usize,\n    ) -> RequestReaderHandleResult {\n        let mut request_line: String = String::with_capacity(buffer_size);\n        let _ = AsyncBufReadExt::read_line(reader, &mut request_line).await;\n        let parts: Vec<&str> = request_line.split_whitespace().collect();\n        let parts_len: usize = parts.len();\n        if parts_len < 3 {\n            return Err(RequestError::InvalidHttpRequestPartsLength(parts_len));\n        }\n        let method: RequestMethod = parts[0].parse::<RequestMethod>().unwrap_or_default();\n        let full_path: RequestPath = parts[1].to_string();\n        let version: RequestVersion = parts[2].parse::<RequestVersion>().unwrap_or_default();\n        let hash_index: OptionUsize = full_path.find(HASH_SYMBOL);\n        let query_index: OptionUsize = full_path.find(QUERY_SYMBOL);\n        let query_string: String = query_index.map_or(String::new(), |i| {\n            let temp: &str = &full_path[i + 1..];\n            if hash_index.is_none() || hash_index.unwrap() <= i {\n                return temp.to_string();\n            }\n            temp.split(HASH_SYMBOL)\n                .next()\n                .unwrap_or_default()\n                .to_string()\n        });\n        let querys: RequestQuerys = Self::parse_querys(&query_string);\n        let path: RequestPath = if let Some(i) = query_index.or(hash_index) {\n            full_path[..i].to_string()\n        } else {\n            full_path\n        };\n        let mut headers: RequestHeaders = hash_map_xx_hash3_64();\n        let mut host: RequestHost = String::new();\n        let mut content_length: usize = 0;\n        loop {\n            let mut header_line: String = String::with_capacity(buffer_size);\n            let _ = AsyncBufReadExt::read_line(reader, &mut header_line).await;\n            let header_line: &str = header_line.trim();\n            if header_line.is_empty() {\n                break;\n            }\n            if let Some((key_part, value_part)) = header_line.split_once(COLON_SPACE_SYMBOL) {\n                let key: String = key_part.trim().to_ascii_lowercase();\n                if key.is_empty() {\n                    continue;\n                }\n                let value: String = value_part.trim().to_string();\n                if key == HOST {\n                    host = value.clone();\n                } else if key == CONTENT_LENGTH {\n                    content_length = value.parse().unwrap_or(0);\n                }\n                headers\n                    .entry(key)\n                    .or_insert_with(VecDeque::new)\n                    .push_back(value);\n            }\n        }\n        let mut body: RequestBody = vec![0; content_length];\n        if content_length > 0 {\n            let _ = AsyncReadExt::read_exact(reader, &mut body).await;\n        }\n        Ok(Request {\n            method,\n            host,\n            version,\n            path,\n            querys,\n            headers,\n            body,\n        })\n    }\n\n    /// Parses an HTTP request from a TCP stream.\n    ///\n    /// Wraps the stream in a buffered reader and delegates to `http_from_reader`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ArcRwLock<TcpStream>` - The TCP stream to read from.\n    /// - `usize` - The buffer size for reading.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Request, RequestError>` - The parsed request or an error.\n    pub async fn http_from_stream(\n        stream: &ArcRwLockStream,\n        buffer_size: usize,\n    ) -> RequestReaderHandleResult {\n        let mut buf_stream: RwLockWriteGuard<'_, TcpStream> = stream.write().await;\n        let mut reader: BufReader<&mut TcpStream> = BufReader::new(&mut buf_stream);\n        Self::http_from_reader(&mut reader, buffer_size).await\n    }\n\n    /// Parses a WebSocket request from a TCP stream.\n    ///\n    /// Wraps the stream in a buffered reader and delegates to `ws_from_reader`.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ArcRwLock<TcpStream>` - The TCP stream to read from.\n    /// - `usize` - The buffer size for reading.\n    /// - `&mut Request` - The request template to populate.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Request, RequestError>` - The parsed WebSocket request or an error.\n    pub async fn ws_from_stream(\n        stream: &ArcRwLockStream,\n        buffer_size: usize,\n        request: &mut Self,\n    ) -> RequestReaderHandleResult {\n        let mut buf_stream: RwLockWriteGuard<'_, TcpStream> = stream.write().await;\n        let mut reader: BufReader<&mut TcpStream> = BufReader::new(&mut buf_stream);\n        Self::ws_from_reader(&mut reader, buffer_size, request).await\n    }\n\n    /// Parses a WebSocket request from a buffered TCP stream.\n    ///\n    /// Handles WebSocket frames including text, binary, ping, pong and close frames.\n    /// Assembles the request body from frame payload data.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut BufReader<&mut TcpStream>` - The buffered TCP stream reader.\n    /// - `usize` - The buffer size for reading frames.\n    /// - `&mut Request` - The request template to populate.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Request, RequestError>` - The parsed WebSocket request or an error.\n    pub async fn ws_from_reader(\n        reader: &mut BufReader<&mut TcpStream>,\n        buffer_size: usize,\n        request: &mut Self,\n    ) -> RequestReaderHandleResult {\n        let mut dynamic_buffer: Vec<u8> = Vec::with_capacity(buffer_size);\n        let mut temp_buffer: Vec<u8> = vec![0; buffer_size];\n        let mut full_frame: Vec<u8> = Vec::new();\n        let mut error_handle = || {\n            request.body.clear();\n        };\n        loop {\n            let len: usize = match reader.read(&mut temp_buffer).await {\n                Ok(len) => len,\n                Err(err) => {\n                    error_handle();\n                    if err.kind() == ErrorKind::ConnectionReset\n                        || err.kind() == ErrorKind::ConnectionAborted\n                    {\n                        return Err(RequestError::ClientDisconnected);\n                    }\n                    return Err(RequestError::InvalidWebSocketRequest(err.to_string()));\n                }\n            };\n            if len == 0 {\n                error_handle();\n                return Err(RequestError::IncompleteWebSocketFrame);\n            }\n            dynamic_buffer.extend_from_slice(&temp_buffer[..len]);\n            while let Some((frame, consumed)) = WebSocketFrame::decode_ws_frame(&dynamic_buffer) {\n                dynamic_buffer.drain(0..consumed);\n                match frame.get_opcode() {\n                    WebSocketOpcode::Close => {\n                        error_handle();\n                        return Err(RequestError::ClientClosedConnection);\n                    }\n                    WebSocketOpcode::Ping | WebSocketOpcode::Pong => {\n                        continue;\n                    }\n                    WebSocketOpcode::Text | WebSocketOpcode::Binary => {\n                        full_frame.extend_from_slice(frame.get_payload_data());\n                        if *frame.get_fin() {\n                            let mut request: Request = request.clone();\n                            request.body = full_frame;\n                            return Ok(request);\n                        }\n                    }\n                    _ => {\n                        error_handle();\n                        return Err(RequestError::InvalidWebSocketFrame(\n                            \"Unsupported opcode\".into(),\n                        ));\n                    }\n                }\n            }\n        }\n    }\n\n    /// Parses a query string into key-value pairs.\n    ///\n    /// Expects format \"key1=value1&key2=value2\". Empty values are allowed.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The query string to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `HashMap<String, String>` - The parsed query parameters.\n    fn parse_querys(query: &str) -> RequestQuerys {\n        let mut query_map: RequestQuerys = hash_map_xx_hash3_64();\n        for pair in query.split(AND) {\n            if let Some((key, value)) = pair.split_once(EQUAL) {\n                if !key.is_empty() {\n                    query_map.insert(key.to_string(), value.to_string());\n                }\n            } else if !pair.is_empty() {\n                query_map.insert(pair.to_string(), String::new());\n            }\n        }\n        query_map\n    }\n\n    /// Gets a query parameter value by key.\n    ///\n    /// The key type must implement Into<String> conversion.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The query parameter key (implements Into<String>).\n    ///\n    /// # Returns\n    ///\n    /// - `Option<String>` - The parameter value if exists.\n    pub fn get_query<K>(&self, key: K) -> OptionRequestQuerysValue\n    where\n        K: Into<RequestQuerysKey>,\n    {\n        self.querys.get(&key.into()).cloned()\n    }\n\n    /// Retrieves the value of a request header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<RequestHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValue` - The optional header values.\n    pub fn get_header<K>(&self, key: K) -> OptionRequestHeadersValue\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.headers.get(&key.into()).cloned()\n    }\n\n    /// Retrieves the first value of a request header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<RequestHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValueItem` - The first header value if exists.\n    pub fn get_header_front<K>(&self, key: K) -> OptionRequestHeadersValueItem\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .and_then(|values| values.front().cloned())\n    }\n\n    /// Retrieves the last value of a request header by its key.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<RequestHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `OptionRequestHeadersValueItem` - The last header value if exists.\n    pub fn get_header_back<K>(&self, key: K) -> OptionRequestHeadersValueItem\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .and_then(|values| values.back().cloned())\n    }\n\n    /// Retrieves the number of values for a specific header.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header's key (must implement Into<RequestHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The count of values for the header.\n    pub fn get_header_length<K>(&self, key: K) -> usize\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.headers\n            .get(&key.into())\n            .map(|values| values.len())\n            .unwrap_or(0)\n    }\n\n    /// Retrieves the total number of header values across all headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The total count of all header values.\n    pub fn get_headers_values_length(&self) -> usize {\n        self.headers.values().map(|values| values.len()).sum()\n    }\n\n    /// Retrieves the number of unique headers.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The count of unique header keys.\n    pub fn get_headers_length(&self) -> usize {\n        self.headers.len()\n    }\n\n    /// Checks if a specific header exists.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to check (must implement Into<RequestHeadersKey>).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the header exists.\n    pub fn has_header<K>(&self, key: K) -> bool\n    where\n        K: Into<RequestHeadersKey>,\n    {\n        self.headers.contains_key(&key.into())\n    }\n\n    /// Checks if a header contains a specific value.\n    ///\n    /// # Arguments\n    ///\n    /// - `K` - The header key to check (must implement Into<RequestHeadersKey>).\n    /// - `V` - The value to search for (must implement Into<RequestHeadersValueItem>).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the header contains the value.\n    pub fn has_header_value<K, V>(&self, key: K, value: V) -> bool\n    where\n        K: Into<RequestHeadersKey>,\n        V: Into<RequestHeadersValueItem>,\n    {\n        let key: RequestHeadersKey = key.into();\n        let value: RequestHeadersValueItem = value.into();\n        if let Some(values) = self.headers.get(&key) {\n            values.contains(&value)\n        } else {\n            false\n        }\n    }\n\n    /// Retrieves the body content of the request as a UTF-8 encoded string.\n    ///\n    /// This method uses `String::from_utf8_lossy` to convert the byte slice returned by `self.get_body()` into a string.\n    /// If the byte slice contains invalid UTF-8 sequences, they will be replaced with the Unicode replacement character ().\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The body content as a string.\n    pub fn get_body_string(&self) -> String {\n        String::from_utf8_lossy(self.get_body()).into_owned()\n    }\n\n    /// Deserializes the body content of the request into a specified type `T`.\n    ///\n    /// This method first retrieves the body content as a byte slice using `self.get_body()`.\n    /// It then attempts to deserialize the byte slice into the specified type `T` using `json_from_slice`.\n    ///\n    /// # Type Parameters\n    ///\n    /// - `T` - The target type to deserialize into (must implement DeserializeOwned).\n    ///\n    /// # Returns\n    ///\n    /// - `ResultJsonError<T>` - The deserialization result.\n    pub fn get_body_json<T>(&self) -> ResultJsonError<T>\n    where\n        T: DeserializeOwned,\n    {\n        json_from_slice(self.get_body())\n    }\n\n    /// Converts the request to a formatted string representation.\n    ///\n    /// This method provides a human-readable summary of the request, including its method,\n    /// host, version, path, query parameters, headers, and body information.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The formatted request details.\n    pub fn get_string(&self) -> String {\n        let body: &Vec<u8> = self.get_body();\n        let body_type: &'static str = if std::str::from_utf8(body).is_ok() {\n            PLAIN\n        } else {\n            BINARY\n        };\n        format!(\n            \"[Request] => [method]: {}; [host]: {}; [version]: {}; [path]: {}; [querys]: {:?}; [headers]: {:?}; [body]: {} bytes {};\",\n            self.get_method(),\n            self.get_host(),\n            self.get_version(),\n            self.get_path(),\n            self.get_querys(),\n            self.get_headers(),\n            body.len(),\n            body_type\n        )\n    }\n\n    /// Retrieves the upgrade type from the request headers.\n    ///\n    /// This method looks for the `UPGRADE` header and attempts to parse its value\n    /// into an `UpgradeType`. If the header is missing or the value is invalid,\n    /// it returns the default `UpgradeType`.\n    ///\n    /// # Returns\n    ///\n    /// - `UpgradeType` - The parsed upgrade type.\n    pub fn get_upgrade_type(&self) -> UpgradeType {\n        let upgrade_type: UpgradeType = self\n            .get_header_back(UPGRADE)\n            .and_then(|data| data.parse::<UpgradeType>().ok())\n            .unwrap_or_default();\n        upgrade_type\n    }\n\n    /// Checks whether the WebSocket upgrade is enabled for this request.\n    ///\n    /// This method determines if the `UPGRADE` header indicates a WebSocket connection.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether WebSocket upgrade is enabled.\n    pub fn is_ws(&self) -> bool {\n        self.get_upgrade_type().is_ws()\n    }\n\n    /// Checks if the current upgrade type is HTTP/2 cleartext (h2c).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the upgrade type is h2c.\n    pub fn is_h2c(&self) -> bool {\n        self.get_upgrade_type().is_h2c()\n    }\n\n    /// Checks if the current upgrade type is TLS (any version).\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the upgrade type is TLS.\n    pub fn is_tls(&self) -> bool {\n        self.get_upgrade_type().is_tls()\n    }\n\n    /// Checks whether the upgrade type is unknown.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the upgrade type is unknown.\n    pub fn is_unknown_upgrade(&self) -> bool {\n        self.get_upgrade_type().is_unknown()\n    }\n\n    /// Checks if the HTTP version is HTTP/1.1 or higher.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/1.1 or higher.\n    pub fn is_http1_1_or_higher(&self) -> bool {\n        self.get_version().is_http1_1_or_higher()\n    }\n\n    /// Checks whether the HTTP version is HTTP/0.9.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/0.9.\n    pub fn is_http0_9(&self) -> bool {\n        self.get_version().is_http0_9()\n    }\n\n    /// Checks whether the HTTP version is HTTP/1.0.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/1.0.\n    pub fn is_http1_0(&self) -> bool {\n        self.get_version().is_http1_0()\n    }\n\n    /// Checks whether the HTTP version is HTTP/1.1.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/1.1.\n    pub fn is_http1_1(&self) -> bool {\n        self.get_version().is_http1_1()\n    }\n\n    /// Checks whether the HTTP version is HTTP/2.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/2.\n    pub fn is_http2(&self) -> bool {\n        self.get_version().is_http2()\n    }\n\n    /// Checks whether the HTTP version is HTTP/3.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP/3.\n    pub fn is_http3(&self) -> bool {\n        self.get_version().is_http3()\n    }\n\n    /// Checks whether the HTTP version is unknown.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is unknown.\n    pub fn is_unknown_version(&self) -> bool {\n        self.get_version().is_unknown()\n    }\n\n    /// Checks whether the version belongs to the HTTP family.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the version is HTTP.\n    pub fn is_http(&self) -> bool {\n        self.get_version().is_http()\n    }\n\n    /// Checks whether the request method is GET.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is GET.\n    pub fn is_get(&self) -> bool {\n        self.get_method().is_get()\n    }\n\n    /// Checks whether the request method is POST.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is POST.\n    pub fn is_post(&self) -> bool {\n        self.get_method().is_post()\n    }\n\n    /// Checks whether the request method is PUT.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is PUT.\n    pub fn is_put(&self) -> bool {\n        self.get_method().is_put()\n    }\n\n    /// Checks whether the request method is DELETE.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is DELETE.\n    pub fn is_delete(&self) -> bool {\n        self.get_method().is_delete()\n    }\n\n    /// Checks whether the request method is PATCH.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is PATCH.\n    pub fn is_patch(&self) -> bool {\n        self.get_method().is_patch()\n    }\n\n    /// Checks whether the request method is HEAD.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is HEAD.\n    pub fn is_head(&self) -> bool {\n        self.get_method().is_head()\n    }\n\n    /// Checks whether the request method is OPTIONS.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is OPTIONS.\n    pub fn is_options(&self) -> bool {\n        self.get_method().is_options()\n    }\n\n    /// Checks whether the request method is CONNECT.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is CONNECT.\n    pub fn is_connect(&self) -> bool {\n        self.get_method().is_connect()\n    }\n\n    /// Checks whether the request method is TRACE.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is TRACE.\n    pub fn is_trace(&self) -> bool {\n        self.get_method().is_trace()\n    }\n\n    /// Checks whether the request method is UNKNOWN.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether the method is UNKNOWN.\n    pub fn is_unknown_method(&self) -> bool {\n        self.get_method().is_unknown()\n    }\n\n    /// Determines if a keep-alive connection should be enabled for this request.\n    ///\n    /// This function checks the `Connection` header and the HTTP version to determine\n    /// if keep-alive should be enabled. The logic is as follows:\n    ///\n    /// 1. If the `Connection` header exists:\n    ///    - Returns `true` if the header value is \"keep-alive\" (case-insensitive).\n    ///    - Returns `false` if the header value is \"close\" (case-insensitive).\n    /// 2. If no `Connection` header is present:\n    ///    - Returns `true` if the HTTP version is 1.1 or higher.\n    ///    - Returns `false` otherwise.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether keep-alive should be enabled.\n    pub fn is_enable_keep_alive(&self) -> bool {\n        if let Some(connection_value) = self.get_header_back(CONNECTION) {\n            if connection_value.eq_ignore_ascii_case(KEEP_ALIVE) {\n                return true;\n            } else if connection_value.eq_ignore_ascii_case(CLOSE) {\n                return self.is_ws();\n            }\n        }\n        self.is_http1_1_or_higher() || self.is_ws()\n    }\n}", "file_size": 22782, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\stream\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl ArcRwLockStream {\n    /// Creates a new ArcRwLockStream from an Arc<RwLock<TcpStream>>.\n    ///\n    /// # Arguments\n    ///\n    /// - `Arc<RwLock<TcpStream>>` - The stream to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `ArcRwLockStream` - The new stream wrapper.\n    pub fn from(arc_rw_lock_stream: ArcRwLock<TcpStream>) -> Self {\n        Self(arc_rw_lock_stream)\n    }\n\n    /// Creates a new ArcRwLockStream from a TcpStream.\n    ///\n    /// Wraps the stream in an Arc<RwLock<_>>.\n    ///\n    /// # Arguments\n    ///\n    /// - `TcpStream` - The raw stream to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `ArcRwLockStream` - The new thread-safe stream wrapper.\n    pub fn from_stream(stream: TcpStream) -> Self {\n        Self(arc_rwlock(stream))\n    }\n\n    /// Gets a read lock on the inner TcpStream.\n    ///\n    /// Allows shared read access to the stream.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockReadGuardTcpStream` - The read guard for the stream.\n    pub async fn read(&self) -> RwLockReadGuardTcpStream {\n        self.get_0().read().await\n    }\n\n    /// Gets a write lock on the inner TcpStream.\n    ///\n    /// Allows exclusive write access to the stream.\n    ///\n    /// # Returns\n    ///\n    /// - `RwLockWriteGuardTcpStream` - The write guard for the stream.\n    pub(crate) async fn write(&self) -> RwLockWriteGuardTcpStream {\n        self.get_0().write().await\n    }\n\n    /// Sends HTTP response data over the stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ResponseData` - The response data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result indicating success or failure.\n    pub async fn send(&self, data: &ResponseData) -> ResponseResult {\n        self.write()\n            .await\n            .write_all(&data)\n            .await\n            .map_err(|err| ResponseError::Response(err.to_string()))?;\n        Ok(())\n    }\n\n    /// Sends response body with WebSocket framing condition.\n    ///\n    /// Handles both HTTP and WebSocket response formats.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ResponseBody` - The response body data.\n    /// - `bool` - Whether to use WebSocket framing.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result indicating success or failure.\n    pub async fn send_body_conditional(\n        &self,\n        body: &ResponseBody,\n        is_websocket: bool,\n    ) -> ResponseResult {\n        let body_list: Vec<ResponseBody> = if is_websocket {\n            WebSocketFrame::create_response_frame_list(body)\n        } else {\n            vec![body.clone()]\n        };\n        let mut stream: RwLockWriteGuardTcpStream = self.write().await;\n        for tmp_body in body_list {\n            stream\n                .write_all(&tmp_body)\n                .await\n                .map_err(|err| ResponseError::Response(err.to_string()))?;\n        }\n        Ok(())\n    }\n\n    /// Sends HTTP response body (non-WebSocket).\n    ///\n    /// Convenience wrapper for send_body_conditional with WebSocket disabled.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ResponseBody` - The response body data.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result indicating success or failure.\n    pub async fn send_body(&self, body: &ResponseBody) -> ResponseResult {\n        self.send_body_conditional(body, false).await\n    }\n\n    /// Sends WebSocket response body.\n    ///\n    /// Convenience wrapper for send_body_conditional with WebSocket enabled.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ResponseBody` - The WebSocket frame data.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseResult` - Result indicating success or failure.\n    pub async fn send_ws_body(&self, body: &ResponseBody) -> ResponseResult {\n        self.send_body_conditional(body, true).await\n    }\n\n    /// Flushes all buffered data to the stream.\n    ///\n    /// # Returns\n    ///\n    /// - `&Self` - Reference to self for method chaining.\n    pub async fn flush(&self) -> &Self {\n        let _ = self.write().await.flush();\n        self\n    }\n}", "file_size": 4062, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\stream\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A thread-safe reference-counted `TcpStream`.\npub type ArcStream = Arc<TcpStream>;\n/// An optional thread-safe reference-counted `TcpStream`.\npub type OptionArcTcpStream = Option<ArcStream>;\n/// An optional thread-safe read-write locked `TcpStream` wrapper.\npub type OptionArcRwLockStream = Option<ArcRwLockStream>;\n/// A read guard for a `RwLock<TcpStream>`.\npub type RwLockReadGuardTcpStream<'a> = RwLockReadGuard<'a, TcpStream>;\n/// A write guard for a `RwLock<TcpStream>`.\npub type RwLockWriteGuardTcpStream<'a> = RwLockWriteGuard<'a, TcpStream>;\n/// A thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type ArcRwLockWriteGuardTcpStream<'a> = Arc<RwLockWriteGuard<'a, TcpStream>>;\n/// An optional thread-safe reference to a `RwLock` write guard for `TcpStream`.\npub type OptionArcRwLockWriteGuardTcpStream<'a> = Option<ArcRwLockWriteGuardTcpStream<'a>>;\n/// A thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type ArcMutexGuardTcpStream<'a> = Arc<MutexGuard<'a, TcpStream>>;\n/// An optional thread-safe reference to a `Mutex` guard for `TcpStream`.\npub type OptionArcMutexGuardTcpStream<'a> = Option<ArcMutexGuardTcpStream<'a>>;\n/// A socket host represented by an IP address.\npub type SocketHost = IpAddr;\n/// A socket port number.\npub type SocketPort = u16;\n/// An optional socket host.\npub type OptionSocketHost = Option<SocketHost>;\n/// An optional socket port.\npub type OptionSocketPort = Option<SocketPort>;\n/// An optional full socket address.\npub type OptionSocketAddr = Option<SocketAddr>;", "file_size": 1552, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\upgrade_type\\enum.rs", "language": "rust", "content": "/// Represents different upgrade types.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum UpgradeType {\n    /// Represents an upgrade to the WebSocket protocol.\n    WebSocket,\n    /// Represents an upgrade to HTTP/2 cleartext (h2c).\n    H2c,\n    /// Represents a TLS upgrade, which is rare and experimental. It includes the specific TLS protocol string.\n    Tls(String),\n    /// Represents other custom or unknown upgrade protocols, including the protocol string.\n    Unknown(String),\n}", "file_size": 484, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\upgrade_type\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `Default` trait for `UpgradeType`.\n///\n/// Provides a default value for `UpgradeType`, which is `Self::Unknown(String::new())`.\nimpl Default for UpgradeType {\n    /// Returns the default `UpgradeType`, which is `Self::Unknown(String::new())`.\n    ///\n    /// # Returns\n    ///\n    /// The default `UpgradeType` instance.\n    fn default() -> Self {\n        Self::Unknown(String::new())\n    }\n}\n\n/// Implements the `Display` trait for `UpgradeType`.\n/// This allows `UpgradeType` variants to be formatted into human-readable strings.\nimpl fmt::Display for UpgradeType {\n    /// Formats the `UpgradeType` variant into a human-readable string.\n    ///\n    /// # Arguments\n    ///\n    /// - `f`: A mutable reference to a `fmt::Formatter` used for writing the formatted string.\n    ///\n    /// # Returns\n    ///\n    /// A `fmt::Result` indicating whether the formatting was successful.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::WebSocket => write!(f, \"{}\", WEBSOCKET),\n            Self::H2c => write!(f, \"{}\", H2C_LOWERCASE),\n            Self::Tls(version) => write!(f, \"{}\", version),\n            Self::Unknown(tmp_str) => write!(f, \"{}\", tmp_str),\n        }\n    }\n}\n\n/// Implements the `FromStr` trait for `UpgradeType`.\n/// This allows parsing string representations into `UpgradeType` variants.\nimpl FromStr for UpgradeType {\n    /// The error type for `FromStr` implementation, which is a unit type `()` indicating no specific error information.\n    type Err = ();\n\n    /// Parses a string slice into an `UpgradeType`.\n    ///\n    /// The parsing is case-insensitive. It recognizes \"websocket\", \"h2c\", and strings starting with \"tls\" as specific types.\n    /// Any other string is parsed as `Self::Unknown`.\n    ///\n    /// # Arguments\n    ///\n    /// - `from_str`: The string slice to parse.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(UpgradeType)`: The parsed `UpgradeType` variant.\n    /// - `Err(())`: If parsing fails (though this implementation always returns `Ok`).\n    fn from_str(from_str: &str) -> Result<Self, Self::Err> {\n        match from_str.to_ascii_lowercase().as_str() {\n            WEBSOCKET => Ok(Self::WebSocket),\n            H2C_LOWERCASE => Ok(Self::H2c),\n            val if val.starts_with(TLS_LOWERCASE) => Ok(Self::Tls(val.to_string())),\n            other => Ok(Self::Unknown(other.to_string())),\n        }\n    }\n}\n\nimpl UpgradeType {\n    /// Checks if the current upgrade type is `WebSocket`.\n    ///\n    /// # Returns\n    ///\n    /// `true` if `self` is `Self::WebSocket`, otherwise `false`.\n    pub fn is_ws(&self) -> bool {\n        matches!(self, &Self::WebSocket)\n    }\n\n    /// Checks if the current upgrade type is HTTP/2 cleartext (`h2c`).\n    ///\n    /// # Returns\n    ///\n    /// `true` if `self` is `Self::H2c`, otherwise `false`.\n    pub fn is_h2c(&self) -> bool {\n        matches!(self, &Self::H2c)\n    }\n\n    /// Checks if the current upgrade type is a TLS variant (any version).\n    ///\n    /// # Returns\n    ///\n    /// `true` if `self` matches `Self::Tls(_)`, otherwise `false`.\n    pub fn is_tls(&self) -> bool {\n        matches!(self, Self::Tls(_))\n    }\n\n    /// Checks if the current upgrade type is unknown (neither `WebSocket`, `H2c`, nor `Tls`).\n    ///\n    /// # Returns\n    ///\n    /// `true` if `self` is none of the known upgrade types, otherwise `false`.\n    pub fn is_unknown(&self) -> bool {\n        !self.is_ws() && !self.is_h2c() && !self.is_tls()\n    }\n}", "file_size": 3512, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\websocket_frame\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// WebSocket frame opcode types\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n#[repr(u8)]\npub enum WebSocketOpcode {\n    /// Represents a continuation frame (0x0).\n    Continuation = 0x0,\n    /// Represents a text frame (0x1).\n    Text = 0x1,\n    /// Represents a binary frame (0x2).\n    Binary = 0x2,\n    /// Represents a connection close frame (0x8).\n    Close = 0x8,\n    /// Represents a ping frame (0x9).\n    Ping = 0x9,\n    /// Represents a pong frame (0xA).\n    Pong = 0xA,\n    /// Represents a reserved opcode for future use, including the specific byte value.\n    Reserved(u8),\n}", "file_size": 602, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\websocket_frame\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;\n\npub use r#enum::*;\npub use r#struct::*;\npub use r#type::*;", "file_size": 153, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\request\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl StdError for RequestError {}\n\nimpl Display for RequestError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::HttpRead => write!(f, \"Http read error\"),\n            Self::GetTcpStream => write!(f, \"Failed to get tcp stream\"),\n            Self::GetTlsStream => write!(f, \"Failed to get tls stream\"),\n            Self::ReadConnection => write!(f, \"Connection read error\"),\n            Self::RequestAborted => write!(f, \"Request aborted\"),\n            Self::TlsStreamConnect => write!(f, \"Tls stream connection error\"),\n            Self::NeedOpenRedirect => write!(f, \"Open redirect required\"),\n            Self::MaxRedirectTimes => write!(f, \"Exceeded maximum redirect attempts\"),\n            Self::MethodsNotSupport => write!(f, \"Http method not supported\"),\n            Self::RedirectInvalidUrl => write!(f, \"Invalid redirect url\"),\n            Self::ClientDisconnected => write!(f, \"Client disconnected\"),\n            Self::RedirectUrlDeadLoop => write!(f, \"Redirect url dead loop detected\"),\n            Self::ClientClosedConnection => {\n                write!(f, \"Client closed connection\")\n            }\n            Self::IncompleteWebSocketFrame => write!(\n                f,\n                \"WebSocket connection closed before a complete frame was received\"\n            ),\n            Self::Request(err) => write!(f, \"Request error{}{}\", COLON_SPACE, err),\n            Self::Unknown(err) => write!(f, \"Unknown error{}{}\", COLON_SPACE, err),\n            Self::InvalidUrl(err) => write!(f, \"Invalid url{}{}\", COLON_SPACE, err),\n            Self::SetReadTimeout(err) => {\n                write!(f, \"Failed to set read timeout{}{}\", COLON_SPACE, err)\n            }\n            Self::SetWriteTimeout(err) => {\n                write!(f, \"Failed to set write timeout{}{}\", COLON_SPACE, err)\n            }\n            Self::TcpStreamConnect(err) => {\n                write!(f, \"Tcp stream connection error{}{}\", COLON_SPACE, err)\n            }\n            Self::TlsConnectorBuild(err) => {\n                write!(f, \"Tls connector build error{}{}\", COLON_SPACE, err)\n            }\n            Self::InvalidWebSocketFrame(err) => {\n                write!(f, \"Invalid websocket frame{}{}\", COLON_SPACE, err)\n            }\n\n            Self::InvalidWebSocketRequest(err) => {\n                write!(f, \"Invalid websocket request{}{}\", COLON_SPACE, err)\n            }\n            Self::InvalidHttpRequestPartsLength(len) => {\n                write!(f, \"Invalid http request parts length{}{}\", COLON_SPACE, len)\n            }\n        }\n    }\n}", "file_size": 2609, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// An alias for `Vec<u8>`, representing the binary body of the HTTP response.\npub type ResponseBody = Vec<u8>;\n/// An alias for `String`, representing the body of the HTTP response as a UTF-8 string.\npub type ResponseBodyString = String;\n/// An alias for `String`, representing the key type used in HTTP response headers.\npub type ResponseHeadersKey = String;\n/// An alias for `String`, representing a single value string for an HTTP response header.\npub type ResponseHeadersValueItem = String;\n/// An alias for `Option<ResponseHeadersValueItem>`, representing an optional value string for an HTTP response header.\npub type OptionResponseHeadersValueItem = Option<ResponseHeadersValueItem>;\n/// An alias for `VecDeque<ResponseHeadersValueItem>`, representing a collection of values for a single HTTP response header.\npub type ResponseHeadersValue = VecDeque<ResponseHeadersValueItem>;\n/// An alias for `HashMapXxHash3_64<ResponseHeadersKey, ResponseHeadersValue>`, representing a map of HTTP response headers.\npub type ResponseHeaders = HashMapXxHash3_64<ResponseHeadersKey, ResponseHeadersValue>;\n/// An alias for `HttpVersion`, representing the HTTP version of the response.\npub type ResponseVersion = HttpVersion;\n/// An alias for `usize`, representing the numeric status code of the HTTP response.\npub type ResponseStatusCode = usize;\n/// An alias for `String`, representing the reason phrase associated with the HTTP status code.\npub type ResponseReasonPhrase = String;\n/// An alias for `Result<(), ResponseError>`, representing the result type returned after writing an HTTP response.\npub type ResponseResult = Result<(), ResponseError>;\n/// An alias for `Vec<u8>`, representing the full serialized binary content of the HTTP response.\npub type ResponseData = Vec<u8>;\n/// An alias for `String`, representing the full serialized content of the HTTP response as a UTF-8 string.\npub type ResponseDataString = String;\n/// An alias for `RwLockReadGuard<'a, Response>`, representing a read guard to a shared `Response` value protected by `RwLock`.\npub type RwLockReadGuardResponse<'a> = RwLockReadGuard<'a, Response>;\n/// An alias for `RwLockWriteGuard<'a, Response>`, representing a write guard to a shared `Response` value protected by `RwLock`.\npub type RwLockWriteGuardResponse<'a> = RwLockWriteGuard<'a, Response>;\n/// An alias for `Option<ResponseHeadersValue>`, representing an optional collection of values for a response header.\npub type OptionResponseHeadersValue = Option<ResponseHeadersValue>;", "file_size": 2522, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\response\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `StdError` trait for `ResponseError`.\n/// This allows `ResponseError` to be treated as a standard Rust error type.\nimpl StdError for ResponseError {}\n\n/// Implements the `Display` trait for `ResponseError`.\n/// This allows `ResponseError` variants to be formatted into human-readable strings.\nimpl Display for ResponseError {\n    /// Formats the `ResponseError` variant into a human-readable string.\n    ///\n    /// # Arguments\n    ///\n    /// - `f`: A mutable reference to a `fmt::Formatter` used for writing the formatted string.\n    ///\n    /// # Returns\n    ///\n    /// A `fmt::Result` indicating whether the formatting was successful.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::NotFoundStream => {\n                write!(f, \"Not found stream\")\n            }\n            Self::ConnectionClosed => {\n                write!(f, \"Connection has been closed\")\n            }\n            Self::Terminated => {\n                write!(f, \"Current processing has been terminated\")\n            }\n            Self::Unknown(err) => write!(f, \"Unknown error{}{}\", COLON_SPACE, err),\n            Self::Response(data) => write!(f, \"Response error{}{}\", COLON_SPACE, data),\n            Self::WebSocketHandShake(err) => {\n                write!(f, \"Websocket handshake error{}{}\", COLON_SPACE, err)\n            }\n            Self::MethodNotSupported(err) => {\n                write!(f, \"Method not supported{}{}\", COLON_SPACE, err)\n            }\n        }\n    }\n}", "file_size": 1542, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\lib.rs", "language": "rust", "content": "//! http-request\n//!\n//! http-request is a lightweight, efficient library for building, sending,\n//! and handling HTTP/HTTPS requests in Rust applications.\n//! It provides a simple and intuitive API, allowing developers to easily\n//! interact with web services, whether they use the \"HTTP\" or \"HTTPS\" protocol.\n//! The library supports various HTTP methods, custom headers, request bodies,\n//! timeout, automatic handling of redirects (including detecting redirect loops),\n//! and enhanced response body decoding (both automatic and manual), enabling fast\n//! and secure communication. Whether working with secure \"HTTPS\" connections\n//! or standard \"HTTP\" requests, the library is optimized for performance,\n//! minimal resource usage, and easy integration into Rust projects.\n\npub(crate) mod body;\npub(crate) mod cfg;\npub(crate) mod common;\npub(crate) mod r#const;\npub(crate) mod request;\npub(crate) mod response;\npub(crate) mod utils;\npub(crate) mod websocket;\n\npub use request::*;\npub use response::*;\npub use websocket::*;\n\npub use http_type::{\n    HashMapXxHash3_64, JsonDeserializer, JsonError, JsonMap, JsonNumber, JsonResult,\n    JsonSerializer, JsonStreamDeserializer, JsonValue, hash_map_xx_hash3_64, json_from_reader,\n    json_from_slice, json_from_str, json_from_value, json_to_string, json_to_string_pretty,\n    json_to_value, json_to_vec, json_to_vec_pretty, json_to_writer, json_to_writer_pretty,\n    json_value,\n};\n\npub(crate) use body::*;\npub(crate) use common::*;\npub(crate) use r#const::*;\npub(crate) use utils::*;\n\npub(crate) use futures::{Future, Sink, SinkExt, Stream, StreamExt};\npub(crate) use http_type::{\n    ACCEPT, ACCEPT_ANY, BR_BYTES, CONNECTION, CONTENT_LENGTH, CONTENT_TYPE, Compress, ContentType,\n    DEFAULT_BUFFER_SIZE, DEFAULT_HTTP_PATH, DEFAULT_MAX_REDIRECT_TIMES, DEFAULT_TIMEOUT, EMPTY_STR,\n    HOST, HTTP_BR_BYTES, HttpStatus, HttpUrlComponents, HttpVersion, LOCATION, Method, Protocol,\n    QUERY_SYMBOL, RequestBody, RequestBodyString, RequestError, RequestHeaders, ResponseHeaders,\n    ResponseStatusCode, SEC_WEBSOCKET_KEY, SEC_WEBSOCKET_VERSION, SPACE_U8, TAB_U8, UPGRADE,\n    USER_AGENT,\n    tokio::{\n        io::{AsyncRead, AsyncReadExt, AsyncWrite, AsyncWriteExt, ReadBuf},\n        net::TcpStream as AsyncTcpStream,\n        runtime::Runtime,\n        sync::{Mutex as AsyncMutex, MutexGuard as AsyncMutexGuard},\n        time::timeout,\n    },\n};\npub(crate) use rustls::{\n    ClientConfig, ClientConnection, RootCertStore, StreamOwned, pki_types::ServerName,\n};\npub(crate) use serde::{Serialize, Serializer};\npub(crate) use std::{\n    borrow::Cow,\n    collections::{HashSet, VecDeque},\n    fmt::{self, Debug, Display, Formatter},\n    io::{Read, Write},\n    net::{Ipv4Addr, Ipv6Addr, TcpStream},\n    pin::Pin,\n    str::from_utf8,\n    sync::{\n        Arc, RwLock,\n        atomic::{AtomicBool, Ordering},\n    },\n    task::{Context, Poll},\n    time::{Duration, SystemTime, UNIX_EPOCH},\n    vec::IntoIter,\n};\npub(crate) use tokio_rustls::{TlsConnector, client::TlsStream};\npub(crate) use tokio_tungstenite::{\n    MaybeTlsStream, WebSocketStream, client_async_with_config, connect_async_with_config,\n    tungstenite::Message, tungstenite::handshake::client::Request,\n};\npub(crate) use webpki_roots::TLS_SERVER_ROOTS;\n\n#[cfg(test)]\nuse std::{\n    sync::{Mutex, MutexGuard},\n    thread::{JoinHandle, spawn},\n    time::Instant,\n};\n\n#[cfg(test)]\nuse http_type::tokio;", "file_size": 3401, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\websocket_frame\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// An alias for `Option<(WebSocketFrame, usize)>`, representing a decoded WebSocket frame along with the number of bytes consumed.\npub type WebsocketFrameWithLengthOption = Option<(WebSocketFrame, usize)>;", "file_size": 221, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\common\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Thread-safe reference-counted read-write lock wrapper.\npub(crate) type ArcRwLock<T> = Arc<RwLock<T>>;", "file_size": 120, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\cfg.rs", "language": "rust", "content": "#[cfg(test)]\nuse crate::*;\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_async_http_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_async();\n\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"Async GET ResponseTrait => {:?}\", response.text());\n        }\n        Err(e) => println!(\"Async GET Error => {}\", e),\n    }\n}\n\n#[test]\nfn test_http_post_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Accept\", \"*/*\");\n    header.insert(\"Content-Type\", \"application/json\");\n    header.insert(\"Connection\", \"keep-alive\");\n    header.insert(\"Accept-Encoding\", \"gzip, deflate\");\n    let body: JsonValue = json_value!({\n        \"code\": \"fn main() {\\r\\n    println!(\\\"hello world\\\");\\r\\n}\",\n        \"language\": \"rust\",\n        \"testin\": \"\"\n    });\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"https://ide.ltpp.vip/?language=rust\")\n        .json(body)\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_http_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut body: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    body.insert(\"body-key\", \"body-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_https_post_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Accept\", \"*/*\");\n    header.insert(\"Content-Type\", \"application/json\");\n    header.insert(\"Connection\", \"keep-alive\");\n    header.insert(\"Accept-Encoding\", \"gzip, deflate\");\n    let body: JsonValue = json_value!({\n        \"code\": \"fn main() {\\r\\n    println!(\\\"hello world\\\");\\r\\n}\",\n        \"language\": \"rust\",\n        \"testin\": \"\"\n    });\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"https://code.ltpp.vip/\")\n        .json(body)\n        .headers(header)\n        .timeout(4000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_https_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut body: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    body.insert(\"body-key\", \"body-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://code.ltpp.vip/\")\n        .headers(header)\n        .timeout(4000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_http_post_text_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Accept\", \"*/*\");\n    header.insert(\"Content-Type\", \"application/json\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"http://code.ltpp.vip\")\n        .text(\"hello\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_http_post_binary_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Accept\", \"*/*\");\n    header.insert(\"Content-Type\", \"application/json\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"http://code.ltpp.vip\")\n        .body(\"hello\".as_bytes())\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_auto_gzip_get() {\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .timeout(4000)\n        .redirect()\n        .max_redirect_times(8)\n        .decode()\n        .buffer(4096)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_gzip_get() {\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .timeout(4000)\n        .redirect()\n        .max_redirect_times(8)\n        .buffer(4096)\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response.decode(4096).text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_unredirect_get() {\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"https://ide.ltpp.vip/?language=rust\")\n        .timeout(4000)\n        .max_redirect_times(8)\n        .buffer(4096)\n        .unredirect()\n        .http1_1_only()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"ResponseTrait => {:?}\", response);\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_thread_https_get_request() {\n    let header_key: &str = \"header-key\";\n    let header_value: &str = \"header-value\";\n    let body_key: &str = \"body-key\";\n    let body_value: &str = \"body-value\";\n    let mut body: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    body.insert(body_key, body_value);\n    let num_threads: i32 = 10;\n    let mut handles: Vec<JoinHandle<()>> = Vec::new();\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(header_key, header_value);\n    let request_builder: Arc<Mutex<BoxRequestTrait>> = Arc::new(Mutex::new(\n        RequestBuilder::new()\n            .get(\"https://code.ltpp.vip/\")\n            .headers(header.clone())\n            .timeout(4000)\n            .redirect()\n            .buffer(4096)\n            .max_redirect_times(8)\n            .http1_1_only()\n            .build_sync(),\n    ));\n    for _ in 0..num_threads {\n        let request_builder: Arc<\n            Mutex<\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<\n                                dyn ResponseTrait<\n                                        OutputText = HttpResponseText,\n                                        OutputBinary = HttpResponseBinary,\n                                    >,\n                            >,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            >,\n        > = Arc::clone(&request_builder);\n        let handle: JoinHandle<()> = spawn(move || {\n            let mut request_builder: MutexGuard<\n                '_,\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<\n                                dyn ResponseTrait<\n                                        OutputText = HttpResponseText,\n                                        OutputBinary = HttpResponseBinary,\n                                    >,\n                            >,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            > = request_builder.lock().unwrap();\n            let start_time: Instant = Instant::now();\n            match request_builder.send() {\n                Ok(response) => {\n                    let duration: Duration = start_time.elapsed();\n                    let response_text: HttpResponseText = response.text();\n                    println!(\"Thread finished in: {:?}\", duration);\n                    println!(\"ResponseTrait => {:?}\", response_text);\n                }\n                Err(e) => {\n                    let duration: Duration = start_time.elapsed();\n                    println!(\"Thread finished in: {:?}\", duration);\n                    println!(\"Error => {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_thread_http_get_request() {\n    let num_threads: i32 = 10;\n    let mut handles: Vec<JoinHandle<()>> = Vec::new();\n    let request_builder: Arc<Mutex<BoxRequestTrait>> = Arc::new(Mutex::new(\n        RequestBuilder::new()\n            .get(\"http://127.0.0.1:7890/\")\n            .timeout(10)\n            .redirect()\n            .buffer(100)\n            .max_redirect_times(0)\n            .http2_only()\n            .build_sync(),\n    ));\n    for _ in 0..num_threads {\n        let request_builder: Arc<\n            Mutex<\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<\n                                dyn ResponseTrait<\n                                        OutputText = HttpResponseText,\n                                        OutputBinary = HttpResponseBinary,\n                                    >,\n                            >,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            >,\n        > = Arc::clone(&request_builder);\n        let handle: JoinHandle<()> = spawn(move || {\n            let mut request_builder: MutexGuard<\n                '_,\n                Box<\n                    dyn RequestTrait<\n                        RequestResult = Result<\n                            Box<\n                                dyn ResponseTrait<\n                                        OutputText = HttpResponseText,\n                                        OutputBinary = HttpResponseBinary,\n                                    >,\n                            >,\n                            RequestError,\n                        >,\n                    >,\n                >,\n            > = request_builder.lock().unwrap();\n            let start_time: Instant = Instant::now();\n            match request_builder.send() {\n                Ok(response) => {\n                    let duration: Duration = start_time.elapsed();\n                    println!(\"Thread finished in: {:?}\", duration);\n                    let response_text: HttpResponseText = response.text();\n                    println!(\"ResponseTrait => {:?}\", response_text);\n                }\n                Err(e) => {\n                    let duration: Duration = start_time.elapsed();\n                    println!(\"Thread finished in: {:?}\", duration);\n                    println!(\"Error => {}\", e);\n                }\n            }\n        });\n        handles.push(handle);\n    }\n    for handle in handles {\n        handle.join().unwrap();\n    }\n}\n\n#[test]\nfn test_readme_sync_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://ltpp.vip/\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .decode()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"{:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_readme_sync_post_json_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let body: JsonValue = json_value!({\n        \"test\": 1\n    });\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"http://code.ltpp.vip\")\n        .json(body)\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"{:?}\", response.decode(4096).text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_readme_sync_post_text_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"http://ide.ltpp.vip/?language=rust\")\n        .text(\"hello\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .decode()\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"{:?}\", response.text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_readme_sync_post_binary_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .post(\"http://ide.ltpp.vip/?language=rust\")\n        .body(\"hello\".as_bytes())\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .build_sync();\n    request_builder\n        .send()\n        .and_then(|response| {\n            println!(\"{:?}\", response.decode(4096).text());\n            Ok(())\n        })\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_async_websocket_connection() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Authorization\", \"Bearer test-token\");\n\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .headers(header)\n        .timeout(10000)\n        .buffer(4096)\n        .protocols(&[\"chat\", \"superchat\"])\n        .build_async();\n\n    match websocket_builder.send_text_async(\"Hello WebSocket!\").await {\n        Ok(_) => {\n            println!(\"Async WebSocket text message sent successfully\");\n            match websocket_builder.send_binary_async(b\"binary data\").await {\n                Ok(_) => {\n                    println!(\"Async WebSocket binary message sent successfully\");\n                    match websocket_builder.receive_async().await {\n                        Ok(message) => match message {\n                            WebSocketMessage::Text(text) => println!(\"Received text: {}\", text),\n                            WebSocketMessage::Binary(data) => {\n                                println!(\"Received binary: {:?}\", data)\n                            }\n                            WebSocketMessage::Close => println!(\"Connection closed\"),\n                            _ => println!(\"Received other message type\"),\n                        },\n                        Err(e) => println!(\"Error receiving message: {}\", e),\n                    }\n                }\n                Err(e) => println!(\"Error sending binary: {}\", e),\n            }\n        }\n        Err(e) => println!(\"Error sending text: {}\", e),\n    }\n\n    websocket_builder\n        .close_async_method()\n        .await\n        .unwrap_or_else(|e| println!(\"Error closing: {}\", e));\n}\n\n#[test]\nfn test_sync_websocket_connection() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"Authorization\", \"Bearer test-token\");\n\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .headers(header)\n        .timeout(10000)\n        .buffer(4096)\n        .protocols(&[\"chat\", \"superchat\"])\n        .build_sync();\n\n    websocket_builder\n        .send_text(\"Hello WebSocket!\")\n        .and_then(|_| {\n            println!(\"Sync WebSocket text message sent successfully\");\n            websocket_builder.send_binary(b\"binary data\")\n        })\n        .and_then(|_| {\n            println!(\"Sync WebSocket binary message sent successfully\");\n            match websocket_builder.receive() {\n                Ok(message) => match message {\n                    WebSocketMessage::Text(text) => println!(\"Received text: {}\", text),\n                    WebSocketMessage::Binary(data) => println!(\"Received binary: {:?}\", data),\n                    WebSocketMessage::Close => println!(\"Connection closed\"),\n                    _ => println!(\"Received other message type\"),\n                },\n                Err(e) => println!(\"Error receiving message: {}\", e),\n            }\n            Ok(())\n        })\n        .and_then(|_| websocket_builder.close())\n        .unwrap_or_else(|e| println!(\"Error => {}\", e));\n}\n\n#[test]\nfn test_websocket_with_http_proxy() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .http_proxy(\"127.0.0.1\", 7890)\n        .build_sync();\n\n    match websocket_builder.send_text(\"Hello WebSocket with HTTP proxy!\") {\n        Ok(_) => println!(\"WebSocket HTTP proxy test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\"WebSocket HTTP proxy test correctly failed: {}\", e);\n        }\n    }\n}\n\n#[test]\nfn test_websocket_with_https_proxy() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .https_proxy(\"127.0.0.1\", 7890)\n        .build_sync();\n\n    match websocket_builder.send_text(\"Hello WebSocket with HTTPS proxy!\") {\n        Ok(_) => println!(\"WebSocket HTTPS proxy test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\"WebSocket HTTPS proxy test correctly failed: {}\", e);\n        }\n    }\n}\n\n#[test]\nfn test_websocket_with_socks5_proxy() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .socks5_proxy(\"127.0.0.1\", 1080)\n        .build_sync();\n\n    match websocket_builder.send_text(\"Hello WebSocket with SOCKS5 proxy!\") {\n        Ok(_) => println!(\"WebSocket SOCKS5 proxy test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\"WebSocket SOCKS5 proxy test correctly failed: {}\", e);\n        }\n    }\n}\n\n#[test]\nfn test_websocket_with_http_proxy_auth() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n        .build_sync();\n\n    match websocket_builder.send_text(\"Hello WebSocket with HTTP proxy auth!\") {\n        Ok(_) => println!(\"WebSocket HTTP proxy auth test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\"WebSocket HTTP proxy auth test correctly failed: {}\", e);\n        }\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_websocket_with_socks5_proxy_auth_async() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n        .build_async();\n\n    match websocket_builder\n        .send_text_async(\"Hello WebSocket with SOCKS5 proxy auth!\")\n        .await\n    {\n        Ok(_) => println!(\"WebSocket SOCKS5 proxy auth async test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\n                \"WebSocket SOCKS5 proxy auth async test correctly failed: {}\",\n                e\n            );\n        }\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_websocket_with_https_proxy_auth_async() {\n    let mut websocket_builder: WebSocket = WebSocketBuilder::new()\n        .connect(\"ws://127.0.0.1:60006/api/ws?uuid=1\")\n        .timeout(10000)\n        .buffer(4096)\n        .https_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n        .build_async();\n\n    match websocket_builder\n        .send_text_async(\"Hello WebSocket with HTTPS proxy auth!\")\n        .await\n    {\n        Ok(_) => println!(\"WebSocket HTTPS proxy auth async test unexpectedly succeeded\"),\n        Err(e) => {\n            println!(\n                \"WebSocket HTTPS proxy auth async test correctly failed: {}\",\n                e\n            );\n        }\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_readme_async_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"https://ltpp.vip/\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .decode()\n        .build_async();\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"{:?}\", response.text());\n        }\n        Err(e) => println!(\"Error => {}\", e),\n    }\n}\n\n#[test]\nfn test_case_insensitive_header_matching() {\n    let mut header1: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header1.insert(\"Content-Type\", \"application/json\");\n    header1.insert(\"User-Agent\", \"test-agent\");\n\n    let mut header2: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header2.insert(\"content-type\", \"text/html\");\n    header2.insert(\"HOST\", \"example.com\");\n\n    let _request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header1)\n        .headers(header2)\n        .timeout(6000)\n        .build_sync();\n\n    println!(\"Case insensitive header test completed\");\n}\n\n#[test]\nfn test_case_insensitive_required_headers() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"host\", \"custom-host.com\");\n    header.insert(\"CONTENT-LENGTH\", \"100\");\n    header.insert(\"Accept\", \"application/xml\");\n    header.insert(\"user-agent\", \"custom-agent\");\n\n    let _request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(6000)\n        .build_sync();\n\n    println!(\"Case insensitive required headers test completed\");\n}\n\n#[test]\nfn test_http_proxy_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .http_proxy(\"127.0.0.1\", 7890)\n        .build_sync();\n\n    match request_builder.send() {\n        Ok(response) => {\n            println!(\"HTTP Proxy GET Response => {:?}\", response.text());\n        }\n        Err(e) => println!(\"HTTP Proxy GET Error (expected) => {}\", e),\n    }\n}\n\n#[test]\nfn test_http_proxy_auth_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .http_proxy_auth(\"127.0.0.1\", 7890, \"username\", \"password\")\n        .build_sync();\n\n    match request_builder.send() {\n        Ok(response) => {\n            println!(\"HTTP Proxy Auth GET Response => {:?}\", response.text());\n        }\n        Err(e) => println!(\"HTTP Proxy Auth GET Error (expected) => {}\", e),\n    }\n}\n\n#[test]\nfn test_socks5_proxy_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .socks5_proxy(\"127.0.0.1\", 1080)\n        .build_sync();\n\n    match request_builder.send() {\n        Ok(response) => {\n            println!(\"SOCKS5 Proxy GET Response => {:?}\", response.text());\n        }\n        Err(e) => println!(\"SOCKS5 Proxy GET Error (expected) => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_async_http_proxy_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .http_proxy(\"127.0.0.1\", 7890)\n        .build_async();\n\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"Async HTTP Proxy GET Response => {:?}\", response.text());\n        }\n        Err(e) => println!(\"Async HTTP Proxy GET Error (expected) => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_async_socks5_proxy_auth_get_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"http://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .redirect()\n        .buffer(4096)\n        .max_redirect_times(8)\n        .http1_1_only()\n        .socks5_proxy_auth(\"127.0.0.1\", 1080, \"username\", \"password\")\n        .build_async();\n\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\n                \"Async SOCKS5 Proxy Auth GET Response => {:?}\",\n                response.text()\n            );\n        }\n        Err(e) => println!(\"Async SOCKS5 Proxy Auth GET Error (expected) => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_readme_async_post_json_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let body: JsonValue = json_value!({\n        \"test\": 1\n    });\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .post(\"http://code.ltpp.vip\")\n        .json(body)\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .build_async();\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"{:?}\", response.decode(4096).text());\n        }\n        Err(e) => println!(\"Error => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_readme_async_post_text_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .post(\"http://ide.ltpp.vip/?language=rust\")\n        .text(\"hello\")\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .decode()\n        .build_async();\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"{:?}\", response.text());\n        }\n        Err(e) => println!(\"Error => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_readme_async_post_binary_request() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"header-key\", \"header-value\");\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .post(\"http://ide.ltpp.vip/?language=rust\")\n        .body(\"hello\".as_bytes())\n        .headers(header)\n        .timeout(6000)\n        .redirect()\n        .max_redirect_times(8)\n        .http1_1_only()\n        .buffer(4096)\n        .build_async();\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\"{:?}\", response.decode(4096).text());\n        }\n        Err(e) => println!(\"Error => {}\", e),\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_https_over_http_proxy_async() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"User-Agent\", \"test-agent\");\n\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .http_proxy(\"127.0.0.1\", 7890)\n        .build_async();\n\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\n                \"HTTPS over HTTP proxy test passed: {}\",\n                response.binary().get_status_code()\n            );\n        }\n        Err(e) => {\n            println!(\"HTTPS over HTTP proxy test failed (expected): {}\", e);\n        }\n    }\n}\n\n#[cfg(test)]\n#[tokio::test]\nasync fn test_https_over_socks5_proxy_async() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"User-Agent\", \"test-agent\");\n\n    let mut request_builder: BoxAsyncRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .socks5_proxy(\"127.0.0.1\", 1080)\n        .build_async();\n\n    match request_builder.send().await {\n        Ok(response) => {\n            println!(\n                \"HTTPS over SOCKS5 proxy test passed: {}\",\n                response.binary().get_status_code()\n            );\n        }\n        Err(e) => {\n            println!(\"HTTPS over SOCKS5 proxy test failed (expected): {}\", e);\n        }\n    }\n}\n\n#[test]\nfn test_https_over_http_proxy_sync() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"User-Agent\", \"test-agent\");\n\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .http_proxy(\"127.0.0.1\", 7890)\n        .build_sync();\n\n    match request_builder.send() {\n        Ok(response) => {\n            println!(\n                \"Sync HTTPS over HTTP proxy test passed: {}\",\n                response.binary().get_status_code()\n            );\n        }\n        Err(e) => {\n            println!(\"Sync HTTPS over HTTP proxy test failed (expected): {}\", e);\n        }\n    }\n}\n\n#[test]\nfn test_https_over_socks5_proxy_sync() {\n    let mut header: HashMapXxHash3_64<&str, &str> = hash_map_xx_hash3_64();\n    header.insert(\"User-Agent\", \"test-agent\");\n\n    let mut request_builder: BoxRequestTrait = RequestBuilder::new()\n        .get(\"https://ide.ltpp.vip/?language=rust\")\n        .headers(header)\n        .timeout(10000)\n        .socks5_proxy(\"127.0.0.1\", 1080)\n        .build_sync();\n\n    match request_builder.send() {\n        Ok(response) => {\n            println!(\n                \"Sync HTTPS over SOCKS5 proxy test passed: {}\",\n                response.binary().get_status_code()\n            );\n        }\n        Err(e) => {\n            println!(\"Sync HTTPS over SOCKS5 proxy test failed (expected): {}\", e);\n        }\n    }\n}", "file_size": 33797, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\response\\error\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents various errors that can occur during HTTP response processing.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ResponseError {\n    /// Represents an error where the stream was not found.\n    NotFoundStream,\n    /// Represents an error where the connection was closed.\n    ConnectionClosed,\n    /// Represents a terminated operation or connection.\n    Terminated,\n    /// Represents an unknown error with a message.\n    Unknown(String),\n    /// Represents a generic response error with a message.\n    Response(String),\n    /// Represents an error during WebSocket handshake with a message.\n    WebSocketHandShake(String),\n    /// Represents an error for an unsupported HTTP method with a message.\n    MethodNotSupported(String),\n}", "file_size": 759, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\const\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\n\npub(crate) use r#const::*;", "file_size": 51, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_url\\error\\impl.rs", "language": "rust", "content": "use super::*;\nuse crate::*;\n\n/// Implements the `StdError` trait for `HttpUrlError`.\nimpl StdError for HttpUrlError {}\n\n/// Implements the `Display` trait for `HttpUrlError`, allowing it to be formatted as a string.\nimpl Display for HttpUrlError {\n    /// Formats the `HttpUrlError` variant into a human-readable string.\n    ///\n    /// # Arguments\n    ///\n    /// - `f` - The formatter to write the string into.\n    ///\n    /// # Returns\n    ///\n    /// A `fmt::Result` indicating success or failure of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            HttpUrlError::InvalidUrl => write!(f, \"Invalid URL\"),\n        }\n    }\n}", "file_size": 697, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\websocket_frame\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a decoded WebSocket frame.\n#[derive(Debug, Clone, Getter, DisplayDebug, PartialEq, Eq)]\npub struct WebSocketFrame {\n    /// FIN flag indicating if this is the final frame.\n    pub(super) fin: bool,\n    /// Opcode indicating the frame type (text, binary, etc.).\n    pub(super) opcode: WebSocketOpcode,\n    /// Mask flag indicating if the payload is masked.\n    pub(super) mask: bool,\n    /// The payload data of the frame.\n    pub(super) payload_data: Vec<u8>,\n}", "file_size": 491, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\const\\const.rs", "language": "rust", "content": "/// The application name used for user agent and logging.\npub const APP_NAME: &str = \"http-request\";", "file_size": 100, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\mod.rs", "language": "rust", "content": "pub(crate) mod config;\npub(crate) mod proxy;\npub(crate) mod request;\npub(crate) mod request_builder;\npub(crate) mod shared;\npub(crate) mod tmp;\n\npub use request::*;\n\npub(crate) use config::*;\npub(crate) use proxy::*;\npub(crate) use shared::*;\npub(crate) use tmp::*;\n\npub use request_builder::*;", "file_size": 294, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\mod.rs", "language": "rust", "content": "pub(crate) mod response_binary;\npub(crate) mod response_text;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use response_binary::*;\npub use response_text::*;\npub use r#trait::*;\npub use r#type::*;", "file_size": 202, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\http_url\\error\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents different types of errors that can occur when handling HTTP URLs.\n///\n/// This enum defines various error types specifically related to parsing or\n/// otherwise processing HTTP URLs.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum HttpUrlError {\n    /// Indicates that the provided URL is invalid.\n    InvalidUrl,\n}", "file_size": 345, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\body\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\npub(crate) mod r#type;\n\npub(crate) use r#enum::*;\npub(crate) use r#type::*;", "file_size": 121, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) struct WebSocketConfig {\n    pub(crate) timeout: u64,\n    pub(crate) url_obj: HttpUrlComponents,\n    pub(crate) buffer: usize,\n    pub(crate) protocols: Vec<String>,\n    pub(crate) proxy: Option<ProxyConfig>,\n}", "file_size": 275, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\body\\enum.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents the body content of an HTTP request/response.\n///\n/// Can be text, JSON or binary data.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum Body {\n    /// Text content body.\n    Text(BodyText),\n    /// JSON content body.\n    Json(BodyJson),\n    /// Binary data body.\n    Binary(BodyBinary),\n}", "file_size": 325, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-type\\src\\request\\error\\enum.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum RequestError {\n    HttpRead,\n    GetTcpStream,\n    GetTlsStream,\n    ReadConnection,\n    RequestAborted,\n    TlsStreamConnect,\n    NeedOpenRedirect,\n    MaxRedirectTimes,\n    MethodsNotSupport,\n    RedirectInvalidUrl,\n    ClientDisconnected,\n    RedirectUrlDeadLoop,\n    ClientClosedConnection,\n    IncompleteWebSocketFrame,\n    Request(String),\n    Unknown(String),\n    InvalidUrl(String),\n    SetReadTimeout(String),\n    SetWriteTimeout(String),\n    TcpStreamConnect(String),\n    TlsConnectorBuild(String),\n    InvalidWebSocketFrame(String),\n    InvalidWebSocketRequest(String),\n    InvalidHttpRequestPartsLength(usize),\n}", "file_size": 687, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// A trait representing common behaviors for HTTP response types.\n///\n/// This trait provides methods for transforming an HTTP response into\n/// different formats (text and binary) and parsing raw HTTP response data.\n/// Implementing types should define how to convert the response into text\n/// and binary formats, as well as how to parse raw response data into a\n/// structured representation.\n///\n/// # Associated Types\n/// - `OutputText`: The type returned by the `text` method, typically a text-based HTTP response.\n/// - `OutputBinary`: The type returned by the `binary` method, typically a binary-based HTTP response.\npub trait ResponseTrait: Send + Debug {\n    type OutputText: Clone + Sized;\n    type OutputBinary: Clone + Sized;\n\n    /// Transforms the HTTP response into a text representation.\n    ///\n    /// This method converts the body of the HTTP response into a string format.\n    ///\n    /// # Returns\n    /// - `Self::OutputText`: The text representation of the HTTP response, typically a string.\n    fn text(&self) -> Self::OutputText;\n\n    /// Transforms the HTTP response into a binary representation.\n    ///\n    /// This method converts the body of the HTTP response into a byte-based format.\n    ///\n    /// # Returns\n    /// - `Self::OutputBinary`: The binary representation of the HTTP response, typically a byte vector.\n    fn binary(&self) -> Self::OutputBinary;\n\n    /// Parses a raw HTTP response into the associated type `Output`.\n    ///\n    /// This method is responsible for parsing a byte slice representing a raw HTTP response\n    /// and transforming it into a structured HTTP response object.\n    ///\n    /// # Parameters\n    /// - `response`: A byte slice representing the raw HTTP response.\n    ///\n    /// # Returns\n    /// - `Self`: An instance of the implementing type, populated with parsed data.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized;\n\n    /// Decodes the data using a specified buffer size.\n    ///\n    /// This method takes a buffer size as input and performs the decoding process.\n    /// It returns the decoded output in the form of `Self::OutputBinary`.\n    ///\n    /// # Parameters\n    /// - `buffer_size`: The buffer size to be used during decoding.\n    ///\n    /// # Returns\n    /// Returns the decoded data as `Self::OutputBinary`. The exact type of `OutputBinary` depends on the implementation of the `Self` type.\n    fn decode(&self, buffer_size: usize) -> Self::OutputBinary;\n}", "file_size": 2480, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\body\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// JSON body content represented as a hash map with string keys.\npub(crate) type BodyJson = HashMapXxHash3_64<String, JsonValue>;\n/// Text body content represented as a string.\npub(crate) type BodyText = String;\n/// Binary body content represented as a byte vector.\npub(crate) type BodyBinary = Vec<u8>;", "file_size": 319, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Default for WebSocketConfig {\n    fn default() -> Self {\n        Self {\n            timeout: DEFAULT_TIMEOUT,\n            url_obj: HttpUrlComponents::default(),\n            buffer: DEFAULT_BUFFER_SIZE,\n            protocols: Vec::new(),\n            proxy: None,\n        }\n    }\n}", "file_size": 299, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\body\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Body.\n///\n/// # Returns\n///\n/// - `Body` - Returns a Body with empty text content.\nimpl Default for Body {\n    fn default() -> Self {\n        Self::Text(EMPTY_STR.to_owned())\n    }\n}\n\n/// Formats the Body for display.\n///\n/// # Arguments\n///\n/// - `&mut Formatter<'_>` - The formatter to write to.\n///\n/// # Returns\n///\n/// - `fmt::Result` - Result of the formatting operation.\nimpl Display for Body {\n    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {\n        match self {\n            Self::Text(text) => write!(f, \"{}\", text.to_string()),\n            Self::Json(json) => write!(\n                f,\n                \"{}\",\n                serde_json::to_string(json).unwrap_or_else(|_| String::from(\"{}\"))\n            ),\n            Self::Binary(binary) => write!(f, \"{:?}\", binary),\n        }\n    }\n}\n\n/// Serializes the Body content.\n///\n/// # Arguments\n///\n/// - `S` - The type of the serializer.\n///\n/// # Returns\n///\n/// - `Result<S::Ok, S::Error>` - Result of the serialization.\nimpl Serialize for Body {\n    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n    where\n        S: Serializer,\n    {\n        match self {\n            Self::Text(text) => text.serialize(serializer),\n            Self::Json(json) => json.serialize(serializer),\n            Self::Binary(binary) => binary.serialize(serializer),\n        }\n    }\n}", "file_size": 1395, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\utils\\mod.rs", "language": "rust", "content": "pub(crate) mod encode;\npub(crate) mod vec;\n\npub(crate) use encode::*;\npub(crate) use vec::*;", "file_size": 92, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\proxy\\struct.rs", "language": "rust", "content": "use crate::*;\n\npub struct WebSocketProxyTunnelStream {\n    pub(super) inner: BoxAsyncReadWrite,\n}\n\npub struct SyncWebSocketProxyTunnelStream {\n    pub(super) inner: BoxReadWrite,\n}", "file_size": 180, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\message\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl WebSocketMessage {\n    pub fn text<T: ToString>(text: T) -> Self {\n        Self::Text(text.to_string())\n    }\n\n    pub fn binary<T: Into<Vec<u8>>>(data: T) -> Self {\n        Self::Binary(data.into())\n    }\n\n    pub fn ping<T: Into<Vec<u8>>>(data: T) -> Self {\n        Self::Ping(data.into())\n    }\n\n    pub fn pong<T: Into<Vec<u8>>>(data: T) -> Self {\n        Self::Pong(data.into())\n    }\n\n    pub fn close() -> Self {\n        Self::Close\n    }\n\n    pub fn is_text(&self) -> bool {\n        matches!(self, Self::Text(_))\n    }\n\n    pub fn is_binary(&self) -> bool {\n        matches!(self, Self::Binary(_))\n    }\n\n    pub fn is_ping(&self) -> bool {\n        matches!(self, Self::Ping(_))\n    }\n\n    pub fn is_pong(&self) -> bool {\n        matches!(self, Self::Pong(_))\n    }\n\n    pub fn is_close(&self) -> bool {\n        matches!(self, Self::Close)\n    }\n\n    pub fn as_text(&self) -> Option<&str> {\n        match self {\n            Self::Text(text) => Some(text),\n            _ => None,\n        }\n    }\n\n    pub fn as_binary(&self) -> Option<&[u8]> {\n        match self {\n            Self::Binary(data) => Some(data),\n            _ => None,\n        }\n    }\n\n    pub fn into_text(self) -> Option<String> {\n        match self {\n            Self::Text(text) => Some(text),\n            _ => None,\n        }\n    }\n\n    pub fn into_binary(self) -> Option<Vec<u8>> {\n        match self {\n            Self::Binary(data) => Some(data),\n            _ => None,\n        }\n    }\n}", "file_size": 1487, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\shared\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl std::fmt::Display for WebSocketError {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        match self.kind {\n            WebSocketErrorKind::Connection => write!(f, \"Connection error: {}\", self.message),\n            WebSocketErrorKind::Protocol => write!(f, \"Protocol error: {}\", self.message),\n            WebSocketErrorKind::Timeout => write!(f, \"Timeout error: {}\", self.message),\n            WebSocketErrorKind::InvalidUrl => write!(f, \"Invalid URL: {}\", self.message),\n            WebSocketErrorKind::Io => write!(f, \"IO error: {}\", self.message),\n            WebSocketErrorKind::Tls => write!(f, \"TLS error: {}\", self.message),\n        }\n    }\n}\n\nimpl std::error::Error for WebSocketError {}\n\nimpl WebSocketError {\n    pub(crate) fn connection<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::Connection,\n            message: message.to_string(),\n        }\n    }\n\n    pub(crate) fn protocol<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::Protocol,\n            message: message.to_string(),\n        }\n    }\n\n    pub(crate) fn timeout<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::Timeout,\n            message: message.to_string(),\n        }\n    }\n\n    pub(crate) fn invalid_url<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::InvalidUrl,\n            message: message.to_string(),\n        }\n    }\n\n    pub(crate) fn io<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::Io,\n            message: message.to_string(),\n        }\n    }\n\n    pub(crate) fn tls<T: ToString>(message: T) -> Self {\n        Self {\n            kind: WebSocketErrorKind::Tls,\n            message: message.to_string(),\n        }\n    }\n}\n\nimpl SharedWebSocketBuilder {\n    pub(crate) fn parse_url(url: &str) -> Result<HttpUrlComponents, WebSocketError> {\n        if url.is_empty() {\n            return Err(WebSocketError::invalid_url(\"URL is empty\"));\n        }\n        let mut url_obj: HttpUrlComponents = HttpUrlComponents::default();\n        if url.starts_with(\"ws://\") {\n            url_obj.protocol = Protocol::HTTP;\n            url_obj.port = Some(80);\n        } else if url.starts_with(\"wss://\") {\n            url_obj.protocol = Protocol::HTTPS;\n            url_obj.port = Some(443);\n        } else {\n            return Err(WebSocketError::invalid_url(\"Invalid WebSocket URL scheme\"));\n        }\n        let without_protocol: &str = if url.starts_with(\"ws://\") {\n            &url[5..]\n        } else {\n            &url[6..]\n        };\n        let parts: Vec<&str> = without_protocol.splitn(2, '/').collect();\n        let host_port: &str = parts[0];\n        let path: &str = if parts.len() > 1 { parts[1] } else { \"\" };\n        if host_port.contains(':') {\n            let host_port_parts: Vec<&str> = host_port.splitn(2, ':').collect();\n            url_obj.host = Some(host_port_parts[0].to_string());\n            if let Ok(port) = host_port_parts[1].parse::<u16>() {\n                url_obj.port = Some(port);\n            }\n        } else {\n            url_obj.host = Some(host_port.to_string());\n        }\n        url_obj.path = Some(if path.is_empty() {\n            \"/\".to_string()\n        } else {\n            format!(\"/{}\", path)\n        });\n        Ok(url_obj)\n    }\n}", "file_size": 3393, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\mod.rs", "language": "rust", "content": "pub(crate) mod config;\npub(crate) mod message;\npub(crate) mod proxy;\npub(crate) mod shared;\npub(crate) mod websocket;\npub(crate) mod websocket_builder;\n\npub use shared::*;\npub use websocket::*;\npub use websocket_builder::*;\n\npub(crate) use config::*;\npub(crate) use message::*;\npub(crate) use proxy::*;", "file_size": 302, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// A type alias for a boxed dynamic trait object implementing the `ResponseTrait` trait.\n///\n/// This alias defines a `ResponseTrait` as a `Box` containing any type that implements the\n/// `ResponseTrait` trait, with associated types `OutputText` set to `HttpResponseText`\n/// and `OutputBinary` set to `HttpResponseBinary`. It allows for flexible handling of\n/// HTTP responses that can be either in text or binary format.\npub type BoxResponseTrait =\n    Box<dyn ResponseTrait<OutputText = HttpResponseText, OutputBinary = HttpResponseBinary>>;", "file_size": 561, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\message\\enum.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Debug, Clone, PartialEq)]\npub enum WebSocketMessage {\n    Text(String),\n    Binary(Vec<u8>),\n    Ping(Vec<u8>),\n    Pong(Vec<u8>),\n    Close,\n}", "file_size": 167, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl WebSocket {\n    fn get_url(&self) -> String {\n        self.url.as_ref().clone()\n    }\n\n    fn generate_websocket_key() -> String {\n        let mut key_bytes: [u8; 16] = [0u8; 16];\n        let now: u64 = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .unwrap_or_default()\n            .as_nanos() as u64;\n        let ptr: usize = &key_bytes as *const _ as usize;\n        for (i, byte) in key_bytes.iter_mut().enumerate() {\n            *byte = ((now.wrapping_add(ptr as u64).wrapping_add(i as u64)) % 256) as u8;\n        }\n        base64_encode(&key_bytes)\n    }\n\n    fn get_headers(&self) -> Vec<(String, String)> {\n        let mut headers: Vec<(String, String)> = Vec::new();\n        for (key, value) in self.header.iter() {\n            if let Some(first_value) = value.front() {\n                headers.push((key.clone(), first_value.clone()));\n            }\n        }\n        headers\n    }\n\n    async fn connect_async_internal(&self) -> Result<(), WebSocketError> {\n        if self.connected.load(Ordering::Relaxed) {\n            return Ok(());\n        }\n        let url: String = self.get_url();\n        if url.is_empty() {\n            return Err(WebSocketError::invalid_url(\"URL is empty\"));\n        }\n        let url_obj: HttpUrlComponents = SharedWebSocketBuilder::parse_url(&url)?;\n        if let Ok(mut config) = self.config.write() {\n            config.url_obj = url_obj;\n        }\n        let timeout_duration: Duration = Duration::from_millis(\n            self.config\n                .read()\n                .map(|c| c.timeout)\n                .unwrap_or(DEFAULT_TIMEOUT),\n        );\n        let headers: Vec<(String, String)> = self.get_headers();\n        let mut request_builder = Request::builder().uri(&url);\n        for (key, value) in &headers {\n            request_builder = request_builder.header(key, value);\n        }\n        let request: Request = request_builder\n            .body(())\n            .map_err(|e| WebSocketError::invalid_url(format!(\"Failed to build request: {}\", e)))?;\n        let proxy_config: Option<ProxyConfig> = self\n            .config\n            .read()\n            .ok()\n            .and_then(|config| config.proxy.clone());\n        let ws_stream: WebSocketConnectionType = if let Some(proxy_config) = proxy_config {\n            let url_obj: HttpUrlComponents = self\n                .config\n                .read()\n                .map(|c| c.url_obj.clone())\n                .unwrap_or_default();\n            let target_host: String = url_obj.host.clone().unwrap_or_default();\n            let target_port: u16 = url_obj.port.unwrap_or_default();\n            let proxy_stream: BoxAsyncReadWrite = self\n                .get_proxy_connection_stream_async(target_host.clone(), target_port, &proxy_config)\n                .await?;\n            let proxy_tunnel_stream: WebSocketProxyTunnelStream =\n                WebSocketProxyTunnelStream::new(proxy_stream);\n            let mut proxy_request_builder = Request::builder().uri(&url);\n            proxy_request_builder = proxy_request_builder\n                .header(HOST, format!(\"{}:{}\", target_host, target_port))\n                .header(UPGRADE, \"websocket\")\n                .header(CONNECTION, \"Upgrade\")\n                .header(SEC_WEBSOCKET_VERSION, \"13\")\n                .header(SEC_WEBSOCKET_KEY, Self::generate_websocket_key());\n            for (key, value) in &headers {\n                proxy_request_builder = proxy_request_builder.header(key, value);\n            }\n            let protocols: Vec<String> = self\n                .config\n                .read()\n                .map(|c| c.protocols.clone())\n                .unwrap_or_default();\n            if !protocols.is_empty() {\n                proxy_request_builder =\n                    proxy_request_builder.header(\"Sec-WebSocket-Protocol\", protocols.join(\", \"));\n            }\n            let proxy_request: Request = proxy_request_builder.body(()).map_err(|e| {\n                WebSocketError::invalid_url(format!(\"Failed to build proxy request: {}\", e))\n            })?;\n            let connect_future = client_async_with_config(proxy_request, proxy_tunnel_stream, None);\n            let (ws_stream, _) = timeout(timeout_duration, connect_future)\n                .await\n                .map_err(|_| WebSocketError::timeout(\"Connection timeout\"))?\n                .map_err(|e| {\n                    let error_msg: String = e.to_string();\n                    if error_msg.contains(\"tls\")\n                        || error_msg.contains(\"TLS\")\n                        || error_msg.contains(\"ssl\")\n                        || error_msg.contains(\"SSL\")\n                        || error_msg.contains(\"certificate\")\n                        || error_msg.contains(\"handshake\")\n                    {\n                        WebSocketError::tls(error_msg)\n                    } else {\n                        WebSocketError::connection(error_msg)\n                    }\n                })?;\n            WebSocketConnectionType::Proxy(ws_stream)\n        } else {\n            let connect_future = connect_async_with_config(request, None, false);\n            let (ws_stream, _) = timeout(timeout_duration, connect_future)\n                .await\n                .map_err(|_| WebSocketError::timeout(\"Connection timeout\"))?\n                .map_err(|e| {\n                    let error_msg: String = e.to_string();\n                    if error_msg.contains(\"tls\")\n                        || error_msg.contains(\"TLS\")\n                        || error_msg.contains(\"ssl\")\n                        || error_msg.contains(\"SSL\")\n                        || error_msg.contains(\"certificate\")\n                        || error_msg.contains(\"handshake\")\n                    {\n                        WebSocketError::tls(error_msg)\n                    } else {\n                        WebSocketError::connection(error_msg)\n                    }\n                })?;\n            WebSocketConnectionType::Direct(ws_stream)\n        };\n        let mut connection: AsyncMutexGuard<'_, Option<WebSocketConnectionType>> =\n            self.connection.lock().await;\n        *connection = Some(ws_stream);\n        self.connected.store(true, Ordering::Relaxed);\n        Ok(())\n    }\n\n    async fn send_message_async(&self, message: Message) -> Result<(), WebSocketError> {\n        if !self.connected.load(Ordering::Relaxed) {\n            self.connect_async_internal().await?;\n        }\n        let mut connection: AsyncMutexGuard<'_, Option<WebSocketConnectionType>> =\n            self.connection.lock().await;\n        if let Some(ref mut ws_stream) = *connection {\n            ws_stream\n                .send(message)\n                .await\n                .map_err(|e| WebSocketError::protocol(e.to_string()))?;\n        } else {\n            return Err(WebSocketError::connection(\"Not connected\"));\n        }\n        Ok(())\n    }\n\n    fn send_message_sync(&self, message: Message) -> Result<(), WebSocketError> {\n        let rt: Runtime = Runtime::new().map_err(|e| WebSocketError::io(e.to_string()))?;\n        rt.block_on(self.send_message_async(message))\n    }\n\n    async fn receive_message_async(&self) -> Result<WebSocketMessage, WebSocketError> {\n        if !self.connected.load(Ordering::Relaxed) {\n            return Err(WebSocketError::connection(\"Not connected\"));\n        }\n        let timeout_duration: Duration = Duration::from_millis(\n            self.config\n                .read()\n                .map(|c| c.timeout)\n                .unwrap_or(DEFAULT_TIMEOUT),\n        );\n        let mut connection: AsyncMutexGuard<'_, Option<WebSocketConnectionType>> =\n            self.connection.lock().await;\n        if let Some(ref mut ws_stream) = *connection {\n            let receive_future = ws_stream.next();\n            if let Some(msg_result) = timeout(timeout_duration, receive_future)\n                .await\n                .map_err(|_| WebSocketError::timeout(\"Receive timeout\"))?\n            {\n                let message: Message =\n                    msg_result.map_err(|e| WebSocketError::protocol(e.to_string()))?;\n                return Ok(self.convert_message(message));\n            }\n        }\n        Err(WebSocketError::connection(\"Connection closed\"))\n    }\n\n    fn receive_message_sync(&self) -> Result<WebSocketMessage, WebSocketError> {\n        let rt: Runtime = Runtime::new().map_err(|e| WebSocketError::io(e.to_string()))?;\n        rt.block_on(self.receive_message_async())\n    }\n\n    fn convert_message(&self, message: Message) -> WebSocketMessage {\n        match message {\n            Message::Text(text) => WebSocketMessage::Text(text.to_string()),\n            Message::Binary(data) => WebSocketMessage::Binary(data.to_vec()),\n            Message::Ping(data) => WebSocketMessage::Ping(data.to_vec()),\n            Message::Pong(data) => WebSocketMessage::Pong(data.to_vec()),\n            Message::Close(_) => WebSocketMessage::Close,\n            Message::Frame(_) => WebSocketMessage::Close,\n        }\n    }\n\n    async fn close_async_internal(&self) -> Result<(), WebSocketError> {\n        let mut connection: AsyncMutexGuard<'_, Option<WebSocketConnectionType>> =\n            self.connection.lock().await;\n        if let Some(ref mut ws_stream) = *connection {\n            ws_stream\n                .send(Message::Close(None))\n                .await\n                .map_err(|e| WebSocketError::protocol(e.to_string()))?;\n            use futures::SinkExt;\n            ws_stream\n                .close()\n                .await\n                .map_err(|e| WebSocketError::protocol(e.to_string()))?;\n        }\n        *connection = None;\n        self.connected.store(false, Ordering::Relaxed);\n        Ok(())\n    }\n\n    fn close_sync(&self) -> Result<(), WebSocketError> {\n        let rt: Runtime = Runtime::new().map_err(|e| WebSocketError::io(e.to_string()))?;\n        rt.block_on(self.close_async_internal())\n    }\n\n    async fn get_proxy_connection_stream_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, WebSocketError> {\n        match proxy_config.proxy_type {\n            ProxyType::Http | ProxyType::Https => {\n                self.get_http_proxy_connection_async(target_host, target_port, proxy_config)\n                    .await\n            }\n            ProxyType::Socks5 => {\n                self.get_socks5_proxy_connection_async(target_host, target_port, proxy_config)\n                    .await\n            }\n        }\n    }\n\n    async fn get_http_proxy_connection_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, WebSocketError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let tcp_stream: AsyncTcpStream = AsyncTcpStream::connect(proxy_host_port)\n            .await\n            .map_err(|err| WebSocketError::connection(err.to_string()))?;\n        let mut proxy_stream: BoxAsyncReadWrite = if proxy_config.proxy_type == ProxyType::Https {\n            let roots: RootCertStore = RootCertStore {\n                roots: TLS_SERVER_ROOTS.iter().cloned().collect(),\n            };\n            let tls_config: ClientConfig = ClientConfig::builder()\n                .with_root_certificates(roots)\n                .with_no_client_auth();\n            let connector: TlsConnector = TlsConnector::from(Arc::new(tls_config));\n            let dns_name: ServerName<'_> = ServerName::try_from(proxy_config.host.clone())\n                .map_err(|err| WebSocketError::tls(err.to_string()))?;\n            let tls_stream: TlsStream<AsyncTcpStream> = connector\n                .connect(dns_name, tcp_stream)\n                .await\n                .map_err(|err| WebSocketError::tls(err.to_string()))?;\n            Box::new(tls_stream)\n        } else {\n            Box::new(tcp_stream)\n        };\n        let connect_request: String = if let (Some(username), Some(password)) =\n            (&proxy_config.username, &proxy_config.password)\n        {\n            let auth: String = format!(\"{}:{}\", username, password);\n            let auth_encoded: String = base64_encode(auth.as_bytes());\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\nProxy-Authorization: Basic {}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port, auth_encoded\n            )\n        } else {\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port\n            )\n        };\n        proxy_stream\n            .write_all(connect_request.as_bytes())\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n        proxy_stream\n            .flush()\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n        let mut response_buffer: [u8; 1024] = [0u8; 1024];\n        let bytes_read: usize = proxy_stream\n            .read(&mut response_buffer)\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n        let response: Cow<'_, str> = String::from_utf8_lossy(&response_buffer[..bytes_read]);\n        if !response.starts_with(\"HTTP/1.1 200\") && !response.starts_with(\"HTTP/1.0 200\") {\n            return Err(WebSocketError::connection(format!(\n                \"Proxy connection failed: {}\",\n                response.lines().next().unwrap_or(\"Unknown error\")\n            )));\n        }\n        Ok(proxy_stream)\n    }\n\n    async fn get_socks5_proxy_connection_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, WebSocketError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let mut tcp_stream: AsyncTcpStream = AsyncTcpStream::connect(proxy_host_port)\n            .await\n            .map_err(|err| WebSocketError::connection(err.to_string()))?;\n        let auth_methods: Vec<u8> =\n            if proxy_config.username.is_some() && proxy_config.password.is_some() {\n                vec![0x05, 0x02, 0x00, 0x02]\n            } else {\n                vec![0x05, 0x01, 0x00]\n            };\n        tcp_stream\n            .write_all(&auth_methods)\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n        let mut response: [u8; 2] = [0u8; 2];\n        tcp_stream\n            .read_exact(&mut response)\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n        if response[0] != 0x05 {\n            return Err(WebSocketError::protocol(\"Invalid SOCKS5 response\"));\n        }\n        match response[1] {\n            0x00 => {}\n            0x02 => {\n                if let (Some(username), Some(password)) =\n                    (&proxy_config.username, &proxy_config.password)\n                {\n                    let mut auth_request = vec![0x01];\n                    auth_request.push(username.len() as u8);\n                    auth_request.extend_from_slice(username.as_bytes());\n                    auth_request.push(password.len() as u8);\n                    auth_request.extend_from_slice(password.as_bytes());\n\n                    tcp_stream\n                        .write_all(&auth_request)\n                        .await\n                        .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n\n                    let mut auth_response = [0u8; 2];\n                    tcp_stream\n                        .read_exact(&mut auth_response)\n                        .await\n                        .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n\n                    if auth_response[1] != 0x00 {\n                        return Err(WebSocketError::protocol(\"SOCKS5 authentication failed\"));\n                    }\n                } else {\n                    return Err(WebSocketError::protocol(\n                        \"SOCKS5 proxy requires authentication\",\n                    ));\n                }\n            }\n            0xFF => {\n                return Err(WebSocketError::protocol(\n                    \"No acceptable SOCKS5 authentication methods\",\n                ));\n            }\n            _ => {\n                return Err(WebSocketError::protocol(\n                    \"Unsupported SOCKS5 authentication method\",\n                ));\n            }\n        }\n        let mut connect_request: Vec<u8> = vec![0x05, 0x01, 0x00];\n        if target_host.parse::<Ipv4Addr>().is_ok() {\n            connect_request.push(0x01);\n            let ip: Ipv4Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else if target_host.parse::<Ipv6Addr>().is_ok() {\n            connect_request.push(0x04);\n            let ip: Ipv6Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else {\n            connect_request.push(0x03);\n            connect_request.push(target_host.len() as u8);\n            connect_request.extend_from_slice(target_host.as_bytes());\n        }\n        connect_request.extend_from_slice(&target_port.to_be_bytes());\n        tcp_stream\n            .write_all(&connect_request)\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n\n        let mut connect_response: [u8; 4] = [0u8; 4];\n        tcp_stream\n            .read_exact(&mut connect_response)\n            .await\n            .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n\n        if connect_response[0] != 0x05 || connect_response[1] != 0x00 {\n            return Err(WebSocketError::protocol(format!(\n                \"SOCKS5 connection failed with code: {}\",\n                connect_response[1]\n            )));\n        }\n        match connect_response[3] {\n            0x01 => {\n                let mut skip: [u8; 6] = [0u8; 6];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n            }\n            0x03 => {\n                let mut len: [u8; 1] = [0u8; 1];\n                tcp_stream\n                    .read_exact(&mut len)\n                    .await\n                    .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n                let mut skip: Vec<u8> = vec![0u8; len[0] as usize + 2];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n            }\n            0x04 => {\n                let mut skip: [u8; 18] = [0u8; 18];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| WebSocketError::protocol(err.to_string()))?;\n            }\n            _ => {\n                return Err(WebSocketError::protocol(\"Invalid SOCKS5 address type\"));\n            }\n        }\n        let proxy_stream: BoxAsyncReadWrite = Box::new(tcp_stream);\n        Ok(proxy_stream)\n    }\n\n    /// Sends a text message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The text message to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub fn send_text(&mut self, text: &str) -> WebSocketResult {\n        let message: Message = Message::Text(text.into());\n        self.send_message_sync(message)\n    }\n\n    /// Sends a binary message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The binary data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub fn send_binary(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Binary(data.to_vec().into());\n        self.send_message_sync(message)\n    }\n\n    /// Sends a ping message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The ping data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub fn send_ping(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Ping(data.to_vec().into());\n        self.send_message_sync(message)\n    }\n\n    /// Sends a pong message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The pong data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub fn send_pong(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Pong(data.to_vec().into());\n        self.send_message_sync(message)\n    }\n\n    /// Receives a message synchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketMessageResult` - Result containing the received message or error.\n    pub fn receive(&mut self) -> WebSocketMessageResult {\n        self.receive_message_sync()\n    }\n\n    /// Closes the WebSocket connection synchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub fn close(&mut self) -> WebSocketResult {\n        self.close_sync()\n    }\n\n    /// Checks if the WebSocket is currently connected.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if connected, false otherwise.\n    pub fn is_connected(&self) -> bool {\n        self.connected.load(Ordering::Relaxed)\n    }\n\n    /// Sends a text message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The text message to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub async fn send_text_async(&mut self, text: &str) -> WebSocketResult {\n        let message: Message = Message::Text(text.into());\n        self.send_message_async(message).await\n    }\n\n    /// Sends a binary message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The binary data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub async fn send_binary_async(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Binary(data.to_vec().into());\n        self.send_message_async(message).await\n    }\n\n    /// Sends a ping message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The ping data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub async fn send_ping_async(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Ping(data.to_vec().into());\n        self.send_message_async(message).await\n    }\n\n    /// Sends a pong message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The pong data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub async fn send_pong_async(&mut self, data: &[u8]) -> WebSocketResult {\n        let message: Message = Message::Pong(data.to_vec().into());\n        self.send_message_async(message).await\n    }\n\n    /// Receives a message asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketMessageResult` - Result containing the received message or error.\n    pub async fn receive_async(&mut self) -> WebSocketMessageResult {\n        self.receive_message_async().await\n    }\n\n    /// Closes the WebSocket connection asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    pub async fn close_async_method(&mut self) -> WebSocketResult {\n        self.close_async_internal().await\n    }\n}\n\n/// Synchronous WebSocket trait implementation.\n///\n/// Provides synchronous methods for WebSocket operations including:\n/// - Sending messages (text, binary, ping, pong)\n/// - Receiving messages\n/// - Closing connections\n/// - Checking connection status\nimpl WebSocketTrait for WebSocket {\n    fn send_text(&mut self, text: &str) -> WebSocketResult {\n        self.send_text(text)\n    }\n\n    fn send_binary(&mut self, data: &[u8]) -> WebSocketResult {\n        self.send_binary(data)\n    }\n\n    fn send_ping(&mut self, data: &[u8]) -> WebSocketResult {\n        self.send_ping(data)\n    }\n\n    fn send_pong(&mut self, data: &[u8]) -> WebSocketResult {\n        self.send_pong(data)\n    }\n\n    fn receive(&mut self) -> WebSocketMessageResult {\n        self.receive()\n    }\n\n    fn close(&mut self) -> WebSocketResult {\n        self.close()\n    }\n\n    fn is_connected(&self) -> bool {\n        self.is_connected()\n    }\n}\n\n/// Asynchronous WebSocket trait implementation.\n///\n/// Provides asynchronous methods for WebSocket operations including:\n/// - Sending messages (text, binary, ping, pong)\n/// - Receiving messages\n/// - Closing connections\n/// - Checking connection status\nimpl AsyncWebSocketTrait for WebSocket {\n    fn send_text<'a>(\n        &'a mut self,\n        text: &'a str,\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>> {\n        Box::pin(self.send_text_async(text))\n    }\n\n    fn send_binary<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>> {\n        Box::pin(self.send_binary_async(data))\n    }\n\n    fn send_ping<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>> {\n        Box::pin(self.send_ping_async(data))\n    }\n\n    fn send_pong<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>> {\n        Box::pin(self.send_pong_async(data))\n    }\n\n    fn receive(&mut self) -> Pin<Box<dyn Future<Output = WebSocketMessageResult> + Send + '_>> {\n        Box::pin(self.receive_async())\n    }\n\n    fn close(&mut self) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + '_>> {\n        Box::pin(self.close_async_method())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.is_connected()\n    }\n}", "file_size": 26146, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Synchronous WebSocket operations trait.\n///\n/// Defines the interface for synchronous WebSocket operations including:\n/// - Sending messages (text, binary, ping, pong)\n/// - Receiving messages\n/// - Closing connections\n/// - Checking connection status\npub trait WebSocketTrait: Send + Sync {\n    /// Sends a text message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The text message to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_text(&mut self, text: &str) -> WebSocketResult;\n    /// Sends a binary message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The binary data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_binary(&mut self, data: &[u8]) -> WebSocketResult;\n    /// Sends a ping message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The ping data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_ping(&mut self, data: &[u8]) -> WebSocketResult;\n    /// Sends a pong message synchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The pong data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_pong(&mut self, data: &[u8]) -> WebSocketResult;\n    /// Receives a message synchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketMessageResult` - Result containing the received message or error.\n    fn receive(&mut self) -> WebSocketMessageResult;\n    /// Closes the WebSocket connection synchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn close(&mut self) -> WebSocketResult;\n    /// Checks if the WebSocket is currently connected.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if connected, false otherwise.\n    fn is_connected(&self) -> bool;\n}\n\n/// Asynchronous WebSocket operations trait.\n///\n/// Defines the interface for asynchronous WebSocket operations including:\n/// - Sending messages (text, binary, ping, pong)\n/// - Receiving messages\n/// - Closing connections\n/// - Checking connection status\npub trait AsyncWebSocketTrait: Send + Sync {\n    /// Sends a text message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The text message to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_text<'a>(\n        &'a mut self,\n        text: &'a str,\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>>;\n    /// Sends a binary message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The binary data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_binary<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>>;\n    /// Sends a ping message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The ping data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_ping<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>>;\n    /// Sends a pong message asynchronously.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The pong data to send.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn send_pong<'a>(\n        &'a mut self,\n        data: &'a [u8],\n    ) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>>;\n    /// Receives a message asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketMessageResult` - Result containing the received message or error.\n    fn receive<'a>(\n        &'a mut self,\n    ) -> Pin<Box<dyn Future<Output = WebSocketMessageResult> + Send + 'a>>;\n    /// Closes the WebSocket connection asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `WebSocketResult` - Result indicating success or failure.\n    fn close<'a>(&'a mut self) -> Pin<Box<dyn Future<Output = WebSocketResult> + Send + 'a>>;\n    /// Checks if the WebSocket is currently connected.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - True if connected, false otherwise.\n    fn is_connected(&self) -> bool;\n}", "file_size": 4539, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\shared\\struct.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Debug, Clone)]\npub(crate) struct SharedWebSocketBuilder;\n\n#[derive(Debug, Clone)]\npub struct WebSocketError {\n    pub(crate) kind: WebSocketErrorKind,\n    pub(crate) message: String,\n}\n\n#[derive(Debug, Clone, PartialEq)]\npub enum WebSocketErrorKind {\n    Connection,\n    Protocol,\n    Timeout,\n    InvalidUrl,\n    Io,\n    Tls,\n}", "file_size": 352, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket\\mod.rs", "language": "rust", "content": "pub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use r#trait::*;\npub use r#type::*;\n\npub(crate) use r#struct::*;", "file_size": 163, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl WebSocketBuilder {\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    pub fn connect(&mut self, url: &str) -> &mut Self {\n        self.websocket.url = Arc::new(url.to_owned());\n        self\n    }\n\n    pub fn headers<K, V>(&mut self, header: HashMapXxHash3_64<K, V>) -> &mut Self\n    where\n        K: ToString,\n        V: ToString,\n    {\n        if let Some(tmp_header) = Arc::get_mut(&mut self.websocket.header) {\n            for (key, value) in header {\n                let key_str: String = key.to_string();\n                let value_str: String = value.to_string();\n                let mut found_existing: bool = false;\n                let mut existing_key: Option<String> = None;\n                for existing_key_ref in tmp_header.keys() {\n                    if existing_key_ref.eq_ignore_ascii_case(&key_str) {\n                        existing_key = Some(existing_key_ref.clone());\n                        found_existing = true;\n                        break;\n                    }\n                }\n                if found_existing {\n                    if let Some(existing_key) = existing_key {\n                        tmp_header.remove(&existing_key);\n                    }\n                }\n                let mut value_deque: VecDeque<String> = VecDeque::new();\n                value_deque.push_front(value_str);\n                tmp_header.insert(key_str, value_deque);\n            }\n        }\n        self\n    }\n\n    pub fn timeout(&mut self, timeout: u64) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.timeout = timeout;\n        }\n        self\n    }\n\n    pub fn buffer(&mut self, buffer: usize) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.buffer = buffer;\n        }\n        self\n    }\n\n    pub fn protocols(&mut self, protocols: &[&str]) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.protocols = protocols.iter().map(|s| s.to_string()).collect();\n        }\n        self\n    }\n\n    pub fn http_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Http,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    pub fn https_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Https,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    pub fn socks5_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Socks5,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    pub fn http_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Http,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    pub fn https_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Https,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    pub fn socks5_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.websocket.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Socks5,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    pub fn build_sync(&mut self) -> WebSocket {\n        self.builder = self.websocket.clone();\n        self.websocket = WebSocket::default();\n        self.builder.clone()\n    }\n\n    pub fn build_async(&mut self) -> WebSocket {\n        self.builder = self.websocket.clone();\n        self.websocket = WebSocket::default();\n        self.builder.clone()\n    }\n}", "file_size": 5223, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents different types of WebSocket connections.\n///\n/// This enum encapsulates both direct and proxy-based WebSocket connections,\n/// providing a unified interface for WebSocket operations.\n#[derive(Debug)]\npub enum WebSocketConnectionType {\n    Direct(WebSocketStream<MaybeTlsStream<AsyncTcpStream>>),\n    Proxy(WebSocketStream<WebSocketProxyTunnelStream>),\n}\n\n/// Represents a WebSocket client connection.\n///\n/// This struct manages the WebSocket lifecycle including:\n/// - Connection state\n/// - Message sending/receiving\n/// - Configuration\n#[derive(Debug)]\npub struct WebSocket {\n    /// The WebSocket server URL.\n    pub(crate) url: Arc<String>,\n    /// HTTP headers for the WebSocket handshake.\n    pub(crate) header: Arc<RequestHeaders>,\n    /// Configuration settings for the WebSocket connection.\n    pub(crate) config: ArcRwLock<WebSocketConfig>,\n    /// Atomic flag indicating connection status.\n    pub(crate) connected: Arc<AtomicBool>,\n    /// The underlying WebSocket connection.\n    pub(crate) connection: WebSocketConnection,\n}\n\n/// Clone implementation for WebSocket.\n///\n/// Creates a new WebSocket instance with cloned configuration but resets:\n/// - Connection status to false\n/// - Connection to None\nimpl Clone for WebSocket {\n    fn clone(&self) -> Self {\n        Self {\n            url: self.url.clone(),\n            header: self.header.clone(),\n            config: self.config.clone(),\n            connected: Arc::new(AtomicBool::new(false)),\n            connection: Arc::new(AsyncMutex::new(None)),\n        }\n    }\n}\n\n/// Default implementation for WebSocket.\n///\n/// Creates a WebSocket with:\n/// - Empty URL\n/// - Empty headers\n/// - Default configuration\n/// - Disconnected state\n/// - No active connection\nimpl Default for WebSocket {\n    fn default() -> Self {\n        Self {\n            url: Arc::new(String::new()),\n            header: Arc::new(hash_map_xx_hash3_64()),\n            config: Arc::new(RwLock::new(WebSocketConfig::default())),\n            connected: Arc::new(AtomicBool::new(false)),\n            connection: Arc::new(AsyncMutex::new(None)),\n        }\n    }\n}\n\n/// Stream implementation for WebSocketConnectionType.\n///\n/// Allows polling for incoming WebSocket messages.\n/// Handles both direct and proxy connections uniformly.\nimpl Stream for WebSocketConnectionType {\n    type Item =\n        Result<tokio_tungstenite::tungstenite::Message, tokio_tungstenite::tungstenite::Error>;\n\n    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n        match &mut *self {\n            WebSocketConnectionType::Direct(stream) => Pin::new(stream).poll_next(cx),\n            WebSocketConnectionType::Proxy(stream) => Pin::new(stream).poll_next(cx),\n        }\n    }\n}\n\n/// Sink implementation for WebSocketConnectionType.\n///\n/// Allows sending WebSocket messages.\n/// Handles both direct and proxy connections uniformly.\nimpl Sink<tokio_tungstenite::tungstenite::Message> for WebSocketConnectionType {\n    type Error = tokio_tungstenite::tungstenite::Error;\n\n    fn poll_ready(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        match &mut *self {\n            WebSocketConnectionType::Direct(stream) => Pin::new(stream).poll_ready(cx),\n            WebSocketConnectionType::Proxy(stream) => Pin::new(stream).poll_ready(cx),\n        }\n    }\n\n    fn start_send(\n        mut self: Pin<&mut Self>,\n        item: tokio_tungstenite::tungstenite::Message,\n    ) -> Result<(), Self::Error> {\n        match &mut *self {\n            WebSocketConnectionType::Direct(stream) => Pin::new(stream).start_send(item),\n            WebSocketConnectionType::Proxy(stream) => Pin::new(stream).start_send(item),\n        }\n    }\n\n    fn poll_flush(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        match &mut *self {\n            WebSocketConnectionType::Direct(stream) => Pin::new(stream).poll_flush(cx),\n            WebSocketConnectionType::Proxy(stream) => Pin::new(stream).poll_flush(cx),\n        }\n    }\n\n    fn poll_close(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Result<(), Self::Error>> {\n        match &mut *self {\n            WebSocketConnectionType::Direct(stream) => Pin::new(stream).poll_close(cx),\n            WebSocketConnectionType::Proxy(stream) => Pin::new(stream).poll_close(cx),\n        }\n    }\n}", "file_size": 4388, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\proxy\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl WebSocketProxyTunnelStream {\n    pub(crate) fn new(stream: BoxAsyncReadWrite) -> Self {\n        Self { inner: stream }\n    }\n}\n\nimpl AsyncRead for WebSocketProxyTunnelStream {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<std::io::Result<()>> {\n        Pin::new(&mut self.inner).poll_read(cx, buf)\n    }\n}\n\nimpl AsyncWrite for WebSocketProxyTunnelStream {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<Result<usize, std::io::Error>> {\n        Pin::new(&mut self.inner).poll_write(cx, buf)\n    }\n\n    fn poll_flush(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Result<(), std::io::Error>> {\n        Pin::new(&mut self.inner).poll_flush(cx)\n    }\n\n    fn poll_shutdown(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Result<(), std::io::Error>> {\n        Pin::new(&mut self.inner).poll_shutdown(cx)\n    }\n}\n\nimpl Unpin for WebSocketProxyTunnelStream {}\n\nimpl Debug for WebSocketProxyTunnelStream {\n    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"WebSocketProxyTunnelStream\")\n            .field(\"inner\", &\"<BoxAsyncReadWrite>\")\n            .finish()\n    }\n}\n\nimpl SyncWebSocketProxyTunnelStream {\n    #[allow(dead_code)]\n    pub(crate) fn new(stream: BoxReadWrite) -> Self {\n        Self { inner: stream }\n    }\n}\n\nimpl Read for SyncWebSocketProxyTunnelStream {\n    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {\n        self.inner.read(buf)\n    }\n}\n\nimpl Write for SyncWebSocketProxyTunnelStream {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.inner.flush()\n    }\n}", "file_size": 1871, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\utils\\encode\\const.rs", "language": "rust", "content": "/// Base64 encoding character set.\n///\n/// Contains the 64 characters used in standard base64 encoding:\n/// A-Z, a-z, 0-9, '+', and '/'.\npub(crate) const CHARS: &[u8] = b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";", "file_size": 237, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\utils\\vec\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\n\npub(crate) use r#fn::*;", "file_size": 45, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n#[derive(Debug, Clone)]\npub struct WebSocketBuilder {\n    pub(crate) websocket: WebSocket,\n    pub(crate) builder: WebSocket,\n}\n\nimpl Default for WebSocketBuilder {\n    fn default() -> Self {\n        Self {\n            websocket: WebSocket::default(),\n            builder: WebSocket::default(),\n        }\n    }\n}", "file_size": 327, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\websocket\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Boxed synchronous WebSocket trait object.\npub type BoxWebSocketTrait = Box<dyn WebSocketTrait>;\n/// Boxed asynchronous WebSocket trait object.\npub type BoxAsyncWebSocketTrait = Box<dyn AsyncWebSocketTrait>;\n\n/// Internal WebSocket connection type.\n///\n/// Wraps the WebSocket connection in an Arc<AsyncMutex> for thread-safe sharing.\npub(crate) type WebSocketConnection = Arc<AsyncMutex<Option<WebSocketConnectionType>>>;", "file_size": 440, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\websocket\\shared\\type.rs", "language": "rust", "content": "use crate::*;\n\npub type WebSocketResult = Result<(), WebSocketError>;\npub type WebSocketMessageResult = Result<WebSocketMessage, WebSocketError>;", "file_size": 145, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\config\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Configuration for HTTP requests.\n///\n/// Contains settings like timeout, redirect handling, and proxy configuration.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) struct Config {\n    /// Request timeout in milliseconds.\n    pub(crate) timeout: u64,\n    /// Parsed URL components for the request.\n    pub(crate) url_obj: HttpUrlComponents,\n    /// Whether to follow redirects automatically.\n    pub(crate) redirect: bool,\n    /// Maximum number of redirects to follow.\n    pub(crate) max_redirect_times: usize,\n    /// Current number of redirects followed.\n    pub(crate) redirect_times: usize,\n    /// HTTP version to use (1.1 or 2).\n    pub(crate) http_version: HttpVersion,\n    /// Buffer size for reading responses.\n    pub(crate) buffer: usize,\n    /// Whether to decode response bodies automatically.\n    pub(crate) decode: bool,\n    /// Optional proxy configuration.\n    pub(crate) proxy: Option<ProxyConfig>,\n}\n\n/// Proxy server configuration.\n///\n/// Contains proxy type, host/port, and optional authentication.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) struct ProxyConfig {\n    /// Type of proxy (HTTP/HTTPS/SOCKS5).\n    pub(crate) proxy_type: ProxyType,\n    /// Proxy server hostname or IP address.\n    pub(crate) host: String,\n    /// Proxy server port number.\n    pub(crate) port: u16,\n    /// Optional username for proxy authentication.\n    pub(crate) username: Option<String>,\n    /// Optional password for proxy authentication.\n    pub(crate) password: Option<String>,\n}\n\n/// Supported proxy types.\n#[derive(Debug, Clone, PartialEq, Eq)]\npub(crate) enum ProxyType {\n    /// HTTP proxy.\n    Http,\n    /// HTTPS proxy.\n    Https,\n    /// SOCKS5 proxy.\n    Socks5,\n}", "file_size": 1709, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\config\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides default configuration values for HTTP requests.\n///\n/// # Returns\n///\n/// - `Config` - A configuration instance with default values:\n///   - timeout: DEFAULT_TIMEOUT\n///   - redirect: false\n///   - max_redirect_times: DEFAULT_MAX_REDIRECT_TIMES\n///   - buffer: DEFAULT_BUFFER_SIZE\n///   - decode: true\nimpl Default for Config {\n    fn default() -> Self {\n        Self {\n            timeout: DEFAULT_TIMEOUT,\n            url_obj: HttpUrlComponents::default(),\n            redirect: false,\n            max_redirect_times: DEFAULT_MAX_REDIRECT_TIMES,\n            redirect_times: 0,\n            http_version: HttpVersion::default(),\n            buffer: DEFAULT_BUFFER_SIZE,\n            decode: true,\n            proxy: None,\n        }\n    }\n}", "file_size": 766, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\response_text\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `ResponseTrait` trait for `HttpResponseText`.\n///\n/// This implementation allows `HttpResponseText` to convert between text and binary\n/// representations of HTTP responses. It provides methods for parsing raw responses, as well\n/// as accessing text and binary formats.\n///\n/// # Associated Types\n/// - `OutputText`: Specifies the text representation of an HTTP response (`HttpResponseText`).\n/// - `OutputBinary`: Specifies the binary representation of an HTTP response (`HttpResponseBinary`).\nimpl ResponseTrait for HttpResponseText {\n    type OutputText = HttpResponseText;\n    type OutputBinary = HttpResponseBinary;\n\n    /// Creates a new HttpResponseText from raw response bytes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw HTTP response bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The parsed HttpResponseText.\n    fn from(response: &[u8]) -> Self::OutputText\n    where\n        Self: Sized,\n    {\n        <HttpResponseBinary as ResponseTrait>::from(response).text()\n    }\n\n    /// Converts the response to text format.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputText` - The text representation of the response.\n    fn text(&self) -> Self::OutputText {\n        self.clone()\n    }\n\n    /// Converts the response to binary format.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpResponseBinary` - The binary representation of the response.\n    fn binary(&self) -> HttpResponseBinary {\n        let body: Vec<u8> = self\n            .body\n            .read()\n            .map_or(Vec::new(), |body| body.clone().into_bytes());\n        HttpResponseBinary {\n            http_version: self.http_version.clone(),\n            status_code: self.status_code,\n            status_text: self.status_text.clone(),\n            headers: self.headers.clone(),\n            body: Arc::new(RwLock::new(body)),\n        }\n    }\n\n    /// Decodes the response body using the specified buffer size.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The buffer size for decoding.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpResponseBinary` - The decoded binary response.\n    fn decode(&self, buffer_size: usize) -> HttpResponseBinary {\n        let http_response: HttpResponseText = self.clone();\n        let tmp_body: Vec<u8> = self\n            .body\n            .read()\n            .map_or(Vec::new(), |body| body.as_bytes().to_vec())\n            .to_vec();\n        let headers: HashMapXxHash3_64<String, String> =\n            self.headers\n                .read()\n                .map_or(hash_map_xx_hash3_64(), |headers_ref| {\n                    let mut string_headers: HashMapXxHash3_64<String, String> =\n                        hash_map_xx_hash3_64();\n                    for (key, value_deque) in headers_ref.iter() {\n                        if let Some(first_value) = value_deque.front() {\n                            string_headers.insert(key.clone(), first_value.clone());\n                        }\n                    }\n                    string_headers\n                });\n        let body: Vec<u8> = Compress::from(&headers)\n            .decode(&tmp_body, buffer_size)\n            .into_owned();\n        HttpResponseBinary {\n            http_version: http_response.http_version,\n            status_code: http_response.status_code,\n            status_text: http_response.status_text,\n            headers: http_response.headers,\n            body: Arc::new(RwLock::new(body)),\n        }\n    }\n}\n\nimpl HttpResponseText {\n    /// Retrieves the HTTP version associated with this response.\n    ///\n    /// # Returns\n    /// - `HttpVersion`: The HTTP version used for the response.\n    /// Gets the HTTP version of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpVersion` - The HTTP version.\n    pub fn get_http_version(&self) -> HttpVersion {\n        if let Ok(http_version) = self.http_version.read() {\n            return http_version\n                .to_string()\n                .parse::<HttpVersion>()\n                .unwrap_or_default();\n        }\n        return HttpVersion::default();\n    }\n\n    /// Retrieves the HTTP status code associated with this response.\n    ///\n    /// # Returns\n    /// - `ResponseStatusCode`: The HTTP status code as a usize.\n    /// Gets the HTTP status code of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseStatusCode` - The status code.\n    pub fn get_status_code(&self) -> ResponseStatusCode {\n        self.status_code\n    }\n\n    /// Retrieves the status text associated with the HTTP status code.\n    ///\n    /// # Returns\n    /// - `String`: The human-readable status text.\n    /// Gets the HTTP status text of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The status text.\n    pub fn get_status_text(&self) -> String {\n        if let Ok(status_text) = self.status_text.read() {\n            return status_text.to_string();\n        }\n        return HttpStatus::default().to_string();\n    }\n\n    /// Retrieves the headers of the HTTP response.\n    ///\n    /// # Returns\n    /// - `ResponseHeaders`: A map of header names and their corresponding values as key-value pairs.\n    /// Gets the HTTP response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseHeaders` - The response headers.\n    pub fn get_headers(&self) -> ResponseHeaders {\n        if let Ok(headers) = self.headers.read() {\n            return headers.clone();\n        }\n        return hash_map_xx_hash3_64();\n    }\n\n    /// Retrieves the body content of the HTTP response as a `String`.\n    ///\n    /// This method attempts to read the body of the response. If the body can be successfully read,\n    /// it is converted into a `String` and returned. If reading the body fails, an empty string is returned.\n    ///\n    /// # Returns\n    /// - `RequestBodyString`: The body of the response as a string. If the body could not be read,\n    ///   an empty string is returned.\n    /// Gets the HTTP response body.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBodyString` - The response body.\n    pub fn get_body(&self) -> RequestBodyString {\n        if let Ok(body) = self.body.read() {\n            return body.to_string();\n        }\n        return RequestBodyString::new();\n    }\n}\n\n/// Default implementation for HttpResponseText.\n///\n/// # Returns\n///\n/// - `HttpResponseText` - Default initialized HttpResponseText.\nimpl Default for HttpResponseText {\n    fn default() -> Self {\n        Self {\n            http_version: Arc::new(RwLock::new(HttpVersion::Unknown(String::new()))),\n            status_code: HttpStatus::Unknown.code(),\n            status_text: Arc::new(RwLock::new(HttpStatus::Unknown.to_string())),\n            headers: Arc::new(RwLock::new(hash_map_xx_hash3_64())),\n            body: Arc::new(RwLock::new(String::new())),\n        }\n    }\n}", "file_size": 6824, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\response_binary\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implements the `ResponseTrait` trait for `HttpResponseBinary`.\n///\n/// This implementation specifies the associated types for binary and text representations\n/// of HTTP responses, enabling seamless conversion and handling of HTTP response data.\n///\n/// # Associated Types\n/// - `OutputText`: Specifies the text representation of an HTTP response (`HttpResponseText`).\n/// - `OutputBinary`: Specifies the binary representation of an HTTP response (`HttpResponseBinary`).\nimpl ResponseTrait for HttpResponseBinary {\n    type OutputText = HttpResponseText;\n    type OutputBinary = HttpResponseBinary;\n    /// Creates a new HttpResponseBinary from raw response bytes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw HTTP response bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - The parsed HttpResponseBinary.\n    fn from(response: &[u8]) -> Self\n    where\n        Self: Sized,\n    {\n        let split_lines: Vec<&[u8]> = split_multi_byte(response, HTTP_BR_BYTES);\n        let mut lines: IntoIter<&[u8]> = split_lines.into_iter();\n        let status_line: &[u8] = lines.next().unwrap_or(&[]);\n        let status_parts: Vec<&[u8]> = split_whitespace(&status_line);\n        let http_version: HttpVersion = status_parts\n            .get(0)\n            .and_then(|part: &&[u8]| from_utf8(part).ok())\n            .and_then(|version_str: &str| version_str.parse::<HttpVersion>().ok())\n            .unwrap_or_default();\n        let status_code: ResponseStatusCode = status_parts\n            .get(1)\n            .and_then(|part: &&[u8]| from_utf8(part).ok())\n            .and_then(|code_str: &str| code_str.parse().ok())\n            .unwrap_or(HttpStatus::Unknown.code());\n        let status_text: String = status_parts.get(2..).map_or_else(\n            || HttpStatus::Unknown.to_string(),\n            |parts: &[&[u8]]| {\n                if parts.is_empty() {\n                    HttpStatus::Unknown.to_string()\n                } else if parts.len() == 1 {\n                    String::from_utf8_lossy(parts[0]).into_owned()\n                } else {\n                    let total_len: usize =\n                        parts.iter().map(|p: &&[u8]| p.len()).sum::<usize>() + parts.len() - 1;\n                    let mut result: String = String::with_capacity(total_len);\n                    for (i, part) in parts.iter().enumerate() {\n                        if i > 0 {\n                            result.push(' ');\n                        }\n                        result.push_str(&String::from_utf8_lossy(part));\n                    }\n                    result\n                }\n            },\n        );\n        let mut headers: HashMapXxHash3_64<String, VecDeque<String>> = hash_map_xx_hash3_64();\n        for line in lines.by_ref() {\n            if line.is_empty() {\n                break;\n            }\n            let mut colon_pos: Option<usize> = None;\n            for (i, &byte) in line.iter().enumerate() {\n                if byte == b':' {\n                    colon_pos = Some(i);\n                    break;\n                }\n            }\n            if let Some(pos) = colon_pos {\n                if pos > 0 && pos + 1 < line.len() {\n                    let key_bytes: &[u8] = &line[..pos];\n                    let value_start: usize = if line.get(pos + 1) == Some(&b' ') {\n                        pos + 2\n                    } else {\n                        pos + 1\n                    };\n                    let value_bytes: &[u8] = &line[value_start..];\n                    if let (Ok(key_str), Ok(value_str)) =\n                        (from_utf8(key_bytes), from_utf8(value_bytes))\n                    {\n                        let mut value_deque: VecDeque<String> = VecDeque::new();\n                        value_deque.push_front(value_str.trim().to_string());\n                        headers.insert(key_str.trim().to_string(), value_deque);\n                    }\n                }\n            }\n        }\n        let body: Vec<u8> = match lines.len() {\n            0 => Vec::new(),\n            1 => {\n                let line: &[u8] = lines.next().unwrap_or(&[]);\n                let mut body = Vec::with_capacity(line.len());\n                body.extend_from_slice(line);\n                body\n            }\n            _ => {\n                let lines_slice: &[&[u8]] = lines.as_slice();\n                let total_size: usize = lines_slice\n                    .iter()\n                    .map(|line: &&[u8]| line.len())\n                    .sum::<usize>()\n                    + lines_slice.len().saturating_sub(1) * BR_BYTES.len();\n                let mut body: Vec<u8> = Vec::with_capacity(total_size);\n                let mut first: bool = true;\n                for line in lines {\n                    if !first {\n                        body.extend_from_slice(BR_BYTES);\n                    }\n                    body.extend_from_slice(line);\n                    first = false;\n                }\n                body\n            }\n        };\n        HttpResponseBinary {\n            http_version: Arc::new(RwLock::new(http_version)),\n            status_code,\n            status_text: Arc::new(RwLock::new(status_text)),\n            headers: Arc::new(RwLock::new(headers)),\n            body: Arc::new(RwLock::new(body)),\n        }\n    }\n\n    /// Converts the response to binary format.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::OutputBinary` - The binary representation of the response.\n    fn binary(&self) -> Self::OutputBinary {\n        self.clone()\n    }\n\n    /// Converts the response to text format.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpResponseText` - The text representation of the response.\n    fn text(&self) -> HttpResponseText {\n        let body: String = self.body.read().map_or(String::new(), |body_ref| {\n            String::from_utf8_lossy(&body_ref).into_owned()\n        });\n        HttpResponseText {\n            http_version: Arc::clone(&self.http_version),\n            status_code: self.status_code,\n            status_text: Arc::clone(&self.status_text),\n            headers: Arc::clone(&self.headers),\n            body: Arc::new(RwLock::new(body)),\n        }\n    }\n\n    /// Decodes the response body using the specified buffer size.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The buffer size for decoding.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpResponseBinary` - The decoded binary response.\n    fn decode(&self, buffer_size: usize) -> HttpResponseBinary {\n        let decoded_body: Vec<u8> = {\n            let headers_guard = self.headers.read();\n            let body_guard = self.body.read();\n            match (headers_guard, body_guard) {\n                (Ok(headers_ref), Ok(body_ref)) => {\n                    let mut string_headers: HashMapXxHash3_64<String, String> =\n                        hash_map_xx_hash3_64();\n                    for (key, value_deque) in headers_ref.iter() {\n                        if let Some(first_value) = value_deque.front() {\n                            string_headers.insert(key.clone(), first_value.clone());\n                        }\n                    }\n                    Compress::from(&string_headers)\n                        .decode(&*body_ref, buffer_size)\n                        .into_owned()\n                }\n                _ => Vec::new(),\n            }\n        };\n        HttpResponseBinary {\n            http_version: Arc::clone(&self.http_version),\n            status_code: self.status_code,\n            status_text: Arc::clone(&self.status_text),\n            headers: Arc::clone(&self.headers),\n            body: Arc::new(RwLock::new(decoded_body)),\n        }\n    }\n}\n\nimpl HttpResponseBinary {\n    /// Retrieves the HTTP version associated with this response.\n    ///\n    /// # Returns\n    /// - `HttpVersion`: The HTTP version used for the response.\n    /// Gets the HTTP version of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `HttpVersion` - The HTTP version.\n    pub fn get_http_version(&self) -> HttpVersion {\n        if let Ok(http_version) = self.http_version.read() {\n            return http_version\n                .to_string()\n                .parse::<HttpVersion>()\n                .unwrap_or_default();\n        }\n        return HttpVersion::default();\n    }\n\n    /// Retrieves the HTTP status code associated with this response.\n    ///\n    /// # Returns\n    /// - `ResponseStatusCode`: The HTTP status code as a usize.\n    /// Gets the HTTP status code of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseStatusCode` - The status code.\n    pub fn get_status_code(&self) -> ResponseStatusCode {\n        self.status_code\n    }\n\n    /// Retrieves the status text associated with the HTTP status code.\n    ///\n    /// # Returns\n    /// - `String`: The human-readable status text.\n    /// Gets the HTTP status text of the response.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The status text.\n    pub fn get_status_text(&self) -> String {\n        if let Ok(status_text) = self.status_text.read() {\n            return status_text.to_string();\n        }\n        return HttpStatus::default().to_string();\n    }\n\n    /// Retrieves the headers of the HTTP response.\n    ///\n    /// # Returns\n    /// - `ResponseHeaders`: A map of header names and their corresponding values as key-value pairs.\n    /// Gets the HTTP response headers.\n    ///\n    /// # Returns\n    ///\n    /// - `ResponseHeaders` - The response headers.\n    pub fn get_headers(&self) -> ResponseHeaders {\n        if let Ok(headers) = self.headers.read() {\n            return headers.clone();\n        }\n        return hash_map_xx_hash3_64();\n    }\n\n    /// Retrieves the body content of the HTTP response.\n    ///\n    /// # Returns\n    /// - `RequestBody`: The body of the response in binary form (could be raw bytes, a stream, etc.).\n    /// Gets the HTTP response body.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBody` - The response body.\n    pub fn get_body(&self) -> RequestBody {\n        if let Ok(body) = self.body.read() {\n            return body.clone();\n        }\n        return RequestBody::new();\n    }\n}\n\n/// Default implementation for HttpResponseBinary.\n///\n/// # Returns\n///\n/// - `HttpResponseBinary` - Default initialized HttpResponseBinary.\nimpl Default for HttpResponseBinary {\n    fn default() -> Self {\n        Self {\n            http_version: Arc::new(RwLock::new(HttpVersion::Unknown(String::new()))),\n            status_code: HttpStatus::Unknown.code(),\n            status_text: Arc::new(RwLock::new(HttpStatus::Unknown.to_string())),\n            headers: Arc::new(RwLock::new(hash_map_xx_hash3_64())),\n            body: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n}", "file_size": 10699, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\utils\\encode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Encodes binary data into a base64 string.\n///\n/// # Arguments\n///\n/// - `&[u8]` - The binary data to encode.\n///\n/// # Returns\n///\n/// - `String` - The base64 encoded string.\npub(crate) fn base64_encode(input: &[u8]) -> String {\n    let mut result: String = String::new();\n    for chunk in input.chunks(3) {\n        let mut buf: [u8; 3] = [0u8; 3];\n        for (i, &byte) in chunk.iter().enumerate() {\n            buf[i] = byte;\n        }\n        let b: u32 = ((buf[0] as u32) << 16) | ((buf[1] as u32) << 8) | (buf[2] as u32);\n        result.push(CHARS[((b >> 18) & 63) as usize] as char);\n        result.push(CHARS[((b >> 12) & 63) as usize] as char);\n        result.push(if chunk.len() > 1 {\n            CHARS[((b >> 6) & 63) as usize] as char\n        } else {\n            '='\n        });\n        result.push(if chunk.len() > 2 {\n            CHARS[(b & 63) as usize] as char\n        } else {\n            '='\n        });\n    }\n    result\n}", "file_size": 960, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\proxy\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Asynchronous proxy tunnel stream wrapper.\n///\n/// Provides unified interface for different proxy implementations.\npub struct ProxyTunnelStream {\n    /// The underlying asynchronous read/write stream.\n    pub(super) inner: BoxAsyncReadWrite,\n    /// Pre-read data from the stream.\n    pub(super) pre_read_data: Vec<u8>,\n}\n\n/// Synchronous proxy tunnel stream wrapper.\n///\n/// Provides unified interface for different proxy implementations.\npub struct SyncProxyTunnelStream {\n    /// The underlying synchronous read/write stream.\n    pub(super) inner: BoxReadWrite,\n    /// Pre-read data from the stream.\n    pub(super) pre_read_data: Vec<u8>,\n}", "file_size": 662, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\utils\\vec\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Splits byte slice into parts by whitespace (space or tab).\n///\n/// # Arguments\n///\n/// - `&[u8]` - The input byte slice to split.\n///\n/// # Returns\n///\n/// - `Vec<&[u8]>` - Vector of byte slices split by whitespace.\npub(crate) fn split_whitespace(input: &[u8]) -> Vec<&[u8]> {\n    let mut parts: Vec<&[u8]> = Vec::new();\n    let mut start: usize = 0;\n    for (i, &byte) in input.iter().enumerate() {\n        if byte == SPACE_U8 || byte == TAB_U8 {\n            if i > start {\n                parts.push(&input[start..i]);\n            }\n            start = i + 1;\n        }\n    }\n    if start < input.len() {\n        parts.push(&input[start..]);\n    }\n    parts\n}\n\n/// Splits byte slice into parts by multi-byte delimiter.\n///\n/// # Arguments\n///\n/// - `&[u8]` - The input byte slice to split.\n/// - `&[u8]` - The delimiter byte sequence.\n///\n/// # Returns\n///\n/// - `Vec<&[u8]>` - Vector of byte slices split by delimiter.\npub(crate) fn split_multi_byte<'a>(data: &'a [u8], delimiter: &'a [u8]) -> Vec<&'a [u8]> {\n    let mut result: Vec<&[u8]> = Vec::new();\n    let mut start: usize = 0;\n    for i in 0..=data.len() {\n        if data[i..].starts_with(delimiter) {\n            result.push(&data[start..i]);\n            start = i + delimiter.len();\n        }\n    }\n    if start < data.len() {\n        result.push(&data[start..]);\n    }\n    result\n}", "file_size": 1365, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Combines AsyncRead and AsyncWrite traits with Unpin and Send bounds.\n///\n/// Provides a unified trait for asynchronous read/write operations.\npub(crate) trait AsyncReadWrite: AsyncRead + AsyncWrite + Unpin + Send {}\n\n/// Combines Read and Write traits.\n///\n/// Provides a unified trait for synchronous read/write operations.\npub(crate) trait ReadWrite: Read + Write {}\n\n/// Asynchronous HTTP request trait.\n///\n/// Defines the interface for sending asynchronous HTTP requests.\npub trait AsyncRequestTrait: Send + Debug {\n    /// The result type of the asynchronous request.\n    type RequestResult: Sized;\n\n    /// Sends the HTTP request asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `Pin<Box<dyn Future<Output = Self::RequestResult> + Send + '_>>` -\n    ///   A pinned boxed future representing the asynchronous operation.\n    fn send(&mut self) -> Pin<Box<dyn Future<Output = Self::RequestResult> + Send + '_>>;\n}\n\n/// Synchronous HTTP request trait.\n///\n/// Defines the interface for sending synchronous HTTP requests.\npub trait RequestTrait: Send + Debug {\n    /// The result type of the synchronous request.\n    type RequestResult: Sized;\n\n    /// Sends the HTTP request synchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `Self::RequestResult` - The result of the synchronous request.\n    fn send(&mut self) -> Self::RequestResult;\n}", "file_size": 1378, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\common\\const.rs", "language": "rust", "content": "use crate::*;\n\n/// A single space character.\n///\n/// This constant is used to represent a space character in string\n/// or byte operations.\npub const SPACE: &str = \" \";\n\n/// The byte representation of a single space character.\n///\n/// This constant provides the byte equivalent of the space character\n/// for use in low-level operations.\npub const SPACE_U8: u8 = SPACE.as_bytes()[0];\n\n/// A tab character.\n///\n/// This constant is used to represent a tab character in string\n/// or byte operations.\npub const TAB: &str = \"\\t\";\n\n/// The byte representation of a tab character.\n///\n/// This constant provides the byte equivalent of the tab character\n/// for use in low-level operations.\npub const TAB_U8: u8 = TAB.as_bytes()[0];\n\n/// A line break character (newline).\n///\n/// This constant is used to represent a line break character in\n/// string or byte operations.\npub const BR: &str = \"\\n\";\n\n/// A const byte slice representation of the string `BR`.\npub const BR_BYTES: &[u8] = BR.as_bytes();\n\n/// A colon followed by a space (`: `).\n///\n/// This constant is commonly used in formatted strings, such as\n/// headers or key-value pairs, where a colon and a space are needed.\npub const COLON_SPACE: &str = \": \";\n\n/// The byte representation of the first character in the `COLON_SPACE`.\n///\n/// This constant provides the byte equivalent of the colon character\n/// from the `COLON_SPACE` string.\npub const COLON_SPACE_BYTES: &[u8] = COLON_SPACE.as_bytes();\n\n/// A colon followed by a space symbol (`:`).\n///\n/// This constant is commonly used in formatted strings, such as\n/// headers or key-value pairs, where a colon and a space are needed.\npub const COLON_SPACE_SYMBOL: &str = \":\";\n\n/// A query symbol (`?`).\n///\n/// This constant represents the question mark character, which is\n/// commonly used to denote the beginning of a query string in a URL.\npub const QUERY_SYMBOL: &str = \"?\";\n\n/// A hash symbol (`#`).\n///\n/// This constant represents the hash character, which is used to\n/// identify a fragment or anchor in a URL.\npub const HASH_SYMBOL: &str = \"#\";\n\n/// An empty string.\n///\n/// This constant represents an empty string, which can be used as a\n/// default or placeholder value.\npub const EMPTY_STR: &str = \"\";\n\n/// The default host address.\n///\n/// This constant represents the default host address, which is typically\n/// used to bind a server to all available network interfaces.\npub const DEFAULT_HOST: &str = \"0.0.0.0\";\n\n/// The default web port.\n///\n/// This constant represents the default port for HTTP traffic.\npub const DEFAULT_WEB_PORT: usize = 80;\n\n/// An HTTP line break (`\\r\\n`).\n///\n/// This constant represents the standard line break sequence used in\n/// the HTTP protocol.\npub const HTTP_BR: &str = \"\\r\\n\";\n\n/// The byte representation of an HTTP line break.\n///\n/// This constant provides the byte equivalent of the HTTP line break\n/// for use in low-level network operations.\npub const HTTP_BR_BYTES: &[u8] = HTTP_BR.as_bytes();\n\n/// A double HTTP line break (`\\r\\n\\r\\n`).\n///\n/// This constant represents the sequence used to separate headers\n/// from the body in an HTTP message.\npub const HTTP_DOUBLE_BR: &str = \"\\r\\n\\r\\n\";\n\n/// The byte representation of a double HTTP line break.\n///\n/// This constant provides the byte equivalent of the double HTTP line\n/// break for use in parsing and constructing HTTP messages.\npub const HTTP_DOUBLE_BR_BYTES: &[u8] = HTTP_DOUBLE_BR.as_bytes();\n\n/// The default HTTP path.\n///\n/// This constant represents the root path of a URL, which is used\n/// when no specific path is provided.\npub const DEFAULT_HTTP_PATH: &str = \"/\";\n\n/// The byte representation of the default HTTP path.\n///\n/// This constant provides the byte equivalent of the default HTTP path\n/// for use in low-level operations.\npub const DEFAULT_HTTP_PATH_BYTES: &[u8] = DEFAULT_HTTP_PATH.as_bytes();\n\n/// An ampersand character (`&`).\n///\n/// This constant represents the ampersand character, which is used\n/// to separate query parameters in a URL.\npub const AND: &str = \"&\";\n\n/// The byte representation of an ampersand character.\n///\n/// This constant provides the byte equivalent of the ampersand character\n/// for use in URL parsing and construction.\npub const AND_BYTES: &[u8] = AND.as_bytes();\n\n/// An equal sign (`=`).\n///\n/// This constant represents the equal sign, which is used to separate\n/// keys and values in query parameters.\npub const EQUAL: &str = \"=\";\n\n/// The byte representation of an equal sign.\n///\n/// This constant provides the byte equivalent of the equal sign for\n/// use in URL parsing and construction.\npub const EQUAL_BYTES: &[u8] = EQUAL.as_bytes();\n\n/// The string representation of the number zero.\n///\n/// This constant represents the character '0' as a string.\npub const ZERO_STR: &str = \"0\";\n\n/// The byte representation of the number zero.\n///\n/// This constant provides the byte equivalent of the character '0'.\npub const ZERO_STR_BYTES: &[u8] = ZERO_STR.as_bytes();\n\n/// The default buffer size.\n///\n/// This constant defines the default size for buffers used in I/O\n/// operations, such as reading from a network stream.\npub const DEFAULT_BUFFER_SIZE: usize = 4096;\n\n/// The default maximum number of redirect times.\n///\n/// This constant specifies the default limit for the number of times\n/// an HTTP client should follow a redirect.\npub const DEFAULT_MAX_REDIRECT_TIMES: usize = 8;\n\n/// The default timeout value.\n///\n/// This constant represents the default timeout for operations, which\n/// is set to the maximum value of `u64` to indicate no timeout.\npub const DEFAULT_TIMEOUT: u64 = u64::MAX;\n\n/// A point character (`.`).\n///\n/// This constant represents the period or dot character, which is\n/// often used as a separator in file names or domain names.\npub const POINT: &str = \".\";\n\n/// The root path.\n///\n/// This constant represents the root path in a file system or URL.\npub const ROOT_PATH: &str = \"/\";\n\n/// A semicolon character (`;`).\n///\n/// This constant represents the semicolon character, which is used\n/// as a separator in various contexts.\npub const SEMICOLON: &str = \";\";\n\n/// A semicolon followed by a space (`; `).\n///\n/// This constant represents a semicolon followed by a space, which is\n/// commonly used as a separator in formatted text.\npub const SEMICOLON_SPACE: &str = \"; \";\n\n/// A globally unique identifier (GUID) for WebSocket connections.\n///\n/// This constant is used in the WebSocket handshake process to create\n/// the `Sec-WebSocket-Accept` header.\npub const GUID: &[u8; 36] = b\"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n\n/// The initial hash state for SHA-1.\n///\n/// This constant represents the initial values used in the SHA-1\n/// hashing algorithm.\npub const HASH_STATE: [u32; 5] = [\n    0x67452301u32,\n    0xEFCDAB89,\n    0x98BADCFE,\n    0x10325476,\n    0xC3D2E1F0,\n];\n\n/// The Base64 character set table.\n///\n/// This constant contains the characters used for Base64 encoding.\npub const BASE64_CHARSET_TABLE: &[u8] =\n    b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n/// The maximum frame size for WebSockets.\n///\n/// This constant defines the maximum size of a WebSocket frame that\n/// can be processed.\npub const MAX_FRAME_SIZE: usize = 65535;\n\n/// The maximum number of attempts to decode a UTF-8 character.\n///\n/// This constant specifies the maximum number of bytes that can be\n/// part of a single UTF-8 character.\npub const MAX_UTF8_ATTEMPTS: usize = 4;\n\n/// The default socket address.\n///\n/// This constant represents a default, unspecified socket address.\npub const DEFAULT_SOCKET_ADDR: SocketAddr =\n    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(0, 0, 0, 0), 0));\n\n/// The loopback socket address (127.0.0.1).\n///\n/// This constant represents the loopback address, which is used for\n/// local network communication.\npub const SOCKET_ADDR_127_0_0_1: SocketAddr =\n    SocketAddr::V4(SocketAddrV4::new(Ipv4Addr::new(127, 0, 0, 1), 0));\n\n/// The string \"hyperlane\".\n///\n/// This constant is used for identification or naming purposes.\npub const HYPERLANE: &str = \"hyperlane\";\n\n/// The string \"Hyperlane\" in PascalCase.\n///\n/// This constant is a PascalCase version of the \"hyperlane\" string.\npub const HYPERLANE_PASCAL_CASE: &str = \"Hyperlane\";\n\n/// The string \"Hyperlane\" in UpperCase.\n///\n/// This constant is a UpperCase version of the \"hyperlane\" string.\npub const HYPERLANE_UPPERCASE: &str = \"HYPERLANE\";\n\n/// The default setting for inner printing.\n///\n/// This constant determines whether internal printing is enabled by\n/// default.\npub const DEFAULT_INNER_PRINT: bool = true;\n\n/// The default setting for inner logging.\n///\n/// This constant determines whether internal logging is enabled by\n/// default.\npub const DEFAULT_INNER_LOG: bool = true;\n\n/// The default setting for TCP_NODELAY.\n///\n/// This constant specifies the default value for the `TCP_NODELAY`\n/// socket option.\npub const DEFAULT_NODELAY: Option<bool> = None;\n\n/// The default setting for socket linger.\n///\n/// This constant specifies the default value for the `SO_LINGER`\n/// socket option.\npub const DEFAULT_LINGER: Option<Duration> = None;\n\n/// The default time-to-live (TTL) setting.\n///\n/// This constant specifies the default value for the IP_TTL socket\n/// option.\npub const DEFAULT_TTI: Option<u32> = None;\n\n/// The string \"warning\".\n///\n/// This constant is used to represent a warning message type.\npub const WARNING: &str = \"warning\";\n\n/// The string \"success\".\n///\n/// This constant is used to represent a success message type.\npub const SUCCESS: &str = \"success\";\n\n/// The string \"fail\".\n///\n/// This constant is used to represent a failure message type.\npub const FAIL: &str = \"fail\";\n\n/// The string \"error\".\n///\n/// This constant is used to represent an error message type.\npub const ERROR: &str = \"error\";\n\n/// The string \"info\".\n///\n/// This constant is used to represent an informational message type.\npub const INFO: &str = \"info\";\n\n/// The string \"debug\".\n///\n/// This constant is used to represent a debug message type.\npub const DEBUG: &str = \"debug\";\n\n/// The string \"plain\".\n///\n/// This constant is used to represent plain text content.\npub const PLAIN: &str = \"plain\";\n\n/// The string \"binary\".\n///\n/// This constant is used to represent binary content.\npub const BINARY: &str = \"binary\";", "file_size": 10252, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\shared\\struct.rs", "language": "rust", "content": "/// A shared builder for constructing HTTP requests.\npub(crate) struct SharedRequestBuilder;\n\n/// A shared handler for processing HTTP responses.\npub(crate) struct SharedResponseHandler;", "file_size": 186, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\response_binary\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// A struct representing an HTTP response.\n///\n/// This struct contains all the components of an HTTP response: the HTTP version, status code,\n/// status text, headers, and body. It is used to model and manipulate HTTP responses within the\n/// application.\n///\n/// # Fields\n/// - `http_version`: A string representing the HTTP version.\n/// - `status_code`: The HTTP status code.\n/// - `status_text`: A string containing the status text associated with the status code.\n/// - `headers`: A `HashMap<String, String>` containing the headers of the response, where each key is the header name\n///   and the value is the corresponding header value.\n/// - `body`: A `Vec<u8>` representing the body of the HTTP response, which contains the content being returned.\n#[derive(Debug, Clone)]\npub struct HttpResponseBinary {\n    /// HTTP protocol version.\n    pub(crate) http_version: ArcRwLock<HttpVersion>,\n    /// HTTP response status code.\n    pub(crate) status_code: ResponseStatusCode,\n    /// HTTP response status text.\n    pub(crate) status_text: ArcRwLock<String>,\n    /// HTTP response headers.\n    pub(crate) headers: ArcRwLock<ResponseHeaders>,\n    /// HTTP response body content.\n    pub(crate) body: ArcRwLock<RequestBody>,\n}", "file_size": 1242, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\response\\response_text\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// A struct representing an HTTP response.\n///\n/// This struct contains all the components of an HTTP response: the HTTP version, status code,\n/// status text, headers, and body. It is used to model and manipulate HTTP responses within the\n/// application.\n///\n/// # Fields\n/// - `http_version`: A string representing the HTTP version.\n/// - `status_code`: The HTTP status code.\n/// - `status_text`: A string containing the status text associated with the status code.\n/// - `headers`: A `HashMap<String, String>` containing the headers of the response, where each key is the header name\n///   and the value is the corresponding header value.\n/// - `body`: A `Vec<u8>` representing the body of the HTTP response, which contains the content being returned.\n#[derive(Debug, Clone)]\npub struct HttpResponseText {\n    /// HTTP protocol version.\n    pub(crate) http_version: ArcRwLock<HttpVersion>,\n    /// HTTP response status code.\n    pub(crate) status_code: ResponseStatusCode,\n    /// HTTP response status text.\n    pub(crate) status_text: ArcRwLock<String>,\n    /// HTTP response headers.\n    pub(crate) headers: ArcRwLock<ResponseHeaders>,\n    /// HTTP response body content.\n    pub(crate) body: ArcRwLock<RequestBodyString>,\n}", "file_size": 1246, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Default for RequestBuilder {\n    fn default() -> Self {\n        Self {\n            http_request: HttpRequest::default(),\n            builder: HttpRequest::default(),\n        }\n    }\n}\n\nimpl RequestBuilder {\n    /// Creates a new RequestBuilder instance.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestBuilder` - A new builder instance with default values.\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Sets the HTTP method to POST and the request URL.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The request URL.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn post(&mut self, url: &str) -> &mut Self {\n        self.http_request.methods = Arc::new(Method::POST);\n        self.url(url);\n        self\n    }\n\n    /// Sets the HTTP method to GET and the request URL.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The request URL.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn get(&mut self, url: &str) -> &mut Self {\n        self.http_request.methods = Arc::new(Method::GET);\n        self.url(url);\n        self\n    }\n\n    /// Sets the request URL.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The request URL.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    fn url(&mut self, url: &str) -> &mut Self {\n        self.http_request.url = Arc::new(url.to_owned());\n        self\n    }\n\n    /// Forces HTTP/1.1 protocol version.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn http1_1_only(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.http_version = HttpVersion::HTTP1_1;\n        }\n        self\n    }\n\n    /// Forces HTTP/2 protocol version.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn http2_only(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.http_version = HttpVersion::HTTP2;\n        }\n        self\n    }\n\n    /// Sets request headers.\n    ///\n    /// # Arguments\n    ///\n    /// - `HashMapXxHash3_64<K, V>` - The headers to set.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn headers<K, V>(&mut self, header: HashMapXxHash3_64<K, V>) -> &mut Self\n    where\n        K: ToString,\n        V: ToString,\n    {\n        if let Some(tmp_header) = Arc::get_mut(&mut self.http_request.header) {\n            for (key, value) in header {\n                let key_str: String = key.to_string();\n                let value_str: String = value.to_string();\n                let mut found_existing: bool = false;\n                let mut existing_key: Option<String> = None;\n                for existing_key_ref in tmp_header.keys() {\n                    if existing_key_ref.eq_ignore_ascii_case(&key_str) {\n                        existing_key = Some(existing_key_ref.clone());\n                        found_existing = true;\n                        break;\n                    }\n                }\n                if found_existing {\n                    if let Some(existing_key) = existing_key {\n                        tmp_header.remove(&existing_key);\n                    }\n                }\n                let mut value_deque: VecDeque<String> = VecDeque::new();\n                value_deque.push_front(value_str);\n                tmp_header.insert(key_str, value_deque);\n            }\n        }\n        self\n    }\n\n    /// Sets JSON request body.\n    ///\n    /// # Arguments\n    ///\n    /// - `JsonValue` - The JSON body data.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn json(&mut self, body: JsonValue) -> &mut Self {\n        if let JsonValue::Object(map) = body {\n            let mut res_body: HashMapXxHash3_64<String, JsonValue> = hash_map_xx_hash3_64();\n            for (k, v) in map.iter() {\n                res_body.insert(k.to_string(), v.clone());\n            }\n            self.http_request.body = Arc::new(Body::Json(res_body));\n        }\n        self\n    }\n\n    /// Sets plain text request body.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The text body data (must implement ToString).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn text<T: ToString>(&mut self, body: T) -> &mut Self {\n        self.http_request.body = Arc::new(Body::Text(body.to_string()));\n        self\n    }\n\n    /// Sets binary request body.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - The binary body data (must implement Into<Vec<u8>>).\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn body<T: Into<Vec<u8>>>(&mut self, body: T) -> &mut Self {\n        self.http_request.body = Arc::new(Body::Binary(body.into()));\n        self\n    }\n\n    /// Sets the timeout value for the current connection.\n    ///\n    /// This method sets the timeout duration for the connection, which is used to determine\n    /// how long the system should wait for a response before considering the connection attempt\n    /// as failed. The timeout value is stored in an `Arc` to allow it to be shared safely across\n    /// multiple threads if needed.\n    ///\n    /// # Arguments\n    ///\n    /// - `u64` - The timeout duration in seconds. This value will be used to configure the\n    ///   connection timeout.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn timeout(&mut self, timeout: u64) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.timeout = timeout;\n        }\n        self\n    }\n\n    /// Enables HTTP redirection for the request.\n    ///\n    /// This method sets the `redirect` property of the `http_request` to `true`.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn redirect(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.redirect = true;\n        }\n        self\n    }\n\n    /// Unenables HTTP redirection for the request.\n    ///\n    /// This method sets the `redirect` property of the `http_request` to `false`.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - The builder for method chaining.\n    pub fn unredirect(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.redirect = false;\n        };\n        self\n    }\n\n    /// Sets the maximum number of allowed redirections for the HTTP request.\n    ///\n    /// This method updates the `max_redirect_times` field in the configuration and returns a mutable\n    /// reference to `self` to enable method chaining.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The maximum number of redirections allowed. A value of `0` disables redirection.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance for method chaining.\n    ///\n    /// # Notes\n    ///\n    /// Ensure that the value provided to `num` is within a valid range. Excessively high values\n    /// may lead to performance issues or unintended behavior.\n    pub fn max_redirect_times(&mut self, num: usize) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.max_redirect_times = num;\n        }\n        self\n    }\n\n    /// Sets the buffer size for the HTTP request configuration.\n    ///\n    /// This method allows you to set the size of the buffer used for reading\n    /// the HTTP response. It modifies the `buffer` field of the HTTP request's\n    /// configuration, which will be used when processing the response data.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - The size of the buffer to be used, in bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - Returns a mutable reference to `self`, allowing for method chaining.\n    pub fn buffer(&mut self, buffer: usize) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.buffer = buffer;\n        }\n        self\n    }\n\n    /// Enables automatic response decoding.\n    ///\n    /// When enabled, the response body will be automatically decompressed if it is encoded\n    /// using a supported compression format.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn decode(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.decode = true;\n        }\n        self\n    }\n\n    /// Disables automatic response decoding.\n    ///\n    /// When disabled, the response body will not be automatically decompressed,\n    /// and the raw encoded data will be returned as-is.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn undecode(&mut self) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.decode = false;\n        }\n        self\n    }\n\n    /// Sets an HTTP proxy for the request.\n    ///\n    /// This method configures the request to use an HTTP proxy server.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn http_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Http,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    /// Sets an HTTPS proxy for the request.\n    ///\n    /// This method configures the request to use an HTTPS proxy server.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn https_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Https,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    /// Sets a SOCKS5 proxy for the request.\n    ///\n    /// This method configures the request to use a SOCKS5 proxy server.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn socks5_proxy(&mut self, host: &str, port: u16) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Socks5,\n                host: host.to_string(),\n                port,\n                username: None,\n                password: None,\n            });\n        }\n        self\n    }\n\n    /// Sets an HTTP proxy with authentication for the request.\n    ///\n    /// This method configures the request to use an HTTP proxy server with username and password authentication.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    /// - `str` - The username for proxy authentication.\n    /// - `str` - The password for proxy authentication.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn http_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Http,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    /// Sets an HTTPS proxy with authentication for the request.\n    ///\n    /// This method configures the request to use an HTTPS proxy server with username and password authentication.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    /// - `str` - The username for proxy authentication.\n    /// - `str` - The password for proxy authentication.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn https_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Https,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    /// Sets a SOCKS5 proxy with authentication for the request.\n    ///\n    /// This method configures the request to use a SOCKS5 proxy server with username and password authentication.\n    ///\n    /// # Arguments\n    ///\n    /// - `str` - The hostname or IP address of the proxy server.\n    /// - `u16` - The port number of the proxy server.\n    /// - `str` - The username for proxy authentication.\n    /// - `str` - The password for proxy authentication.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut RequestBuilder` - A mutable reference to the current instance, allowing for method chaining.\n    pub fn socks5_proxy_auth(\n        &mut self,\n        host: &str,\n        port: u16,\n        username: &str,\n        password: &str,\n    ) -> &mut Self {\n        if let Ok(mut config) = self.http_request.config.write() {\n            config.proxy = Some(ProxyConfig {\n                proxy_type: ProxyType::Socks5,\n                host: host.to_string(),\n                port,\n                username: Some(username.to_string()),\n                password: Some(password.to_string()),\n            });\n        }\n        self\n    }\n\n    /// Finalizes the builder and returns a fully constructed async `HttpRequest` instance.\n    ///\n    /// This method takes the current configuration stored in `http_request`, creates a new\n    /// `HttpRequest` instance with the configuration, and resets the builder's temporary\n    /// state for further use.\n    ///\n    /// # Returns\n    ///\n    /// - `BoxAsyncRequestTrait` - Returns a fully constructed `BoxAsyncRequestTrait` instance based on the current builder state.\n    pub fn build_async(&mut self) -> BoxAsyncRequestTrait {\n        self.builder = self.http_request.clone();\n        self.http_request = HttpRequest::default();\n        Box::new(self.builder.clone())\n    }\n\n    /// Finalizes the builder and returns a fully constructed synchronous `HttpRequest` instance.\n    ///\n    /// This method takes the current configuration stored in `http_request`, creates a new\n    /// `HttpRequest` instance with the configuration, and resets the builder's temporary\n    /// state for further use.\n    ///\n    /// # Returns\n    ///\n    /// - `BoxRequestTrait` - Returns a fully constructed `BoxRequestTrait` instance based on the current builder state.\n    pub fn build_sync(&mut self) -> BoxRequestTrait {\n        self.builder = self.http_request.clone();\n        self.http_request = HttpRequest::default();\n        Box::new(self.builder.clone())\n    }\n}", "file_size": 16708, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#trait;\npub(crate) mod r#type;\n\npub use r#trait::*;\npub use r#type::*;\n\npub(crate) use r#const::*;\npub(crate) use r#struct::*;", "file_size": 214, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\shared\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl SharedRequestBuilder {\n    /// Constructs an HTTP request byte vector.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The HTTP method.\n    /// - `String` - The request path.\n    /// - `Vec<u8>` - The raw bytes of the request headers.\n    /// - `Option<Vec<u8>>` - The optional raw bytes of the request body.\n    /// - `String` - The HTTP version string.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - The complete HTTP request as a byte vector.\n    pub(crate) fn build_http_request(\n        method: &str,\n        path: String,\n        header_bytes: Vec<u8>,\n        body_bytes: Option<Vec<u8>>,\n        http_version_str: String,\n    ) -> Vec<u8> {\n        let request_line_size: usize = method.len() + 1 + path.len() + 1 + http_version_str.len();\n        let body_size: usize = body_bytes.as_ref().map_or(0, |b| b.len());\n        let total_size: usize = request_line_size + 2 + header_bytes.len() + 2 + body_size;\n        let mut request: Vec<u8> = Vec::with_capacity(total_size);\n        request.extend_from_slice(method.as_bytes());\n        request.push(b' ');\n        request.extend_from_slice(path.as_bytes());\n        request.push(b' ');\n        request.extend_from_slice(http_version_str.as_bytes());\n        request.extend_from_slice(HTTP_BR_BYTES);\n        request.extend_from_slice(&header_bytes);\n        request.extend_from_slice(HTTP_BR_BYTES);\n        if let Some(body) = body_bytes {\n            request.extend_from_slice(&body);\n        }\n        request\n    }\n\n    /// Constructs an HTTP GET request byte vector.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The request path.\n    /// - `Vec<u8>` - The raw bytes of the request headers.\n    /// - `String` - The HTTP version string.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - The complete HTTP GET request as a byte vector.\n    pub(crate) fn build_get_request(\n        path: String,\n        header_bytes: Vec<u8>,\n        http_version_str: String,\n    ) -> Vec<u8> {\n        Self::build_http_request(\"GET\", path, header_bytes, None, http_version_str)\n    }\n\n    /// Constructs an HTTP POST request byte vector.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The request path.\n    /// - `Vec<u8>` - The raw bytes of the request headers.\n    /// - `Vec<u8>` - The raw bytes of the request body.\n    /// - `String` - The HTTP version string.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - The complete HTTP POST request as a byte vector.\n    pub(crate) fn build_post_request(\n        path: String,\n        header_bytes: Vec<u8>,\n        body_bytes: Vec<u8>,\n        http_version_str: String,\n    ) -> Vec<u8> {\n        Self::build_http_request(\n            \"POST\",\n            path,\n            header_bytes,\n            Some(body_bytes),\n            http_version_str,\n        )\n    }\n}\n\nimpl SharedResponseHandler {\n    /// Parses response headers to extract status code, content length, and redirect URL.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw bytes of the response headers.\n    /// - `&[u8]` - The raw bytes of the HTTP version.\n    /// - `&[u8]` - The byte pattern to identify the \"Location\" header.\n    /// - `&mut usize` - A mutable reference to store the content length.\n    /// - `&mut Option<Vec<u8>>` - A mutable reference to store the redirect URL if present.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<(), RequestError>` - Ok if parsing is successful, Err otherwise.\n    pub(crate) fn parse_response_headers(\n        headers_bytes: &[u8],\n        http_version_bytes: &[u8],\n        location_sign_key: &[u8],\n        content_length: &mut usize,\n        redirect_url: &mut Option<Vec<u8>>,\n    ) -> Result<(), RequestError> {\n        if let Some(status_pos) =\n            Self::find_pattern_case_insensitive(headers_bytes, http_version_bytes)\n        {\n            let status_code_start: usize = status_pos + http_version_bytes.len() + 1;\n            let status_code_end: usize = status_code_start + 3;\n            if status_code_end <= headers_bytes.len() {\n                let status_code: usize =\n                    Self::parse_status_code(&headers_bytes[status_code_start..status_code_end]);\n\n                if (300..=399).contains(&status_code) {\n                    if let Some(location_pos) =\n                        Self::find_pattern_case_insensitive(headers_bytes, location_sign_key)\n                    {\n                        let start: usize = location_pos + location_sign_key.len();\n                        if let Some(end_pos) = Self::find_crlf(headers_bytes, start) {\n                            let mut url_vec = Vec::with_capacity(end_pos - start);\n                            url_vec.extend_from_slice(&headers_bytes[start..end_pos]);\n                            *redirect_url = Some(url_vec);\n                        }\n                    }\n                }\n            }\n        }\n        *content_length = Self::get_content_length(headers_bytes);\n        Ok(())\n    }\n\n    /// Finds a pattern within a byte slice, ignoring case.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The haystack (the byte slice to search within).\n    /// - `&[u8]` - The needle (the byte slice to search for).\n    ///\n    /// # Returns\n    ///\n    /// - `Option<usize>` - The starting index of the first occurrence of the needle in the haystack,\n    ///   or None if not found.\n    pub(crate) fn find_pattern_case_insensitive(haystack: &[u8], needle: &[u8]) -> Option<usize> {\n        if needle.is_empty() || haystack.len() < needle.len() {\n            return None;\n        }\n        let needle_len: usize = needle.len();\n        let search_len: usize = haystack.len() - needle_len + 1;\n        let first_needle_lower: u8 = needle[0].to_ascii_lowercase();\n        'outer: for i in 0..search_len {\n            if haystack[i].to_ascii_lowercase() != first_needle_lower {\n                continue;\n            }\n            for j in 1..needle_len {\n                if haystack[i + j].to_ascii_lowercase() != needle[j].to_ascii_lowercase() {\n                    continue 'outer;\n                }\n            }\n            return Some(i);\n        }\n        None\n    }\n\n    /// Finds the position of the Carriage Return Line Feed (CRLF) sequence in a byte slice.\n    ///\n    /// Searches for `\\r\\n` starting from the specified index.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to search within.\n    /// - `usize` - The starting index for the search.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<usize>` - The index where the CRLF sequence starts, or None if not found.\n    pub(crate) fn find_crlf(data: &[u8], start: usize) -> Option<usize> {\n        let search_data: &[u8] = &data[start..];\n        for i in 0..search_data.len().saturating_sub(1) {\n            if search_data[i] == b'\\r' && search_data[i + 1] == b'\\n' {\n                return Some(start + i);\n            }\n        }\n        None\n    }\n\n    /// Finds the position of the double Carriage Return Line Feed (CRLF) sequence in a byte slice.\n    ///\n    /// Searches for `\\r\\n\\r\\n` starting from the specified index.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The data to search within.\n    /// - `usize` - The starting index for the search.\n    ///\n    /// # Returns\n    ///\n    /// - `Option<usize>` - The index where the double CRLF sequence starts, or None if not found.\n    pub(crate) fn find_double_crlf(data: &[u8], start: usize) -> Option<usize> {\n        let search_data: &[u8] = &data[start..];\n        for i in 0..search_data.len().saturating_sub(3) {\n            if search_data[i] == b'\\r'\n                && search_data[i + 1] == b'\\n'\n                && search_data[i + 2] == b'\\r'\n                && search_data[i + 3] == b'\\n'\n            {\n                return Some(start + i);\n            }\n        }\n        None\n    }\n\n    /// Extracts the Content-Length value from response bytes.\n    ///\n    /// Searches for the \"Content-Length\" header and parses its value.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The raw bytes of the HTTP response.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The content length value, or 0 if not found or parsing fails.\n    pub(crate) fn get_content_length(response_bytes: &[u8]) -> usize {\n        if let Some(pos) =\n            Self::find_pattern_case_insensitive(response_bytes, CONTENT_LENGTH_PATTERN)\n        {\n            let value_start: usize = pos + CONTENT_LENGTH_PATTERN.len();\n            let value_start: usize = if response_bytes.get(value_start) == Some(&b' ') {\n                value_start + 1\n            } else {\n                value_start\n            };\n            if let Some(end_pos) = Self::find_crlf(response_bytes, value_start) {\n                let value_bytes: &[u8] = &response_bytes[value_start..end_pos];\n                return Self::parse_decimal_bytes(value_bytes);\n            }\n        }\n        0\n    }\n\n    /// Parses a byte slice representing a decimal number into a `usize`.\n    ///\n    /// Skips leading whitespace and stops at the first non-digit character.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The byte slice containing the decimal number.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The parsed decimal value.\n    pub(crate) fn parse_decimal_bytes(bytes: &[u8]) -> usize {\n        let mut result: usize = 0;\n        let mut started: bool = false;\n        for &byte in bytes {\n            match byte {\n                b'0'..=b'9' => {\n                    started = true;\n                    result = result * 10 + (byte - b'0') as usize;\n                }\n                b' ' | b'\\t' if !started => continue,\n                _ => break,\n            }\n        }\n        result\n    }\n\n    /// Parses a byte slice representing an HTTP status code into a `usize`.\n    ///\n    /// Expects a 3-digit status code.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The byte slice containing the status code.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The parsed status code, or 0 if parsing fails or the input is invalid.\n    pub(crate) fn parse_status_code(status_bytes: &[u8]) -> usize {\n        if status_bytes.len() != 3 {\n            return 0;\n        }\n        let mut result: usize = 0;\n        for &byte in status_bytes {\n            if byte >= b'0' && byte <= b'9' {\n                result = result * 10 + (byte - b'0') as usize;\n            } else {\n                return 0;\n            }\n        }\n        result\n    }\n\n    /// Calculates a new buffer capacity based on current capacity and needed size.\n    ///\n    /// This function determines an appropriate buffer size, typically doubling the current\n    /// capacity or increasing it by 50% of the needed capacity, ensuring efficient memory allocation.\n    ///\n    /// # Arguments\n    ///\n    /// - `&[u8]` - The current response bytes.\n    /// - `usize` - The number of additional bytes needed.\n    /// - `usize` - The current buffer capacity.\n    ///\n    /// # Returns\n    ///\n    /// - `usize` - The recommended new buffer capacity. Returns 0 if no increase is needed.\n    pub(crate) fn calculate_buffer_capacity(\n        response_bytes: &[u8],\n        n: usize,\n        current_capacity: usize,\n    ) -> usize {\n        if response_bytes.len() + n <= current_capacity {\n            return 0;\n        }\n\n        let needed_cap: usize = response_bytes.len() + n;\n        if current_capacity == 0 {\n            needed_cap.max(1024)\n        } else if needed_cap <= current_capacity * 2 {\n            current_capacity * 2\n        } else {\n            (needed_cap * 3) / 2\n        }\n    }\n}", "file_size": 11606, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Blanket implementation for AsyncReadWrite trait.\n///\n/// # Generic Parameters\n///\n/// - `T` - Type implementing AsyncRead + AsyncWrite + Unpin + Send\nimpl<T: AsyncRead + AsyncWrite + Unpin + Send> AsyncReadWrite for T {}\n\n/// Blanket implementation for ReadWrite trait.\n///\n/// # Generic Parameters\n///\n/// - `T` - Type implementing Read + Write\nimpl<T: Read + Write> ReadWrite for T {}\n\n/// Async request trait implementation for HttpRequest.\n///\n/// # Associated Types\n///\n/// - `RequestResult` - The result type of async requests.\n///\n/// # Returns\n///\n/// - `Pin<Box<dyn Future<Output = RequestResult> + Send + '_>>` - Future representing the async request.\nimpl AsyncRequestTrait for HttpRequest {\n    type RequestResult = RequestResult;\n\n    /// Sends an asynchronous HTTP request.\n    ///\n    /// # Returns\n    ///\n    /// - `Pin<Box<dyn Future<Output = RequestResult> + Send + '_>>` - Future representing the async request.\n    fn send(&mut self) -> Pin<Box<dyn Future<Output = Self::RequestResult> + Send + '_>> {\n        Box::pin(self.send_async())\n    }\n}\n\n/// Sync request trait implementation for HttpRequest.\n///\n/// # Associated Types\n///\n/// - `RequestResult` - The result type of sync requests.\n///\n/// # Returns\n///\n/// - `RequestResult` - Result of the sync request.\nimpl RequestTrait for HttpRequest {\n    type RequestResult = RequestResult;\n\n    /// Sends a synchronous HTTP request.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestResult` - Result of the sync request.\n    fn send(&mut self) -> Self::RequestResult {\n        self.send_sync()\n    }\n}\n\n/// Default implementation for HttpRequest.\n///\n/// # Returns\n///\n/// - `HttpRequest` - Default initialized HttpRequest with:\n///   - Empty methods\n///   - Empty URL\n///   - Empty headers\n///   - Default body\n///   - Default config\n///   - Default tmp storage\n///   - Default response\nimpl Default for HttpRequest {\n    fn default() -> Self {\n        Self {\n            methods: Arc::new(Method::new()),\n            url: Arc::new(String::new()),\n            header: Arc::new(hash_map_xx_hash3_64()),\n            body: Arc::new(Body::default()),\n            config: Arc::new(RwLock::new(Config::default())),\n            tmp: Arc::new(RwLock::new(Tmp::default())),\n            response: Arc::new(RwLock::new(HttpResponseBinary::default())),\n        }\n    }\n}\n\n/// Implements methods for the `HttpRequest` struct.\n///\n/// These methods provide functionality for managing HTTP requests, including:\n/// - Retrieving or setting HTTP attributes.\n/// - Constructing and sending HTTP GET or POST requests.\n/// - Parsing responses and handling redirects.\nimpl HttpRequest {\n    /// Gets the protocol from config.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Config` - Request configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Protocol` - The HTTP protocol.\n    pub(crate) fn get_protocol(config: &Config) -> Protocol {\n        config.url_obj.protocol.clone()\n    }\n\n    /// Gets the HTTP methods.\n    ///\n    /// # Returns\n    ///\n    /// - `Method` - The HTTP methods.\n    pub(crate) fn get_methods(&self) -> Method {\n        self.methods.as_ref().clone()\n    }\n\n    /// Gets the request URL.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The request URL.\n    fn get_url(&self) -> String {\n        self.url.as_ref().clone()\n    }\n\n    /// Gets the request headers.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestHeaders` - The request headers.\n    fn get_header(&self) -> RequestHeaders {\n        self.header.as_ref().clone()\n    }\n\n    /// Gets the request body.\n    ///\n    /// # Returns\n    ///\n    /// - `Body` - The request body.\n    fn get_body(&self) -> Body {\n        self.body.as_ref().clone()\n    }\n\n    /// Sets the URL for the HTTP request.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The new URL to set.\n    pub(crate) fn url(&mut self, url: String) {\n        self.url = Arc::new(url);\n    }\n\n    /// Parses the current URL into a `HttpUrlComponents` object.\n    ///\n    /// Returns `Ok(HttpUrlComponents)` if the parsing succeeds, or `Err(RequestError::InvalidUrl)` otherwise.\n    /// Parses the current URL into a `HttpUrlComponents` object.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(HttpUrlComponents)` if parsing succeeds\n    /// - `Err(RequestError::InvalidUrl)` if parsing fails\n    pub(crate) fn parse_url(&self) -> Result<HttpUrlComponents, RequestError> {\n        match HttpUrlComponents::parse(&self.get_url()) {\n            Ok(parse_res) => Ok(parse_res),\n            Err(err) => Err(RequestError::InvalidUrl(err.to_string())),\n        }\n    }\n\n    /// Converts the HTTP headers into a formatted HTTP header string and returns it as a byte vector.\n    ///\n    /// This method processes the HTTP headers by combining both user-defined and required headers.\n    /// Required headers such as `Host`, `Content-Length`, `Accept`, and `User-Agent` are added if\n    /// they are missing, with appropriate default values. The headers are then formatted into\n    /// the standard HTTP header format and converted into a vector of bytes.\n    ///\n    /// # Returns\n    ///\n    /// A `Vec<u8>` containing the formatted HTTP headers as a byte sequence.\n    ///\n    /// # Notes\n    ///\n    /// - The `Host` header is derived from the URL's host in the configuration.\n    /// - The `Content-Length` header is calculated based on the request method:\n    ///   - For `GET` requests, it is set to `0`.\n    ///   - For other methods, it is determined by the length of the body.\n    /// - If any required header is missing, it is automatically added with its default value.\n    /// - Headers are concatenated into a string with each header ending in a line break specified by `HTTP_BR`.\n    ///\n    /// # Behavior\n    ///\n    /// This function ensures that all necessary headers are present and correctly formatted\n    /// before constructing the HTTP request.\n    fn header_contains_key_case_insensitive(header: &RequestHeaders, target_key: &str) -> bool {\n        header\n            .keys()\n            .any(|key| key.eq_ignore_ascii_case(target_key))\n    }\n\n    /// Converts HTTP headers into formatted HTTP header bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - The formatted HTTP headers as bytes.\n    pub(crate) fn get_header_bytes(&self) -> Vec<u8> {\n        let mut header: RequestHeaders = self.get_header();\n        let body_length: usize = if self.get_methods().is_get() {\n            0usize\n        } else {\n            self.get_body_bytes().len()\n        };\n        if let Ok(config) = self.config.read() {\n            let host_value: String = config.url_obj.host.clone().unwrap_or_default();\n            let content_length_value: String = body_length.to_string();\n            if !Self::header_contains_key_case_insensitive(&header, HOST) {\n                let mut host_deque: VecDeque<String> = VecDeque::new();\n                host_deque.push_front(host_value);\n                header.insert(HOST.to_owned(), host_deque);\n            }\n            if !Self::header_contains_key_case_insensitive(&header, CONTENT_LENGTH) {\n                let mut content_length_deque: VecDeque<String> = VecDeque::new();\n                content_length_deque.push_front(content_length_value);\n                header.insert(CONTENT_LENGTH.to_owned(), content_length_deque);\n            }\n            if !Self::header_contains_key_case_insensitive(&header, ACCEPT) {\n                let mut accept_deque: VecDeque<String> = VecDeque::new();\n                accept_deque.push_front(ACCEPT_ANY.to_owned());\n                header.insert(ACCEPT.to_owned(), accept_deque);\n            }\n            if !Self::header_contains_key_case_insensitive(&header, USER_AGENT) {\n                let mut user_agent_deque: VecDeque<String> = VecDeque::new();\n                user_agent_deque.push_front(APP_NAME.to_owned());\n                header.insert(USER_AGENT.to_owned(), user_agent_deque);\n            }\n        }\n        let estimated_size: usize = header\n            .iter()\n            .map(|(k, v)| k.len() + v.front().map_or(0, |s| s.len()) + 4)\n            .sum();\n        let mut header_bytes: Vec<u8> = Vec::with_capacity(estimated_size);\n        for (key, value) in &header {\n            header_bytes.extend_from_slice(key.as_bytes());\n            header_bytes.extend_from_slice(b\": \");\n            if let Some(header_value) = value.front() {\n                header_bytes.extend_from_slice(header_value.as_bytes());\n            }\n            header_bytes.extend_from_slice(HTTP_BR_BYTES);\n        }\n        header_bytes\n    }\n\n    /// Converts the HTTP body into a URL-encoded byte vector (`Vec<u8>`).\n    ///\n    /// This method processes the body of the HTTP request based on the `Content-Type` header.\n    /// If the `Content-Type` is valid and supports conversion, the body is transformed into a\n    /// URL-encoded string and returned as a vector of bytes.\n    ///\n    /// # Returns\n    ///\n    /// A `Vec<u8>` containing the URL-encoded representation of the HTTP body.\n    /// If the `Content-Type` is not recognized or if the body cannot be converted,\n    /// an empty byte vector is returned.\n    ///\n    /// # Notes\n    ///\n    /// The `Content-Type` header is matched case-insensitively. If no matching `Content-Type`\n    /// is found or the parsing fails, the method defaults to returning an empty byte vector.\n    /// The body processing relies on the implementation of the `ContentType` parsing logic.\n    /// Converts the HTTP body into URL-encoded bytes.\n    ///\n    /// # Returns\n    ///\n    /// - `Vec<u8>` - The URL-encoded body bytes.\n    pub(crate) fn get_body_bytes(&self) -> Vec<u8> {\n        let header: RequestHeaders = self.get_header();\n        let body: Body = self.get_body();\n        if let Some(content_type_value) = header.get(CONTENT_TYPE) {\n            if let Some(first_value) = content_type_value.front() {\n                let res: String = first_value\n                    .to_lowercase()\n                    .parse::<ContentType>()\n                    .unwrap_or_default()\n                    .get_body_string(&body);\n                return res.into_bytes();\n            }\n        }\n        for (key, value) in &header {\n            if key.eq_ignore_ascii_case(CONTENT_TYPE) {\n                if let Some(first_value) = value.front() {\n                    let res: String = first_value\n                        .to_lowercase()\n                        .parse::<ContentType>()\n                        .unwrap_or_default()\n                        .get_body_string(&body);\n                    return res.into_bytes();\n                }\n            }\n        }\n        String::new().into_bytes()\n    }\n\n    /// Retrieves the full path of the HTTP request, including the query string if present.\n    ///\n    /// This function constructs and returns the complete path of the HTTP request, which\n    /// is composed of the path and, if available, the query string. The method checks if\n    /// the `url_obj` contains a query string, and if it does, appends it to the path using\n    /// the appropriate query separator (`?`). If no query string is present, only the\n    /// path is returned.\n    ///\n    /// The function defaults to a predefined path (`DEFAULT_HTTP_PATH`) if the path is\n    /// not set in the `url_obj` configuration. If the query string is empty, the function\n    /// simply returns the path.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The full path, including the query string if available, or just the\n    ///   path if no query string is present.\n    /// Gets the full request path including query string.\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The full path with query string if present.\n    pub(crate) fn get_path(&self) -> String {\n        let path: String = self.config.read().map_or(String::new(), |config| {\n            let query: String = config.url_obj.query.clone().unwrap_or_default();\n            if query.is_empty() {\n                config\n                    .url_obj\n                    .path\n                    .clone()\n                    .unwrap_or(DEFAULT_HTTP_PATH.to_string())\n            } else {\n                format!(\n                    \"{}{}{}\",\n                    config.url_obj.path.clone().unwrap_or_default(),\n                    QUERY_SYMBOL,\n                    query\n                )\n            }\n        });\n        path\n    }\n\n    /// Sends a GET request over the provided stream and returns the HTTP response.\n    ///\n    /// This method constructs and sends an HTTP GET request to the server. It formats the URL path\n    /// and query parameters based on the current configuration and sends the request to the server\n    /// via the provided `stream`. After sending the request, it waits for the response and reads\n    /// the result.\n    ///\n    /// # Parameters\n    /// - `stream`: A mutable reference to a `Box<dyn ReadWrite>`, representing the stream used\n    ///   for sending and receiving data.\n    ///\n    /// # Returns\n    /// Returns a `Result<HttpResponseBinary, RequestError>`, where:\n    /// - `Ok(HttpResponseBinary)` contains the HTTP response received from the server.\n    /// - `Err(RequestError)` indicates that an error occurred while sending the request or reading the response.\n    fn send_get_request(\n        &mut self,\n        stream: &mut Box<dyn ReadWrite>,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let path: String = self.get_path();\n        let header_bytes: Vec<u8> = self.get_header_bytes();\n        let http_version_str: String =\n            self.config.read().map_or(\"HTTP/1.1\".to_string(), |config| {\n                config.http_version.to_string()\n            });\n\n        let request: Vec<u8> =\n            SharedRequestBuilder::build_get_request(path, header_bytes, http_version_str);\n\n        stream\n            .write_all(&request)\n            .and_then(|_| stream.flush())\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        self.read_response(stream)\n    }\n\n    /// Sends a POST request over the provided stream and returns the HTTP response.\n    ///\n    /// This method constructs and sends an HTTP POST request to the server. It formats the URL path\n    /// and sends the body content along with the headers to the server via the provided `stream`. After\n    /// sending the request, it waits for the response and reads the result.\n    ///\n    /// # Parameters\n    /// - `stream`: A mutable reference to a `Box<dyn ReadWrite>`, representing the stream used\n    ///   for sending and receiving data.\n    ///\n    /// # Returns\n    /// Returns a `Result<HttpResponseBinary, RequestError>`, where:\n    /// - `Ok(HttpResponseBinary)` contains the HTTP response received from the server.\n    /// - `Err(RequestError)` indicates that an error occurred while sending the request or reading the response.\n    fn send_post_request(\n        &mut self,\n        stream: &mut Box<dyn ReadWrite>,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let path: String = self.get_path();\n        let header_bytes: Vec<u8> = self.get_header_bytes();\n        let body_bytes: Vec<u8> = self.get_body_bytes();\n        let http_version_str: String =\n            self.config.read().map_or(\"HTTP/1.1\".to_string(), |config| {\n                config.http_version.to_string()\n            });\n\n        let request: Vec<u8> = SharedRequestBuilder::build_post_request(\n            path,\n            header_bytes,\n            body_bytes,\n            http_version_str,\n        );\n\n        stream\n            .write_all(&request)\n            .and_then(|_| stream.flush())\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        self.read_response(stream)\n    }\n\n    /// Reads the HTTP response from the provided stream.\n    ///\n    /// This method reads the response from the server after sending an HTTP request. It processes the\n    /// headers, checks for redirects, and retrieves the response body based on the content length.\n    /// If a redirect is detected, it follows the redirection URL. The method ensures that the entire\n    /// response is read before returning.\n    ///\n    /// # Parameters\n    /// - `stream`: A mutable reference to a `Box<dyn ReadWrite>`, representing the stream used\n    ///   for receiving the response.\n    ///\n    /// # Returns\n    /// Returns a `Result<HttpResponseBinary, RequestError>`, where:\n    /// - `Ok(HttpResponseBinary)` contains the complete HTTP response after processing headers and body.\n    /// - `Err(RequestError)` indicates that an error occurred while reading the response.\n    fn read_response(\n        &mut self,\n        stream: &mut Box<dyn ReadWrite>,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let buffer_size: usize = self\n            .config\n            .read()\n            .map_or(DEFAULT_BUFFER_SIZE, |config| config.buffer);\n        let mut buffer: Vec<u8> = vec![0; buffer_size];\n        let initial_capacity: usize = buffer_size.max(8192);\n        let mut response_bytes: Vec<u8> = Vec::with_capacity(initial_capacity);\n        let mut headers_done: bool = false;\n        let mut content_length: usize = 0;\n        let mut redirect_url: Option<Vec<u8>> = None;\n        let mut headers_end_pos: usize = 0;\n        let http_version: String = self\n            .config\n            .read()\n            .map_or(HttpVersion::default().to_string(), |config| {\n                config.http_version.to_string()\n            });\n        let http_version_bytes: Vec<u8> = http_version.to_lowercase().into_bytes();\n        let location_sign_key: Vec<u8> = format!(\"{}:\", LOCATION.to_lowercase()).into_bytes();\n        'read_loop: while let Ok(n) = stream.read(&mut buffer) {\n            if n == 0 {\n                break;\n            }\n            let new_capacity: usize = SharedResponseHandler::calculate_buffer_capacity(\n                &response_bytes,\n                n,\n                response_bytes.capacity(),\n            );\n            if new_capacity > 0 {\n                response_bytes.reserve(new_capacity - response_bytes.capacity());\n            }\n            let old_len: usize = response_bytes.len();\n            response_bytes.extend_from_slice(&buffer[..n]);\n            if !headers_done {\n                let search_start: usize = old_len.saturating_sub(3);\n                if let Some(pos) =\n                    SharedResponseHandler::find_double_crlf(&response_bytes, search_start)\n                {\n                    headers_done = true;\n                    headers_end_pos = pos + 4;\n\n                    SharedResponseHandler::parse_response_headers(\n                        &response_bytes[..headers_end_pos],\n                        &http_version_bytes,\n                        &location_sign_key,\n                        &mut content_length,\n                        &mut redirect_url,\n                    )?;\n                }\n            }\n            if headers_done {\n                let total_expected_length: usize = headers_end_pos + content_length;\n                if response_bytes.len() >= total_expected_length {\n                    response_bytes.truncate(total_expected_length);\n                    break 'read_loop;\n                }\n            }\n        }\n        self.response = Arc::new(RwLock::new(<HttpResponseBinary as ResponseTrait>::from(\n            &response_bytes,\n        )));\n        if let Ok(config) = self.config.read() {\n            if !config.redirect || redirect_url.is_none() {\n                if config.decode {\n                    if let Ok(mut response) = self.response.write() {\n                        *response = response.decode(config.buffer);\n                    }\n                }\n                return Ok(Box::new(\n                    self.response\n                        .read()\n                        .map_or(HttpResponseBinary::default(), |response| response.clone()),\n                ));\n            }\n        }\n        let url: String = String::from_utf8(redirect_url.unwrap())\n            .map_err(|err| RequestError::InvalidUrl(err.to_string()))?;\n        self.handle_redirect(url)\n    }\n\n    /// Handles HTTP redirects by following the redirection URL.\n    ///\n    /// # Parameters\n    ///\n    /// - `url`: The redirection URL to follow.\n    ///\n    /// Returns `Ok(HttpResponseBinary)` if the redirection is successful, or `Err(RequestError)` otherwise.\n    fn handle_redirect(&mut self, url: String) -> Result<BoxResponseTrait, RequestError> {\n        if let Ok(mut config) = self.config.write() {\n            if !config.redirect {\n                return Err(RequestError::NeedOpenRedirect);\n            }\n            if let Ok(mut tmp) = self.tmp.clone().write() {\n                if tmp.visit_url.contains(&url) {\n                    return Err(RequestError::RedirectUrlDeadLoop);\n                }\n                tmp.visit_url.insert(url.clone());\n                if config.redirect_times >= config.max_redirect_times {\n                    return Err(RequestError::MaxRedirectTimes);\n                }\n                config.redirect_times += 1;\n            }\n        }\n        self.url(url.clone());\n        self.send_sync()\n    }\n\n    /// Determines the appropriate port for the HTTP request.\n    ///\n    /// # Parameters\n    ///\n    /// - `port`: The default port (if any).\n    /// - `config`: Config\n    ///\n    /// Returns the resolved port.\n    pub(crate) fn get_port(&self, port: u16, config: &Config) -> u16 {\n        if port != 0 {\n            return port;\n        }\n        let protocol: Protocol = Self::get_protocol(config);\n        protocol.get_port()\n    }\n\n    /// Establishes a connection stream to the specified host and port.\n    ///\n    /// This method attempts to create a connection stream based on the protocol type\n    /// (HTTP or HTTPS) defined by the current configuration. It supports both plain\n    /// TCP connections and TLS-secured connections. If the protocol is HTTPS, it will\n    /// use the `TlsConnector` to establish a secure TLS connection. For both cases,\n    /// it ensures a read timeout is set on the stream.\n    ///\n    /// # Parameters\n    ///\n    /// - `host`: The hostname or IP address to connect to.\n    /// - `port`: The port number to connect to.\n    ///\n    /// # Returns\n    ///\n    /// - `Ok(Box<dyn ReadWrite>)`: A boxed stream that implements the `ReadWrite` trait,\n    ///   representing the established connection.\n    /// - `Err(RequestError)`: An error indicating what went wrong during the connection process.\n    fn get_connection_stream(\n        &self,\n        host: String,\n        port: u16,\n    ) -> Result<Box<dyn ReadWrite>, RequestError> {\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if let Some(proxy_config) = &config.proxy {\n            return self.get_proxy_connection_stream(host, port, proxy_config);\n        }\n        let host_port: (String, u16) = (host.clone(), port);\n        let timeout: Duration = Duration::from_millis(config.timeout);\n        let tcp_stream: TcpStream = TcpStream::connect(host_port.clone())\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        tcp_stream\n            .set_read_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetReadTimeout(err.to_string()))?;\n        tcp_stream\n            .set_write_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetWriteTimeout(err.to_string()))?;\n        let stream: Result<Box<dyn ReadWrite>, RequestError> =\n            if Self::get_protocol(&config).is_https() {\n                match self.tmp.clone().read() {\n                    Ok(tmp) => {\n                        let roots: RootCertStore = tmp.root_cert.clone();\n                        let tls_config: ClientConfig = ClientConfig::builder()\n                            .with_root_certificates(roots)\n                            .with_no_client_auth();\n                        let client_config: Arc<ClientConfig> = Arc::new(tls_config);\n                        let dns_name: ServerName<'_> = ServerName::try_from(host.clone())\n                            .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                        let session: ClientConnection =\n                            ClientConnection::new(Arc::clone(&client_config), dns_name)\n                                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                        let tls_stream: StreamOwned<ClientConnection, TcpStream> =\n                            StreamOwned::new(session, tcp_stream);\n                        return Ok(Box::new(tls_stream));\n                    }\n                    Err(err) => Err(RequestError::Unknown(format!(\n                        \"error reading temporary configuration: {}\",\n                        err\n                    ))),\n                }\n            } else {\n                Ok(Box::new(tcp_stream))\n            };\n        stream\n    }\n\n    /// Establishes a proxy connection stream to the specified host and port.\n    fn get_proxy_connection_stream(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<Box<dyn ReadWrite>, RequestError> {\n        let timeout: Duration = Duration::from_millis(\n            self.config\n                .read()\n                .map_or(DEFAULT_TIMEOUT, |config| config.timeout),\n        );\n        match proxy_config.proxy_type {\n            ProxyType::Http | ProxyType::Https => {\n                self.get_http_proxy_connection(target_host, target_port, proxy_config, timeout)\n            }\n            ProxyType::Socks5 => {\n                self.get_socks5_proxy_connection(target_host, target_port, proxy_config, timeout)\n            }\n        }\n    }\n\n    /// Establishes an HTTP/HTTPS proxy connection.\n    fn get_http_proxy_connection(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n        timeout: Duration,\n    ) -> Result<Box<dyn ReadWrite>, RequestError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let tcp_stream: TcpStream = TcpStream::connect(proxy_host_port)\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        tcp_stream\n            .set_read_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetReadTimeout(err.to_string()))?;\n        tcp_stream\n            .set_write_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetWriteTimeout(err.to_string()))?;\n        let mut proxy_stream: Box<dyn ReadWrite> = if proxy_config.proxy_type == ProxyType::Https {\n            match self.tmp.clone().read() {\n                Ok(tmp) => {\n                    let roots: RootCertStore = tmp.root_cert.clone();\n                    let tls_config: ClientConfig = ClientConfig::builder()\n                        .with_root_certificates(roots)\n                        .with_no_client_auth();\n                    let client_config: Arc<ClientConfig> = Arc::new(tls_config);\n                    let dns_name: ServerName<'_> = ServerName::try_from(proxy_config.host.clone())\n                        .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                    let session: ClientConnection =\n                        ClientConnection::new(Arc::clone(&client_config), dns_name)\n                            .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                    let tls_stream: StreamOwned<ClientConnection, TcpStream> =\n                        StreamOwned::new(session, tcp_stream);\n                    Box::new(tls_stream)\n                }\n                Err(err) => {\n                    return Err(RequestError::Unknown(format!(\n                        \"error reading temporary configuration: {}\",\n                        err\n                    )));\n                }\n            }\n        } else {\n            Box::new(tcp_stream)\n        };\n        let connect_request: String = if let (Some(username), Some(password)) =\n            (&proxy_config.username, &proxy_config.password)\n        {\n            let auth: String = format!(\"{}:{}\", username, password);\n            let auth_encoded: String = base64_encode(auth.as_bytes());\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\nProxy-Authorization: Basic {}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port, auth_encoded\n            )\n        } else {\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port\n            )\n        };\n        proxy_stream\n            .write_all(connect_request.as_bytes())\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        proxy_stream\n            .flush()\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let mut response_buffer = [0u8; 1024];\n        let bytes_read: usize = proxy_stream\n            .read(&mut response_buffer)\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let response_str: &str = std::str::from_utf8(&response_buffer[..bytes_read]).unwrap_or(\"\");\n        let headers_end_pos: Option<usize> = response_str.find(\"\\r\\n\\r\\n\");\n        let pre_read_data: Vec<u8> = if let Some(pos) = headers_end_pos {\n            let header_part: &str = &response_str[..pos];\n            if !header_part.starts_with(\"HTTP/1.1 200\") && !header_part.starts_with(\"HTTP/1.0 200\")\n            {\n                return Err(RequestError::Request(format!(\n                    \"Proxy connection failed: {}\",\n                    header_part.lines().next().unwrap_or(\"Unknown error\")\n                )));\n            }\n            response_buffer[pos + 4..bytes_read].to_vec()\n        } else {\n            if !response_str.starts_with(\"HTTP/1.1 200\")\n                && !response_str.starts_with(\"HTTP/1.0 200\")\n            {\n                return Err(RequestError::Request(format!(\n                    \"Proxy connection failed: {}\",\n                    response_str.lines().next().unwrap_or(\"Unknown error\")\n                )));\n            }\n            vec![]\n        };\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if Self::get_protocol(&config).is_https() {\n            match self.tmp.clone().read() {\n                Ok(tmp) => {\n                    let roots: RootCertStore = tmp.root_cert.clone();\n                    let tls_config: ClientConfig = ClientConfig::builder()\n                        .with_root_certificates(roots)\n                        .with_no_client_auth();\n                    let client_config: Arc<ClientConfig> = Arc::new(tls_config);\n                    let dns_name: ServerName<'_> = ServerName::try_from(target_host.clone())\n                        .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                    let session: ClientConnection =\n                        ClientConnection::new(Arc::clone(&client_config), dns_name)\n                            .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n\n                    let tunnel_stream = SyncProxyTunnelStream::new(proxy_stream, pre_read_data);\n                    let tls_stream: StreamOwned<ClientConnection, SyncProxyTunnelStream> =\n                        StreamOwned::new(session, tunnel_stream);\n                    return Ok(Box::new(tls_stream));\n                }\n                Err(err) => {\n                    return Err(RequestError::Unknown(format!(\n                        \"error reading temporary configuration: {}\",\n                        err\n                    )));\n                }\n            }\n        }\n        let tunnel_stream: SyncProxyTunnelStream =\n            SyncProxyTunnelStream::new(proxy_stream, pre_read_data);\n        Ok(Box::new(tunnel_stream))\n    }\n\n    /// Establishes a SOCKS5 proxy connection.\n    fn get_socks5_proxy_connection(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n        timeout: Duration,\n    ) -> Result<Box<dyn ReadWrite>, RequestError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let mut tcp_stream: TcpStream = TcpStream::connect(proxy_host_port)\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        tcp_stream\n            .set_read_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetReadTimeout(err.to_string()))?;\n        tcp_stream\n            .set_write_timeout(Some(timeout))\n            .map_err(|err| RequestError::SetWriteTimeout(err.to_string()))?;\n        let auth_methods: Vec<u8> =\n            if proxy_config.username.is_some() && proxy_config.password.is_some() {\n                vec![0x05, 0x02, 0x00, 0x02]\n            } else {\n                vec![0x05, 0x01, 0x00]\n            };\n        tcp_stream\n            .write_all(&auth_methods)\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let mut response = [0u8; 2];\n        tcp_stream\n            .read_exact(&mut response)\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        if response[0] != 0x05 {\n            return Err(RequestError::Request(\"Invalid SOCKS5 response\".to_string()));\n        }\n        match response[1] {\n            0x00 => {}\n            0x02 => {\n                if let (Some(username), Some(password)) =\n                    (&proxy_config.username, &proxy_config.password)\n                {\n                    let mut auth_request: Vec<u8> = vec![0x01];\n                    auth_request.push(username.len() as u8);\n                    auth_request.extend_from_slice(username.as_bytes());\n                    auth_request.push(password.len() as u8);\n                    auth_request.extend_from_slice(password.as_bytes());\n                    tcp_stream\n                        .write_all(&auth_request)\n                        .map_err(|err| RequestError::Request(err.to_string()))?;\n                    let mut auth_response: [u8; 2] = [0u8; 2];\n                    tcp_stream\n                        .read_exact(&mut auth_response)\n                        .map_err(|err| RequestError::Request(err.to_string()))?;\n                    if auth_response[1] != 0x00 {\n                        return Err(RequestError::Request(\n                            \"SOCKS5 authentication failed\".to_string(),\n                        ));\n                    }\n                } else {\n                    return Err(RequestError::Request(\n                        \"SOCKS5 proxy requires authentication\".to_string(),\n                    ));\n                }\n            }\n            0xFF => {\n                return Err(RequestError::Request(\n                    \"No acceptable SOCKS5 authentication methods\".to_string(),\n                ));\n            }\n            _ => {\n                return Err(RequestError::Request(\n                    \"Unsupported SOCKS5 authentication method\".to_string(),\n                ));\n            }\n        }\n        let mut connect_request: Vec<u8> = vec![0x05, 0x01, 0x00];\n        if target_host.parse::<Ipv4Addr>().is_ok() {\n            connect_request.push(0x01);\n            let ip: Ipv4Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else if target_host.parse::<Ipv6Addr>().is_ok() {\n            connect_request.push(0x04);\n            let ip: Ipv6Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else {\n            connect_request.push(0x03);\n            connect_request.push(target_host.len() as u8);\n            connect_request.extend_from_slice(target_host.as_bytes());\n        }\n        connect_request.extend_from_slice(&target_port.to_be_bytes());\n        tcp_stream\n            .write_all(&connect_request)\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let mut connect_response: [u8; 4] = [0u8; 4];\n        tcp_stream\n            .read_exact(&mut connect_response)\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        if connect_response[0] != 0x05 || connect_response[1] != 0x00 {\n            return Err(RequestError::Request(format!(\n                \"SOCKS5 connection failed with code: {}\",\n                connect_response[1]\n            )));\n        }\n        match connect_response[3] {\n            0x01 => {\n                let mut skip = [0u8; 6];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            0x03 => {\n                let mut len = [0u8; 1];\n                tcp_stream\n                    .read_exact(&mut len)\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n                let mut skip = vec![0u8; len[0] as usize + 2];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            0x04 => {\n                let mut skip = [0u8; 18];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            _ => {\n                return Err(RequestError::Request(\n                    \"Invalid SOCKS5 address type\".to_string(),\n                ));\n            }\n        }\n        let proxy_stream: Box<dyn ReadWrite> = Box::new(tcp_stream);\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if Self::get_protocol(&config).is_https() {\n            match self.tmp.clone().read() {\n                Ok(tmp) => {\n                    let roots: RootCertStore = tmp.root_cert.clone();\n                    let tls_config: ClientConfig = ClientConfig::builder()\n                        .with_root_certificates(roots)\n                        .with_no_client_auth();\n                    let client_config: Arc<ClientConfig> = Arc::new(tls_config);\n                    let dns_name: ServerName<'_> = ServerName::try_from(target_host.clone())\n                        .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n                    let session: ClientConnection =\n                        ClientConnection::new(Arc::clone(&client_config), dns_name)\n                            .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n\n                    let tunnel_stream = SyncProxyTunnelStream::new(proxy_stream, vec![]);\n                    let tls_stream: StreamOwned<ClientConnection, SyncProxyTunnelStream> =\n                        StreamOwned::new(session, tunnel_stream);\n                    return Ok(Box::new(tls_stream));\n                }\n                Err(err) => {\n                    return Err(RequestError::Unknown(format!(\n                        \"error reading temporary configuration: {}\",\n                        err\n                    )));\n                }\n            }\n        }\n        Ok(proxy_stream)\n    }\n}\n\nimpl HttpRequest {\n    /// Sends the HTTP request synchronously.\n    pub(crate) fn send_sync(&mut self) -> RequestResult {\n        let methods: Method = self.get_methods();\n        let mut host: String = String::new();\n        let mut port: u16 = u16::default();\n        if let Ok(mut config) = self.config.write() {\n            config.url_obj = self\n                .parse_url()\n                .map_err(|err| RequestError::InvalidUrl(err.to_string()))?;\n            host = config.url_obj.host.clone().unwrap_or_default();\n            port = self.get_port(config.url_obj.port.clone().unwrap_or_default(), &config);\n        }\n        let mut stream: BoxReadWrite = self.get_connection_stream(host, port)?;\n        let res: Result<BoxResponseTrait, RequestError> = match methods {\n            m if m.is_get() => self.send_get_request(&mut stream),\n            m if m.is_post() => self.send_post_request(&mut stream),\n            err => Err(RequestError::Request(format!(\n                \"do not support {} method\",\n                err\n            ))),\n        };\n        res\n    }\n}\n\n/// Async implementation for HttpRequest\nimpl HttpRequest {\n    /// Sends an async GET request.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut BoxAsyncReadWrite` - The async stream to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - Result containing the response or error.\n    async fn send_get_request_async(\n        &mut self,\n        stream: &mut BoxAsyncReadWrite,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let path: String = self.get_path();\n        let header_bytes: Vec<u8> = self.get_header_bytes();\n        let http_version_str: String =\n            self.config.read().map_or(\"HTTP/1.1\".to_string(), |config| {\n                config.http_version.to_string()\n            });\n        let request: Vec<u8> =\n            SharedRequestBuilder::build_get_request(path, header_bytes, http_version_str);\n        stream\n            .write_all(&request)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        stream\n            .flush()\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        self.read_response_async(stream).await\n    }\n\n    /// Sends an async POST request.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut BoxAsyncReadWrite` - The async stream to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - Result containing the response or error.\n    async fn send_post_request_async(\n        &mut self,\n        stream: &mut BoxAsyncReadWrite,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let path: String = self.get_path();\n        let header_bytes: Vec<u8> = self.get_header_bytes();\n        let body_bytes: Vec<u8> = self.get_body_bytes();\n        let http_version_str: String =\n            self.config.read().map_or(\"HTTP/1.1\".to_string(), |config| {\n                config.http_version.to_string()\n            });\n        let request: Vec<u8> = SharedRequestBuilder::build_post_request(\n            path,\n            header_bytes,\n            body_bytes,\n            http_version_str,\n        );\n        stream\n            .write_all(&request)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        stream\n            .flush()\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        self.read_response_async(stream).await\n    }\n\n    /// Reads an async HTTP response.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut BoxAsyncReadWrite` - The async stream to read from.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxResponseTrait, RequestError>` - Result containing the response or error.\n    async fn read_response_async(\n        &mut self,\n        stream: &mut BoxAsyncReadWrite,\n    ) -> Result<BoxResponseTrait, RequestError> {\n        let buffer_size: usize = self\n            .config\n            .read()\n            .map_or(DEFAULT_BUFFER_SIZE, |config| config.buffer);\n        let mut buffer: Vec<u8> = vec![0; buffer_size];\n        let initial_capacity: usize = buffer_size.max(8192);\n        let mut response_bytes: Vec<u8> = Vec::with_capacity(initial_capacity);\n        let mut headers_done: bool = false;\n        let mut content_length: usize = 0;\n        let mut redirect_url: Option<Vec<u8>> = None;\n        let mut headers_end_pos: usize = 0;\n        let http_version: String = self\n            .config\n            .read()\n            .map_or(HttpVersion::default().to_string(), |config| {\n                config.http_version.to_string()\n            });\n        let http_version_bytes: Vec<u8> = http_version.to_lowercase().into_bytes();\n        let location_sign_key: Vec<u8> = format!(\"{}:\", LOCATION.to_lowercase()).into_bytes();\n        'read_loop: loop {\n            let n: usize = stream\n                .read(&mut buffer)\n                .await\n                .map_err(|err| RequestError::Request(err.to_string()))?;\n            if n == 0 {\n                break;\n            }\n            let new_capacity: usize = SharedResponseHandler::calculate_buffer_capacity(\n                &response_bytes,\n                n,\n                response_bytes.capacity(),\n            );\n            if new_capacity > 0 {\n                response_bytes.reserve(new_capacity - response_bytes.capacity());\n            }\n            let old_len: usize = response_bytes.len();\n            response_bytes.extend_from_slice(&buffer[..n]);\n            if !headers_done {\n                let search_start: usize = old_len.saturating_sub(3);\n                if let Some(pos) =\n                    SharedResponseHandler::find_double_crlf(&response_bytes, search_start)\n                {\n                    headers_done = true;\n                    headers_end_pos = pos + 4;\n                    SharedResponseHandler::parse_response_headers(\n                        &response_bytes[..headers_end_pos],\n                        &http_version_bytes,\n                        &location_sign_key,\n                        &mut content_length,\n                        &mut redirect_url,\n                    )?;\n                }\n            }\n            if headers_done {\n                let total_expected_length: usize = headers_end_pos + content_length;\n                if response_bytes.len() >= total_expected_length {\n                    response_bytes.truncate(total_expected_length);\n                    break 'read_loop;\n                }\n            }\n        }\n        self.response = Arc::new(RwLock::new(<HttpResponseBinary as ResponseTrait>::from(\n            &response_bytes,\n        )));\n        let (should_redirect, should_decode, buffer_size) = {\n            if let Ok(config) = self.config.read() {\n                (config.redirect, config.decode, config.buffer)\n            } else {\n                (false, false, DEFAULT_BUFFER_SIZE)\n            }\n        };\n        if !should_redirect || redirect_url.is_none() {\n            if should_decode {\n                if let Ok(mut response) = self.response.write() {\n                    *response = response.decode(buffer_size);\n                }\n            }\n            return Ok(Box::new(\n                self.response\n                    .read()\n                    .map_or(HttpResponseBinary::default(), |response| response.clone()),\n            ));\n        }\n        let url: String = String::from_utf8(redirect_url.unwrap())\n            .map_err(|err| RequestError::InvalidUrl(err.to_string()))?;\n        self.handle_redirect_async(url).await\n    }\n\n    /// Handles async HTTP redirects.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The redirect URL.\n    ///\n    /// # Returns\n    ///\n    /// - `Pin<Box<dyn Future<Output = Result<BoxResponseTrait, RequestError>> + Send + '_>>` - Future representing the redirect handling.\n    fn handle_redirect_async(\n        &mut self,\n        url: String,\n    ) -> Pin<Box<dyn Future<Output = Result<BoxResponseTrait, RequestError>> + Send + '_>> {\n        Box::pin(async move {\n            {\n                if let Ok(mut config) = self.config.write() {\n                    if !config.redirect {\n                        return Err(RequestError::NeedOpenRedirect);\n                    }\n                    if let Ok(mut tmp) = self.tmp.clone().write() {\n                        if tmp.visit_url.contains(&url) {\n                            return Err(RequestError::RedirectUrlDeadLoop);\n                        }\n                        tmp.visit_url.insert(url.clone());\n                        if config.redirect_times >= config.max_redirect_times {\n                            return Err(RequestError::MaxRedirectTimes);\n                        }\n                        config.redirect_times += 1;\n                    }\n                }\n            }\n            self.url(url.clone());\n            self.send_async().await\n        })\n    }\n\n    /// Establishes an async connection stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The host to connect to.\n    /// - `u16` - The port to connect to.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxAsyncReadWrite, RequestError>` - Result containing the stream or error.\n    async fn get_connection_stream_async(\n        &self,\n        host: String,\n        port: u16,\n    ) -> Result<BoxAsyncReadWrite, RequestError> {\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if let Some(proxy_config) = &config.proxy {\n            return self\n                .get_proxy_connection_stream_async(host, port, proxy_config)\n                .await;\n        }\n        let host_port: (String, u16) = (host.clone(), port);\n        let tcp_stream: AsyncTcpStream = AsyncTcpStream::connect(host_port.clone())\n            .await\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        if Self::get_protocol(&config).is_https() {\n            let roots: RootCertStore = {\n                match self.tmp.clone().read() {\n                    Ok(tmp) => tmp.root_cert.clone(),\n                    Err(err) => {\n                        return Err(RequestError::Unknown(format!(\n                            \"error reading temporary configuration: {}\",\n                            err\n                        )));\n                    }\n                }\n            };\n            let tls_config: ClientConfig = ClientConfig::builder()\n                .with_root_certificates(roots)\n                .with_no_client_auth();\n            let connector: TlsConnector = TlsConnector::from(Arc::new(tls_config));\n            let dns_name: ServerName<'_> = ServerName::try_from(host.clone())\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            let tls_stream: TlsStream<AsyncTcpStream> = connector\n                .connect(dns_name, tcp_stream)\n                .await\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            Ok(Box::new(tls_stream))\n        } else {\n            Ok(Box::new(tcp_stream))\n        }\n    }\n\n    /// Establishes an async proxy connection stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The target host.\n    /// - `u16` - The target port.\n    /// - `&ProxyConfig` - The proxy configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxAsyncReadWrite, RequestError>` - Result containing the stream or error.\n    async fn get_proxy_connection_stream_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, RequestError> {\n        match proxy_config.proxy_type {\n            ProxyType::Http | ProxyType::Https => {\n                self.get_http_proxy_connection_async(target_host, target_port, proxy_config)\n                    .await\n            }\n            ProxyType::Socks5 => {\n                self.get_socks5_proxy_connection_async(target_host, target_port, proxy_config)\n                    .await\n            }\n        }\n    }\n\n    /// Establishes an async HTTP/HTTPS proxy connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The target host.\n    /// - `u16` - The target port.\n    /// - `&ProxyConfig` - The proxy configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxAsyncReadWrite, RequestError>` - Result containing the stream or error.\n    async fn get_http_proxy_connection_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, RequestError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let tcp_stream: AsyncTcpStream = AsyncTcpStream::connect(proxy_host_port)\n            .await\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        let mut proxy_stream: BoxAsyncReadWrite = if proxy_config.proxy_type == ProxyType::Https {\n            let roots: RootCertStore = {\n                match self.tmp.clone().read() {\n                    Ok(tmp) => tmp.root_cert.clone(),\n                    Err(err) => {\n                        return Err(RequestError::Unknown(format!(\n                            \"error reading temporary configuration: {}\",\n                            err\n                        )));\n                    }\n                }\n            };\n            let tls_config: ClientConfig = ClientConfig::builder()\n                .with_root_certificates(roots)\n                .with_no_client_auth();\n            let connector: TlsConnector = TlsConnector::from(Arc::new(tls_config));\n            let dns_name: ServerName<'_> = ServerName::try_from(proxy_config.host.clone())\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            let tls_stream: TlsStream<AsyncTcpStream> = connector\n                .connect(dns_name, tcp_stream)\n                .await\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            Box::new(tls_stream)\n        } else {\n            Box::new(tcp_stream)\n        };\n        let connect_request: String = if let (Some(username), Some(password)) =\n            (&proxy_config.username, &proxy_config.password)\n        {\n            let auth: String = format!(\"{}:{}\", username, password);\n            let auth_encoded: String = base64_encode(auth.as_bytes());\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\nProxy-Authorization: Basic {}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port, auth_encoded\n            )\n        } else {\n            format!(\n                \"CONNECT {}:{} HTTP/1.1\\r\\nHost: {}:{}\\r\\n\\r\\n\",\n                target_host, target_port, target_host, target_port\n            )\n        };\n        proxy_stream\n            .write_all(connect_request.as_bytes())\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        proxy_stream\n            .flush()\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let mut response_buffer: [u8; 1024] = [0u8; 1024];\n        let bytes_read: usize = proxy_stream\n            .read(&mut response_buffer)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let response_str: &str = std::str::from_utf8(&response_buffer[..bytes_read]).unwrap_or(\"\");\n        let headers_end_pos: Option<usize> = response_str.find(\"\\r\\n\\r\\n\");\n        let pre_read_data: Vec<u8> = if let Some(pos) = headers_end_pos {\n            let header_part: &str = &response_str[..pos];\n            if !header_part.starts_with(\"HTTP/1.1 200\") && !header_part.starts_with(\"HTTP/1.0 200\")\n            {\n                return Err(RequestError::Request(format!(\n                    \"Proxy connection failed: {}\",\n                    header_part.lines().next().unwrap_or(\"Unknown error\")\n                )));\n            }\n            response_buffer[pos + 4..bytes_read].to_vec()\n        } else {\n            if !response_str.starts_with(\"HTTP/1.1 200\")\n                && !response_str.starts_with(\"HTTP/1.0 200\")\n            {\n                return Err(RequestError::Request(format!(\n                    \"Proxy connection failed: {}\",\n                    response_str.lines().next().unwrap_or(\"Unknown error\")\n                )));\n            }\n            vec![]\n        };\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if Self::get_protocol(&config).is_https() {\n            let roots: RootCertStore = {\n                match self.tmp.clone().read() {\n                    Ok(tmp) => tmp.root_cert.clone(),\n                    Err(err) => {\n                        return Err(RequestError::Unknown(format!(\n                            \"error reading temporary configuration: {}\",\n                            err\n                        )));\n                    }\n                }\n            };\n            let tls_config: ClientConfig = ClientConfig::builder()\n                .with_root_certificates(roots)\n                .with_no_client_auth();\n            let connector: TlsConnector = TlsConnector::from(Arc::new(tls_config));\n            let dns_name: ServerName<'_> = ServerName::try_from(target_host.clone())\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            let tunnel_stream: ProxyTunnelStream =\n                ProxyTunnelStream::new(proxy_stream, pre_read_data);\n            let tls_stream: TlsStream<ProxyTunnelStream> = connector\n                .connect(dns_name, tunnel_stream)\n                .await\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            return Ok(Box::new(tls_stream));\n        }\n        let tunnel_stream: ProxyTunnelStream = ProxyTunnelStream::new(proxy_stream, pre_read_data);\n        Ok(Box::new(tunnel_stream))\n    }\n\n    /// Establishes an async SOCKS5 proxy connection.\n    ///\n    /// # Arguments\n    ///\n    /// - `String` - The target host.\n    /// - `u16` - The target port.\n    /// - `&ProxyConfig` - The proxy configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<BoxAsyncReadWrite, RequestError>` - Result containing the stream or error.\n    async fn get_socks5_proxy_connection_async(\n        &self,\n        target_host: String,\n        target_port: u16,\n        proxy_config: &ProxyConfig,\n    ) -> Result<BoxAsyncReadWrite, RequestError> {\n        let proxy_host_port: (String, u16) = (proxy_config.host.clone(), proxy_config.port);\n        let mut tcp_stream: AsyncTcpStream = AsyncTcpStream::connect(proxy_host_port)\n            .await\n            .map_err(|err| RequestError::TcpStreamConnect(err.to_string()))?;\n        let auth_methods: Vec<u8> =\n            if proxy_config.username.is_some() && proxy_config.password.is_some() {\n                vec![0x05, 0x02, 0x00, 0x02]\n            } else {\n                vec![0x05, 0x01, 0x00]\n            };\n        tcp_stream\n            .write_all(&auth_methods)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        let mut response: [u8; 2] = [0u8; 2];\n        tcp_stream\n            .read_exact(&mut response)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n        if response[0] != 0x05 {\n            return Err(RequestError::Request(\"Invalid SOCKS5 response\".to_string()));\n        }\n        match response[1] {\n            0x00 => {}\n            0x02 => {\n                if let (Some(username), Some(password)) =\n                    (&proxy_config.username, &proxy_config.password)\n                {\n                    let mut auth_request = vec![0x01];\n                    auth_request.push(username.len() as u8);\n                    auth_request.extend_from_slice(username.as_bytes());\n                    auth_request.push(password.len() as u8);\n                    auth_request.extend_from_slice(password.as_bytes());\n\n                    tcp_stream\n                        .write_all(&auth_request)\n                        .await\n                        .map_err(|err| RequestError::Request(err.to_string()))?;\n\n                    let mut auth_response = [0u8; 2];\n                    tcp_stream\n                        .read_exact(&mut auth_response)\n                        .await\n                        .map_err(|err| RequestError::Request(err.to_string()))?;\n\n                    if auth_response[1] != 0x00 {\n                        return Err(RequestError::Request(\n                            \"SOCKS5 authentication failed\".to_string(),\n                        ));\n                    }\n                } else {\n                    return Err(RequestError::Request(\n                        \"SOCKS5 proxy requires authentication\".to_string(),\n                    ));\n                }\n            }\n            0xFF => {\n                return Err(RequestError::Request(\n                    \"No acceptable SOCKS5 authentication methods\".to_string(),\n                ));\n            }\n            _ => {\n                return Err(RequestError::Request(\n                    \"Unsupported SOCKS5 authentication method\".to_string(),\n                ));\n            }\n        }\n        let mut connect_request: Vec<u8> = vec![0x05, 0x01, 0x00];\n        if target_host.parse::<Ipv4Addr>().is_ok() {\n            connect_request.push(0x01);\n            let ip: Ipv4Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else if target_host.parse::<Ipv6Addr>().is_ok() {\n            connect_request.push(0x04);\n            let ip: Ipv6Addr = target_host.parse().unwrap();\n            connect_request.extend_from_slice(&ip.octets());\n        } else {\n            connect_request.push(0x03);\n            connect_request.push(target_host.len() as u8);\n            connect_request.extend_from_slice(target_host.as_bytes());\n        }\n        connect_request.extend_from_slice(&target_port.to_be_bytes());\n        tcp_stream\n            .write_all(&connect_request)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n\n        let mut connect_response: [u8; 4] = [0u8; 4];\n        tcp_stream\n            .read_exact(&mut connect_response)\n            .await\n            .map_err(|err| RequestError::Request(err.to_string()))?;\n\n        if connect_response[0] != 0x05 || connect_response[1] != 0x00 {\n            return Err(RequestError::Request(format!(\n                \"SOCKS5 connection failed with code: {}\",\n                connect_response[1]\n            )));\n        }\n        match connect_response[3] {\n            0x01 => {\n                let mut skip: [u8; 6] = [0u8; 6];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            0x03 => {\n                let mut len: [u8; 1] = [0u8; 1];\n                tcp_stream\n                    .read_exact(&mut len)\n                    .await\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n                let mut skip: Vec<u8> = vec![0u8; len[0] as usize + 2];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            0x04 => {\n                let mut skip: [u8; 18] = [0u8; 18];\n                tcp_stream\n                    .read_exact(&mut skip)\n                    .await\n                    .map_err(|err| RequestError::Request(err.to_string()))?;\n            }\n            _ => {\n                return Err(RequestError::Request(\n                    \"Invalid SOCKS5 address type\".to_string(),\n                ));\n            }\n        }\n        let proxy_stream: BoxAsyncReadWrite = Box::new(tcp_stream);\n        let config: Config = self\n            .config\n            .read()\n            .map_or(Config::default(), |config| config.clone());\n        if Self::get_protocol(&config).is_https() {\n            let roots: RootCertStore = {\n                match self.tmp.clone().read() {\n                    Ok(tmp) => tmp.root_cert.clone(),\n                    Err(err) => {\n                        return Err(RequestError::Unknown(format!(\n                            \"error reading temporary configuration: {}\",\n                            err\n                        )));\n                    }\n                }\n            };\n            let tls_config: ClientConfig = ClientConfig::builder()\n                .with_root_certificates(roots)\n                .with_no_client_auth();\n            let connector: TlsConnector = TlsConnector::from(Arc::new(tls_config));\n            let dns_name: ServerName<'_> = ServerName::try_from(target_host.clone())\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            let tunnel_stream: ProxyTunnelStream = ProxyTunnelStream::new(proxy_stream, Vec::new());\n            let tls_stream: TlsStream<ProxyTunnelStream> = connector\n                .connect(dns_name, tunnel_stream)\n                .await\n                .map_err(|err| RequestError::TlsConnectorBuild(err.to_string()))?;\n            return Ok(Box::new(tls_stream));\n        }\n        Ok(proxy_stream)\n    }\n\n    /// Sends the HTTP request asynchronously.\n    ///\n    /// # Returns\n    ///\n    /// - `RequestResult` - Result of the async request.\n    pub(crate) async fn send_async(&mut self) -> RequestResult {\n        let methods: Method = self.get_methods();\n        let (host, port) = {\n            if let Ok(mut config) = self.config.write() {\n                config.url_obj = self\n                    .parse_url()\n                    .map_err(|err| RequestError::InvalidUrl(err.to_string()))?;\n                let host: String = config.url_obj.host.clone().unwrap_or_default();\n                let port = self.get_port(config.url_obj.port.clone().unwrap_or_default(), &config);\n                (host, port)\n            } else {\n                (String::new(), 0u16)\n            }\n        };\n        let mut stream: BoxAsyncReadWrite = self.get_connection_stream_async(host, port).await?;\n        let res: Result<BoxResponseTrait, RequestError> = match methods {\n            m if m.is_get() => self.send_get_request_async(&mut stream).await,\n            m if m.is_post() => self.send_post_request_async(&mut stream).await,\n            err => Err(RequestError::Request(format!(\n                \"do not support {} method\",\n                err\n            ))),\n        };\n        res\n    }\n}", "file_size": 66214, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\lib.rs", "language": "rust", "content": "//! http-constant\n//! A comprehensive library providing common HTTP constants for\n//! header names, versions, MIME types, and protocol identifiers.\n\npub(crate) mod common;\npub(crate) mod content_type_value;\npub(crate) mod file_extension;\npub(crate) mod header_key;\npub(crate) mod header_value;\npub(crate) mod http_status;\npub(crate) mod http_version;\npub(crate) mod method;\npub(crate) mod protocol;\npub(crate) mod session;\n\npub(crate) use std::{\n    net::{Ipv4Addr, SocketAddr, SocketAddrV4},\n    time::Duration,\n};\n\npub use common::*;\npub use content_type_value::*;\npub use file_extension::*;\npub use header_key::*;\npub use header_value::*;\npub use http_status::*;\npub use http_version::*;\npub use method::*;\npub use protocol::*;\npub use session::*;", "file_size": 750, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents an HTTP request, encapsulating various components such as the method, URL, protocol,\n/// headers, body, and additional metadata.\n#[derive(Debug, Clone)]\npub(crate) struct HttpRequest {\n    /// HTTP request methods.\n    pub(crate) methods: Arc<Method>,\n    /// Target URL for the request.\n    pub(crate) url: Arc<String>,\n    /// HTTP request headers.\n    pub(crate) header: Arc<RequestHeaders>,\n    /// HTTP request body content.\n    pub(crate) body: Arc<Body>,\n    /// Request configuration settings.\n    pub(crate) config: ArcRwLock<Config>,\n    /// Temporary storage for request processing.\n    pub(crate) tmp: ArcRwLock<Tmp>,\n    /// Response storage for the request.\n    pub(crate) response: ArcRwLock<HttpResponseBinary>,\n}", "file_size": 759, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\const.rs", "language": "rust", "content": "/// Byte pattern for matching 'content-length' header in HTTP requests.\n///\n/// Used for case-sensitive matching of the content-length header.\npub(crate) const CONTENT_LENGTH_PATTERN: &[u8] = b\"content-length:\";", "file_size": 211, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\header_key\\const.rs", "language": "rust", "content": "/// The HTTP header field name `server`.\npub const SERVER: &str = \"server\";\n\n/// The HTTP header field name `accept`.\npub const ACCEPT: &str = \"accept\";\n\n/// The HTTP header field name `accept-encoding`, used to specify acceptable content encodings.\npub const ACCEPT_ENCODING: &str = \"accept-encoding\";\n\n/// The HTTP header field name `accept-language`, used to specify preferred languages for the response.\npub const ACCEPT_LANGUAGE: &str = \"accept-language\";\n\n/// The HTTP header field name `authorization`, used to specify authentication credentials.\npub const AUTHORIZATION: &str = \"authorization\";\n\n/// The HTTP header field name `cache-control`, used to specify caching directives.\npub const CACHE_CONTROL: &str = \"cache-control\";\n\n/// The HTTP header field name `connection`, used to specify control options for the current connection.\npub const CONNECTION: &str = \"connection\";\n\n/// The HTTP header field name `cookie`, used to send cookies from the server to the client.\npub const COOKIE: &str = \"cookie\";\n\n/// The HTTP header field name `date`, used to specify the date and time at which the message was sent.\npub const DATE: &str = \"date\";\n\n/// The HTTP header field name `etag`, used to specify a unique identifier for a resource version.\npub const ETAG: &str = \"etag\";\n\n/// The HTTP header field name `host`, used to specify the host and port number of the server.\npub const HOST: &str = \"host\";\n\n/// The HTTP header field name `last-modified`, used to specify the last modification date of the resource.\npub const LAST_MODIFIED: &str = \"last-modified\";\n\n/// The HTTP header field name `location`, used to specify the url to redirect a client.\npub const LOCATION: &str = \"location\";\n\n/// The HTTP header field name `referer`, used to specify the url of the referring resource.\npub const REFERER: &str = \"referer\";\n\n/// The HTTP header field name `set-cookie`, used to send cookies from the server to the client.\npub const SET_COOKIE: &str = \"set-cookie\";\n\n/// The HTTP header field name `transfer-encoding`, used to specify the form of encoding used to safely transfer the entity to the user.\npub const TRANSFER_ENCODING: &str = \"transfer-encoding\";\n\n/// The HTTP header field name `upgrade`, used to indicate the protocol the client wants to upgrade to.\npub const UPGRADE: &str = \"upgrade\";\n\n/// The HTTP header field name `sec-websocket-accept`.\npub const SEC_WEBSOCKET_ACCEPT: &str = \"sec-websocket-accept\";\n\n/// The HTTP header field name `sec-websocket-key`.\npub const SEC_WEBSOCKET_KEY: &str = \"sec-websocket-key\";\n\n/// The HTTP header field name `sec-websocket-protocol`.\npub const SEC_WEBSOCKET_VERSION: &str = \"sec-websocket-version\";\n\n/// The HTTP header field name `sec-websocket-protocol`.\npub const SEC_WEBSOCKET_PROTOCOL: &str = \"sec-websocket-protocol\";\n\n/// The HTTP header field name `sec-websocket-extensions`.\npub const SEC_WEBSOCKET_EXTENSIONS: &str = \"sec-websocket-extensions\";\n\n/// The HTTP header field name `vary`, used to specify that the response may vary based on certain request headers.\npub const VARY: &str = \"vary\";\n\n/// The HTTP header field name `x-frame-options`, used to specify whether a browser should be allowed to render a page in a `<frame>`.\npub const X_FRAME_OPTIONS: &str = \"x-frame-options\";\n\n/// The HTTP header field name `x-content-type-options`, used to indicate that the browser should not sniff the mime type of a response.\npub const X_CONTENT_TYPE_OPTIONS: &str = \"x-content-type-options\";\n\n/// The HTTP header field name `x-powered-by`, used to indicate the technology used by the server.\npub const X_POWERED_BY: &str = \"x-powered-by\";\n\n/// The HTTP header field name `x-requested-with`, used to identify the type of request, typically for ajax requests.\npub const X_REQUESTED_WITH: &str = \"x-requested-with\";\n\n/// The HTTP header field name `content-length`.\npub const CONTENT_LENGTH: &str = \"content-length\";\n\n/// The HTTP header field name `content-encoding`, used to specify the encoding transformations applied to the response body.\npub const CONTENT_ENCODING: &str = \"content-encoding\";\n\n/// The HTTP header field name content-type, used to specify the media type of the resource or the data being sent in an http request or response.\npub const CONTENT_TYPE: &str = \"content-type\";\n\n/// The HTTP header field `user-agent`.\npub const USER_AGENT: &str = \"user-agent\";\n\n/// The HTTP header field `access-control-allow-origin`, used to specify which origins are allowed to access the resource.\npub const ACCESS_CONTROL_ALLOW_ORIGIN: &str = \"access-control-allow-origin\";\n\n/// The HTTP header field `access-control-allow-methods`, used to specify The HTTP methods that are allowed when accessing the resource.\npub const ACCESS_CONTROL_ALLOW_METHODS: &str = \"access-control-allow-methods\";\n\n/// The HTTP header field `access-control-allow-headers`, used to specify which http headers can be used during the request.\npub const ACCESS_CONTROL_ALLOW_HEADERS: &str = \"access-control-allow-headers\";\n\n/// The HTTP header field `expires`, used to specify the date/time after which the response is considered stale.\npub const EXPIRES: &str = \"expires\";\n\n/// The HTTP header field `if-match`, used to make a request conditional based on etag values.\npub const IF_MATCH: &str = \"if-match\";\n\n/// The HTTP header field `if-none-match`, used to make a request conditional based on etag values.\npub const IF_NONE_MATCH: &str = \"if-none-match\";\n\n/// The HTTP header field `if-modified-since`, used to make a request conditional based on timestamps.\npub const IF_MODIFIED_SINCE: &str = \"if-modified-since\";\n\n/// The HTTP header field `if-unmodified-since`, used to make a request conditional based on timestamps.\npub const IF_UNMODIFIED_SINCE: &str = \"if-unmodified-since\";\n\n/// The HTTP header field `accept-charset`, used to specify which character sets are acceptable.\npub const ACCEPT_CHARSET: &str = \"accept-charset\";\n\n/// The HTTP header field `access-control-max-age`, used to indicate how long the results of a preflight request can be cached.\npub const ACCESS_CONTROL_MAX_AGE: &str = \"access-control-max-age\";\n\n/// The HTTP header field `access-control-expose-headers`, used to indicate which headers can be exposed as part of the response.\npub const ACCESS_CONTROL_EXPOSE_HEADERS: &str = \"access-control-expose-headers\";\n\n/// The HTTP header field `access-control-request-headers`, used in preflight requests to indicate which headers will be used.\npub const ACCESS_CONTROL_REQUEST_HEADERS: &str = \"access-control-request-headers\";\n\n/// The HTTP header field `access-control-request-method`, used in preflight requests to indicate which HTTP method will be used.\npub const ACCESS_CONTROL_REQUEST_METHOD: &str = \"access-control-request-method\";\n\n/// The HTTP header field `allow`, used to specify supported HTTP methods.\npub const ALLOW: &str = \"allow\";\n\n/// The HTTP header field `content-disposition`, used to indicate how the content should be displayed.\npub const CONTENT_DISPOSITION: &str = \"content-disposition\";\n\n/// The HTTP header field `content-language`, used to specify the language of the content.\npub const CONTENT_LANGUAGE: &str = \"content-language\";\n\n/// The HTTP header field `content-range`, used to indicate where in the full resource this partial message belongs.\npub const CONTENT_RANGE: &str = \"content-range\";\n\n/// The HTTP header field `origin`, used to indicate where the cross-origin request originates from.\npub const ORIGIN: &str = \"origin\";\n\n/// The HTTP header field `pragma`, used to include implementation-specific directives.\npub const PRAGMA: &str = \"pragma\";\n\n/// The HTTP header field `proxy-authenticate`, used in responses from a proxy to indicate authentication is required.\npub const PROXY_AUTHENTICATE: &str = \"proxy-authenticate\";\n\n/// The HTTP header field `proxy-authorization`, used to authenticate with a proxy server.\npub const PROXY_AUTHORIZATION: &str = \"proxy-authorization\";\n\n/// The HTTP header field `retry-after`, used to indicate how long to wait before making a new request.\npub const RETRY_AFTER: &str = \"retry-after\";\n\n/// The HTTP header field `strict-transport-security`, used to specify that the browser should only connect using HTTPS.\npub const STRICT_TRANSPORT_SECURITY: &str = \"strict-transport-security\";\n\n/// The HTTP header field `www-authenticate`, used to indicate the authentication scheme.\npub const WWW_AUTHENTICATE: &str = \"www-authenticate\";\n\n/// The HTTP/2 pseudo-header field `:authority`, used to specify the authority portion of the target URI.\npub const COLON_AUTHORITY: &str = \":authority\";\n\n/// The HTTP/2 pseudo-header field `:method`, used to specify the HTTP method.\npub const COLON_METHOD: &str = \":method\";\n\n/// The HTTP/2 pseudo-header field `:path`, used to specify the path and query parts of the target URI.\npub const COLON_PATH: &str = \":path\";\n\n/// The HTTP/2 pseudo-header field `:scheme`, used to specify the scheme portion of the target URI.\npub const COLON_SCHEME: &str = \":scheme\";\n\n/// The HTTP header field `priority`, used to indicate the priority of the request.\npub const PRIORITY: &str = \"priority\";\n\n/// The HTTP header field `sec-ch-ua`, used to indicate the user agent's brand and version.\npub const SEC_CH_UA: &str = \"sec-ch-ua\";\n\n/// The HTTP header field `sec-ch-ua-mobile`, used to indicate whether the user agent is running on a mobile device.\npub const SEC_CH_UA_MOBILE: &str = \"sec-ch-ua-mobile\";\n\n/// The HTTP header field `sec-ch-ua-platform`, used to indicate the platform the user agent is running on.\npub const SEC_CH_UA_PLATFORM: &str = \"sec-ch-ua-platform\";\n\n/// The HTTP header field `sec-fetch-dest`, used to indicate the destination of the request.\npub const SEC_FETCH_DEST: &str = \"sec-fetch-dest\";\n\n/// The HTTP header field `sec-fetch-mode`, used to indicate the mode of the request.\npub const SEC_FETCH_MODE: &str = \"sec-fetch-mode\";\n\n/// The HTTP header field `sec-fetch-site`, used to indicate the relationship between the request initiator's origin and the origin of the requested resource.\npub const SEC_FETCH_SITE: &str = \"sec-fetch-site\";\n\n/// The HTTP header field `age`, used to indicate the age of the response in seconds.\npub const AGE: &str = \"age\";\n\n/// The HTTP header field `alt-svc`, used to advertise alternative services through which the same resource can be reached.\npub const ALT_SVC: &str = \"alt-svc\";\n\n/// The HTTP header field `expect`, used to indicate expectations that need to be fulfilled by the server.\npub const EXPECT: &str = \"expect\";\n\n/// The HTTP header field `forwarded`, used to disclose original information of a client connecting to a web server through an HTTP proxy.\npub const FORWARDED: &str = \"forwarded\";\n\n/// The HTTP header field `from`, used to specify an Internet email address for a human user.\npub const FROM: &str = \"from\";\n\n/// The HTTP header field `link`, used to specify relationships between resources.\npub const LINK: &str = \"link\";\n\n/// The HTTP header field `max-forwards`, used to limit the number of times a message can be forwarded through proxies or gateways.\npub const MAX_FORWARDS: &str = \"max-forwards\";\n\n/// The HTTP header field `range`, used to specify the range of a resource to be retrieved.\npub const RANGE: &str = \"range\";\n\n/// The HTTP header field `te`, used to specify which transfer encodings the user agent is willing to accept.\npub const TE: &str = \"te\";\n\n/// The HTTP header field `via`, used to indicate the intermediate protocols and recipients between the user agent and the server.\npub const VIA: &str = \"via\";\n\n/// The HTTP header field `dnt`, used to specify the user's tracking preference.\npub const DNT: &str = \"dnt\";\n\n/// The HTTP header field `sec-fetch-user`, used to indicate whether the request was triggered by a user activation.\npub const SEC_FETCH_USER: &str = \"sec-fetch-user\";\n\n/// The HTTP header field `accept-ranges`, used to specify the range units that can be accepted.\npub const ACCEPT_RANGES: &str = \"accept-ranges\";\n\n/// The HTTP header field `content-md5`, used to specify the MD5 checksum of the entity-body.\npub const CONTENT_MD5: &str = \"content-md5\";\n\n/// The HTTP header field `content-location`, used to specify the location of the resource.\npub const CONTENT_LOCATION: &str = \"content-location\";\n\n/// The HTTP header field `content-security-policy`, used to specify the security policy of the resource.\npub const CONTENT_SECURITY_POLICY: &str = \"content-security-policy\";\n\n/// The HTTP header field `content-security-policy-report-only`, used to specify the security policy of the resource.\npub const CONTENT_SECURITY_POLICY_REPORT_ONLY: &str = \"content-security-policy-report-only\";\n\n/// The HTTP header field `content-security-policy-report`, used to specify the security policy of the resource.\npub const CONTENT_SECURITY_POLICY_REPORT: &str = \"content-security-policy-report\";\n\n/// The HTTP header field `content-security-policy-report-to`, used to specify the security policy of the resource.\npub const CONTENT_SECURITY_POLICY_REPORT_TO: &str = \"content-security-policy-report-to\";\n\n/// The HTTP header field `content-security-policy-report-uri`, used to specify the security policy of the resource.\npub const CONTENT_SECURITY_POLICY_REPORT_URI: &str = \"content-security-policy-report-uri\";\n\n/// The HTTP header field `x-forwarded-for`, used to identify the originating IP address of a client connecting through a proxy.\npub const X_FORWARDED_FOR: &str = \"x-forwarded-for\";\n\n/// The HTTP header field `x-forwarded-host`, used to identify the original host requested by the client.\npub const X_FORWARDED_HOST: &str = \"x-forwarded-host\";\n\n/// The HTTP header field `x-forwarded-proto`, used to identify the protocol used by the client to connect to the proxy.\npub const X_FORWARDED_PROTO: &str = \"x-forwarded-proto\";\n\n/// The HTTP header field `x-forwarded-port`, used to identify the port used by the client to connect to the proxy.\npub const X_FORWARDED_PORT: &str = \"x-forwarded-port\";\n\n/// The HTTP header field `x-real-ip`, used to identify the real IP address of the client.\npub const X_REAL_IP: &str = \"x-real-ip\";\n\n/// The HTTP header field `accept-patch`, used to specify which patch document formats are accepted.\npub const ACCEPT_PATCH: &str = \"accept-patch\";\n\n/// The HTTP header field `if-range`, used to make a range request conditional.\npub const IF_RANGE: &str = \"if-range\";\n\n/// The HTTP header field `warning`, used to carry additional information about the status of a response.\npub const WARNING_HEADER: &str = \"warning\";\n\n/// The HTTP header field `upgrade-insecure-requests`, used to signal the server that the client prefers encrypted responses.\npub const UPGRADE_INSECURE_REQUESTS: &str = \"upgrade-insecure-requests\";\n\n/// The HTTP header field `x-xss-protection`, used to enable XSS filtering in browsers.\npub const X_XSS_PROTECTION: &str = \"x-xss-protection\";\n\n/// The HTTP header field `referrer-policy`, used to control how much referrer information is included with requests.\npub const REFERRER_POLICY: &str = \"referrer-policy\";\n\n/// The HTTP header field `feature-policy`, used to control which browser features can be used.\npub const FEATURE_POLICY: &str = \"feature-policy\";\n\n/// The HTTP header field `permissions-policy`, used to control which browser features can be used.\npub const PERMISSIONS_POLICY: &str = \"permissions-policy\";\n\n/// The HTTP header field `cross-origin-embedder-policy`, used to prevent a document from loading cross-origin resources.\npub const CROSS_ORIGIN_EMBEDDER_POLICY: &str = \"cross-origin-embedder-policy\";\n\n/// The HTTP header field `cross-origin-opener-policy`, used to ensure a top-level document does not share a browsing context group.\npub const CROSS_ORIGIN_OPENER_POLICY: &str = \"cross-origin-opener-policy\";\n\n/// The HTTP header field `cross-origin-resource-policy`, used to convey a desire that the browser blocks no-cors cross-origin requests.\npub const CROSS_ORIGIN_RESOURCE_POLICY: &str = \"cross-origin-resource-policy\";\n\n/// The HTTP header field `timing-allow-origin`, used to specify origins that are allowed to see timing information.\npub const TIMING_ALLOW_ORIGIN: &str = \"timing-allow-origin\";\n\n/// The HTTP header field `server-timing`, used to communicate performance metrics about the request-response cycle.\npub const SERVER_TIMING: &str = \"server-timing\";\n\n/// The HTTP header field `clear-site-data`, used to clear browsing data associated with the requesting website.\npub const CLEAR_SITE_DATA: &str = \"clear-site-data\";\n\n/// The HTTP header field `early-data`, used to indicate that the request was sent in TLS early data.\npub const EARLY_DATA: &str = \"early-data\";\n\n/// The HTTP header field `accept-post`, used to specify which media types are accepted for POST requests.\npub const ACCEPT_POST: &str = \"accept-post\";\n\n/// The HTTP header field `access-control-allow-credentials`, used to indicate whether credentials can be exposed.\npub const ACCESS_CONTROL_ALLOW_CREDENTIALS: &str = \"access-control-allow-credentials\";\n\n/// The HTTP header field `nel`, used to define a network error logging policy.\npub const NEL: &str = \"nel\";\n\n/// The HTTP header field `report-to`, used to specify endpoints for reporting.\npub const REPORT_TO: &str = \"report-to\";\n\n/// The HTTP header field `x-dns-prefetch-control`, used to control DNS prefetching.\npub const X_DNS_PREFETCH_CONTROL: &str = \"x-dns-prefetch-control\";\n\n/// The HTTP header field `x-download-options`, used to prevent file downloads from being executed.\npub const X_DOWNLOAD_OPTIONS: &str = \"x-download-options\";\n\n/// The HTTP header field `x-permitted-cross-domain-policies`, used to control cross-domain policy files.\npub const X_PERMITTED_CROSS_DOMAIN_POLICIES: &str = \"x-permitted-cross-domain-policies\";\n\n/// The HTTP header field `x-robots-tag`, used to control how search engines index content.\npub const X_ROBOTS_TAG: &str = \"x-robots-tag\";\n\n/// The HTTP header field `x-ua-compatible`, used to specify which version of Internet Explorer the page should be rendered as.\npub const X_UA_COMPATIBLE: &str = \"x-ua-compatible\";", "file_size": 17974, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\proxy\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of ProxyTunnelStream methods.\nimpl ProxyTunnelStream {\n    /// Creates a new ProxyTunnelStream from an async read/write stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `BoxAsyncReadWrite` - The async stream to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `ProxyTunnelStream` - The new proxy tunnel stream.\n    pub(crate) fn new(stream: BoxAsyncReadWrite, pre_read_data: Vec<u8>) -> Self {\n        Self {\n            inner: stream,\n            pre_read_data,\n        }\n    }\n}\n\n/// AsyncRead implementation for ProxyTunnelStream.\n///\n/// Delegates all operations to the underlying stream.\nimpl AsyncRead for ProxyTunnelStream {\n    fn poll_read(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &mut ReadBuf<'_>,\n    ) -> Poll<std::io::Result<()>> {\n        if !self.pre_read_data.is_empty() {\n            let len: usize = std::cmp::min(self.pre_read_data.len(), buf.remaining());\n            buf.put_slice(&self.pre_read_data[..len]);\n            self.pre_read_data.drain(..len);\n            return Poll::Ready(Ok(()));\n        }\n        Pin::new(&mut self.inner).poll_read(cx, buf)\n    }\n}\n\n/// AsyncWrite implementation for ProxyTunnelStream.\n///\n/// Delegates all operations to the underlying stream.\nimpl AsyncWrite for ProxyTunnelStream {\n    fn poll_write(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n        buf: &[u8],\n    ) -> Poll<Result<usize, std::io::Error>> {\n        Pin::new(&mut self.inner).poll_write(cx, buf)\n    }\n\n    fn poll_flush(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Result<(), std::io::Error>> {\n        Pin::new(&mut self.inner).poll_flush(cx)\n    }\n\n    fn poll_shutdown(\n        mut self: Pin<&mut Self>,\n        cx: &mut Context<'_>,\n    ) -> Poll<Result<(), std::io::Error>> {\n        Pin::new(&mut self.inner).poll_shutdown(cx)\n    }\n}\n\nimpl Unpin for ProxyTunnelStream {}\n\n/// Implementation of SyncProxyTunnelStream methods.\nimpl SyncProxyTunnelStream {\n    /// Creates a new SyncProxyTunnelStream from a sync read/write stream.\n    ///\n    /// # Arguments\n    ///\n    /// - `BoxReadWrite` - The sync stream to wrap.\n    ///\n    /// # Returns\n    ///\n    /// - `SyncProxyTunnelStream` - The new sync proxy tunnel stream.\n    pub(crate) fn new(stream: BoxReadWrite, pre_read_data: Vec<u8>) -> Self {\n        Self {\n            inner: stream,\n            pre_read_data,\n        }\n    }\n}\n\n/// Read implementation for SyncProxyTunnelStream.\n///\n/// Delegates all operations to the underlying stream.\nimpl Read for SyncProxyTunnelStream {\n    fn read(&mut self, buf: &mut [u8]) -> std::io::Result<usize> {\n        if !self.pre_read_data.is_empty() {\n            let len: usize = std::cmp::min(self.pre_read_data.len(), buf.len());\n            buf[..len].copy_from_slice(&self.pre_read_data[..len]);\n            self.pre_read_data.drain(..len);\n            return Ok(len);\n        }\n        self.inner.read(buf)\n    }\n}\n\n/// Write implementation for SyncProxyTunnelStream.\n///\n/// Delegates all operations to the underlying stream.\nimpl Write for SyncProxyTunnelStream {\n    fn write(&mut self, buf: &[u8]) -> std::io::Result<usize> {\n        self.inner.write(buf)\n    }\n\n    fn flush(&mut self) -> std::io::Result<()> {\n        self.inner.flush()\n    }\n}", "file_size": 3317, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\file_extension\\const.rs", "language": "rust", "content": "/// The file extension for Lotus 1-2-3.\npub const FILE_EXTENSION_123: &str = \"123\";\n/// The file extension for 3DML.\npub const FILE_EXTENSION_3DML: &str = \"3dml\";\n/// The file extension for 3D Studio.\npub const FILE_EXTENSION_3DS: &str = \"3ds\";\n/// The file extension for 3GPP2.\npub const FILE_EXTENSION_3G2: &str = \"3g2\";\n/// The file extension for 3GPP.\npub const FILE_EXTENSION_3GP: &str = \"3gp\";\n/// The file extension for 7-Zip.\npub const FILE_EXTENSION_7Z: &str = \"7z\";\n/// The file extension for Authorware.\npub const FILE_EXTENSION_AAB: &str = \"aab\";\n/// The file extension for AAC audio.\npub const FILE_EXTENSION_AAC: &str = \"aac\";\n/// The file extension for Authorware.\npub const FILE_EXTENSION_AAM: &str = \"aam\";\n/// The file extension for Authorware.\npub const FILE_EXTENSION_AAS: &str = \"aas\";\n/// The file extension for an absolute file.\npub const FILE_EXTENSION_ABS: &str = \"abs\";\n/// The file extension for AbiWord.\npub const FILE_EXTENSION_ABW: &str = \"abw\";\n/// The file extension for an AC file.\npub const FILE_EXTENSION_AC: &str = \"ac\";\n/// The file extension for American Dynamics ACC.\npub const FILE_EXTENSION_ACC: &str = \"acc\";\n/// The file extension for ACE archive.\npub const FILE_EXTENSION_ACE: &str = \"ace\";\n/// The file extension for AcuCobol.\npub const FILE_EXTENSION_ACU: &str = \"acu\";\n/// The file extension for AcuCobol.\npub const FILE_EXTENSION_ACUTC: &str = \"acutc\";\n/// The file extension for ADPCM audio.\npub const FILE_EXTENSION_ADP: &str = \"adp\";\n/// The file extension for Audiograph.\npub const FILE_EXTENSION_AEP: &str = \"aep\";\n/// The file extension for Adobe Font Metrics.\npub const FILE_EXTENSION_AFM: &str = \"afm\";\n/// The file extension for AFP.\npub const FILE_EXTENSION_AFP: &str = \"afp\";\n/// The file extension for Ahead AIR Application.\npub const FILE_EXTENSION_AHEAD: &str = \"ahead\";\n/// The file extension for Adobe Illustrator.\npub const FILE_EXTENSION_AI: &str = \"ai\";\n/// The file extension for AIFF audio.\npub const FILE_EXTENSION_AIF: &str = \"aif\";\n/// The file extension for AIFF audio.\npub const FILE_EXTENSION_AIFC: &str = \"aifc\";\n/// The file extension for AIFF audio.\npub const FILE_EXTENSION_AIFF: &str = \"aiff\";\n/// The file extension for AIM.\npub const FILE_EXTENSION_AIM: &str = \"aim\";\n/// The file extension for Adobe AIR Application.\npub const FILE_EXTENSION_AIR: &str = \"air\";\n/// The file extension for DVB AIT.\npub const FILE_EXTENSION_AIT: &str = \"ait\";\n/// The file extension for Amiga AMI.\npub const FILE_EXTENSION_AMI: &str = \"ami\";\n/// The file extension for Annodex.\npub const FILE_EXTENSION_ANX: &str = \"anx\";\n/// The file extension for Android Package Archive.\npub const FILE_EXTENSION_APK: &str = \"apk\";\n/// The file extension for Cache Manifest.\npub const FILE_EXTENSION_APPCACHE: &str = \"appcache\";\n/// The file extension for Microsoft Application.\npub const FILE_EXTENSION_APPLICATION: &str = \"application\";\n/// The file extension for Lotus Approach.\npub const FILE_EXTENSION_APR: &str = \"apr\";\n/// The file extension for FreeArc archive.\npub const FILE_EXTENSION_ARC: &str = \"arc\";\n/// The file extension for ART image.\npub const FILE_EXTENSION_ART: &str = \"art\";\n/// The file extension for PGP signature.\npub const FILE_EXTENSION_ASC: &str = \"asc\";\n/// The file extension for ASF video.\npub const FILE_EXTENSION_ASF: &str = \"asf\";\n/// The file extension for Assembly source.\npub const FILE_EXTENSION_ASM: &str = \"asm\";\n/// The file extension for Accpac Simply ASO.\npub const FILE_EXTENSION_ASO: &str = \"aso\";\n/// The file extension for ASX video.\npub const FILE_EXTENSION_ASX: &str = \"asx\";\n/// The file extension for AcuCorp.\npub const FILE_EXTENSION_ATC: &str = \"atc\";\n/// The file extension for Atom feed.\npub const FILE_EXTENSION_ATOM: &str = \"atom\";\n/// The file extension for Atom category document.\npub const FILE_EXTENSION_ATOMCAT: &str = \"atomcat\";\n/// The file extension for Atom service document.\npub const FILE_EXTENSION_ATOMSVC: &str = \"atomsvc\";\n/// The file extension for Antix Game Component.\npub const FILE_EXTENSION_ATX: &str = \"atx\";\n/// The file extension for basic audio.\npub const FILE_EXTENSION_AU: &str = \"au\";\n/// The file extension for AVI video.\npub const FILE_EXTENSION_AVI: &str = \"avi\";\n/// The file extension for Rad ScreenPlay video.\npub const FILE_EXTENSION_AVX: &str = \"avx\";\n/// The file extension for Applixware.\npub const FILE_EXTENSION_AW: &str = \"aw\";\n/// The file extension for Annodex audio.\npub const FILE_EXTENSION_AXA: &str = \"axa\";\n/// The file extension for Annodex video.\npub const FILE_EXTENSION_AXV: &str = \"axv\";\n/// The file extension for AirZip FileSecure AZF.\npub const FILE_EXTENSION_AZF: &str = \"azf\";\n/// The file extension for AirZip FileSecure AZS.\npub const FILE_EXTENSION_AZS: &str = \"azs\";\n/// The file extension for Amazon Kindle eBook.\npub const FILE_EXTENSION_AZW: &str = \"azw\";\n/// The file extension for Batch file.\npub const FILE_EXTENSION_BAT: &str = \"bat\";\n/// The file extension for BCPIO archive.\npub const FILE_EXTENSION_BCPIO: &str = \"bcpio\";\n/// The file extension for BDF font.\npub const FILE_EXTENSION_BDF: &str = \"bdf\";\n/// The file extension for SyncML DM+WBXML.\npub const FILE_EXTENSION_BDM: &str = \"bdm\";\n/// The file extension for RealVNC BED.\npub const FILE_EXTENSION_BED: &str = \"bed\";\n/// The file extension for Fujitsu OasysPRS.\npub const FILE_EXTENSION_BH2: &str = \"bh2\";\n/// The file extension for binary data.\npub const FILE_EXTENSION_BIN: &str = \"bin\";\n/// The file extension for Blorb interactive fiction.\npub const FILE_EXTENSION_BLB: &str = \"blb\";\n/// The file extension for Blorb interactive fiction.\npub const FILE_EXTENSION_BLORB: &str = \"blorb\";\n/// The file extension for BMI.\npub const FILE_EXTENSION_BMI: &str = \"bmi\";\n/// The file extension for BMP image.\npub const FILE_EXTENSION_BMP: &str = \"bmp\";\n/// The file extension for a body file.\npub const FILE_EXTENSION_BODY: &str = \"body\";\n/// The file extension for a book file.\npub const FILE_EXTENSION_BOOK: &str = \"book\";\n/// The file extension for Preview Systems BOX.\npub const FILE_EXTENSION_BOX: &str = \"box\";\n/// The file extension for BZip2 archive.\npub const FILE_EXTENSION_BOZ: &str = \"boz\";\n/// The file extension for a package file.\npub const FILE_EXTENSION_BPK: &str = \"bpk\";\n/// The file extension for BTIF image.\npub const FILE_EXTENSION_BTIF: &str = \"btif\";\n/// The file extension for BZip archive.\npub const FILE_EXTENSION_BZ: &str = \"bz\";\n/// The file extension for BZip2 archive.\npub const FILE_EXTENSION_BZ2: &str = \"bz2\";\n/// The file extension for C source code.\npub const FILE_EXTENSION_C: &str = \"c\";\n/// The file extension for ClueTrust CartoMobile Config.\npub const FILE_EXTENSION_C11AMC: &str = \"c11amc\";\n/// The file extension for ClueTrust CartoMobile Config Package.\npub const FILE_EXTENSION_C11AMZ: &str = \"c11amz\";\n/// The file extension for Clonk C4Group.\npub const FILE_EXTENSION_C4D: &str = \"c4d\";\n/// The file extension for Clonk C4Group.\npub const FILE_EXTENSION_C4F: &str = \"c4f\";\n/// The file extension for Clonk C4Group.\npub const FILE_EXTENSION_C4G: &str = \"c4g\";\n/// The file extension for Clonk C4Group.\npub const FILE_EXTENSION_C4P: &str = \"c4p\";\n/// The file extension for Clonk C4Group.\npub const FILE_EXTENSION_C4U: &str = \"c4u\";\n/// The file extension for Microsoft Cabinet file.\npub const FILE_EXTENSION_CAB: &str = \"cab\";\n/// The file extension for CAF audio.\npub const FILE_EXTENSION_CAF: &str = \"caf\";\n/// The file extension for TCPDump capture file.\npub const FILE_EXTENSION_CAP: &str = \"cap\";\n/// The file extension for cURL CAR file.\npub const FILE_EXTENSION_CAR: &str = \"car\";\n/// The file extension for Microsoft PKI Security Catalog.\npub const FILE_EXTENSION_CAT: &str = \"cat\";\n/// The file extension for Comic Book archive.\npub const FILE_EXTENSION_CB7: &str = \"cb7\";\n/// The file extension for Comic Book archive.\npub const FILE_EXTENSION_CBA: &str = \"cba\";\n/// The file extension for Comic Book RAR archive.\npub const FILE_EXTENSION_CBR: &str = \"cbr\";\n/// The file extension for Comic Book archive.\npub const FILE_EXTENSION_CBT: &str = \"cbt\";\n/// The file extension for Comic Book ZIP archive.\npub const FILE_EXTENSION_CBZ: &str = \"cbz\";\n/// The file extension for C++ source code.\npub const FILE_EXTENSION_CC: &str = \"cc\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_CCT: &str = \"cct\";\n/// The file extension for CCXML.\npub const FILE_EXTENSION_CCXML: &str = \"ccxml\";\n/// The file extension for Contact CMSG.\npub const FILE_EXTENSION_CDBCMSG: &str = \"cdbcmsg\";\n/// The file extension for CDF.\npub const FILE_EXTENSION_CDF: &str = \"cdf\";\n/// The file extension for MediaStation CDKey.\npub const FILE_EXTENSION_CDKEY: &str = \"cdkey\";\n/// The file extension for CDMI Capability.\npub const FILE_EXTENSION_CDMIA: &str = \"cdmia\";\n/// The file extension for CDMI Container.\npub const FILE_EXTENSION_CDMIC: &str = \"cdmic\";\n/// The file extension for CDMI Domain.\npub const FILE_EXTENSION_CDMID: &str = \"cdmid\";\n/// The file extension for CDMI Object.\npub const FILE_EXTENSION_CDMIO: &str = \"cdmio\";\n/// The file extension for CDMI Queue.\npub const FILE_EXTENSION_CDMIQ: &str = \"cdmiq\";\n/// The file extension for ChemDraw CDX.\npub const FILE_EXTENSION_CDX: &str = \"cdx\";\n/// The file extension for ChemDraw XML.\npub const FILE_EXTENSION_CDXML: &str = \"cdxml\";\n/// The file extension for Cinderella.\npub const FILE_EXTENSION_CDY: &str = \"cdy\";\n/// The file extension for PKIX Certificate.\npub const FILE_EXTENSION_CER: &str = \"cer\";\n/// The file extension for CFS compressed file.\npub const FILE_EXTENSION_CFS: &str = \"cfs\";\n/// The file extension for CGM image.\npub const FILE_EXTENSION_CGM: &str = \"cgm\";\n/// The file extension for Chat file.\npub const FILE_EXTENSION_CHAT: &str = \"chat\";\n/// The file extension for Microsoft HTML Help.\npub const FILE_EXTENSION_CHM: &str = \"chm\";\n/// The file extension for KDE KChart.\npub const FILE_EXTENSION_CHRT: &str = \"chrt\";\n/// The file extension for CIF.\npub const FILE_EXTENSION_CIF: &str = \"cif\";\n/// The file extension for Anser-Web Certificate Issue Initiation.\npub const FILE_EXTENSION_CII: &str = \"cii\";\n/// The file extension for Microsoft ArtGalry.\npub const FILE_EXTENSION_CIL: &str = \"cil\";\n/// The file extension for Claymore.\npub const FILE_EXTENSION_CLA: &str = \"cla\";\n/// The file extension for Java class.\npub const FILE_EXTENSION_CLASS: &str = \"class\";\n/// The file extension for Crick Clicker Keyboard.\npub const FILE_EXTENSION_CLKK: &str = \"clkk\";\n/// The file extension for Crick Clicker Palette.\npub const FILE_EXTENSION_CLKP: &str = \"clkp\";\n/// The file extension for Crick Clicker Template.\npub const FILE_EXTENSION_CLKT: &str = \"clkt\";\n/// The file extension for Crick Clicker Wordbank.\npub const FILE_EXTENSION_CLKW: &str = \"clkw\";\n/// The file extension for Crick Clicker.\npub const FILE_EXTENSION_CLKX: &str = \"clkx\";\n/// The file extension for Microsoft Clipboard.\npub const FILE_EXTENSION_CLP: &str = \"clp\";\n/// The file extension for CosmoCaller.\npub const FILE_EXTENSION_CMC: &str = \"cmc\";\n/// The file extension for CMDF.\npub const FILE_EXTENSION_CMDF: &str = \"cmdf\";\n/// The file extension for CML.\npub const FILE_EXTENSION_CML: &str = \"cml\";\n/// The file extension for a CMP file.\npub const FILE_EXTENSION_CMP: &str = \"cmp\";\n/// The file extension for CMX image.\npub const FILE_EXTENSION_CMX: &str = \"cmx\";\n/// The file extension for RIM COD.\npub const FILE_EXTENSION_COD: &str = \"cod\";\n/// The file extension for a command file.\npub const FILE_EXTENSION_COM: &str = \"com\";\n/// The file extension for a configuration file.\npub const FILE_EXTENSION_CONF: &str = \"conf\";\n/// The file extension for CPIO archive.\npub const FILE_EXTENSION_CPIO: &str = \"cpio\";\n/// The file extension for C++ source code.\npub const FILE_EXTENSION_CPP: &str = \"cpp\";\n/// The file extension for Mac CompactPro.\npub const FILE_EXTENSION_CPT: &str = \"cpt\";\n/// The file extension for Microsoft CardFile.\npub const FILE_EXTENSION_CRD: &str = \"crd\";\n/// The file extension for PKIX CRL.\npub const FILE_EXTENSION_CRL: &str = \"crl\";\n/// The file extension for X.509 CA Certificate.\npub const FILE_EXTENSION_CRT: &str = \"crt\";\n/// The file extension for Rig Cryptonote.\npub const FILE_EXTENSION_CRYPTONOTE: &str = \"cryptonote\";\n/// The file extension for C-Shell script.\npub const FILE_EXTENSION_CSH: &str = \"csh\";\n/// The file extension for CSML.\npub const FILE_EXTENSION_CSML: &str = \"csml\";\n/// The file extension for CommonSpace.\npub const FILE_EXTENSION_CSP: &str = \"csp\";\n/// The file extension for CSS.\npub const FILE_EXTENSION_CSS: &str = \"css\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_CST: &str = \"cst\";\n/// The file extension for CSV.\npub const FILE_EXTENSION_CSV: &str = \"csv\";\n/// The file extension for CU-SeeMe.\npub const FILE_EXTENSION_CU: &str = \"cu\";\n/// The file extension for cURL text.\npub const FILE_EXTENSION_CURL: &str = \"curl\";\n/// The file extension for CWW.\npub const FILE_EXTENSION_CWW: &str = \"cww\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_CXT: &str = \"cxt\";\n/// The file extension for C++ source code.\npub const FILE_EXTENSION_CXX: &str = \"cxx\";\n/// The file extension for COLLADA XML.\npub const FILE_EXTENSION_DAE: &str = \"dae\";\n/// The file extension for Mobius DAF.\npub const FILE_EXTENSION_DAF: &str = \"daf\";\n/// The file extension for Dart.\npub const FILE_EXTENSION_DART: &str = \"dart\";\n/// The file extension for FDSN SEED.\npub const FILE_EXTENSION_DATALESS: &str = \"dataless\";\n/// The file extension for WebDAV Mount.\npub const FILE_EXTENSION_DAVMOUNT: &str = \"davmount\";\n/// The file extension for DocBook XML.\npub const FILE_EXTENSION_DBK: &str = \"dbk\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_DCR: &str = \"dcr\";\n/// The file extension for cURL DCURL.\npub const FILE_EXTENSION_DCURL: &str = \"dcurl\";\n/// The file extension for OMA DD2 XML.\npub const FILE_EXTENSION_DD2: &str = \"dd2\";\n/// The file extension for Fujixerox DDD.\npub const FILE_EXTENSION_DDD: &str = \"ddd\";\n/// The file extension for Debian package.\npub const FILE_EXTENSION_DEB: &str = \"deb\";\n/// The file extension for a definition file.\npub const FILE_EXTENSION_DEF: &str = \"def\";\n/// The file extension for a deployment file.\npub const FILE_EXTENSION_DEPLOY: &str = \"deploy\";\n/// The file extension for DER certificate.\npub const FILE_EXTENSION_DER: &str = \"der\";\n/// The file extension for DreamFactory.\npub const FILE_EXTENSION_DFAC: &str = \"dfac\";\n/// The file extension for DGC compressed.\npub const FILE_EXTENSION_DGC: &str = \"dgc\";\n/// The file extension for DIB image.\npub const FILE_EXTENSION_DIB: &str = \"dib\";\n/// The file extension for Yamaha HV Dictionary.\npub const FILE_EXTENSION_DIC: &str = \"dic\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_DIR: &str = \"dir\";\n/// The file extension for Mobius DIS.\npub const FILE_EXTENSION_DIS: &str = \"dis\";\n/// The file extension for a distribution file.\npub const FILE_EXTENSION_DIST: &str = \"dist\";\n/// The file extension for a distribution file.\npub const FILE_EXTENSION_DISTZ: &str = \"distz\";\n/// The file extension for DjVu image.\npub const FILE_EXTENSION_DJV: &str = \"djv\";\n/// The file extension for DjVu image.\npub const FILE_EXTENSION_DJVU: &str = \"djvu\";\n/// The file extension for Dynamic Link Library.\npub const FILE_EXTENSION_DLL: &str = \"dll\";\n/// The file extension for Apple Disk Image.\npub const FILE_EXTENSION_DMG: &str = \"dmg\";\n/// The file extension for TCPDump capture file.\npub const FILE_EXTENSION_DMP: &str = \"dmp\";\n/// The file extension for a DMS file.\npub const FILE_EXTENSION_DMS: &str = \"dms\";\n/// The file extension for DNA.\npub const FILE_EXTENSION_DNA: &str = \"dna\";\n/// The file extension for Microsoft Word.\npub const FILE_EXTENSION_DOC: &str = \"doc\";\n/// The file extension for Microsoft Word (Macro-Enabled).\npub const FILE_EXTENSION_DOCM: &str = \"docm\";\n/// The file extension for Office Open XML Word Document.\npub const FILE_EXTENSION_DOCX: &str = \"docx\";\n/// The file extension for Microsoft Word Template.\npub const FILE_EXTENSION_DOT: &str = \"dot\";\n/// The file extension for Microsoft Word Template (Macro-Enabled).\npub const FILE_EXTENSION_DOTM: &str = \"dotm\";\n/// The file extension for Office Open XML Word Template.\npub const FILE_EXTENSION_DOTX: &str = \"dotx\";\n/// The file extension for OSGi Deployment Package.\npub const FILE_EXTENSION_DP: &str = \"dp\";\n/// The file extension for DPGraph.\npub const FILE_EXTENSION_DPG: &str = \"dpg\";\n/// The file extension for DRA audio.\npub const FILE_EXTENSION_DRA: &str = \"dra\";\n/// The file extension for PRS Lines Tag.\npub const FILE_EXTENSION_DSC: &str = \"dsc\";\n/// The file extension for DSSC DER.\npub const FILE_EXTENSION_DSSC: &str = \"dssc\";\n/// The file extension for DTBook XML.\npub const FILE_EXTENSION_DTB: &str = \"dtb\";\n/// The file extension for XML DTD.\npub const FILE_EXTENSION_DTD: &str = \"dtd\";\n/// The file extension for DTS audio.\npub const FILE_EXTENSION_DTS: &str = \"dts\";\n/// The file extension for DTS HD audio.\npub const FILE_EXTENSION_DTSHD: &str = \"dtshd\";\n/// The file extension for a dump file.\npub const FILE_EXTENSION_DUMP: &str = \"dump\";\n/// The file extension for DV video.\npub const FILE_EXTENSION_DV: &str = \"dv\";\n/// The file extension for DVB file.\npub const FILE_EXTENSION_DVB: &str = \"dvb\";\n/// The file extension for DVI file.\npub const FILE_EXTENSION_DVI: &str = \"dvi\";\n/// The file extension for DWF model.\npub const FILE_EXTENSION_DWF: &str = \"dwf\";\n/// The file extension for DWG image.\npub const FILE_EXTENSION_DWG: &str = \"dwg\";\n/// The file extension for DXF image.\npub const FILE_EXTENSION_DXF: &str = \"dxf\";\n/// The file extension for Spotfire DXP.\npub const FILE_EXTENSION_DXP: &str = \"dxp\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_DXR: &str = \"dxr\";\n/// The file extension for Nuera ECELP 4800 audio.\npub const FILE_EXTENSION_ECELP4800: &str = \"ecelp4800\";\n/// The file extension for Nuera ECELP 7470 audio.\npub const FILE_EXTENSION_ECELP7470: &str = \"ecelp7470\";\n/// The file extension for Nuera ECELP 9600 audio.\npub const FILE_EXTENSION_ECELP9600: &str = \"ecelp9600\";\n/// The file extension for ECMAScript.\npub const FILE_EXTENSION_ECMA: &str = \"ecma\";\n/// The file extension for Novadigm EDM.\npub const FILE_EXTENSION_EDM: &str = \"edm\";\n/// The file extension for Novadigm EDX.\npub const FILE_EXTENSION_EDX: &str = \"edx\";\n/// The file extension for Picsel.\npub const FILE_EXTENSION_EFIF: &str = \"efif\";\n/// The file extension for PG OSASLI.\npub const FILE_EXTENSION_EI6: &str = \"ei6\";\n/// The file extension for an ELC file.\npub const FILE_EXTENSION_ELC: &str = \"elc\";\n/// The file extension for Microsoft Metafile.\npub const FILE_EXTENSION_EMF: &str = \"emf\";\n/// The file extension for RFC 822 message.\npub const FILE_EXTENSION_EML: &str = \"eml\";\n/// The file extension for EMMA XML.\npub const FILE_EXTENSION_EMMA: &str = \"emma\";\n/// The file extension for Microsoft Metafile.\npub const FILE_EXTENSION_EMZ: &str = \"emz\";\n/// The file extension for Digital Winds audio.\npub const FILE_EXTENSION_EOL: &str = \"eol\";\n/// The file extension for Microsoft Font Object.\npub const FILE_EXTENSION_EOT: &str = \"eot\";\n/// The file extension for PostScript.\npub const FILE_EXTENSION_EPS: &str = \"eps\";\n/// The file extension for EPUB.\npub const FILE_EXTENSION_EPUB: &str = \"epub\";\n/// The file extension for E-Szigno XML.\npub const FILE_EXTENSION_ES3: &str = \"es3\";\n/// The file extension for OSGi Subsystem.\npub const FILE_EXTENSION_ESA: &str = \"esa\";\n/// The file extension for Epson ESF.\npub const FILE_EXTENSION_ESF: &str = \"esf\";\n/// The file extension for E-Szigno XML.\npub const FILE_EXTENSION_ET3: &str = \"et3\";\n/// The file extension for Setext.\npub const FILE_EXTENSION_ETX: &str = \"etx\";\n/// The file extension for EVA.\npub const FILE_EXTENSION_EVA: &str = \"eva\";\n/// The file extension for Envoy.\npub const FILE_EXTENSION_EVY: &str = \"evy\";\n/// The file extension for an executable file.\npub const FILE_EXTENSION_EXE: &str = \"exe\";\n/// The file extension for EXI.\npub const FILE_EXTENSION_EXI: &str = \"exi\";\n/// The file extension for Novadigm EXT.\npub const FILE_EXTENSION_EXT: &str = \"ext\";\n/// The file extension for Andrew Inset.\npub const FILE_EXTENSION_EZ: &str = \"ez\";\n/// The file extension for EZPix Album.\npub const FILE_EXTENSION_EZ2: &str = \"ez2\";\n/// The file extension for EZPix Package.\npub const FILE_EXTENSION_EZ3: &str = \"ez3\";\n/// The file extension for Fortran source.\npub const FILE_EXTENSION_F: &str = \"f\";\n/// The file extension for F4V video.\npub const FILE_EXTENSION_F4V: &str = \"f4v\";\n/// The file extension for Fortran source.\npub const FILE_EXTENSION_F77: &str = \"f77\";\n/// The file extension for Fortran source.\npub const FILE_EXTENSION_F90: &str = \"f90\";\n/// The file extension for FastBidSheet.\npub const FILE_EXTENSION_FBS: &str = \"fbs\";\n/// The file extension for Adobe FormsCentral FCDT.\npub const FILE_EXTENSION_FCDT: &str = \"fcdt\";\n/// The file extension for ISAC FCS.\npub const FILE_EXTENSION_FCS: &str = \"fcs\";\n/// The file extension for FDF.\npub const FILE_EXTENSION_FDF: &str = \"fdf\";\n/// The file extension for deNovo FCSELAYOUT-LINK.\npub const FILE_EXTENSION_FE_LAUNCH: &str = \"fe_launch\";\n/// The file extension for Fujitsu OasysGP.\npub const FILE_EXTENSION_FG5: &str = \"fg5\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_FGD: &str = \"fgd\";\n/// The file extension for FreeHand image.\npub const FILE_EXTENSION_FH: &str = \"fh\";\n/// The file extension for FreeHand image.\npub const FILE_EXTENSION_FH4: &str = \"fh4\";\n/// The file extension for FreeHand image.\npub const FILE_EXTENSION_FH5: &str = \"fh5\";\n/// The file extension for FreeHand image.\npub const FILE_EXTENSION_FH7: &str = \"fh7\";\n/// The file extension for FreeHand image.\npub const FILE_EXTENSION_FHC: &str = \"fhc\";\n/// The file extension for Xfig image.\npub const FILE_EXTENSION_FIG: &str = \"fig\";\n/// The file extension for FLAC audio.\npub const FILE_EXTENSION_FLAC: &str = \"flac\";\n/// The file extension for FLI video.\npub const FILE_EXTENSION_FLI: &str = \"fli\";\n/// The file extension for Micrografx FLO.\npub const FILE_EXTENSION_FLO: &str = \"flo\";\n/// The file extension for FLV video.\npub const FILE_EXTENSION_FLV: &str = \"flv\";\n/// The file extension for KDE Kivio.\npub const FILE_EXTENSION_FLW: &str = \"flw\";\n/// The file extension for FMI Flexstor.\npub const FILE_EXTENSION_FLX: &str = \"flx\";\n/// The file extension for FLY text.\npub const FILE_EXTENSION_FLY: &str = \"fly\";\n/// The file extension for Adobe FrameMaker.\npub const FILE_EXTENSION_FM: &str = \"fm\";\n/// The file extension for Frogans FNC.\npub const FILE_EXTENSION_FNC: &str = \"fnc\";\n/// The file extension for Fortran source.\npub const FILE_EXTENSION_FOR: &str = \"for\";\n/// The file extension for FPX image.\npub const FILE_EXTENSION_FPX: &str = \"fpx\";\n/// The file extension for Adobe FrameMaker.\npub const FILE_EXTENSION_FRAME: &str = \"frame\";\n/// The file extension for FSC WebLaunch.\npub const FILE_EXTENSION_FSC: &str = \"fsc\";\n/// The file extension for FST image.\npub const FILE_EXTENSION_FST: &str = \"fst\";\n/// The file extension for FluxTime Clip.\npub const FILE_EXTENSION_FTC: &str = \"ftc\";\n/// The file extension for Anser-Web Funds Transfer Initiation.\npub const FILE_EXTENSION_FTI: &str = \"fti\";\n/// The file extension for FVT video.\npub const FILE_EXTENSION_FVT: &str = \"fvt\";\n/// The file extension for Adobe FXP.\npub const FILE_EXTENSION_FXP: &str = \"fxp\";\n/// The file extension for Adobe FXP.\npub const FILE_EXTENSION_FXPL: &str = \"fxpl\";\n/// The file extension for Fuzzysheet.\npub const FILE_EXTENSION_FZS: &str = \"fzs\";\n/// The file extension for GeoPlan.\npub const FILE_EXTENSION_G2W: &str = \"g2w\";\n/// The file extension for G3 fax image.\npub const FILE_EXTENSION_G3: &str = \"g3\";\n/// The file extension for GeoSpace.\npub const FILE_EXTENSION_G3W: &str = \"g3w\";\n/// The file extension for Groove Account.\npub const FILE_EXTENSION_GAC: &str = \"gac\";\n/// The file extension for TADS game.\npub const FILE_EXTENSION_GAM: &str = \"gam\";\n/// The file extension for RPKI Ghostbusters.\npub const FILE_EXTENSION_GBR: &str = \"gbr\";\n/// The file extension for GCA compressed archive.\npub const FILE_EXTENSION_GCA: &str = \"gca\";\n/// The file extension for GDL model.\npub const FILE_EXTENSION_GDL: &str = \"gdl\";\n/// The file extension for DynaGeo.\npub const FILE_EXTENSION_GEO: &str = \"geo\";\n/// The file extension for Geometry Explorer.\npub const FILE_EXTENSION_GEX: &str = \"gex\";\n/// The file extension for GeoGebra File.\npub const FILE_EXTENSION_GGB: &str = \"ggb\";\n/// The file extension for GeoGebra Tool.\npub const FILE_EXTENSION_GGT: &str = \"ggt\";\n/// The file extension for Groove Help.\npub const FILE_EXTENSION_GHF: &str = \"ghf\";\n/// The file extension for GIF image.\npub const FILE_EXTENSION_GIF: &str = \"gif\";\n/// The file extension for Groove Identity Message.\npub const FILE_EXTENSION_GIM: &str = \"gim\";\n/// The file extension for GML XML.\npub const FILE_EXTENSION_GML: &str = \"gml\";\n/// The file extension for GMX.\npub const FILE_EXTENSION_GMX: &str = \"gmx\";\n/// The file extension for Gnumeric.\npub const FILE_EXTENSION_GNUMERIC: &str = \"gnumeric\";\n/// The file extension for FlographIt.\npub const FILE_EXTENSION_GPH: &str = \"gph\";\n/// The file extension for GPX XML.\npub const FILE_EXTENSION_GPX: &str = \"gpx\";\n/// The file extension for Grafeq.\npub const FILE_EXTENSION_GQF: &str = \"gqf\";\n/// The file extension for Grafeq.\npub const FILE_EXTENSION_GQS: &str = \"gqs\";\n/// The file extension for SRGS.\npub const FILE_EXTENSION_GRAM: &str = \"gram\";\n/// The file extension for Gramps XML.\npub const FILE_EXTENSION_GRAMPS: &str = \"gramps\";\n/// The file extension for Groove Injector.\npub const FILE_EXTENSION_GRE: &str = \"gre\";\n/// The file extension for SRGS XML.\npub const FILE_EXTENSION_GRV: &str = \"grv\";\n/// The file extension for SRGS XML.\npub const FILE_EXTENSION_GRXML: &str = \"grxml\";\n/// The file extension for Ghostscript font.\npub const FILE_EXTENSION_GSF: &str = \"gsf\";\n/// The file extension for GTAR archive.\npub const FILE_EXTENSION_GTAR: &str = \"gtar\";\n/// The file extension for Groove Tool Message.\npub const FILE_EXTENSION_GTM: &str = \"gtm\";\n/// The file extension for GTW model.\npub const FILE_EXTENSION_GTW: &str = \"gtw\";\n/// The file extension for Graphviz.\npub const FILE_EXTENSION_GV: &str = \"gv\";\n/// The file extension for GXF.\npub const FILE_EXTENSION_GXF: &str = \"gxf\";\n/// The file extension for GeoNext.\npub const FILE_EXTENSION_GXT: &str = \"gxt\";\n/// The file extension for Gzip archive.\npub const FILE_EXTENSION_GZ: &str = \"gz\";\n/// The file extension for C header.\npub const FILE_EXTENSION_H: &str = \"h\";\n/// The file extension for H.261 video.\npub const FILE_EXTENSION_H261: &str = \"h261\";\n/// The file extension for H.263 video.\npub const FILE_EXTENSION_H263: &str = \"h263\";\n/// The file extension for H.264 video.\npub const FILE_EXTENSION_H264: &str = \"h264\";\n/// The file extension for HAL XML.\npub const FILE_EXTENSION_HAL: &str = \"hal\";\n/// The file extension for HBCI.\npub const FILE_EXTENSION_HBCI: &str = \"hbci\";\n/// The file extension for HDF.\npub const FILE_EXTENSION_HDF: &str = \"hdf\";\n/// The file extension for C++ header.\npub const FILE_EXTENSION_HH: &str = \"hh\";\n/// The file extension for WinHelp.\npub const FILE_EXTENSION_HLP: &str = \"hlp\";\n/// The file extension for HP-GL.\npub const FILE_EXTENSION_HPGL: &str = \"hpgl\";\n/// The file extension for HP-HPID.\npub const FILE_EXTENSION_HPID: &str = \"hpid\";\n/// The file extension for HP-HPS.\npub const FILE_EXTENSION_HPS: &str = \"hps\";\n/// The file extension for Mac BinHex40.\npub const FILE_EXTENSION_HQX: &str = \"hqx\";\n/// The file extension for HTC component.\npub const FILE_EXTENSION_HTC: &str = \"htc\";\n/// The file extension for Kenamea App.\npub const FILE_EXTENSION_HTKE: &str = \"htke\";\n/// The file extension for HTML.\npub const FILE_EXTENSION_HTM: &str = \"htm\";\n/// The file extension for HTML.\npub const FILE_EXTENSION_HTML: &str = \"html\";\n/// The file extension for Yamaha HV Dictionary.\npub const FILE_EXTENSION_HVD: &str = \"hvd\";\n/// The file extension for Yamaha HV Voice.\npub const FILE_EXTENSION_HVP: &str = \"hvp\";\n/// The file extension for Yamaha HV Script.\npub const FILE_EXTENSION_HVS: &str = \"hvs\";\n/// The file extension for Intergeo.\npub const FILE_EXTENSION_I2G: &str = \"i2g\";\n/// The file extension for ICC Profile.\npub const FILE_EXTENSION_ICC: &str = \"icc\";\n/// The file extension for CoolTalk.\npub const FILE_EXTENSION_ICE: &str = \"ice\";\n/// The file extension for ICC Profile.\npub const FILE_EXTENSION_ICM: &str = \"icm\";\n/// The file extension for icon.\npub const FILE_EXTENSION_ICO: &str = \"ico\";\n/// The file extension for iCalendar.\npub const FILE_EXTENSION_ICS: &str = \"ics\";\n/// The file extension for IEF image.\npub const FILE_EXTENSION_IEF: &str = \"ief\";\n/// The file extension for iCalendar.\npub const FILE_EXTENSION_IFB: &str = \"ifb\";\n/// The file extension for Shana Informed Formdata.\npub const FILE_EXTENSION_IFM: &str = \"ifm\";\n/// The file extension for IGES model.\npub const FILE_EXTENSION_IGES: &str = \"iges\";\n/// The file extension for IGLoader.\npub const FILE_EXTENSION_IGL: &str = \"igl\";\n/// The file extension for Insors IGM.\npub const FILE_EXTENSION_IGM: &str = \"igm\";\n/// The file extension for IGES model.\npub const FILE_EXTENSION_IGS: &str = \"igs\";\n/// The file extension for Micrografx IGX.\npub const FILE_EXTENSION_IGX: &str = \"igx\";\n/// The file extension for Shana Informed Interchange.\npub const FILE_EXTENSION_IIF: &str = \"iif\";\n/// The file extension for Accpac Simply IMP.\npub const FILE_EXTENSION_IMP: &str = \"imp\";\n/// The file extension for Microsoft IMS.\npub const FILE_EXTENSION_IMS: &str = \"ims\";\n/// The file extension for an input file.\npub const FILE_EXTENSION_IN: &str = \"in\";\n/// The file extension for InkML.\npub const FILE_EXTENSION_INK: &str = \"ink\";\n/// The file extension for InkML.\npub const FILE_EXTENSION_INKML: &str = \"inkml\";\n/// The file extension for Install Instructions.\npub const FILE_EXTENSION_INSTALL: &str = \"install\";\n/// The file extension for Astraea Software Iota.\npub const FILE_EXTENSION_IOTA: &str = \"iota\";\n/// The file extension for IPFIX.\npub const FILE_EXTENSION_IPFIX: &str = \"ipfix\";\n/// The file extension for Shana Informed Package.\npub const FILE_EXTENSION_IPK: &str = \"ipk\";\n/// The file extension for IBM Rights Management.\npub const FILE_EXTENSION_IRM: &str = \"irm\";\n/// The file extension for iRepository Package XML.\npub const FILE_EXTENSION_IRP: &str = \"irp\";\n/// The file extension for ISO 9660 Image.\npub const FILE_EXTENSION_ISO: &str = \"iso\";\n/// The file extension for Shana Informed Formtemplate.\npub const FILE_EXTENSION_ITP: &str = \"itp\";\n/// The file extension for Immervision IVP.\npub const FILE_EXTENSION_IVP: &str = \"ivp\";\n/// The file extension for Immervision IVU.\npub const FILE_EXTENSION_IVU: &str = \"ivu\";\n/// The file extension for J2ME App Descriptor.\npub const FILE_EXTENSION_JAD: &str = \"jad\";\n/// The file extension for JAM.\npub const FILE_EXTENSION_JAM: &str = \"jam\";\n/// The file extension for Java Archive.\npub const FILE_EXTENSION_JAR: &str = \"jar\";\n/// The file extension for Java source.\npub const FILE_EXTENSION_JAVA: &str = \"java\";\n/// The file extension for JISP.\npub const FILE_EXTENSION_JISP: &str = \"jisp\";\n/// The file extension for HP JLYT.\npub const FILE_EXTENSION_JLT: &str = \"jlt\";\n/// The file extension for Java JNLP.\npub const FILE_EXTENSION_JNLP: &str = \"jnlp\";\n/// The file extension for Joost Joda Archive.\npub const FILE_EXTENSION_JODA: &str = \"joda\";\n/// The file extension for JPEG image.\npub const FILE_EXTENSION_JPE: &str = \"jpe\";\n/// The file extension for JPEG image.\npub const FILE_EXTENSION_JPEG: &str = \"jpeg\";\n/// The file extension for JPEG image.\npub const FILE_EXTENSION_JPG: &str = \"jpg\";\n/// The file extension for JPM video.\npub const FILE_EXTENSION_JPGM: &str = \"jpgm\";\n/// The file extension for JPEG video.\npub const FILE_EXTENSION_JPGV: &str = \"jpgv\";\n/// The file extension for JPM video.\npub const FILE_EXTENSION_JPM: &str = \"jpm\";\n/// The file extension for JavaScript.\npub const FILE_EXTENSION_JS: &str = \"js\";\n/// The file extension for JSF.\npub const FILE_EXTENSION_JSF: &str = \"jsf\";\n/// The file extension for JSON.\npub const FILE_EXTENSION_JSON: &str = \"json\";\n/// The file extension for JSONML.\npub const FILE_EXTENSION_JSONML: &str = \"jsonml\";\n/// The file extension for JSPF.\npub const FILE_EXTENSION_JSPF: &str = \"jspf\";\n/// The file extension for MIDI audio.\npub const FILE_EXTENSION_KAR: &str = \"kar\";\n/// The file extension for KDE Karbon.\npub const FILE_EXTENSION_KARBON: &str = \"karbon\";\n/// The file extension for KDE KFormula.\npub const FILE_EXTENSION_KFO: &str = \"kfo\";\n/// The file extension for Kidspiration.\npub const FILE_EXTENSION_KIA: &str = \"kia\";\n/// The file extension for Google Earth KML.\npub const FILE_EXTENSION_KML: &str = \"kml\";\n/// The file extension for Google Earth KMZ.\npub const FILE_EXTENSION_KMZ: &str = \"kmz\";\n/// The file extension for Kinar.\npub const FILE_EXTENSION_KNE: &str = \"kne\";\n/// The file extension for Kinar.\npub const FILE_EXTENSION_KNP: &str = \"knp\";\n/// The file extension for KDE Kontour.\npub const FILE_EXTENSION_KON: &str = \"kon\";\n/// The file extension for KDE KPresenter.\npub const FILE_EXTENSION_KPR: &str = \"kpr\";\n/// The file extension for KDE KPresenter.\npub const FILE_EXTENSION_KPT: &str = \"kpt\";\n/// The file extension for DS-Keypoint.\npub const FILE_EXTENSION_KPXX: &str = \"kpxx\";\n/// The file extension for KDE KSpread.\npub const FILE_EXTENSION_KSP: &str = \"ksp\";\n/// The file extension for Kahootz.\npub const FILE_EXTENSION_KTR: &str = \"ktr\";\n/// The file extension for KTX image.\npub const FILE_EXTENSION_KTX: &str = \"ktx\";\n/// The file extension for Kahootz.\npub const FILE_EXTENSION_KTZ: &str = \"ktz\";\n/// The file extension for KDE KWord.\npub const FILE_EXTENSION_KWD: &str = \"kwd\";\n/// The file extension for KDE KWord.\npub const FILE_EXTENSION_KWT: &str = \"kwt\";\n/// The file extension for LAS LAS XML.\npub const FILE_EXTENSION_LASXML: &str = \"lasxml\";\n/// The file extension for LaTeX.\npub const FILE_EXTENSION_LATEX: &str = \"latex\";\n/// The file extension for LlamaGraphics Life-Balance Desktop.\npub const FILE_EXTENSION_LBD: &str = \"lbd\";\n/// The file extension for LlamaGraphics Life-Balance Exchange XML.\npub const FILE_EXTENSION_LBE: &str = \"lbe\";\n/// The file extension for HHE Lesson Player.\npub const FILE_EXTENSION_LES: &str = \"les\";\n/// The file extension for LZH compressed archive.\npub const FILE_EXTENSION_LHA: &str = \"lha\";\n/// The file extension for Route 66 Link66 XML.\npub const FILE_EXTENSION_LINK66: &str = \"link66\";\n/// The file extension for a list file.\npub const FILE_EXTENSION_LIST: &str = \"list\";\n/// The file extension for a list file.\npub const FILE_EXTENSION_LIST3820: &str = \"list3820\";\n/// The file extension for a list file.\npub const FILE_EXTENSION_LISTAFP: &str = \"listafp\";\n/// The file extension for Microsoft Shortcut.\npub const FILE_EXTENSION_LNK: &str = \"lnk\";\n/// The file extension for a log file.\npub const FILE_EXTENSION_LOG: &str = \"log\";\n/// The file extension for Lost XML.\npub const FILE_EXTENSION_LOSTXML: &str = \"lostxml\";\n/// The file extension for a LRF file.\npub const FILE_EXTENSION_LRF: &str = \"lrf\";\n/// The file extension for Microsoft LRM.\npub const FILE_EXTENSION_LRM: &str = \"lrm\";\n/// The file extension for Frogans LTF.\npub const FILE_EXTENSION_LTF: &str = \"ltf\";\n/// The file extension for Lucent Voice.\npub const FILE_EXTENSION_LVP: &str = \"lvp\";\n/// The file extension for Lotus WordPro.\npub const FILE_EXTENSION_LWP: &str = \"lwp\";\n/// The file extension for LZH compressed archive.\npub const FILE_EXTENSION_LZH: &str = \"lzh\";\n/// The file extension for a M13 file.\npub const FILE_EXTENSION_M13: &str = \"m13\";\n/// The file extension for a M14 file.\npub const FILE_EXTENSION_M14: &str = \"m14\";\n/// The file extension for MPEG video.\npub const FILE_EXTENSION_M1V: &str = \"m1v\";\n/// The file extension for MP21.\npub const FILE_EXTENSION_M21: &str = \"m21\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_M2A: &str = \"m2a\";\n/// The file extension for MPEG video.\npub const FILE_EXTENSION_M2V: &str = \"m2v\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_M3A: &str = \"m3a\";\n/// The file extension for M3U playlist.\npub const FILE_EXTENSION_M3U: &str = \"m3u\";\n/// The file extension for M3U8 playlist.\npub const FILE_EXTENSION_M3U8: &str = \"m3u8\";\n/// The file extension for MP4 audio.\npub const FILE_EXTENSION_M4A: &str = \"m4a\";\n/// The file extension for MP4 audio.\npub const FILE_EXTENSION_M4B: &str = \"m4b\";\n/// The file extension for MP4 audio.\npub const FILE_EXTENSION_M4R: &str = \"m4r\";\n/// The file extension for M4U playlist.\npub const FILE_EXTENSION_M4U: &str = \"m4u\";\n/// The file extension for MP4 video.\npub const FILE_EXTENSION_M4V: &str = \"m4v\";\n/// The file extension for Mathematica.\npub const FILE_EXTENSION_MA: &str = \"ma\";\n/// The file extension for MacPaint image.\npub const FILE_EXTENSION_MAC: &str = \"mac\";\n/// The file extension for MADS XML.\npub const FILE_EXTENSION_MADS: &str = \"mads\";\n/// The file extension for EcoWin Chart.\npub const FILE_EXTENSION_MAG: &str = \"mag\";\n/// The file extension for Adobe FrameMaker.\npub const FILE_EXTENSION_MAKER: &str = \"maker\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_MAN: &str = \"man\";\n/// The file extension for a MAR file.\npub const FILE_EXTENSION_MAR: &str = \"mar\";\n/// The file extension for MathML XML.\npub const FILE_EXTENSION_MATHML: &str = \"mathml\";\n/// The file extension for Mathematica.\npub const FILE_EXTENSION_MB: &str = \"mb\";\n/// The file extension for Mobius MBK.\npub const FILE_EXTENSION_MBK: &str = \"mbk\";\n/// The file extension for Mbox.\npub const FILE_EXTENSION_MBOX: &str = \"mbox\";\n/// The file extension for MedCalcData.\npub const FILE_EXTENSION_MC1: &str = \"mc1\";\n/// The file extension for MCD.\npub const FILE_EXTENSION_MCD: &str = \"mcd\";\n/// The file extension for cURL MCURL.\npub const FILE_EXTENSION_MCURL: &str = \"mcurl\";\n/// The file extension for Microsoft Access.\npub const FILE_EXTENSION_MDB: &str = \"mdb\";\n/// The file extension for Microsoft MODI.\npub const FILE_EXTENSION_MDI: &str = \"mdi\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_ME: &str = \"me\";\n/// The file extension for Mesh model.\npub const FILE_EXTENSION_MESH: &str = \"mesh\";\n/// The file extension for Metalink4 XML.\npub const FILE_EXTENSION_META4: &str = \"meta4\";\n/// The file extension for Metalink XML.\npub const FILE_EXTENSION_METALINK: &str = \"metalink\";\n/// The file extension for METS XML.\npub const FILE_EXTENSION_METS: &str = \"mets\";\n/// The file extension for MFMP.\npub const FILE_EXTENSION_MFM: &str = \"mfm\";\n/// The file extension for RPKI Manifest.\npub const FILE_EXTENSION_MFT: &str = \"mft\";\n/// The file extension for OSGeo MapGuide Package.\npub const FILE_EXTENSION_MGP: &str = \"mgp\";\n/// The file extension for Proteus Magazine.\npub const FILE_EXTENSION_MGZ: &str = \"mgz\";\n/// The file extension for MIDI audio.\npub const FILE_EXTENSION_MID: &str = \"mid\";\n/// The file extension for MIDI audio.\npub const FILE_EXTENSION_MIDI: &str = \"midi\";\n/// The file extension for MIE.\npub const FILE_EXTENSION_MIE: &str = \"mie\";\n/// The file extension for MIF.\npub const FILE_EXTENSION_MIF: &str = \"mif\";\n/// The file extension for a MIME file.\npub const FILE_EXTENSION_MIME: &str = \"mime\";\n/// The file extension for MJ2 video.\npub const FILE_EXTENSION_MJ2: &str = \"mj2\";\n/// The file extension for MJ2 video.\npub const FILE_EXTENSION_MJP2: &str = \"mjp2\";\n/// The file extension for Matroska video.\npub const FILE_EXTENSION_MK3D: &str = \"mk3d\";\n/// The file extension for Matroska audio.\npub const FILE_EXTENSION_MKA: &str = \"mka\";\n/// The file extension for Matroska video.\npub const FILE_EXTENSION_MKS: &str = \"mks\";\n/// The file extension for Matroska video.\npub const FILE_EXTENSION_MKV: &str = \"mkv\";\n/// The file extension for Dolby MLP.\npub const FILE_EXTENSION_MLP: &str = \"mlp\";\n/// The file extension for Chipnuts Karaoke MMD.\npub const FILE_EXTENSION_MMD: &str = \"mmd\";\n/// The file extension for SMAF.\npub const FILE_EXTENSION_MMF: &str = \"mmf\";\n/// The file extension for Fujixerox EDMICS MMR.\npub const FILE_EXTENSION_MMR: &str = \"mmr\";\n/// The file extension for MNG video.\npub const FILE_EXTENSION_MNG: &str = \"mng\";\n/// The file extension for Microsoft Money.\npub const FILE_EXTENSION_MNY: &str = \"mny\";\n/// The file extension for Mobipocket eBook.\npub const FILE_EXTENSION_MOBI: &str = \"mobi\";\n/// The file extension for MODS XML.\npub const FILE_EXTENSION_MODS: &str = \"mods\";\n/// The file extension for QuickTime video.\npub const FILE_EXTENSION_MOV: &str = \"mov\";\n/// The file extension for SGI movie.\npub const FILE_EXTENSION_MOVIE: &str = \"movie\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MP1: &str = \"mp1\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MP2: &str = \"mp2\";\n/// The file extension for MP21.\npub const FILE_EXTENSION_MP21: &str = \"mp21\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MP2A: &str = \"mp2a\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MP3: &str = \"mp3\";\n/// The file extension for MP4.\npub const FILE_EXTENSION_MP4: &str = \"mp4\";\n/// The file extension for MP4 audio.\npub const FILE_EXTENSION_MP4A: &str = \"mp4a\";\n/// The file extension for MP4.\npub const FILE_EXTENSION_MP4S: &str = \"mp4s\";\n/// The file extension for MP4 video.\npub const FILE_EXTENSION_MP4V: &str = \"mp4v\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MPA: &str = \"mpa\";\n/// The file extension for Mophun Certificate.\npub const FILE_EXTENSION_MPC: &str = \"mpc\";\n/// The file extension for MPEG video.\npub const FILE_EXTENSION_MPE: &str = \"mpe\";\n/// The file extension for MPEG video.\npub const FILE_EXTENSION_MPEG: &str = \"mpeg\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MPEGA: &str = \"mpega\";\n/// The file extension for MPEG video.\npub const FILE_EXTENSION_MPG: &str = \"mpg\";\n/// The file extension for MPEG-4 video.\npub const FILE_EXTENSION_MPG4: &str = \"mpg4\";\n/// The file extension for MPEG audio.\npub const FILE_EXTENSION_MPGA: &str = \"mpga\";\n/// The file extension for Apple Installer XML.\npub const FILE_EXTENSION_MPKG: &str = \"mpkg\";\n/// The file extension for Blueice Multipass.\npub const FILE_EXTENSION_MPM: &str = \"mpm\";\n/// The file extension for Mophun Application.\npub const FILE_EXTENSION_MPN: &str = \"mpn\";\n/// The file extension for Microsoft Project.\npub const FILE_EXTENSION_MPP: &str = \"mpp\";\n/// The file extension for Microsoft Project.\npub const FILE_EXTENSION_MPT: &str = \"mpt\";\n/// The file extension for MPEG-2 video.\npub const FILE_EXTENSION_MPV2: &str = \"mpv2\";\n/// The file extension for IBM MiniPay.\npub const FILE_EXTENSION_MPY: &str = \"mpy\";\n/// The file extension for Mobius MQY.\npub const FILE_EXTENSION_MQY: &str = \"mqy\";\n/// The file extension for MARC.\npub const FILE_EXTENSION_MRC: &str = \"mrc\";\n/// The file extension for MARCXML.\npub const FILE_EXTENSION_MRCX: &str = \"mrcx\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_MS: &str = \"ms\";\n/// The file extension for Media Server Control XML.\npub const FILE_EXTENSION_MSCML: &str = \"mscml\";\n/// The file extension for FDSN mseed.\npub const FILE_EXTENSION_MSEED: &str = \"mseed\";\n/// The file extension for MSEQ.\npub const FILE_EXTENSION_MSEQ: &str = \"mseq\";\n/// The file extension for Epson MSF.\npub const FILE_EXTENSION_MSF: &str = \"msf\";\n/// The file extension for Mesh model.\npub const FILE_EXTENSION_MSH: &str = \"msh\";\n/// The file extension for Microsoft Installer.\npub const FILE_EXTENSION_MSI: &str = \"msi\";\n/// The file extension for Mobius MSL.\npub const FILE_EXTENSION_MSL: &str = \"msl\";\n/// The file extension for Muvee Style.\npub const FILE_EXTENSION_MSTY: &str = \"msty\";\n/// The file extension for MTS model.\npub const FILE_EXTENSION_MTS: &str = \"mts\";\n/// The file extension for Musician.\npub const FILE_EXTENSION_MUS: &str = \"mus\";\n/// The file extension for Recordare MusicXML.\npub const FILE_EXTENSION_MUSICXML: &str = \"musicxml\";\n/// The file extension for a MVB file.\npub const FILE_EXTENSION_MVB: &str = \"mvb\";\n/// The file extension for MFER.\npub const FILE_EXTENSION_MWF: &str = \"mwf\";\n/// The file extension for MXF.\npub const FILE_EXTENSION_MXF: &str = \"mxf\";\n/// The file extension for Recordare MusicXML.\npub const FILE_EXTENSION_MXL: &str = \"mxl\";\n/// The file extension for XV XML.\npub const FILE_EXTENSION_MXML: &str = \"mxml\";\n/// The file extension for Triscape MXS.\npub const FILE_EXTENSION_MXS: &str = \"mxs\";\n/// The file extension for a MXU file.\npub const FILE_EXTENSION_MXU: &str = \"mxu\";\n/// The file extension for Nokia N-Gage Symbian Install.\npub const FILE_EXTENSION_N_GAGE: &str = \"n-gage\";\n/// The file extension for N3.\npub const FILE_EXTENSION_N3: &str = \"n3\";\n/// The file extension for Mathematica.\npub const FILE_EXTENSION_NB: &str = \"nb\";\n/// The file extension for Wolfram Player.\npub const FILE_EXTENSION_NBP: &str = \"nbp\";\n/// The file extension for NetCDF.\npub const FILE_EXTENSION_NC: &str = \"nc\";\n/// The file extension for DTBNCX XML.\npub const FILE_EXTENSION_NCX: &str = \"ncx\";\n/// The file extension for NFO.\npub const FILE_EXTENSION_NFO: &str = \"nfo\";\n/// The file extension for Nokia N-Gage Data.\npub const FILE_EXTENSION_NGDAT: &str = \"ngdat\";\n/// The file extension for NITF.\npub const FILE_EXTENSION_NITF: &str = \"nitf\";\n/// The file extension for NeuroLanguage NLU.\npub const FILE_EXTENSION_NLU: &str = \"nlu\";\n/// The file extension for Enliven.\npub const FILE_EXTENSION_NML: &str = \"nml\";\n/// The file extension for NobleNet Directory.\npub const FILE_EXTENSION_NND: &str = \"nnd\";\n/// The file extension for NobleNet Sealer.\npub const FILE_EXTENSION_NNS: &str = \"nns\";\n/// The file extension for NobleNet Web.\npub const FILE_EXTENSION_NNW: &str = \"nnw\";\n/// The file extension for Net-FPX image.\npub const FILE_EXTENSION_NPX: &str = \"npx\";\n/// The file extension for Conference.\npub const FILE_EXTENSION_NSC: &str = \"nsc\";\n/// The file extension for Lotus Notes.\npub const FILE_EXTENSION_NSF: &str = \"nsf\";\n/// The file extension for NITF.\npub const FILE_EXTENSION_NTF: &str = \"ntf\";\n/// The file extension for NZB.\npub const FILE_EXTENSION_NZB: &str = \"nzb\";\n/// The file extension for Fujitsu Oasys 2.\npub const FILE_EXTENSION_OA2: &str = \"oa2\";\n/// The file extension for Fujitsu Oasys 3.\npub const FILE_EXTENSION_OA3: &str = \"oa3\";\n/// The file extension for Fujitsu Oasys.\npub const FILE_EXTENSION_OAS: &str = \"oas\";\n/// The file extension for Microsoft Binder.\npub const FILE_EXTENSION_OBD: &str = \"obd\";\n/// The file extension for an object file.\npub const FILE_EXTENSION_OBJ: &str = \"obj\";\n/// The file extension for ODA.\npub const FILE_EXTENSION_ODA: &str = \"oda\";\n/// The file extension for OpenDocument Database.\npub const FILE_EXTENSION_ODB: &str = \"odb\";\n/// The file extension for OpenDocument Chart.\npub const FILE_EXTENSION_ODC: &str = \"odc\";\n/// The file extension for OpenDocument Formula.\npub const FILE_EXTENSION_ODF: &str = \"odf\";\n/// The file extension for OpenDocument Formula Template.\npub const FILE_EXTENSION_ODFT: &str = \"odft\";\n/// The file extension for OpenDocument Graphics.\npub const FILE_EXTENSION_ODG: &str = \"odg\";\n/// The file extension for OpenDocument Image.\npub const FILE_EXTENSION_ODI: &str = \"odi\";\n/// The file extension for OpenDocument Text Master.\npub const FILE_EXTENSION_ODM: &str = \"odm\";\n/// The file extension for OpenDocument Presentation.\npub const FILE_EXTENSION_ODP: &str = \"odp\";\n/// The file extension for OpenDocument Spreadsheet.\npub const FILE_EXTENSION_ODS: &str = \"ods\";\n/// The file extension for OpenDocument Text.\npub const FILE_EXTENSION_ODT: &str = \"odt\";\n/// The file extension for Ogg audio.\npub const FILE_EXTENSION_OGA: &str = \"oga\";\n/// The file extension for Ogg.\npub const FILE_EXTENSION_OGG: &str = \"ogg\";\n/// The file extension for Ogg video.\npub const FILE_EXTENSION_OGV: &str = \"ogv\";\n/// The file extension for Ogg.\npub const FILE_EXTENSION_OGX: &str = \"ogx\";\n/// The file extension for OMDOC XML.\npub const FILE_EXTENSION_OMDOC: &str = \"omdoc\";\n/// The file extension for OneNote.\npub const FILE_EXTENSION_ONEPKG: &str = \"onepkg\";\n/// The file extension for OneNote.\npub const FILE_EXTENSION_ONETMP: &str = \"onetmp\";\n/// The file extension for OneNote.\npub const FILE_EXTENSION_ONETOC: &str = \"onetoc\";\n/// The file extension for OneNote.\npub const FILE_EXTENSION_ONETOC2: &str = \"onetoc2\";\n/// The file extension for OEBPS Package XML.\npub const FILE_EXTENSION_OPF: &str = \"opf\";\n/// The file extension for OPML.\npub const FILE_EXTENSION_OPML: &str = \"opml\";\n/// The file extension for Palm.\npub const FILE_EXTENSION_OPRC: &str = \"oprc\";\n/// The file extension for Lotus Organizer.\npub const FILE_EXTENSION_ORG: &str = \"org\";\n/// The file extension for Yamaha OpenScoreFormat.\npub const FILE_EXTENSION_OSF: &str = \"osf\";\n/// The file extension for Yamaha OpenScoreFormat OSFPVG XML.\npub const FILE_EXTENSION_OSFPVG: &str = \"osfpvg\";\n/// The file extension for OpenDocument Chart Template.\npub const FILE_EXTENSION_OTC: &str = \"otc\";\n/// The file extension for OpenType Font.\npub const FILE_EXTENSION_OTF: &str = \"otf\";\n/// The file extension for OpenDocument Graphics Template.\npub const FILE_EXTENSION_OTG: &str = \"otg\";\n/// The file extension for OpenDocument Text Web.\npub const FILE_EXTENSION_OTH: &str = \"oth\";\n/// The file extension for OpenDocument Image Template.\npub const FILE_EXTENSION_OTI: &str = \"oti\";\n/// The file extension for OpenDocument Presentation Template.\npub const FILE_EXTENSION_OTP: &str = \"otp\";\n/// The file extension for OpenDocument Spreadsheet Template.\npub const FILE_EXTENSION_OTS: &str = \"ots\";\n/// The file extension for OpenDocument Text Template.\npub const FILE_EXTENSION_OTT: &str = \"ott\";\n/// The file extension for OpenXPS.\npub const FILE_EXTENSION_OXPS: &str = \"oxps\";\n/// The file extension for OpenOffice Extension.\npub const FILE_EXTENSION_OXT: &str = \"oxt\";\n/// The file extension for Pascal source.\npub const FILE_EXTENSION_P: &str = \"p\";\n/// The file extension for PKCS #10.\npub const FILE_EXTENSION_P10: &str = \"p10\";\n/// The file extension for PKCS #12.\npub const FILE_EXTENSION_P12: &str = \"p12\";\n/// The file extension for PKCS #7 Certificates.\npub const FILE_EXTENSION_P7B: &str = \"p7b\";\n/// The file extension for PKCS #7 MIME.\npub const FILE_EXTENSION_P7C: &str = \"p7c\";\n/// The file extension for PKCS #7 MIME.\npub const FILE_EXTENSION_P7M: &str = \"p7m\";\n/// The file extension for PKCS #7 Certificate Request/Response.\npub const FILE_EXTENSION_P7R: &str = \"p7r\";\n/// The file extension for PKCS #7 Signature.\npub const FILE_EXTENSION_P7S: &str = \"p7s\";\n/// The file extension for PKCS #8.\npub const FILE_EXTENSION_P8: &str = \"p8\";\n/// The file extension for Pascal source.\npub const FILE_EXTENSION_PAS: &str = \"pas\";\n/// The file extension for Pawaafile.\npub const FILE_EXTENSION_PAW: &str = \"paw\";\n/// The file extension for PowerBuilder 6.\npub const FILE_EXTENSION_PBD: &str = \"pbd\";\n/// The file extension for Portable Bitmap image.\npub const FILE_EXTENSION_PBM: &str = \"pbm\";\n/// The file extension for TCPDump capture file.\npub const FILE_EXTENSION_PCAP: &str = \"pcap\";\n/// The file extension for PCF font.\npub const FILE_EXTENSION_PCF: &str = \"pcf\";\n/// The file extension for HP PCL.\npub const FILE_EXTENSION_PCL: &str = \"pcl\";\n/// The file extension for HP PCLXL.\npub const FILE_EXTENSION_PCLXL: &str = \"pclxl\";\n/// The file extension for PICT image.\npub const FILE_EXTENSION_PCT: &str = \"pct\";\n/// The file extension for cURL PCURL.\npub const FILE_EXTENSION_PCURL: &str = \"pcurl\";\n/// The file extension for PCX image.\npub const FILE_EXTENSION_PCX: &str = \"pcx\";\n/// The file extension for Palm.\npub const FILE_EXTENSION_PDB: &str = \"pdb\";\n/// The file extension for PDF.\npub const FILE_EXTENSION_PDF: &str = \"pdf\";\n/// The file extension for Adobe Font Metrics.\npub const FILE_EXTENSION_PFA: &str = \"pfa\";\n/// The file extension for Adobe Font Metrics.\npub const FILE_EXTENSION_PFB: &str = \"pfb\";\n/// The file extension for Adobe Font Metrics.\npub const FILE_EXTENSION_PFM: &str = \"pfm\";\n/// The file extension for Font Tdpfr.\npub const FILE_EXTENSION_PFR: &str = \"pfr\";\n/// The file extension for PKCS #12.\npub const FILE_EXTENSION_PFX: &str = \"pfx\";\n/// The file extension for Portable Graymap image.\npub const FILE_EXTENSION_PGM: &str = \"pgm\";\n/// The file extension for PGN chess notation.\npub const FILE_EXTENSION_PGN: &str = \"pgn\";\n/// The file extension for PGP encrypted.\npub const FILE_EXTENSION_PGP: &str = \"pgp\";\n/// The file extension for PICT image.\npub const FILE_EXTENSION_PIC: &str = \"pic\";\n/// The file extension for PICT image.\npub const FILE_EXTENSION_PICT: &str = \"pict\";\n/// The file extension for a package file.\npub const FILE_EXTENSION_PKG: &str = \"pkg\";\n/// The file extension for PKIXCMP.\npub const FILE_EXTENSION_PKI: &str = \"pki\";\n/// The file extension for PKIX PKIPath.\npub const FILE_EXTENSION_PKIPATH: &str = \"pkipath\";\n/// The file extension for 3GPP PIC BW Large.\npub const FILE_EXTENSION_PLB: &str = \"plb\";\n/// The file extension for Mobius PLC.\npub const FILE_EXTENSION_PLC: &str = \"plc\";\n/// The file extension for PocketLearn.\npub const FILE_EXTENSION_PLF: &str = \"plf\";\n/// The file extension for SCPLS playlist.\npub const FILE_EXTENSION_PLS: &str = \"pls\";\n/// The file extension for CTC POSML.\npub const FILE_EXTENSION_PML: &str = \"pml\";\n/// The file extension for PNG image.\npub const FILE_EXTENSION_PNG: &str = \"png\";\n/// The file extension for Portable Anymap image.\npub const FILE_EXTENSION_PNM: &str = \"pnm\";\n/// The file extension for MacPaint image.\npub const FILE_EXTENSION_PNT: &str = \"pnt\";\n/// The file extension for MacPorts Portpkg.\npub const FILE_EXTENSION_PORTPKG: &str = \"portpkg\";\n/// The file extension for Microsoft PowerPoint.\npub const FILE_EXTENSION_POT: &str = \"pot\";\n/// The file extension for Microsoft PowerPoint Template (Macro-Enabled).\npub const FILE_EXTENSION_POTM: &str = \"potm\";\n/// The file extension for Office Open XML Presentation Template.\npub const FILE_EXTENSION_POTX: &str = \"potx\";\n/// The file extension for Microsoft PowerPoint Add-in (Macro-Enabled).\npub const FILE_EXTENSION_PPAM: &str = \"ppam\";\n/// The file extension for CUPS PPD.\npub const FILE_EXTENSION_PPD: &str = \"ppd\";\n/// The file extension for Portable Pixmap image.\npub const FILE_EXTENSION_PPM: &str = \"ppm\";\n/// The file extension for Microsoft PowerPoint.\npub const FILE_EXTENSION_PPS: &str = \"pps\";\n/// The file extension for Microsoft PowerPoint Slideshow (Macro-Enabled).\npub const FILE_EXTENSION_PPSM: &str = \"ppsm\";\n/// The file extension for Office Open XML Presentation Slideshow.\npub const FILE_EXTENSION_PPSX: &str = \"ppsx\";\n/// The file extension for Microsoft PowerPoint.\npub const FILE_EXTENSION_PPT: &str = \"ppt\";\n/// The file extension for Microsoft PowerPoint Presentation (Macro-Enabled).\npub const FILE_EXTENSION_PPTM: &str = \"pptm\";\n/// The file extension for Office Open XML Presentation.\npub const FILE_EXTENSION_PPTX: &str = \"pptx\";\n/// The file extension for Palm.\npub const FILE_EXTENSION_PQA: &str = \"pqa\";\n/// The file extension for Palm.\npub const FILE_EXTENSION_PRC: &str = \"prc\";\n/// The file extension for Lotus Freelance.\npub const FILE_EXTENSION_PRE: &str = \"pre\";\n/// The file extension for a profile file.\npub const FILE_EXTENSION_PRF: &str = \"prf\";\n/// The file extension for PostScript.\npub const FILE_EXTENSION_PS: &str = \"ps\";\n/// The file extension for 3GPP PIC BW Small.\npub const FILE_EXTENSION_PSB: &str = \"psb\";\n/// The file extension for Adobe Photoshop.\npub const FILE_EXTENSION_PSD: &str = \"psd\";\n/// The file extension for Linux PSF font.\npub const FILE_EXTENSION_PSF: &str = \"psf\";\n/// The file extension for PSKC XML.\npub const FILE_EXTENSION_PSKCXML: &str = \"pskcxml\";\n/// The file extension for PVI PTID1.\npub const FILE_EXTENSION_PTID: &str = \"ptid\";\n/// The file extension for Microsoft Publisher.\npub const FILE_EXTENSION_PUB: &str = \"pub\";\n/// The file extension for 3GPP PIC BW Var.\npub const FILE_EXTENSION_PVB: &str = \"pvb\";\n/// The file extension for 3M Post-It Notes.\npub const FILE_EXTENSION_PWN: &str = \"pwn\";\n/// The file extension for Microsoft PlayReady Media PYA.\npub const FILE_EXTENSION_PYA: &str = \"pya\";\n/// The file extension for Microsoft PlayReady Media PYV.\npub const FILE_EXTENSION_PYV: &str = \"pyv\";\n/// The file extension for Epson QuickAnime.\npub const FILE_EXTENSION_QAM: &str = \"qam\";\n/// The file extension for Intuit QBO.\npub const FILE_EXTENSION_QBO: &str = \"qbo\";\n/// The file extension for Intuit QFX.\npub const FILE_EXTENSION_QFX: &str = \"qfx\";\n/// The file extension for PubliShare Delta Tree.\npub const FILE_EXTENSION_QPS: &str = \"qps\";\n/// The file extension for QuickTime video.\npub const FILE_EXTENSION_QT: &str = \"qt\";\n/// The file extension for QuickTime image.\npub const FILE_EXTENSION_QTI: &str = \"qti\";\n/// The file extension for QuickTime image.\npub const FILE_EXTENSION_QTIF: &str = \"qtif\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QWD: &str = \"qwd\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QWT: &str = \"qwt\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QXB: &str = \"qxb\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QXD: &str = \"qxd\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QXL: &str = \"qxl\";\n/// The file extension for QuarkXPress.\npub const FILE_EXTENSION_QXT: &str = \"qxt\";\n/// The file extension for RealAudio.\npub const FILE_EXTENSION_RA: &str = \"ra\";\n/// The file extension for RealAudio.\npub const FILE_EXTENSION_RAM: &str = \"ram\";\n/// The file extension for RAR compressed archive.\npub const FILE_EXTENSION_RAR: &str = \"rar\";\n/// The file extension for CMU Raster image.\npub const FILE_EXTENSION_RAS: &str = \"ras\";\n/// The file extension for iPunplugged RCProfile.\npub const FILE_EXTENSION_RCPROFILE: &str = \"rcprofile\";\n/// The file extension for RDF XML.\npub const FILE_EXTENSION_RDF: &str = \"rdf\";\n/// The file extension for Data-Vision RDZ.\npub const FILE_EXTENSION_RDZ: &str = \"rdz\";\n/// The file extension for BusinessObjects.\npub const FILE_EXTENSION_REP: &str = \"rep\";\n/// The file extension for DTBResource XML.\npub const FILE_EXTENSION_RES: &str = \"res\";\n/// The file extension for RGB image.\npub const FILE_EXTENSION_RGB: &str = \"rgb\";\n/// The file extension for RegInfo XML.\npub const FILE_EXTENSION_RIF: &str = \"rif\";\n/// The file extension for RIP audio.\npub const FILE_EXTENSION_RIP: &str = \"rip\";\n/// The file extension for Research Info Systems.\npub const FILE_EXTENSION_RIS: &str = \"ris\";\n/// The file extension for Resource Lists XML.\npub const FILE_EXTENSION_RL: &str = \"rl\";\n/// The file extension for Fujixerox EDMICS RLC.\npub const FILE_EXTENSION_RLC: &str = \"rlc\";\n/// The file extension for Resource Lists Diff XML.\npub const FILE_EXTENSION_RLD: &str = \"rld\";\n/// The file extension for RealMedia.\npub const FILE_EXTENSION_RM: &str = \"rm\";\n/// The file extension for MIDI audio.\npub const FILE_EXTENSION_RMI: &str = \"rmi\";\n/// The file extension for RealAudio Plugin.\npub const FILE_EXTENSION_RMP: &str = \"rmp\";\n/// The file extension for JCP J2ME Midlet RMS.\npub const FILE_EXTENSION_RMS: &str = \"rms\";\n/// The file extension for RealMedia VBR.\npub const FILE_EXTENSION_RMVB: &str = \"rmvb\";\n/// The file extension for RELAX NG Compact Syntax.\npub const FILE_EXTENSION_RNC: &str = \"rnc\";\n/// The file extension for RPKI ROA.\npub const FILE_EXTENSION_ROA: &str = \"roa\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_ROFF: &str = \"roff\";\n/// The file extension for Cloanto RP9.\npub const FILE_EXTENSION_RP9: &str = \"rp9\";\n/// The file extension for Nokia Radio Presets.\npub const FILE_EXTENSION_RPSS: &str = \"rpss\";\n/// The file extension for Nokia Radio Preset.\npub const FILE_EXTENSION_RPST: &str = \"rpst\";\n/// The file extension for SPARQL Query.\npub const FILE_EXTENSION_RQ: &str = \"rq\";\n/// The file extension for RSD XML.\npub const FILE_EXTENSION_RSD: &str = \"rsd\";\n/// The file extension for RSS XML.\npub const FILE_EXTENSION_RSS: &str = \"rss\";\n/// The file extension for RTF.\npub const FILE_EXTENSION_RTF: &str = \"rtf\";\n/// The file extension for Rich Text.\npub const FILE_EXTENSION_RTX: &str = \"rtx\";\n/// The file extension for Assembly source.\npub const FILE_EXTENSION_S: &str = \"s\";\n/// The file extension for S3M audio.\npub const FILE_EXTENSION_S3M: &str = \"s3m\";\n/// The file extension for Yamaha SMAF Audio.\npub const FILE_EXTENSION_SAF: &str = \"saf\";\n/// The file extension for SBML XML.\npub const FILE_EXTENSION_SBML: &str = \"sbml\";\n/// The file extension for Microsoft Schedule.\npub const FILE_EXTENSION_SCD: &str = \"scd\";\n/// The file extension for Lotus ScreenCam.\npub const FILE_EXTENSION_SCM: &str = \"scm\";\n/// The file extension for SCVP CV Request.\npub const FILE_EXTENSION_SCQ: &str = \"scq\";\n/// The file extension for SCVP CV Response.\npub const FILE_EXTENSION_SCS: &str = \"scs\";\n/// The file extension for cURL SCURL.\npub const FILE_EXTENSION_SCURL: &str = \"scurl\";\n/// The file extension for StarDivision Draw.\npub const FILE_EXTENSION_SDA: &str = \"sda\";\n/// The file extension for StarDivision Calc.\npub const FILE_EXTENSION_SDC: &str = \"sdc\";\n/// The file extension for StarDivision Impress.\npub const FILE_EXTENSION_SDD: &str = \"sdd\";\n/// The file extension for Solent SDKM XML.\npub const FILE_EXTENSION_SDKD: &str = \"sdkd\";\n/// The file extension for Solent SDKM XML.\npub const FILE_EXTENSION_SDKM: &str = \"sdkm\";\n/// The file extension for SDP.\npub const FILE_EXTENSION_SDP: &str = \"sdp\";\n/// The file extension for StarDivision Writer.\npub const FILE_EXTENSION_SDW: &str = \"sdw\";\n/// The file extension for SeeMail.\npub const FILE_EXTENSION_SEE: &str = \"see\";\n/// The file extension for FDSN mseed.\npub const FILE_EXTENSION_SEED: &str = \"seed\";\n/// The file extension for SEMA.\npub const FILE_EXTENSION_SEMA: &str = \"sema\";\n/// The file extension for SEMD.\npub const FILE_EXTENSION_SEMD: &str = \"semd\";\n/// The file extension for SEMF.\npub const FILE_EXTENSION_SEMF: &str = \"semf\";\n/// The file extension for Java Serialized Object.\npub const FILE_EXTENSION_SER: &str = \"ser\";\n/// The file extension for Set Payment Initiation.\npub const FILE_EXTENSION_SETPAY: &str = \"setpay\";\n/// The file extension for Set Registration Initiation.\npub const FILE_EXTENSION_SETREG: &str = \"setreg\";\n/// The file extension for Hydrostatix SOF-data.\npub const FILE_EXTENSION_SFD_HDSTX: &str = \"sfd-hdstx\";\n/// The file extension for Spotfire SFS.\npub const FILE_EXTENSION_SFS: &str = \"sfs\";\n/// The file extension for SFV.\npub const FILE_EXTENSION_SFV: &str = \"sfv\";\n/// The file extension for SGI image.\npub const FILE_EXTENSION_SGI: &str = \"sgi\";\n/// The file extension for StarDivision Writer Global.\npub const FILE_EXTENSION_SGL: &str = \"sgl\";\n/// The file extension for SGML.\npub const FILE_EXTENSION_SGM: &str = \"sgm\";\n/// The file extension for SGML.\npub const FILE_EXTENSION_SGML: &str = \"sgml\";\n/// The file extension for Shell script.\npub const FILE_EXTENSION_SH: &str = \"sh\";\n/// The file extension for Shar archive.\npub const FILE_EXTENSION_SHAR: &str = \"shar\";\n/// The file extension for SHF XML.\npub const FILE_EXTENSION_SHF: &str = \"shf\";\n/// The file extension for MrSID image.\npub const FILE_EXTENSION_SID: &str = \"sid\";\n/// The file extension for a signature file.\npub const FILE_EXTENSION_SIG: &str = \"sig\";\n/// The file extension for Silk audio.\npub const FILE_EXTENSION_SIL: &str = \"sil\";\n/// The file extension for a SILO file.\npub const FILE_EXTENSION_SILO: &str = \"silo\";\n/// The file extension for Symbian Install.\npub const FILE_EXTENSION_SIS: &str = \"sis\";\n/// The file extension for Symbian Install.\npub const FILE_EXTENSION_SISX: &str = \"sisx\";\n/// The file extension for StuffIt archive.\npub const FILE_EXTENSION_SIT: &str = \"sit\";\n/// The file extension for StuffItX archive.\npub const FILE_EXTENSION_SITX: &str = \"sitx\";\n/// The file extension for Koan.\npub const FILE_EXTENSION_SKD: &str = \"skd\";\n/// The file extension for Koan.\npub const FILE_EXTENSION_SKM: &str = \"skm\";\n/// The file extension for Koan.\npub const FILE_EXTENSION_SKP: &str = \"skp\";\n/// The file extension for Koan.\npub const FILE_EXTENSION_SKT: &str = \"skt\";\n/// The file extension for Microsoft PowerPoint Slide (Macro-Enabled).\npub const FILE_EXTENSION_SLDM: &str = \"sldm\";\n/// The file extension for Office Open XML Presentation Slide.\npub const FILE_EXTENSION_SLDX: &str = \"sldx\";\n/// The file extension for Epson SALT.\npub const FILE_EXTENSION_SLT: &str = \"slt\";\n/// The file extension for StepMania Stepchart.\npub const FILE_EXTENSION_SM: &str = \"sm\";\n/// The file extension for StarDivision Math.\npub const FILE_EXTENSION_SMF: &str = \"smf\";\n/// The file extension for SMIL XML.\npub const FILE_EXTENSION_SMI: &str = \"smi\";\n/// The file extension for SMIL XML.\npub const FILE_EXTENSION_SMIL: &str = \"smil\";\n/// The file extension for SMV video.\npub const FILE_EXTENSION_SMV: &str = \"smv\";\n/// The file extension for StepMania Package.\npub const FILE_EXTENSION_SMZIP: &str = \"smzip\";\n/// The file extension for basic audio.\npub const FILE_EXTENSION_SND: &str = \"snd\";\n/// The file extension for SNF font.\npub const FILE_EXTENSION_SNF: &str = \"snf\";\n/// The file extension for a shared object file.\npub const FILE_EXTENSION_SO: &str = \"so\";\n/// The file extension for Yamaha SMAF Phrase.\npub const FILE_EXTENSION_SPC: &str = \"spc\";\n/// The file extension for FutureSplash.\npub const FILE_EXTENSION_SPF: &str = \"spf\";\n/// The file extension for FutureSplash.\npub const FILE_EXTENSION_SPL: &str = \"spl\";\n/// The file extension for In3D Spot.\npub const FILE_EXTENSION_SPOT: &str = \"spot\";\n/// The file extension for SCVP VP Response.\npub const FILE_EXTENSION_SPP: &str = \"spp\";\n/// The file extension for SCVP VP Request.\npub const FILE_EXTENSION_SPQ: &str = \"spq\";\n/// The file extension for Ogg audio.\npub const FILE_EXTENSION_SPX: &str = \"spx\";\n/// The file extension for SQL.\npub const FILE_EXTENSION_SQL: &str = \"sql\";\n/// The file extension for WAIS source.\npub const FILE_EXTENSION_SRC: &str = \"src\";\n/// The file extension for SubRip subtitle.\npub const FILE_EXTENSION_SRT: &str = \"srt\";\n/// The file extension for SRU XML.\npub const FILE_EXTENSION_SRU: &str = \"sru\";\n/// The file extension for SPARQL Results XML.\npub const FILE_EXTENSION_SRX: &str = \"srx\";\n/// The file extension for SSDL XML.\npub const FILE_EXTENSION_SSDL: &str = \"ssdl\";\n/// The file extension for Kodak Descriptor.\npub const FILE_EXTENSION_SSE: &str = \"sse\";\n/// The file extension for Epson SSF.\npub const FILE_EXTENSION_SSF: &str = \"ssf\";\n/// The file extension for SSML XML.\npub const FILE_EXTENSION_SSML: &str = \"ssml\";\n/// The file extension for SailingTracker Track.\npub const FILE_EXTENSION_ST: &str = \"st\";\n/// The file extension for Sun XML Calc Template.\npub const FILE_EXTENSION_STC: &str = \"stc\";\n/// The file extension for Sun XML Draw Template.\npub const FILE_EXTENSION_STD: &str = \"std\";\n/// The file extension for WT STF.\npub const FILE_EXTENSION_STF: &str = \"stf\";\n/// The file extension for Sun XML Impress Template.\npub const FILE_EXTENSION_STI: &str = \"sti\";\n/// The file extension for HyperStudio.\npub const FILE_EXTENSION_STK: &str = \"stk\";\n/// The file extension for Microsoft PKI STL.\npub const FILE_EXTENSION_STL: &str = \"stl\";\n/// The file extension for PG Format.\npub const FILE_EXTENSION_STR: &str = \"str\";\n/// The file extension for Sun XML Writer Template.\npub const FILE_EXTENSION_STW: &str = \"stw\";\n/// The file extension for DVB Subtitle.\npub const FILE_EXTENSION_SUB: &str = \"sub\";\n/// The file extension for SUS Calendar.\npub const FILE_EXTENSION_SUS: &str = \"sus\";\n/// The file extension for SUS Calendar.\npub const FILE_EXTENSION_SUSP: &str = \"susp\";\n/// The file extension for SV4CPIO archive.\npub const FILE_EXTENSION_SV4CPIO: &str = \"sv4cpio\";\n/// The file extension for SV4CRC archive.\npub const FILE_EXTENSION_SV4CRC: &str = \"sv4crc\";\n/// The file extension for DVB Service.\npub const FILE_EXTENSION_SVC: &str = \"svc\";\n/// The file extension for SVD.\npub const FILE_EXTENSION_SVD: &str = \"svd\";\n/// The file extension for SVG image.\npub const FILE_EXTENSION_SVG: &str = \"svg\";\n/// The file extension for SVG image.\npub const FILE_EXTENSION_SVGZ: &str = \"svgz\";\n/// The file extension for Shockwave Flash.\npub const FILE_EXTENSION_SWA: &str = \"swa\";\n/// The file extension for Shockwave Flash.\npub const FILE_EXTENSION_SWF: &str = \"swf\";\n/// The file extension for Arista Networks SWI.\npub const FILE_EXTENSION_SWI: &str = \"swi\";\n/// The file extension for Sun XML Calc.\npub const FILE_EXTENSION_SXC: &str = \"sxc\";\n/// The file extension for Sun XML Draw.\npub const FILE_EXTENSION_SXD: &str = \"sxd\";\n/// The file extension for Sun XML Writer Global.\npub const FILE_EXTENSION_SXG: &str = \"sxg\";\n/// The file extension for Sun XML Impress.\npub const FILE_EXTENSION_SXI: &str = \"sxi\";\n/// The file extension for Sun XML Math.\npub const FILE_EXTENSION_SXM: &str = \"sxm\";\n/// The file extension for Sun XML Writer.\npub const FILE_EXTENSION_SXW: &str = \"sxw\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_T: &str = \"t\";\n/// The file extension for T3VM image.\npub const FILE_EXTENSION_T3: &str = \"t3\";\n/// The file extension for MyNFC.\npub const FILE_EXTENSION_TAGLET: &str = \"taglet\";\n/// The file extension for Tao Intent Module Archive.\npub const FILE_EXTENSION_TAO: &str = \"tao\";\n/// The file extension for TAR archive.\npub const FILE_EXTENSION_TAR: &str = \"tar\";\n/// The file extension for 3GPP2 TCAP.\npub const FILE_EXTENSION_TCAP: &str = \"tcap\";\n/// The file extension for Tcl script.\npub const FILE_EXTENSION_TCL: &str = \"tcl\";\n/// The file extension for SMART Teacher.\npub const FILE_EXTENSION_TEACHER: &str = \"teacher\";\n/// The file extension for TEI XML.\npub const FILE_EXTENSION_TEI: &str = \"tei\";\n/// The file extension for TEI XML.\npub const FILE_EXTENSION_TEICORPUS: &str = \"teicorpus\";\n/// The file extension for TeX.\npub const FILE_EXTENSION_TEX: &str = \"tex\";\n/// The file extension for Texinfo.\npub const FILE_EXTENSION_TEXI: &str = \"texi\";\n/// The file extension for Texinfo.\npub const FILE_EXTENSION_TEXINFO: &str = \"texinfo\";\n/// The file extension for a text file.\npub const FILE_EXTENSION_TEXT: &str = \"text\";\n/// The file extension for Thraud XML.\npub const FILE_EXTENSION_TFI: &str = \"tfi\";\n/// The file extension for TeX TFM.\npub const FILE_EXTENSION_TFM: &str = \"tfm\";\n/// The file extension for TGA image.\npub const FILE_EXTENSION_TGA: &str = \"tga\";\n/// The file extension for Microsoft Office Theme.\npub const FILE_EXTENSION_THMX: &str = \"thmx\";\n/// The file extension for TIFF image.\npub const FILE_EXTENSION_TIF: &str = \"tif\";\n/// The file extension for TIFF image.\npub const FILE_EXTENSION_TIFF: &str = \"tiff\";\n/// The file extension for T-Mobile LiveTV.\npub const FILE_EXTENSION_TMO: &str = \"tmo\";\n/// The file extension for BitTorrent.\npub const FILE_EXTENSION_TORRENT: &str = \"torrent\";\n/// The file extension for Groove Tool Template.\npub const FILE_EXTENSION_TPL: &str = \"tpl\";\n/// The file extension for TRID TPT.\npub const FILE_EXTENSION_TPT: &str = \"tpt\";\n/// The file extension for Troff.\npub const FILE_EXTENSION_TR: &str = \"tr\";\n/// The file extension for TrueApp.\npub const FILE_EXTENSION_TRA: &str = \"tra\";\n/// The file extension for Microsoft Terminal.\npub const FILE_EXTENSION_TRM: &str = \"trm\";\n/// The file extension for Timestamped Data.\npub const FILE_EXTENSION_TSD: &str = \"tsd\";\n/// The file extension for Tab-Separated Values.\npub const FILE_EXTENSION_TSV: &str = \"tsv\";\n/// The file extension for Font Collection.\npub const FILE_EXTENSION_TTC: &str = \"ttc\";\n/// The file extension for TrueType Font.\npub const FILE_EXTENSION_TTF: &str = \"ttf\";\n/// The file extension for Turtle.\npub const FILE_EXTENSION_TTL: &str = \"ttl\";\n/// The file extension for SimTech MindMapper.\npub const FILE_EXTENSION_TWD: &str = \"twd\";\n/// The file extension for SimTech MindMapper.\npub const FILE_EXTENSION_TWDS: &str = \"twds\";\n/// The file extension for Genomatix Tuxedo.\npub const FILE_EXTENSION_TXD: &str = \"txd\";\n/// The file extension for Mobius TXF.\npub const FILE_EXTENSION_TXF: &str = \"txf\";\n/// The file extension for a text file.\npub const FILE_EXTENSION_TXT: &str = \"txt\";\n/// The file extension for UFDL.\npub const FILE_EXTENSION_U32: &str = \"u32\";\n/// The file extension for a udeb file.\npub const FILE_EXTENSION_UDEB: &str = \"udeb\";\n/// The file extension for UFDL.\npub const FILE_EXTENSION_UFD: &str = \"ufd\";\n/// The file extension for UFDL.\npub const FILE_EXTENSION_UFDL: &str = \"ufdl\";\n/// The file extension for Glulx game.\npub const FILE_EXTENSION_ULW: &str = \"ulw\";\n/// The file extension for Glulx game.\npub const FILE_EXTENSION_ULX: &str = \"ulx\";\n/// The file extension for UMAJIN.\npub const FILE_EXTENSION_UMJ: &str = \"umj\";\n/// The file extension for Unity.\npub const FILE_EXTENSION_UNITYWEB: &str = \"unityweb\";\n/// The file extension for UOML XML.\npub const FILE_EXTENSION_UOML: &str = \"uoml\";\n/// The file extension for URI List.\npub const FILE_EXTENSION_URI: &str = \"uri\";\n/// The file extension for URI List.\npub const FILE_EXTENSION_URIS: &str = \"uris\";\n/// The file extension for URI List.\npub const FILE_EXTENSION_URLS: &str = \"urls\";\n/// The file extension for USTAR archive.\npub const FILE_EXTENSION_USTAR: &str = \"ustar\";\n/// The file extension for UIQ Theme.\npub const FILE_EXTENSION_UTZ: &str = \"utz\";\n/// The file extension for UUEncode.\npub const FILE_EXTENSION_UU: &str = \"uu\";\n/// The file extension for DECE audio.\npub const FILE_EXTENSION_UVA: &str = \"uva\";\n/// The file extension for DECE data.\npub const FILE_EXTENSION_UVD: &str = \"uvd\";\n/// The file extension for DECE data.\npub const FILE_EXTENSION_UVF: &str = \"uvf\";\n/// The file extension for DECE graphic.\npub const FILE_EXTENSION_UVG: &str = \"uvg\";\n/// The file extension for DECE HD video.\npub const FILE_EXTENSION_UVH: &str = \"uvh\";\n/// The file extension for DECE graphic.\npub const FILE_EXTENSION_UVI: &str = \"uvi\";\n/// The file extension for DECE mobile video.\npub const FILE_EXTENSION_UVM: &str = \"uvm\";\n/// The file extension for DECE PD video.\npub const FILE_EXTENSION_UVP: &str = \"uvp\";\n/// The file extension for DECE SD video.\npub const FILE_EXTENSION_UVS: &str = \"uvs\";\n/// The file extension for DECE TTML XML.\npub const FILE_EXTENSION_UVT: &str = \"uvt\";\n/// The file extension for UVVU MP4 video.\npub const FILE_EXTENSION_UVU: &str = \"uvu\";\n/// The file extension for DECE video.\npub const FILE_EXTENSION_UVV: &str = \"uvv\";\n/// The file extension for DECE audio.\npub const FILE_EXTENSION_UVVA: &str = \"uvva\";\n/// The file extension for DECE data.\npub const FILE_EXTENSION_UVVD: &str = \"uvvd\";\n/// The file extension for DECE data.\npub const FILE_EXTENSION_UVVF: &str = \"uvvf\";\n/// The file extension for DECE graphic.\npub const FILE_EXTENSION_UVVG: &str = \"uvvg\";\n/// The file extension for DECE HD video.\npub const FILE_EXTENSION_UVVH: &str = \"uvvh\";\n/// The file extension for DECE graphic.\npub const FILE_EXTENSION_UVVI: &str = \"uvvi\";\n/// The file extension for DECE mobile video.\npub const FILE_EXTENSION_UVVM: &str = \"uvvm\";\n/// The file extension for DECE PD video.\npub const FILE_EXTENSION_UVVP: &str = \"uvvp\";\n/// The file extension for DECE SD video.\npub const FILE_EXTENSION_UVVS: &str = \"uvvs\";\n/// The file extension for DECE TTML XML.\npub const FILE_EXTENSION_UVVT: &str = \"uvvt\";\n/// The file extension for UVVU MP4 video.\npub const FILE_EXTENSION_UVVU: &str = \"uvvu\";\n/// The file extension for DECE video.\npub const FILE_EXTENSION_UVVV: &str = \"uvvv\";\n/// The file extension for DECE unspecified.\npub const FILE_EXTENSION_UVVX: &str = \"uvvx\";\n/// The file extension for DECE ZIP.\npub const FILE_EXTENSION_UVVZ: &str = \"uvvz\";\n/// The file extension for DECE unspecified.\npub const FILE_EXTENSION_UVX: &str = \"uvx\";\n/// The file extension for DECE ZIP.\npub const FILE_EXTENSION_UVZ: &str = \"uvz\";\n/// The file extension for vCard.\npub const FILE_EXTENSION_VCARD: &str = \"vcard\";\n/// The file extension for CDLink.\npub const FILE_EXTENSION_VCD: &str = \"vcd\";\n/// The file extension for vCard.\npub const FILE_EXTENSION_VCF: &str = \"vcf\";\n/// The file extension for Groove vCard.\npub const FILE_EXTENSION_VCG: &str = \"vcg\";\n/// The file extension for vCalendar.\npub const FILE_EXTENSION_VCS: &str = \"vcs\";\n/// The file extension for VCX.\npub const FILE_EXTENSION_VCX: &str = \"vcx\";\n/// The file extension for Visionary.\npub const FILE_EXTENSION_VIS: &str = \"vis\";\n/// The file extension for Vivo video.\npub const FILE_EXTENSION_VIV: &str = \"viv\";\n/// The file extension for VOB video.\npub const FILE_EXTENSION_VOB: &str = \"vob\";\n/// The file extension for VRML model.\npub const FILE_EXTENSION_VOR: &str = \"vor\";\n/// The file extension for VSF.\npub const FILE_EXTENSION_VOX: &str = \"vox\";\n/// The file extension for VRML model.\npub const FILE_EXTENSION_VRML: &str = \"vrml\";\n/// The file extension for Microsoft Visio.\npub const FILE_EXTENSION_VSD: &str = \"vsd\";\n/// The file extension for VSF.\npub const FILE_EXTENSION_VSF: &str = \"vsf\";\n/// The file extension for Microsoft Visio.\npub const FILE_EXTENSION_VSS: &str = \"vss\";\n/// The file extension for Microsoft Visio.\npub const FILE_EXTENSION_VST: &str = \"vst\";\n/// The file extension for Microsoft Visio.\npub const FILE_EXTENSION_VSW: &str = \"vsw\";\n/// The file extension for VTU model.\npub const FILE_EXTENSION_VTU: &str = \"vtu\";\n/// The file extension for VoiceXML.\npub const FILE_EXTENSION_VXML: &str = \"vxml\";\n/// The file extension for Adobe Director.\npub const FILE_EXTENSION_W3D: &str = \"w3d\";\n/// The file extension for Doom WAD.\npub const FILE_EXTENSION_WAD: &str = \"wad\";\n/// The file extension for WAV audio.\npub const FILE_EXTENSION_WAV: &str = \"wav\";\n/// The file extension for WAX audio.\npub const FILE_EXTENSION_WAX: &str = \"wax\";\n/// The file extension for WAP WBMP image.\npub const FILE_EXTENSION_WBMP: &str = \"wbmp\";\n/// The file extension for Critical Tools WBS XML.\npub const FILE_EXTENSION_WBS: &str = \"wbs\";\n/// The file extension for WAP WBXML.\npub const FILE_EXTENSION_WBXML: &str = \"wbxml\";\n/// The file extension for Microsoft Works.\npub const FILE_EXTENSION_WCM: &str = \"wcm\";\n/// The file extension for Microsoft Works.\npub const FILE_EXTENSION_WDB: &str = \"wdb\";\n/// The file extension for Microsoft Photo.\npub const FILE_EXTENSION_WDP: &str = \"wdp\";\n/// The file extension for WebM audio.\npub const FILE_EXTENSION_WEBA: &str = \"weba\";\n/// The file extension for WebM video.\npub const FILE_EXTENSION_WEBM: &str = \"webm\";\n/// The file extension for WebP image.\npub const FILE_EXTENSION_WEBP: &str = \"webp\";\n/// The file extension for PMI Widget.\npub const FILE_EXTENSION_WG: &str = \"wg\";\n/// The file extension for Widget.\npub const FILE_EXTENSION_WGT: &str = \"wgt\";\n/// The file extension for Microsoft Works.\npub const FILE_EXTENSION_WKS: &str = \"wks\";\n/// The file extension for WM video.\npub const FILE_EXTENSION_WM: &str = \"wm\";\n/// The file extension for WMA audio.\npub const FILE_EXTENSION_WMA: &str = \"wma\";\n/// The file extension for WMD.\npub const FILE_EXTENSION_WMD: &str = \"wmd\";\n/// The file extension for Microsoft Metafile.\npub const FILE_EXTENSION_WMF: &str = \"wmf\";\n/// The file extension for WAP WML.\npub const FILE_EXTENSION_WML: &str = \"wml\";\n/// The file extension for WAP WMLC.\npub const FILE_EXTENSION_WMLC: &str = \"wmlc\";\n/// The file extension for WAP WMLScript.\npub const FILE_EXTENSION_WMLS: &str = \"wmls\";\n/// The file extension for WAP WMLScriptC.\npub const FILE_EXTENSION_WMLSC: &str = \"wmlsc\";\n/// The file extension for WMV video.\npub const FILE_EXTENSION_WMV: &str = \"wmv\";\n/// The file extension for WMX video.\npub const FILE_EXTENSION_WMX: &str = \"wmx\";\n/// The file extension for Microsoft Metafile.\npub const FILE_EXTENSION_WMZ: &str = \"wmz\";\n/// The file extension for WOFF font.\npub const FILE_EXTENSION_WOFF: &str = \"woff\";\n/// The file extension for WOFF2 font.\npub const FILE_EXTENSION_WOFF2: &str = \"woff2\";\n/// The file extension for WordPerfect.\npub const FILE_EXTENSION_WPD: &str = \"wpd\";\n/// The file extension for Microsoft WPL.\npub const FILE_EXTENSION_WPL: &str = \"wpl\";\n/// The file extension for Microsoft Works.\npub const FILE_EXTENSION_WPS: &str = \"wps\";\n/// The file extension for WQD.\npub const FILE_EXTENSION_WQD: &str = \"wqd\";\n/// The file extension for Microsoft Write.\npub const FILE_EXTENSION_WRI: &str = \"wri\";\n/// The file extension for VRML model.\npub const FILE_EXTENSION_WRL: &str = \"wrl\";\n/// The file extension for WSDL XML.\npub const FILE_EXTENSION_WSDL: &str = \"wsdl\";\n/// The file extension for WSPolicy XML.\npub const FILE_EXTENSION_WSPOLICY: &str = \"wspolicy\";\n/// The file extension for WebTurbo.\npub const FILE_EXTENSION_WTB: &str = \"wtb\";\n/// The file extension for WVX video.\npub const FILE_EXTENSION_WVX: &str = \"wvx\";\n/// The file extension for X3D XML.\npub const FILE_EXTENSION_X32: &str = \"x32\";\n/// The file extension for X3D XML.\npub const FILE_EXTENSION_X3D: &str = \"x3d\";\n/// The file extension for X3D Binary.\npub const FILE_EXTENSION_X3DB: &str = \"x3db\";\n/// The file extension for X3D Binary.\npub const FILE_EXTENSION_X3DBZ: &str = \"x3dbz\";\n/// The file extension for X3D VRML.\npub const FILE_EXTENSION_X3DV: &str = \"x3dv\";\n/// The file extension for X3D VRML.\npub const FILE_EXTENSION_X3DVZ: &str = \"x3dvz\";\n/// The file extension for X3D XML.\npub const FILE_EXTENSION_X3DZ: &str = \"x3dz\";\n/// The file extension for XAML XML.\npub const FILE_EXTENSION_XAML: &str = \"xaml\";\n/// The file extension for Silverlight App.\npub const FILE_EXTENSION_XAP: &str = \"xap\";\n/// The file extension for Xara.\npub const FILE_EXTENSION_XAR: &str = \"xar\";\n/// The file extension for Microsoft XBAP.\npub const FILE_EXTENSION_XBAP: &str = \"xbap\";\n/// The file extension for Fujixerox DocuWorks Binder.\npub const FILE_EXTENSION_XBD: &str = \"xbd\";\n/// The file extension for XBM image.\npub const FILE_EXTENSION_XBM: &str = \"xbm\";\n/// The file extension for XCAP Diff XML.\npub const FILE_EXTENSION_XDF: &str = \"xdf\";\n/// The file extension for SyncML DM XML.\npub const FILE_EXTENSION_XDM: &str = \"xdm\";\n/// The file extension for Adobe XDP XML.\npub const FILE_EXTENSION_XDP: &str = \"xdp\";\n/// The file extension for DSSC XML.\npub const FILE_EXTENSION_XDSSC: &str = \"xdssc\";\n/// The file extension for Fujixerox DocuWorks.\npub const FILE_EXTENSION_XDW: &str = \"xdw\";\n/// The file extension for XENC XML.\npub const FILE_EXTENSION_XENC: &str = \"xenc\";\n/// The file extension for Patch Ops Error XML.\npub const FILE_EXTENSION_XER: &str = \"xer\";\n/// The file extension for Adobe XFDF.\npub const FILE_EXTENSION_XFDF: &str = \"xfdf\";\n/// The file extension for XFDL.\npub const FILE_EXTENSION_XFDL: &str = \"xfdl\";\n/// The file extension for XHTML XML.\npub const FILE_EXTENSION_XHT: &str = \"xht\";\n/// The file extension for XHTML XML.\npub const FILE_EXTENSION_XHTML: &str = \"xhtml\";\n/// The file extension for XV XML.\npub const FILE_EXTENSION_XHVML: &str = \"xhvml\";\n/// The file extension for XIFF image.\npub const FILE_EXTENSION_XIF: &str = \"xif\";\n/// The file extension for Microsoft Excel.\npub const FILE_EXTENSION_XLA: &str = \"xla\";\n/// The file extension for Microsoft Excel Add-in (Macro-Enabled).\npub const FILE_EXTENSION_XLAM: &str = \"xlam\";\n/// The file extension for Microsoft Excel.\npub const FILE_EXTENSION_XLC: &str = \"xlc\";\n/// The file extension for XLIFF XML.\npub const FILE_EXTENSION_XLF: &str = \"xlf\";\n/// The file extension for Microsoft Excel.\npub const FILE_EXTENSION_XLM: &str = \"xlm\";\n/// The file extension for Microsoft Excel.\npub const FILE_EXTENSION_XLS: &str = \"xls\";\n/// The file extension for Microsoft Excel Sheet (Binary, Macro-Enabled).\npub const FILE_EXTENSION_XLSB: &str = \"xlsb\";\n/// The file extension for Microsoft Excel Sheet (Macro-Enabled).\npub const FILE_EXTENSION_XLSM: &str = \"xlsm\";\n/// The file extension for Office Open XML Spreadsheet.\npub const FILE_EXTENSION_XLSX: &str = \"xlsx\";\n/// The file extension for Microsoft Excel Template.\npub const FILE_EXTENSION_XLT: &str = \"xlt\";\n/// The file extension for Microsoft Excel Template (Macro-Enabled).\npub const FILE_EXTENSION_XLTM: &str = \"xltm\";\n/// The file extension for Office Open XML Spreadsheet Template.\npub const FILE_EXTENSION_XLTX: &str = \"xltx\";\n/// The file extension for Microsoft Excel.\npub const FILE_EXTENSION_XLW: &str = \"xlw\";\n/// The file extension for XM audio.\npub const FILE_EXTENSION_XM: &str = \"xm\";\n/// The file extension for XML.\npub const FILE_EXTENSION_XML: &str = \"xml\";\n/// The file extension for OLPC Sugar.\npub const FILE_EXTENSION_XO: &str = \"xo\";\n/// The file extension for XOP XML.\npub const FILE_EXTENSION_XOP: &str = \"xop\";\n/// The file extension for XPInstall.\npub const FILE_EXTENSION_XPI: &str = \"xpi\";\n/// The file extension for XProc XML.\npub const FILE_EXTENSION_XPL: &str = \"xpl\";\n/// The file extension for XPM image.\npub const FILE_EXTENSION_XPM: &str = \"xpm\";\n/// The file extension for IS-XPR.\npub const FILE_EXTENSION_XPR: &str = \"xpr\";\n/// The file extension for Microsoft XPS Document.\npub const FILE_EXTENSION_XPS: &str = \"xps\";\n/// The file extension for Intercon FormNet.\npub const FILE_EXTENSION_XPW: &str = \"xpw\";\n/// The file extension for Intercon FormNet.\npub const FILE_EXTENSION_XPX: &str = \"xpx\";\n/// The file extension for XSLT XML.\npub const FILE_EXTENSION_XSL: &str = \"xsl\";\n/// The file extension for XSLT XML.\npub const FILE_EXTENSION_XSLT: &str = \"xslt\";\n/// The file extension for SyncML XML.\npub const FILE_EXTENSION_XSM: &str = \"xsm\";\n/// The file extension for XSPF XML.\npub const FILE_EXTENSION_XSPF: &str = \"xspf\";\n/// The file extension for Mozilla XUL XML.\npub const FILE_EXTENSION_XUL: &str = \"xul\";\n/// The file extension for XV XML.\npub const FILE_EXTENSION_XVM: &str = \"xvm\";\n/// The file extension for XV XML.\npub const FILE_EXTENSION_XVML: &str = \"xvml\";\n/// The file extension for XWD image.\npub const FILE_EXTENSION_XWD: &str = \"xwd\";\n/// The file extension for XYZ chemical.\npub const FILE_EXTENSION_XYZ: &str = \"xyz\";\n/// The file extension for XZ archive.\npub const FILE_EXTENSION_XZ: &str = \"xz\";\n/// The file extension for YANG.\npub const FILE_EXTENSION_YANG: &str = \"yang\";\n/// The file extension for YIN XML.\npub const FILE_EXTENSION_YIN: &str = \"yin\";\n/// The file extension for compress archive.\npub const FILE_EXTENSION_Z: &str = \"z\";\n/// The file extension for compress archive.\npub const FILE_EXTENSION_Z_UPPERCASEE: &str = \"Z\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z1: &str = \"z1\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z2: &str = \"z2\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z3: &str = \"z3\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z4: &str = \"z4\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z5: &str = \"z5\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z6: &str = \"z6\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z7: &str = \"z7\";\n/// The file extension for Z-machine.\npub const FILE_EXTENSION_Z8: &str = \"z8\";\n/// The file extension for Zzazz Deck XML.\npub const FILE_EXTENSION_ZAZ: &str = \"zaz\";\n/// The file extension for ZIP archive.\npub const FILE_EXTENSION_ZIP: &str = \"zip\";\n/// The file extension for ZUL.\npub const FILE_EXTENSION_ZIR: &str = \"zir\";\n/// The file extension for ZUL.\npub const FILE_EXTENSION_ZIRZ: &str = \"zirz\";\n/// The file extension for Handheld Entertainment XML.\npub const FILE_EXTENSION_ZMM: &str = \"zmm\";\n/// The file extension for markdown.\npub const FILE_EXTENSION_MARKDOWN: &str = \"md\";\n/// The file extension for toml.\npub const FILE_EXTENSION_TOML: &str = \"toml\";\n/// The file extension for yaml.\npub const FILE_EXTENSION_YAML: &str = \"yaml\";\n/// The file extension for yaml.\npub const FILE_EXTENSION_YML: &str = \"yml\";\n/// The file extension for ini.\npub const FILE_EXTENSION_INI: &str = \"ini\";\n/// The file extension for cfg.\npub const FILE_EXTENSION_CFG: &str = \"cfg\";\n/// The file extension for Python.\npub const FILE_EXTENSION_PY: &str = \"py\";\n/// The file extension for Go.\npub const FILE_EXTENSION_GO: &str = \"go\";\n/// The file extension for TypeScript.\npub const FILE_EXTENSION_TS: &str = \"ts\";\n/// The file extension for C#.\npub const FILE_EXTENSION_CS: &str = \"cs\";\n/// The file extension for PHP.\npub const FILE_EXTENSION_PHP: &str = \"php\";\n/// The file extension for Ruby.\npub const FILE_EXTENSION_RB: &str = \"rb\";\n/// The file extension for Swift.\npub const FILE_EXTENSION_SWIFT: &str = \"swift\";\n/// The file extension for Kotlin.\npub const FILE_EXTENSION_KT: &str = \"kt\";\n/// The file extension for Kotlin Script.\npub const FILE_EXTENSION_KTS: &str = \"kts\";\n/// The file extension for Scala.\npub const FILE_EXTENSION_SCALA: &str = \"scala\";\n/// The file extension for IBM Secure Container or Scala Script.\npub const FILE_EXTENSION_SC: &str = \"sc\";\n/// The file extension for Perl.\npub const FILE_EXTENSION_PL: &str = \"pl\";\n/// The file extension for Perl Module.\npub const FILE_EXTENSION_PM: &str = \"pm\";\n/// The file extension for Lua.\npub const FILE_EXTENSION_LUA: &str = \"lua\";\n/// The file extension for PowerShell.\npub const FILE_EXTENSION_PS1: &str = \"ps1\";\n/// The file extension for C++ Header.\npub const FILE_EXTENSION_HPP: &str = \"hpp\";\n/// The file extension for Objective-C.\npub const FILE_EXTENSION_M: &str = \"m\";\n/// The file extension for Objective-C++.\npub const FILE_EXTENSION_MM: &str = \"mm\";\n/// The file extension for Groovy.\npub const FILE_EXTENSION_GROOVY: &str = \"groovy\";\n/// The file extension for R.\npub const FILE_EXTENSION_R: &str = \"r\";\n/// The file extension for SCSS.\npub const FILE_EXTENSION_SCSS: &str = \"scss\";\n/// The file extension for SASS.\npub const FILE_EXTENSION_SASS: &str = \"sass\";\n/// The file extension for LESS.\npub const FILE_EXTENSION_LESS: &str = \"less\";\n/// The file extension for Vue.\npub const FILE_EXTENSION_VUE: &str = \"vue\";\n/// The file extension for JSX.\npub const FILE_EXTENSION_JSX: &str = \"jsx\";\n/// The file extension for TSX.\npub const FILE_EXTENSION_TSX: &str = \"tsx\";\n/// The file extension for Dockerfile.\npub const FILE_EXTENSION_DOCKERFILE: &str = \"dockerfile\";\n/// The file extension for Makefile.\npub const FILE_EXTENSION_MAKEFILE: &str = \"makefile\";\n/// The file extension for Gitignore.\npub const FILE_EXTENSION_GITIGNORE: &str = \"gitignore\";\n/// The file extension for RLS Services XML or Rust.\npub const FILE_EXTENSION_RS: &str = \"rs\";\n/// The file extension for Haskell.\npub const FILE_EXTENSION_HS: &str = \"hs\";\n/// The file extension for Erlang.\npub const FILE_EXTENSION_ERL: &str = \"erl\";\n/// The file extension for Elixir.\npub const FILE_EXTENSION_EX: &str = \"ex\";\n/// The file extension for Elixir Script.\npub const FILE_EXTENSION_EXS: &str = \"exs\";\n/// The file extension for Clojure.\npub const FILE_EXTENSION_CLJ: &str = \"clj\";\n/// The file extension for ClojureScript.\npub const FILE_EXTENSION_CLJS: &str = \"cljs\";\n/// The file extension for Clojure Common.\npub const FILE_EXTENSION_CLJC: &str = \"cljc\";\n/// The file extension for F#.\npub const FILE_EXTENSION_FS: &str = \"fs\";\n/// The file extension for F# Script.\npub const FILE_EXTENSION_FSX: &str = \"fsx\";\n/// The file extension for OCaml.\npub const FILE_EXTENSION_ML: &str = \"ml\";\n/// The file extension for OCaml Interface.\npub const FILE_EXTENSION_MLI: &str = \"mli\";\n/// The file extension for Bash.\npub const FILE_EXTENSION_BASH: &str = \"bash\";\n/// The file extension for Zsh.\npub const FILE_EXTENSION_ZSH: &str = \"zsh\";\n/// The file extension for env.\npub const FILE_EXTENSION_ENV: &str = \"env\";\n/// The file extension for cj.\npub const FILE_EXTENSION_CJ: &str = \"cj\";", "file_size": 91354, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\content_type_value\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\n\npub use r#const::*;", "file_size": 44, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\content_type_value\\const.rs", "language": "rust", "content": "/// The `Content-Type` for Lotus 1-2-3.\npub const APPLICATION_VND_LOTUS_1_2_3: &str = \"application/vnd.lotus-1-2-3\";\n/// The `Content-Type` for In3D 3DML.\npub const TEXT_VND_IN3D_3DML: &str = \"text/vnd.in3d.3dml\";\n/// The `Content-Type` for 3ds Image.\npub const IMAGE_X_3DS: &str = \"image/x-3ds\";\n/// The `Content-Type` for 3GPP2 video.\npub const VIDEO_3GPP2: &str = \"video/3gpp2\";\n/// The `Content-Type` for 3GPP video.\npub const VIDEO_3GPP: &str = \"video/3gpp\";\n/// The `Content-Type` for 7z compressed archive.\npub const APPLICATION_X_7Z_COMPRESSED: &str = \"application/x-7z-compressed\";\n/// The `Content-Type` for Authorware binary.\npub const APPLICATION_X_AUTHORWARE_BIN: &str = \"application/x-authorware-bin\";\n/// The `Content-Type` for AAC audio.\npub const AUDIO_X_AAC: &str = \"audio/x-aac\";\n/// The `Content-Type` for Authorware map.\npub const APPLICATION_X_AUTHORWARE_MAP: &str = \"application/x-authorware-map\";\n/// The `Content-Type` for Authorware segment.\npub const APPLICATION_X_AUTHORWARE_SEG: &str = \"application/x-authorware-seg\";\n/// The `Content-Type` for MPEG audio.\npub const AUDIO_X_MPEG: &str = \"audio/x-mpeg\";\n/// The `Content-Type` for AbiWord document.\npub const APPLICATION_X_ABIWORD: &str = \"application/x-abiword\";\n/// The `Content-Type` for PKIX attribute certificate.\npub const APPLICATION_PKIX_ATTR_CERT: &str = \"application/pkix-attr-cert\";\n/// The `Content-Type` for American Dynamics ACC.\npub const APPLICATION_VND_AMERICANDYNAMICS_ACC: &str = \"application/vnd.americandynamics.acc\";\n/// The `Content-Type` for ACE compressed archive.\npub const APPLICATION_X_ACE_COMPRESSED: &str = \"application/x-ace-compressed\";\n/// The `Content-Type` for AcuCobol.\npub const APPLICATION_VND_ACUCOBOL: &str = \"application/vnd.acucobol\";\n/// The `Content-Type` for AcuCorp.\npub const APPLICATION_VND_ACUCORP: &str = \"application/vnd.acucorp\";\n/// The `Content-Type` for ADPCM audio.\npub const AUDIO_ADPCM: &str = \"audio/adpcm\";\n/// The `Content-Type` for Audiograph.\npub const APPLICATION_VND_AUDIOGRAPH: &str = \"application/vnd.audiograph\";\n/// The `Content-Type` for Adobe Type 1 Font.\npub const APPLICATION_X_FONT_TYPE1: &str = \"application/x-font-type1\";\n/// The `Content-Type` for IBM MODCAP.\npub const APPLICATION_VND_IBM_MODCAP: &str = \"application/vnd.ibm.modcap\";\n/// The `Content-Type` for Ahead AIR Application.\npub const APPLICATION_VND_AHEAD_SPACE: &str = \"application/vnd.ahead.space\";\n/// The `Content-Type` for PostScript.\npub const APPLICATION_POSTSCRIPT: &str = \"application/postscript\";\n/// The `Content-Type` for AIFF audio.\npub const AUDIO_X_AIFF: &str = \"audio/x-aiff\";\n/// The `Content-Type` for AIM.\npub const APPLICATION_X_AIM: &str = \"application/x-aim\";\n/// The `Content-Type` for Adobe AIR Application.\npub const APPLICATION_VND_ADOBE_AIR_APPLICATION_INSTALLER_PACKAGE_ZIP: &str =\n    \"application/vnd.adobe.air-application-installer-package+zip\";\n/// The `Content-Type` for DVB AIT.\npub const APPLICATION_VND_DVB_AIT: &str = \"application/vnd.dvb.ait\";\n/// The `Content-Type` for Amiga AMI.\npub const APPLICATION_VND_AMIGA_AMI: &str = \"application/vnd.amiga.ami\";\n/// The `Content-Type` for Annodex.\npub const APPLICATION_ANNODEX: &str = \"application/annodex\";\n/// The `Content-Type` for Android Package Archive.\npub const APPLICATION_VND_ANDROID_PACKAGE_ARCHIVE: &str = \"application/vnd.android.package-archive\";\n/// The `Content-Type` for Cache Manifest.\npub const TEXT_CACHE_MANIFEST: &str = \"text/cache-manifest\";\n/// The `Content-Type` for Server-Sent Events.\npub const TEXT_EVENT_STREAM: &str = \"text/event-stream\";\n/// The `Content-Type` for Microsoft Application.\npub const APPLICATION_X_MS_APPLICATION: &str = \"application/x-ms-application\";\n/// The `Content-Type` for Lotus Approach.\npub const APPLICATION_VND_LOTUS_APPROACH: &str = \"application/vnd.lotus-approach\";\n/// The `Content-Type` for FreeArc archive.\npub const APPLICATION_X_FREEARC: &str = \"application/x-freearc\";\n/// The `Content-Type` for JG image.\npub const IMAGE_X_JG: &str = \"image/x-jg\";\n/// The `Content-Type` for PGP signature.\npub const APPLICATION_PGP_SIGNATURE: &str = \"application/pgp-signature\";\n/// The `Content-Type` for ASF video.\npub const VIDEO_X_MS_ASF: &str = \"video/x-ms-asf\";\n/// The `Content-Type` for Assembly source.\npub const TEXT_X_ASM: &str = \"text/x-asm\";\n/// The `Content-Type` for Accpac Simply ASO.\npub const APPLICATION_VND_ACCPAC_SIMPLY_ASO: &str = \"application/vnd.accpac.simply.aso\";\n/// The `Content-Type` for Atom feed.\npub const APPLICATION_ATOM_XML: &str = \"application/atom+xml\";\n/// The `Content-Type` for Atom category document.\npub const APPLICATION_ATOMCAT_XML: &str = \"application/atomcat+xml\";\n/// The `Content-Type` for Atom service document.\npub const APPLICATION_ATOMSVC_XML: &str = \"application/atomsvc+xml\";\n/// The `Content-Type` for Antix Game Component.\npub const APPLICATION_VND_ANTIX_GAME_COMPONENT: &str = \"application/vnd.antix.game-component\";\n/// The `Content-Type` for basic audio.\npub const AUDIO_BASIC: &str = \"audio/basic\";\n/// The `Content-Type` for AVI video.\npub const VIDEO_X_MSVIDEO: &str = \"video/x-msvideo\";\n/// The `Content-Type` for Rad ScreenPlay video.\npub const VIDEO_X_RAD_SCREENPLAY: &str = \"video/x-rad-screenplay\";\n/// The `Content-Type` for Applixware.\npub const APPLICATION_APPLIXWARE: &str = \"application/applixware\";\n/// The `Content-Type` for Annodex audio.\npub const AUDIO_ANNODEX: &str = \"audio/annodex\";\n/// The `Content-Type` for Annodex video.\npub const VIDEO_ANNODEX: &str = \"video/annodex\";\n/// The `Content-Type` for AirZip FileSecure AZF.\npub const APPLICATION_VND_AIRZIP_FILESECURE_AZF: &str = \"application/vnd.airzip.filesecure.azf\";\n/// The `Content-Type` for AirZip FileSecure AZS.\npub const APPLICATION_VND_AIRZIP_FILESECURE_AZS: &str = \"application/vnd.airzip.filesecure.azs\";\n/// The `Content-Type` for Amazon Kindle eBook.\npub const APPLICATION_VND_AMAZON_EBOOK: &str = \"application/vnd.amazon.ebook\";\n/// The `Content-Type` for Microsoft application download.\npub const APPLICATION_X_MSDOWNLOAD: &str = \"application/x-msdownload\";\n/// The `Content-Type` for BCPIO archive.\npub const APPLICATION_X_BCPIO: &str = \"application/x-bcpio\";\n/// The `Content-Type` for BDF font.\npub const APPLICATION_X_FONT_BDF: &str = \"application/x-font-bdf\";\n/// The `Content-Type` for SyncML DM+WBXML.\npub const APPLICATION_VND_SYNCML_DM_WBXML: &str = \"application/vnd.syncml.dm+wbxml\";\n/// The `Content-Type` for RealVNC BED.\npub const APPLICATION_VND_REALVNC_BED: &str = \"application/vnd.realvnc.bed\";\n/// The `Content-Type` for Fujitsu OasysPRS.\npub const APPLICATION_VND_FUJITSU_OASYSPRS: &str = \"application/vnd.fujitsu.oasysprs\";\n/// The `Content-Type` for binary data.\npub const APPLICATION_OCTET_STREAM: &str = \"application/octet-stream\";\n/// The `Content-Type` for Blorb interactive fiction.\npub const APPLICATION_X_BLORB: &str = \"application/x-blorb\";\n/// The `Content-Type` for BMI.\npub const APPLICATION_VND_BMI: &str = \"application/vnd.bmi\";\n/// The `Content-Type` for BMP image.\npub const IMAGE_BMP: &str = \"image/bmp\";\n/// The `Content-Type` for HTML.\npub const TEXT_HTML: &str = \"text/html\";\n/// The `Content-Type` for URL-encoded forms.\npub const FORM_URLENCODED: &str = \"application/x-www-form-urlencoded\";\n/// The `Content-Type` for Adobe FrameMaker.\npub const APPLICATION_VND_FRAMEMAKER: &str = \"application/vnd.framemaker\";\n/// The `Content-Type` for Preview Systems BOX.\npub const APPLICATION_VND_PREVIEWSYSTEMS_BOX: &str = \"application/vnd.previewsystems.box\";\n/// The `Content-Type` for BZip2 archive.\npub const APPLICATION_X_BZIP2: &str = \"application/x-bzip2\";\n/// The `Content-Type` for BTIF image.\npub const IMAGE_PRS_BTIF: &str = \"image/prs.btif\";\n/// The `Content-Type` for BZip archive.\npub const APPLICATION_X_BZIP: &str = \"application/x-bzip\";\n/// The `Content-Type` for C source code.\npub const TEXT_X_C: &str = \"text/x-c\";\n/// The `Content-Type` for ClueTrust CartoMobile Config.\npub const APPLICATION_VND_CLUETRUST_CARTOMOBILE_CONFIG: &str =\n    \"application/vnd.cluetrust.cartomobile-config\";\n/// The `Content-Type` for ClueTrust CartoMobile Config Package.\npub const APPLICATION_VND_CLUETRUST_CARTOMOBILE_CONFIG_PKG: &str =\n    \"application/vnd.cluetrust.cartomobile-config-pkg\";\n/// The `Content-Type` for Clonk C4Group.\npub const APPLICATION_VND_CLONK_C4GROUP: &str = \"application/vnd.clonk.c4group\";\n/// The `Content-Type` for Microsoft Cabinet file.\npub const APPLICATION_VND_MS_CAB_COMPRESSED: &str = \"application/vnd.ms-cab-compressed\";\n/// The `Content-Type` for CAF audio.\npub const AUDIO_X_CAF: &str = \"audio/x-caf\";\n/// The `Content-Type` for TCPDump capture file.\npub const APPLICATION_VND_TCPDUMP_PCAP: &str = \"application/vnd.tcpdump.pcap\";\n/// The `Content-Type` for cURL CAR file.\npub const APPLICATION_VND_CURL_CAR: &str = \"application/vnd.curl.car\";\n/// The `Content-Type` for Microsoft PKI Security Catalog.\npub const APPLICATION_VND_MS_PKI_SECCAT: &str = \"application/vnd.ms-pki.seccat\";\n/// The `Content-Type` for Comic Book RAR archive.\npub const APPLICATION_X_CBR: &str = \"application/x-cbr\";\n/// The `Content-Type` for Adobe Director.\npub const APPLICATION_X_DIRECTOR: &str = \"application/x-director\";\n/// The `Content-Type` for CCXML.\npub const APPLICATION_CCXML_XML: &str = \"application/ccxml+xml\";\n/// The `Content-Type` for Contact CMSG.\npub const APPLICATION_VND_CONTACT_CMSG: &str = \"application/vnd.contact.cmsg\";\n/// The `Content-Type` for CDF.\npub const APPLICATION_X_CDF: &str = \"application/x-cdf\";\n/// The `Content-Type` for MediaStation CDKey.\npub const APPLICATION_VND_MEDIASTATION_CDKEY: &str = \"application/vnd.mediastation.cdkey\";\n/// The `Content-Type` for CDMI Capability.\npub const APPLICATION_CDMI_CAPABILITY: &str = \"application/cdmi-capability\";\n/// The `Content-Type` for CDMI Container.\npub const APPLICATION_CDMI_CONTAINER: &str = \"application/cdmi-container\";\n/// The `Content-Type` for CDMI Domain.\npub const APPLICATION_CDMI_DOMAIN: &str = \"application/cdmi-domain\";\n/// The `Content-Type` for CDMI Object.\npub const APPLICATION_CDMI_OBJECT: &str = \"application/cdmi-object\";\n/// The `Content-Type` for CDMI Queue.\npub const APPLICATION_CDMI_QUEUE: &str = \"application/cdmi-queue\";\n/// The `Content-Type` for ChemDraw CDX.\npub const CHEMICAL_X_CDX: &str = \"chemical/x-cdx\";\n/// The `Content-Type` for ChemDraw XML.\npub const APPLICATION_VND_CHEMDRAW_XML: &str = \"application/vnd.chemdraw+xml\";\n/// The `Content-Type` for Cinderella.\npub const APPLICATION_VND_CINDERELLA: &str = \"application/vnd.cinderella\";\n/// The `Content-Type` for PKIX Certificate.\npub const APPLICATION_PKIX_CERT: &str = \"application/pkix-cert\";\n/// The `Content-Type` for CFS compressed file.\npub const APPLICATION_X_CFS_COMPRESSED: &str = \"application/x-cfs-compressed\";\n/// The `Content-Type` for CGM image.\npub const IMAGE_CGM: &str = \"image/cgm\";\n/// The `Content-Type` for Chat file.\npub const APPLICATION_X_CHAT: &str = \"application/x-chat\";\n/// The `Content-Type` for Microsoft HTML Help.\npub const APPLICATION_VND_MS_HTMLHELP: &str = \"application/vnd.ms-htmlhelp\";\n/// The `Content-Type` for KDE KChart.\npub const APPLICATION_VND_KDE_KCHART: &str = \"application/vnd.kde.kchart\";\n/// The `Content-Type` for CIF.\npub const CHEMICAL_X_CIF: &str = \"chemical/x-cif\";\n/// The `Content-Type` for Anser-Web Certificate Issue Initiation.\npub const APPLICATION_VND_ANSER_WEB_CERTIFICATE_ISSUE_INITIATION: &str =\n    \"application/vnd.anser-web-certificate-issue-initiation\";\n/// The `Content-Type` for Microsoft ArtGalry.\npub const APPLICATION_VND_MS_ARTGALRY: &str = \"application/vnd.ms-artgalry\";\n/// The `Content-Type` for Claymore.\npub const APPLICATION_VND_CLAYMORE: &str = \"application/vnd.claymore\";\n/// The `Content-Type` for Java class.\npub const APPLICATION_JAVA: &str = \"application/java\";\n/// The `Content-Type` for Crick Clicker Keyboard.\npub const APPLICATION_VND_CRICK_CLICKER_KEYBOARD: &str = \"application/vnd.crick.clicker.keyboard\";\n/// The `Content-Type` for Crick Clicker Palette.\npub const APPLICATION_VND_CRICK_CLICKER_PALETTE: &str = \"application/vnd.crick.clicker.palette\";\n/// The `Content-Type` for Crick Clicker Template.\npub const APPLICATION_VND_CRICK_CLICKER_TEMPLATE: &str = \"application/vnd.crick.clicker.template\";\n/// The `Content-Type` for Crick Clicker Wordbank.\npub const APPLICATION_VND_CRICK_CLICKER_WORDBANK: &str = \"application/vnd.crick.clicker.wordbank\";\n/// The `Content-Type` for Crick Clicker.\npub const APPLICATION_VND_CRICK_CLICKER: &str = \"application/vnd.crick.clicker\";\n/// The `Content-Type` for Microsoft Clipboard.\npub const APPLICATION_X_MSCLIP: &str = \"application/x-msclip\";\n/// The `Content-Type` for CosmoCaller.\npub const APPLICATION_VND_COSMOCALLER: &str = \"application/vnd.cosmocaller\";\n/// The `Content-Type` for CMDF.\npub const CHEMICAL_X_CMDF: &str = \"chemical/x-cmdf\";\n/// The `Content-Type` for CML.\npub const CHEMICAL_X_CML: &str = \"chemical/x-cml\";\n/// The `Content-Type` for Yellow-River Custom-Menu.\npub const APPLICATION_VND_YELLOWRIVER_CUSTOM_MENU: &str = \"application/vnd.yellowriver-custom-menu\";\n/// The `Content-Type` for CMX image.\npub const IMAGE_X_CMX: &str = \"image/x-cmx\";\n/// The `Content-Type` for RIM COD.\npub const APPLICATION_VND_RIM_COD: &str = \"application/vnd.rim.cod\";\n/// The `Content-Type` for plain text.\npub const TEXT_PLAIN: &str = \"text/plain\";\n/// The `Content-Type` for CPIO archive.\npub const APPLICATION_X_CPIO: &str = \"application/x-cpio\";\n/// The `Content-Type` for Mac CompactPro.\npub const APPLICATION_MAC_COMPACTPRO: &str = \"application/mac-compactpro\";\n/// The `Content-Type` for Microsoft CardFile.\npub const APPLICATION_X_MSCARDFILE: &str = \"application/x-mscardfile\";\n/// The `Content-Type` for PKIX CRL.\npub const APPLICATION_PKIX_CRL: &str = \"application/pkix-crl\";\n/// The `Content-Type` for X.509 CA Certificate.\npub const APPLICATION_X_X509_CA_CERT: &str = \"application/x-x509-ca-cert\";\n/// The `Content-Type` for Rig Cryptonote.\npub const APPLICATION_VND_RIG_CRYPTONOTE: &str = \"application/vnd.rig.cryptonote\";\n/// The `Content-Type` for C-Shell script.\npub const APPLICATION_X_CSH: &str = \"application/x-csh\";\n/// The `Content-Type` for CSML.\npub const CHEMICAL_X_CSML: &str = \"chemical/x-csml\";\n/// The `Content-Type` for CommonSpace.\npub const APPLICATION_VND_COMMONSPACE: &str = \"application/vnd.commonspace\";\n/// The `Content-Type` for CSS.\npub const TEXT_CSS: &str = \"text/css\";\n/// The `Content-Type` for CSV.\npub const TEXT_CSV: &str = \"text/csv\";\n/// The `Content-Type` for CU-SeeMe.\npub const APPLICATION_CU_SEEME: &str = \"application/cu-seeme\";\n/// The `Content-Type` for cURL text.\npub const TEXT_VND_CURL: &str = \"text/vnd.curl\";\n/// The `Content-Type` for CWW.\npub const APPLICATION_PRS_CWW: &str = \"application/prs.cww\";\n/// The `Content-Type` for COLLADA XML.\npub const MODEL_VND_COLLADA_XML: &str = \"model/vnd.collada+xml\";\n/// The `Content-Type` for Mobius DAF.\npub const APPLICATION_VND_MOBIUS_DAF: &str = \"application/vnd.mobius.daf\";\n/// The `Content-Type` for Dart.\npub const APPLICATION_VND_DART: &str = \"application/vnd.dart\";\n/// The `Content-Type` for FDSN SEED.\npub const APPLICATION_VND_FDSN_SEED: &str = \"application/vnd.fdsn.seed\";\n/// The `Content-Type` for WebDAV Mount.\npub const APPLICATION_DAVMOUNT_XML: &str = \"application/davmount+xml\";\n/// The `Content-Type` for DocBook XML.\npub const APPLICATION_DOCBOOK_XML: &str = \"application/docbook+xml\";\n/// The `Content-Type` for cURL DCURL.\npub const TEXT_VND_CURL_DCURL: &str = \"text/vnd.curl.dcurl\";\n/// The `Content-Type` for OMA DD2 XML.\npub const APPLICATION_VND_OMA_DD2_XML: &str = \"application/vnd.oma.dd2+xml\";\n/// The `Content-Type` for Fujixerox DDD.\npub const APPLICATION_VND_FUJIXEROX_DDD: &str = \"application/vnd.fujixerox.ddd\";\n/// The `Content-Type` for Debian package.\npub const APPLICATION_X_DEBIAN_PACKAGE: &str = \"application/x-debian-package\";\n/// The `Content-Type` for DreamFactory.\npub const APPLICATION_VND_DREAMFACTORY: &str = \"application/vnd.dreamfactory\";\n/// The `Content-Type` for DGC compressed.\npub const APPLICATION_X_DGC_COMPRESSED: &str = \"application/x-dgc-compressed\";\n/// The `Content-Type` for Mobius DIS.\npub const APPLICATION_VND_MOBIUS_DIS: &str = \"application/vnd.mobius.dis\";\n/// The `Content-Type` for DjVu image.\npub const IMAGE_VND_DJVU: &str = \"image/vnd.djvu\";\n/// The `Content-Type` for Apple Disk Image.\npub const APPLICATION_X_APPLE_DISKIMAGE: &str = \"application/x-apple-diskimage\";\n/// The `Content-Type` for DNA.\npub const APPLICATION_VND_DNA: &str = \"application/vnd.dna\";\n/// The `Content-Type` for Microsoft Word.\npub const APPLICATION_MSWORD: &str = \"application/msword\";\n/// The `Content-Type` for Microsoft Word (Macro-Enabled).\npub const APPLICATION_VND_MS_WORD_DOCUMENT_MACROENABLED_12: &str =\n    \"application/vnd.ms-word.document.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Word Document.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_DOCUMENT: &str =\n    \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\";\n/// The `Content-Type` for Microsoft Word Template (Macro-Enabled).\npub const APPLICATION_VND_MS_WORD_TEMPLATE_MACROENABLED_12: &str =\n    \"application/vnd.ms-word.template.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Word Template.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_WORDPROCESSINGML_TEMPLATE: &str =\n    \"application/vnd.openxmlformats-officedocument.wordprocessingml.template\";\n/// The `Content-Type` for OSGi Deployment Package.\npub const APPLICATION_VND_OSGI_DP: &str = \"application/vnd.osgi.dp\";\n/// The `Content-Type` for DPGraph.\npub const APPLICATION_VND_DPGRAPH: &str = \"application/vnd.dpgraph\";\n/// The `Content-Type` for DRA audio.\npub const AUDIO_VND_DRA: &str = \"audio/vnd.dra\";\n/// The `Content-Type` for PRS Lines Tag.\npub const TEXT_PRS_LINES_TAG: &str = \"text/prs.lines.tag\";\n/// The `Content-Type` for DSSC DER.\npub const APPLICATION_DSSC_DER: &str = \"application/dssc+der\";\n/// The `Content-Type` for DTBook XML.\npub const APPLICATION_X_DTBOOK_XML: &str = \"application/x-dtbook+xml\";\n/// The `Content-Type` for XML DTD.\npub const APPLICATION_XML_DTD: &str = \"application/xml-dtd\";\n/// The `Content-Type` for DTS audio.\npub const AUDIO_VND_DTS: &str = \"audio/vnd.dts\";\n/// The `Content-Type` for DTS HD audio.\npub const AUDIO_VND_DTS_HD: &str = \"audio/vnd.dts.hd\";\n/// The `Content-Type` for DV video.\npub const VIDEO_X_DV: &str = \"video/x-dv\";\n/// The `Content-Type` for DVB file.\npub const VIDEO_VND_DVB_FILE: &str = \"video/vnd.dvb.file\";\n/// The `Content-Type` for DVI file.\npub const APPLICATION_X_DVI: &str = \"application/x-dvi\";\n/// The `Content-Type` for DWF model.\npub const MODEL_VND_DWF: &str = \"model/vnd.dwf\";\n/// The `Content-Type` for DWG image.\npub const IMAGE_VND_DWG: &str = \"image/vnd.dwg\";\n/// The `Content-Type` for DXF image.\npub const IMAGE_VND_DXF: &str = \"image/vnd.dxf\";\n/// The `Content-Type` for Spotfire DXP.\npub const APPLICATION_VND_SPOTFIRE_DXP: &str = \"application/vnd.spotfire.dxp\";\n/// The `Content-Type` for Nuera ECELP 4800 audio.\npub const AUDIO_VND_NUERA_ECELP4800: &str = \"audio/vnd.nuera.ecelp4800\";\n/// The `Content-Type` for Nuera ECELP 7470 audio.\npub const AUDIO_VND_NUERA_ECELP7470: &str = \"audio/vnd.nuera.ecelp7470\";\n/// The `Content-Type` for Nuera ECELP 9600 audio.\npub const AUDIO_VND_NUERA_ECELP9600: &str = \"audio/vnd.nuera.ecelp9600\";\n/// The `Content-Type` for ECMAScript.\npub const APPLICATION_ECMASCRIPT: &str = \"application/ecmascript\";\n/// The `Content-Type` for Novadigm EDM.\npub const APPLICATION_VND_NOVADIGM_EDM: &str = \"application/vnd.novadigm.edm\";\n/// The `Content-Type` for Novadigm EDX.\npub const APPLICATION_VND_NOVADIGM_EDX: &str = \"application/vnd.novadigm.edx\";\n/// The `Content-Type` for Picsel.\npub const APPLICATION_VND_PICSEL: &str = \"application/vnd.picsel\";\n/// The `Content-Type` for PG OSASLI.\npub const APPLICATION_VND_PG_OSASLI: &str = \"application/vnd.pg.osasli\";\n/// The `Content-Type` for Microsoft Metafile.\npub const APPLICATION_X_MSMETAFILE: &str = \"application/x-msmetafile\";\n/// The `Content-Type` for RFC 822 message.\npub const MESSAGE_RFC822: &str = \"message/rfc822\";\n/// The `Content-Type` for EMMA XML.\npub const APPLICATION_EMMA_XML: &str = \"application/emma+xml\";\n/// The `Content-Type` for Digital Winds audio.\npub const AUDIO_VND_DIGITAL_WINDS: &str = \"audio/vnd.digital-winds\";\n/// The `Content-Type` for Microsoft Font Object.\npub const APPLICATION_VND_MS_FONTOBJECT: &str = \"application/vnd.ms-fontobject\";\n/// The `Content-Type` for EPUB.\npub const APPLICATION_EPUB_ZIP: &str = \"application/epub+zip\";\n/// The `Content-Type` for E-Szigno XML.\npub const APPLICATION_VND_ESZIGNO3_XML: &str = \"application/vnd.eszigno3+xml\";\n/// The `Content-Type` for OSGi Subsystem.\npub const APPLICATION_VND_OSGI_SUBSYSTEM: &str = \"application/vnd.osgi.subsystem\";\n/// The `Content-Type` for Epson ESF.\npub const APPLICATION_VND_EPSON_ESF: &str = \"application/vnd.epson.esf\";\n/// The `Content-Type` for Setext.\npub const TEXT_X_SETEXT: &str = \"text/x-setext\";\n/// The `Content-Type` for EVA.\npub const APPLICATION_X_EVA: &str = \"application/x-eva\";\n/// The `Content-Type` for Envoy.\npub const APPLICATION_X_ENVOY: &str = \"application/x-envoy\";\n/// The `Content-Type` for EXI.\npub const APPLICATION_EXI: &str = \"application/exi\";\n/// The `Content-Type` for Novadigm EXT.\npub const APPLICATION_VND_NOVADIGM_EXT: &str = \"application/vnd.novadigm.ext\";\n/// The `Content-Type` for Andrew Inset.\npub const APPLICATION_ANDREW_INSET: &str = \"application/andrew-inset\";\n/// The `Content-Type` for EZPix Album.\npub const APPLICATION_VND_EZPIX_ALBUM: &str = \"application/vnd.ezpix-album\";\n/// The `Content-Type` for EZPix Package.\npub const APPLICATION_VND_EZPIX_PACKAGE: &str = \"application/vnd.ezpix-package\";\n/// The `Content-Type` for Fortran source.\npub const TEXT_X_FORTRAN: &str = \"text/x-fortran\";\n/// The `Content-Type` for F4V video.\npub const VIDEO_X_F4V: &str = \"video/x-f4v\";\n/// The `Content-Type` for FastBidSheet.\npub const IMAGE_VND_FASTBIDSHEET: &str = \"image/vnd.fastbidsheet\";\n/// The `Content-Type` for Adobe FormsCentral FCDT.\npub const APPLICATION_VND_ADOBE_FORMSCENTRAL_FCDT: &str = \"application/vnd.adobe.formscentral.fcdt\";\n/// The `Content-Type` for ISAC FCS.\npub const APPLICATION_VND_ISAC_FCS: &str = \"application/vnd.isac.fcs\";\n/// The `Content-Type` for FDF.\npub const APPLICATION_VND_FDF: &str = \"application/vnd.fdf\";\n/// The `Content-Type` for deNovo FCSELAYOUT-LINK.\npub const APPLICATION_VND_DENOVO_FCSELAYOUT_LINK: &str = \"application/vnd.denovo.fcselayout-link\";\n/// The `Content-Type` for Fujitsu OasysGP.\npub const APPLICATION_VND_FUJITSU_OASYSGP: &str = \"application/vnd.fujitsu.oasysgp\";\n/// The `Content-Type` for FreeHand image.\npub const IMAGE_X_FREEHAND: &str = \"image/x-freehand\";\n/// The `Content-Type` for Xfig image.\npub const APPLICATION_X_XFIG: &str = \"application/x-xfig\";\n/// The `Content-Type` for FLAC audio.\npub const AUDIO_FLAC: &str = \"audio/flac\";\n/// The `Content-Type` for FLI video.\npub const VIDEO_X_FLI: &str = \"video/x-fli\";\n/// The `Content-Type` for Micrografx FLO.\npub const APPLICATION_VND_MICROGRAFX_FLO: &str = \"application/vnd.micrografx.flo\";\n/// The `Content-Type` for FLV video.\npub const VIDEO_X_FLV: &str = \"video/x-flv\";\n/// The `Content-Type` for KDE Kivio.\npub const APPLICATION_VND_KDE_KIVIO: &str = \"application/vnd.kde.kivio\";\n/// The `Content-Type` for FMI Flexstor.\npub const TEXT_VND_FMI_FLEXSTOR: &str = \"text/vnd.fmi.flexstor\";\n/// The `Content-Type` for FLY text.\npub const TEXT_VND_FLY: &str = \"text/vnd.fly\";\n/// The `Content-Type` for Frogans FNC.\npub const APPLICATION_VND_FROGANS_FNC: &str = \"application/vnd.frogans.fnc\";\n/// The `Content-Type` for FPX image.\npub const IMAGE_VND_FPX: &str = \"image/vnd.fpx\";\n/// The `Content-Type` for FSC WebLaunch.\npub const APPLICATION_VND_FSC_WEBLAUNCH: &str = \"application/vnd.fsc.weblaunch\";\n/// The `Content-Type` for FST image.\npub const IMAGE_VND_FST: &str = \"image/vnd.fst\";\n/// The `Content-Type` for FluxTime Clip.\npub const APPLICATION_VND_FLUXTIME_CLIP: &str = \"application/vnd.fluxtime.clip\";\n/// The `Content-Type` for Anser-Web Funds Transfer Initiation.\npub const APPLICATION_VND_ANSER_WEB_FUNDS_TRANSFER_INITIATION: &str =\n    \"application/vnd.anser-web-funds-transfer-initiation\";\n/// The `Content-Type` for FVT video.\npub const VIDEO_VND_FVT: &str = \"video/vnd.fvt\";\n/// The `Content-Type` for Adobe FXP.\npub const APPLICATION_VND_ADOBE_FXP: &str = \"application/vnd.adobe.fxp\";\n/// The `Content-Type` for Fuzzysheet.\npub const APPLICATION_VND_FUZZYSHEET: &str = \"application/vnd.fuzzysheet\";\n/// The `Content-Type` for GeoPlan.\npub const APPLICATION_VND_GEOPLAN: &str = \"application/vnd.geoplan\";\n/// The `Content-Type` for G3 fax image.\npub const IMAGE_G3FAX: &str = \"image/g3fax\";\n/// The `Content-Type` for GeoSpace.\npub const APPLICATION_VND_GEOSPACE: &str = \"application/vnd.geospace\";\n/// The `Content-Type` for Groove Account.\npub const APPLICATION_VND_GROOVE_ACCOUNT: &str = \"application/vnd.groove-account\";\n/// The `Content-Type` for TADS game.\npub const APPLICATION_X_TADS: &str = \"application/x-tads\";\n/// The `Content-Type` for RPKI Ghostbusters.\npub const APPLICATION_RPKI_GHOSTBUSTERS: &str = \"application/rpki-ghostbusters\";\n/// The `Content-Type` for GCA compressed archive.\npub const APPLICATION_X_GCA_COMPRESSED: &str = \"application/x-gca-compressed\";\n/// The `Content-Type` for GDL model.\npub const MODEL_VND_GDL: &str = \"model/vnd.gdl\";\n/// The `Content-Type` for DynaGeo.\npub const APPLICATION_VND_DYNAGEO: &str = \"application/vnd.dynageo\";\n/// The `Content-Type` for Geometry Explorer.\npub const APPLICATION_VND_GEOMETRY_EXPLORER: &str = \"application/vnd.geometry-explorer\";\n/// The `Content-Type` for GeoGebra File.\npub const APPLICATION_VND_GEOGEBRA_FILE: &str = \"application/vnd.geogebra.file\";\n/// The `Content-Type` for GeoGebra Tool.\npub const APPLICATION_VND_GEOGEBRA_TOOL: &str = \"application/vnd.geogebra.tool\";\n/// The `Content-Type` for Groove Help.\npub const APPLICATION_VND_GROOVE_HELP: &str = \"application/vnd.groove-help\";\n/// The `Content-Type` for GIF image.\npub const IMAGE_GIF: &str = \"image/gif\";\n/// The `Content-Type` for Groove Identity Message.\npub const APPLICATION_VND_GROOVE_IDENTITY_MESSAGE: &str = \"application/vnd.groove-identity-message\";\n/// The `Content-Type` for GML XML.\npub const APPLICATION_GML_XML: &str = \"application/gml+xml\";\n/// The `Content-Type` for GMX.\npub const APPLICATION_VND_GMX: &str = \"application/vnd.gmx\";\n/// The `Content-Type` for Gnumeric.\npub const APPLICATION_X_GNUMERIC: &str = \"application/x-gnumeric\";\n/// The `Content-Type` for FlographIt.\npub const APPLICATION_VND_FLOGRAPHIT: &str = \"application/vnd.flographit\";\n/// The `Content-Type` for GPX XML.\npub const APPLICATION_GPX_XML: &str = \"application/gpx+xml\";\n/// The `Content-Type` for Grafeq.\npub const APPLICATION_VND_GRAFEQ: &str = \"application/vnd.grafeq\";\n/// The `Content-Type` for SRGS.\npub const APPLICATION_SRGS: &str = \"application/srgs\";\n/// The `Content-Type` for Gramps XML.\npub const APPLICATION_X_GRAMPS_XML: &str = \"application/x-gramps-xml\";\n/// The `Content-Type` for Groove Injector.\npub const APPLICATION_VND_GROOVE_INJECTOR: &str = \"application/vnd.groove-injector\";\n/// The `Content-Type` for SRGS XML.\npub const APPLICATION_SRGS_XML: &str = \"application/srgs+xml\";\n/// The `Content-Type` for Ghostscript font.\npub const APPLICATION_X_FONT_GHOSTSCRIPT: &str = \"application/x-font-ghostscript\";\n/// The `Content-Type` for GTAR archive.\npub const APPLICATION_X_GTAR: &str = \"application/x-gtar\";\n/// The `Content-Type` for Groove Tool Message.\npub const APPLICATION_VND_GROOVE_TOOL_MESSAGE: &str = \"application/vnd.groove-tool-message\";\n/// The `Content-Type` for GTW model.\npub const MODEL_VND_GTW: &str = \"model/vnd.gtw\";\n/// The `Content-Type` for Graphviz.\npub const TEXT_VND_GRAPHVIZ: &str = \"text/vnd.graphviz\";\n/// The `Content-Type` for GXF.\npub const APPLICATION_GXF: &str = \"application/gxf\";\n/// The `Content-Type` for GeoNext.\npub const APPLICATION_VND_GEONEXT: &str = \"application/vnd.geonext\";\n/// The `Content-Type` for Gzip archive.\npub const APPLICATION_X_GZIP: &str = \"application/x-gzip\";\n/// The `Content-Type` for H.261 video.\npub const VIDEO_H261: &str = \"video/h261\";\n/// The `Content-Type` for H.263 video.\npub const VIDEO_H263: &str = \"video/h263\";\n/// The `Content-Type` for H.264 video.\npub const VIDEO_H264: &str = \"video/h264\";\n/// The `Content-Type` for HAL XML.\npub const APPLICATION_VND_HAL_XML: &str = \"application/vnd.hal+xml\";\n/// The `Content-Type` for HBCI.\npub const APPLICATION_VND_HBCI: &str = \"application/vnd.hbci\";\n/// The `Content-Type` for HDF.\npub const APPLICATION_X_HDF: &str = \"application/x-hdf\";\n/// The `Content-Type` for WinHelp.\npub const APPLICATION_WINHLP: &str = \"application/winhlp\";\n/// The `Content-Type` for HP-GL.\npub const APPLICATION_VND_HP_HPGL: &str = \"application/vnd.hp-hpgl\";\n/// The `Content-Type` for HP-HPID.\npub const APPLICATION_VND_HP_HPID: &str = \"application/vnd.hp-hpid\";\n/// The `Content-Type` for HP-HPS.\npub const APPLICATION_VND_HP_HPS: &str = \"application/vnd.hp-hps\";\n/// The `Content-Type` for Mac BinHex40.\npub const APPLICATION_MAC_BINHEX40: &str = \"application/mac-binhex40\";\n/// The `Content-Type` for HTC component.\npub const TEXT_X_COMPONENT: &str = \"text/x-component\";\n/// The `Content-Type` for Kenamea App.\npub const APPLICATION_VND_KENAMEAAPP: &str = \"application/vnd.kenameaapp\";\n/// The `Content-Type` for Yamaha HV Dictionary.\npub const APPLICATION_VND_YAMAHA_HV_DIC: &str = \"application/vnd.yamaha.hv-dic\";\n/// The `Content-Type` for Yamaha HV Voice.\npub const APPLICATION_VND_YAMAHA_HV_VOICE: &str = \"application/vnd.yamaha.hv-voice\";\n/// The `Content-Type` for Yamaha HV Script.\npub const APPLICATION_VND_YAMAHA_HV_SCRIPT: &str = \"application/vnd.yamaha.hv-script\";\n/// The `Content-Type` for Intergeo.\npub const APPLICATION_VND_INTERGEO: &str = \"application/vnd.intergeo\";\n/// The `Content-Type` for ICC Profile.\npub const APPLICATION_VND_ICCPROFILE: &str = \"application/vnd.iccprofile\";\n/// The `Content-Type` for CoolTalk.\npub const X_CONFERENCE_X_COOLTALK: &str = \"x-conference/x-cooltalk\";\n/// The `Content-Type` for icon.\npub const IMAGE_X_ICON: &str = \"image/x-icon\";\n/// The `Content-Type` for iCalendar.\npub const TEXT_CALENDAR: &str = \"text/calendar\";\n/// The `Content-Type` for IEF image.\npub const IMAGE_IEF: &str = \"image/ief\";\n/// The `Content-Type` for Shana Informed Formdata.\npub const APPLICATION_VND_SHANA_INFORMED_FORMDATA: &str = \"application/vnd.shana.informed.formdata\";\n/// The `Content-Type` for IGES model.\npub const MODEL_IGES: &str = \"model/iges\";\n/// The `Content-Type` for IGLoader.\npub const APPLICATION_VND_IGLOADER: &str = \"application/vnd.igloader\";\n/// The `Content-Type` for Insors IGM.\npub const APPLICATION_VND_INSORS_IGM: &str = \"application/vnd.insors.igm\";\n/// The `Content-Type` for Micrografx IGX.\npub const APPLICATION_VND_MICROGRAFX_IGX: &str = \"application/vnd.micrografx.igx\";\n/// The `Content-Type` for Shana Informed Interchange.\npub const APPLICATION_VND_SHANA_INFORMED_INTERCHANGE: &str =\n    \"application/vnd.shana.informed.interchange\";\n/// The `Content-Type` for Accpac Simply IMP.\npub const APPLICATION_VND_ACCPAC_SIMPLY_IMP: &str = \"application/vnd.accpac.simply.imp\";\n/// The `Content-Type` for Microsoft IMS.\npub const APPLICATION_VND_MS_IMS: &str = \"application/vnd.ms-ims\";\n/// The `Content-Type` for InkML.\npub const APPLICATION_INKML_XML: &str = \"application/inkml+xml\";\n/// The `Content-Type` for Install Instructions.\npub const APPLICATION_X_INSTALL_INSTRUCTIONS: &str = \"application/x-install-instructions\";\n/// The `Content-Type` for Astraea Software Iota.\npub const APPLICATION_VND_ASTRAEA_SOFTWARE_IOTA: &str = \"application/vnd.astraea-software.iota\";\n/// The `Content-Type` for IPFIX.\npub const APPLICATION_IPFIX: &str = \"application/ipfix\";\n/// The `Content-Type` for Shana Informed Package.\npub const APPLICATION_VND_SHANA_INFORMED_PACKAGE: &str = \"application/vnd.shana.informed.package\";\n/// The `Content-Type` for IBM Rights Management.\npub const APPLICATION_VND_IBM_RIGHTS_MANAGEMENT: &str = \"application/vnd.ibm.rights-management\";\n/// The `Content-Type` for iRepository Package XML.\npub const APPLICATION_VND_IREPOSITORY_PACKAGE_XML: &str = \"application/vnd.irepository.package+xml\";\n/// The `Content-Type` for ISO 9660 Image.\npub const APPLICATION_X_ISO9660_IMAGE: &str = \"application/x-iso9660-image\";\n/// The `Content-Type` for Shana Informed Formtemplate.\npub const APPLICATION_VND_SHANA_INFORMED_FORMTEMPLATE: &str =\n    \"application/vnd.shana.informed.formtemplate\";\n/// The `Content-Type` for Immervision IVP.\npub const APPLICATION_VND_IMMERVISION_IVP: &str = \"application/vnd.immervision-ivp\";\n/// The `Content-Type` for Immervision IVU.\npub const APPLICATION_VND_IMMERVISION_IVU: &str = \"application/vnd.immervision-ivu\";\n/// The `Content-Type` for J2ME App Descriptor.\npub const TEXT_VND_SUN_J2ME_APP_DESCRIPTOR: &str = \"text/vnd.sun.j2me.app-descriptor\";\n/// The `Content-Type` for JAM.\npub const APPLICATION_VND_JAM: &str = \"application/vnd.jam\";\n/// The `Content-Type` for Java Archive.\npub const APPLICATION_JAVA_ARCHIVE: &str = \"application/java-archive\";\n/// The `Content-Type` for Java source.\npub const TEXT_X_JAVA_SOURCE: &str = \"text/x-java-source\";\n/// The `Content-Type` for JISP.\npub const APPLICATION_VND_JISP: &str = \"application/vnd.jisp\";\n/// The `Content-Type` for HP JLYT.\npub const APPLICATION_VND_HP_JLYT: &str = \"application/vnd.hp-jlyt\";\n/// The `Content-Type` for Java JNLP.\npub const APPLICATION_X_JAVA_JNLP_FILE: &str = \"application/x-java-jnlp-file\";\n/// The `Content-Type` for Joost Joda Archive.\npub const APPLICATION_VND_JOOST_JODA_ARCHIVE: &str = \"application/vnd.joost.joda-archive\";\n/// The `Content-Type` for JPEG image.\npub const IMAGE_JPEG: &str = \"image/jpeg\";\n/// The `Content-Type` for JPM video.\npub const VIDEO_JPM: &str = \"video/jpm\";\n/// The `Content-Type` for JPEG video.\npub const VIDEO_JPEG: &str = \"video/jpeg\";\n/// The `Content-Type` for JavaScript.\npub const APPLICATION_JAVASCRIPT: &str = \"application/javascript\";\n/// The `Content-Type` for JSON.\npub const APPLICATION_JSON: &str = \"application/json\";\n/// The `Content-Type` for JSONML.\npub const APPLICATION_JSONML_JSON: &str = \"application/jsonml+json\";\n/// The `Content-Type` for MIDI audio.\npub const AUDIO_MIDI: &str = \"audio/midi\";\n/// The `Content-Type` for KDE Karbon.\npub const APPLICATION_VND_KDE_KARBON: &str = \"application/vnd.kde.karbon\";\n/// The `Content-Type` for KDE KFormula.\npub const APPLICATION_VND_KDE_KFORMULA: &str = \"application/vnd.kde.kformula\";\n/// The `Content-Type` for Kidspiration.\npub const APPLICATION_VND_KIDSPIRATION: &str = \"application/vnd.kidspiration\";\n/// The `Content-Type` for Google Earth KML.\npub const APPLICATION_VND_GOOGLE_EARTH_KML_XML: &str = \"application/vnd.google-earth.kml+xml\";\n/// The `Content-Type` for Google Earth KMZ.\npub const APPLICATION_VND_GOOGLE_EARTH_KMZ: &str = \"application/vnd.google-earth.kmz\";\n/// The `Content-Type` for Kinar.\npub const APPLICATION_VND_KINAR: &str = \"application/vnd.kinar\";\n/// The `Content-Type` for KDE Kontour.\npub const APPLICATION_VND_KDE_KONTOUR: &str = \"application/vnd.kde.kontour\";\n/// The `Content-Type` for KDE KPresenter.\npub const APPLICATION_VND_KDE_KPRESENTER: &str = \"application/vnd.kde.kpresenter\";\n/// The `Content-Type` for DS-Keypoint.\npub const APPLICATION_VND_DS_KEYPOINT: &str = \"application/vnd.ds-keypoint\";\n/// The `Content-Type` for KDE KSpread.\npub const APPLICATION_VND_KDE_KSPREAD: &str = \"application/vnd.kde.kspread\";\n/// The `Content-Type` for Kahootz.\npub const APPLICATION_VND_KAHOOTZ: &str = \"application/vnd.kahootz\";\n/// The `Content-Type` for KTX image.\npub const IMAGE_KTX: &str = \"image/ktx\";\n/// The `Content-Type` for KDE KWord.\npub const APPLICATION_VND_KDE_KWORD: &str = \"application/vnd.kde.kword\";\n/// The `Content-Type` for LAS LAS XML.\npub const APPLICATION_VND_LAS_LAS_XML: &str = \"application/vnd.las.las+xml\";\n/// The `Content-Type` for LaTeX.\npub const APPLICATION_X_LATEX: &str = \"application/x-latex\";\n/// The `Content-Type` for LlamaGraphics Life-Balance Desktop.\npub const APPLICATION_VND_LLAMAGRAPHICS_LIFE_BALANCE_DESKTOP: &str =\n    \"application/vnd.llamagraphics.life-balance.desktop\";\n/// The `Content-Type` for LlamaGraphics Life-Balance Exchange XML.\npub const APPLICATION_VND_LLAMAGRAPHICS_LIFE_BALANCE_EXCHANGE_XML: &str =\n    \"application/vnd.llamagraphics.life-balance.exchange+xml\";\n/// The `Content-Type` for HHE Lesson Player.\npub const APPLICATION_VND_HHE_LESSON_PLAYER: &str = \"application/vnd.hhe.lesson-player\";\n/// The `Content-Type` for LZH compressed archive.\npub const APPLICATION_X_LZH_COMPRESSED: &str = \"application/x-lzh-compressed\";\n/// The `Content-Type` for Route 66 Link66 XML.\npub const APPLICATION_VND_ROUTE66_LINK66_XML: &str = \"application/vnd.route66.link66+xml\";\n/// The `Content-Type` for Microsoft Shortcut.\npub const APPLICATION_X_MS_SHORTCUT: &str = \"application/x-ms-shortcut\";\n/// The `Content-Type` for Lost XML.\npub const APPLICATION_LOST_XML: &str = \"application/lost+xml\";\n/// The `Content-Type` for Microsoft LRM.\npub const APPLICATION_VND_MS_LRM: &str = \"application/vnd.ms-lrm\";\n/// The `Content-Type` for Frogans LTF.\npub const APPLICATION_VND_FROGANS_LTF: &str = \"application/vnd.frogans.ltf\";\n/// The `Content-Type` for Lucent Voice.\npub const AUDIO_VND_LUCENT_VOICE: &str = \"audio/vnd.lucent.voice\";\n/// The `Content-Type` for Lotus WordPro.\npub const APPLICATION_VND_LOTUS_WORDPRO: &str = \"application/vnd.lotus-wordpro\";\n/// The `Content-Type` for Microsoft MediaView.\npub const APPLICATION_X_MSMEDIAVIEW: &str = \"application/x-msmediaview\";\n/// The `Content-Type` for MPEG video.\npub const VIDEO_MPEG: &str = \"video/mpeg\";\n/// The `Content-Type` for MP21.\npub const APPLICATION_MP21: &str = \"application/mp21\";\n/// The `Content-Type` for MPEG audio.\npub const AUDIO_MPEG: &str = \"audio/mpeg\";\n/// The `Content-Type` for M3U playlist.\npub const AUDIO_X_MPEGURL: &str = \"audio/x-mpegurl\";\n/// The `Content-Type` for Apple MPEG URL.\npub const APPLICATION_VND_APPLE_MPEGURL: &str = \"application/vnd.apple.mpegurl\";\n/// The `Content-Type` for MP4 audio.\npub const AUDIO_MP4: &str = \"audio/mp4\";\n/// The `Content-Type` for MPEG URL video.\npub const VIDEO_VND_MPEGURL: &str = \"video/vnd.mpegurl\";\n/// The `Content-Type` for MP4 video.\npub const VIDEO_MP4: &str = \"video/mp4\";\n/// The `Content-Type` for Mathematica.\npub const APPLICATION_MATHEMATICA: &str = \"application/mathematica\";\n/// The `Content-Type` for MacPaint image.\npub const IMAGE_X_MACPAINT: &str = \"image/x-macpaint\";\n/// The `Content-Type` for MADS XML.\npub const APPLICATION_MADS_XML: &str = \"application/mads+xml\";\n/// The `Content-Type` for EcoWin Chart.\npub const APPLICATION_VND_ECOWIN_CHART: &str = \"application/vnd.ecowin.chart\";\n/// The `Content-Type` for Troff.\npub const TEXT_TROFF: &str = \"text/troff\";\n/// The `Content-Type` for MathML XML.\npub const APPLICATION_MATHML_XML: &str = \"application/mathml+xml\";\n/// The `Content-Type` for Mobius MBK.\npub const APPLICATION_VND_MOBIUS_MBK: &str = \"application/vnd.mobius.mbk\";\n/// The `Content-Type` for Mbox.\npub const APPLICATION_MBOX: &str = \"application/mbox\";\n/// The `Content-Type` for MedCalcData.\npub const APPLICATION_VND_MEDCALCDATA: &str = \"application/vnd.medcalcdata\";\n/// The `Content-Type` for MCD.\npub const APPLICATION_VND_MCD: &str = \"application/vnd.mcd\";\n/// The `Content-Type` for cURL MCURL.\npub const TEXT_VND_CURL_MCURL: &str = \"text/vnd.curl.mcurl\";\n/// The `Content-Type` for Microsoft Access.\npub const APPLICATION_X_MSACCESS: &str = \"application/x-msaccess\";\n/// The `Content-Type` for Microsoft MODI.\npub const IMAGE_VND_MS_MODI: &str = \"image/vnd.ms-modi\";\n/// The `Content-Type` for Mesh model.\npub const MODEL_MESH: &str = \"model/mesh\";\n/// The `Content-Type` for Metalink4 XML.\npub const APPLICATION_METALINK4_XML: &str = \"application/metalink4+xml\";\n/// The `Content-Type` for Metalink XML.\npub const APPLICATION_METALINK_XML: &str = \"application/metalink+xml\";\n/// The `Content-Type` for METS XML.\npub const APPLICATION_METS_XML: &str = \"application/mets+xml\";\n/// The `Content-Type` for MFMP.\npub const APPLICATION_VND_MFMP: &str = \"application/vnd.mfmp\";\n/// The `Content-Type` for RPKI Manifest.\npub const APPLICATION_RPKI_MANIFEST: &str = \"application/rpki-manifest\";\n/// The `Content-Type` for OSGeo MapGuide Package.\npub const APPLICATION_VND_OSGEO_MAPGUIDE_PACKAGE: &str = \"application/vnd.osgeo.mapguide.package\";\n/// The `Content-Type` for Proteus Magazine.\npub const APPLICATION_VND_PROTEUS_MAGAZINE: &str = \"application/vnd.proteus.magazine\";\n/// The `Content-Type` for MIE.\npub const APPLICATION_X_MIE: &str = \"application/x-mie\";\n/// The `Content-Type` for MIF.\npub const APPLICATION_X_MIF: &str = \"application/x-mif\";\n/// The `Content-Type` for MJ2 video.\npub const VIDEO_MJ2: &str = \"video/mj2\";\n/// The `Content-Type` for Matroska video.\npub const VIDEO_X_MATROSKA: &str = \"video/x-matroska\";\n/// The `Content-Type` for Matroska audio.\npub const AUDIO_X_MATROSKA: &str = \"audio/x-matroska\";\n/// The `Content-Type` for Dolby MLP.\npub const APPLICATION_VND_DOLBY_MLP: &str = \"application/vnd.dolby.mlp\";\n/// The `Content-Type` for Chipnuts Karaoke MMD.\npub const APPLICATION_VND_CHIPNUTS_KARAOKE_MMD: &str = \"application/vnd.chipnuts.karaoke-mmd\";\n/// The `Content-Type` for SMAF.\npub const APPLICATION_VND_SMAF: &str = \"application/vnd.smaf\";\n/// The `Content-Type` for Fujixerox EDMICS MMR.\npub const IMAGE_VND_FUJIXEROX_EDMICS_MMR: &str = \"image/vnd.fujixerox.edmics-mmr\";\n/// The `Content-Type` for MNG video.\npub const VIDEO_X_MNG: &str = \"video/x-mng\";\n/// The `Content-Type` for Microsoft Money.\npub const APPLICATION_X_MSMONEY: &str = \"application/x-msmoney\";\n/// The `Content-Type` for Mobipocket eBook.\npub const APPLICATION_X_MOBIPOCKET_EBOOK: &str = \"application/x-mobipocket-ebook\";\n/// The `Content-Type` for MODS XML.\npub const APPLICATION_MODS_XML: &str = \"application/mods+xml\";\n/// The `Content-Type` for QuickTime video.\npub const VIDEO_QUICKTIME: &str = \"video/quicktime\";\n/// The `Content-Type` for SGI movie.\npub const VIDEO_X_SGI_MOVIE: &str = \"video/x-sgi-movie\";\n/// The `Content-Type` for MP4.\npub const APPLICATION_MP4: &str = \"application/mp4\";\n/// The `Content-Type` for Mophun Certificate.\npub const APPLICATION_VND_MOPHUN_CERTIFICATE: &str = \"application/vnd.mophun.certificate\";\n/// The `Content-Type` for Apple Installer XML.\npub const APPLICATION_VND_APPLE_INSTALLER_XML: &str = \"application/vnd.apple.installer+xml\";\n/// The `Content-Type` for Blueice Multipass.\npub const APPLICATION_VND_BLUEICE_MULTIPASS: &str = \"application/vnd.blueice.multipass\";\n/// The `Content-Type` for Mophun Application.\npub const APPLICATION_VND_MOPHUN_APPLICATION: &str = \"application/vnd.mophun.application\";\n/// The `Content-Type` for Microsoft Project.\npub const APPLICATION_VND_MS_PROJECT: &str = \"application/vnd.ms-project\";\n/// The `Content-Type` for MPEG-2 video.\npub const VIDEO_MPEG2: &str = \"video/mpeg2\";\n/// The `Content-Type` for IBM MiniPay.\npub const APPLICATION_VND_IBM_MINIPAY: &str = \"application/vnd.ibm.minipay\";\n/// The `Content-Type` for Mobius MQY.\npub const APPLICATION_VND_MOBIUS_MQY: &str = \"application/vnd.mobius.mqy\";\n/// The `Content-Type` for MARC.\npub const APPLICATION_MARC: &str = \"application/marc\";\n/// The `Content-Type` for MARCXML.\npub const APPLICATION_MARCXML_XML: &str = \"application/marcxml+xml\";\n/// The `Content-Type` for Media Server Control XML.\npub const APPLICATION_MEDIASERVERCONTROL_XML: &str = \"application/mediaservercontrol+xml\";\n/// The `Content-Type` for FDSN mseed.\npub const APPLICATION_VND_FDSN_MSEED: &str = \"application/vnd.fdsn.mseed\";\n/// The `Content-Type` for MSEQ.\npub const APPLICATION_VND_MSEQ: &str = \"application/vnd.mseq\";\n/// The `Content-Type` for Epson MSF.\npub const APPLICATION_VND_EPSON_MSF: &str = \"application/vnd.epson.msf\";\n/// The `Content-Type` for Mobius MSL.\npub const APPLICATION_VND_MOBIUS_MSL: &str = \"application/vnd.mobius.msl\";\n/// The `Content-Type` for Muvee Style.\npub const APPLICATION_VND_MUVEE_STYLE: &str = \"application/vnd.muvee.style\";\n/// The `Content-Type` for MTS model.\npub const MODEL_VND_MTS: &str = \"model/vnd.mts\";\n/// The `Content-Type` for Musician.\npub const APPLICATION_VND_MUSICIAN: &str = \"application/vnd.musician\";\n/// The `Content-Type` for Recordare MusicXML.\npub const APPLICATION_VND_RECORDARE_MUSICXML_XML: &str = \"application/vnd.recordare.musicxml+xml\";\n/// The `Content-Type` for MFER.\npub const APPLICATION_VND_MFER: &str = \"application/vnd.mfer\";\n/// The `Content-Type` for MXF.\npub const APPLICATION_MXF: &str = \"application/mxf\";\n/// The `Content-Type` for Recordare MusicXML.\npub const APPLICATION_VND_RECORDARE_MUSICXML: &str = \"application/vnd.recordare.musicxml\";\n/// The `Content-Type` for XV XML.\npub const APPLICATION_XV_XML: &str = \"application/xv+xml\";\n/// The `Content-Type` for Triscape MXS.\npub const APPLICATION_VND_TRISCAPE_MXS: &str = \"application/vnd.triscape.mxs\";\n/// The `Content-Type` for Nokia N-Gage Symbian Install.\npub const APPLICATION_VND_NOKIA_N_GAGE_SYMBIAN_INSTALL: &str =\n    \"application/vnd.nokia.n-gage.symbian.install\";\n/// The `Content-Type` for N3.\npub const TEXT_N3: &str = \"text/n3\";\n/// The `Content-Type` for Wolfram Player.\npub const APPLICATION_VND_WOLFRAM_PLAYER: &str = \"application/vnd.wolfram.player\";\n/// The `Content-Type` for NetCDF.\npub const APPLICATION_X_NETCDF: &str = \"application/x-netcdf\";\n/// The `Content-Type` for DTBNCX XML.\npub const APPLICATION_X_DTBNCX_XML: &str = \"application/x-dtbncx+xml\";\n/// The `Content-Type` for NFO.\npub const TEXT_X_NFO: &str = \"text/x-nfo\";\n/// The `Content-Type` for Nokia N-Gage Data.\npub const APPLICATION_VND_NOKIA_N_GAGE_DATA: &str = \"application/vnd.nokia.n-gage.data\";\n/// The `Content-Type` for NITF.\npub const APPLICATION_VND_NITF: &str = \"application/vnd.nitf\";\n/// The `Content-Type` for NeuroLanguage NLU.\npub const APPLICATION_VND_NEUROLANGUAGE_NLU: &str = \"application/vnd.neurolanguage.nlu\";\n/// The `Content-Type` for Enliven.\npub const APPLICATION_VND_ENLIVEN: &str = \"application/vnd.enliven\";\n/// The `Content-Type` for NobleNet Directory.\npub const APPLICATION_VND_NOBLENET_DIRECTORY: &str = \"application/vnd.noblenet-directory\";\n/// The `Content-Type` for NobleNet Sealer.\npub const APPLICATION_VND_NOBLENET_SEALER: &str = \"application/vnd.noblenet-sealer\";\n/// The `Content-Type` for NobleNet Web.\npub const APPLICATION_VND_NOBLENET_WEB: &str = \"application/vnd.noblenet-web\";\n/// The `Content-Type` for Net-FPX image.\npub const IMAGE_VND_NET_FPX: &str = \"image/vnd.net-fpx\";\n/// The `Content-Type` for Conference.\npub const APPLICATION_X_CONFERENCE: &str = \"application/x-conference\";\n/// The `Content-Type` for Lotus Notes.\npub const APPLICATION_VND_LOTUS_NOTES: &str = \"application/vnd.lotus-notes\";\n/// The `Content-Type` for NZB.\npub const APPLICATION_X_NZB: &str = \"application/x-nzb\";\n/// The `Content-Type` for Fujitsu Oasys 2.\npub const APPLICATION_VND_FUJITSU_OASYS2: &str = \"application/vnd.fujitsu.oasys2\";\n/// The `Content-Type` for Fujitsu Oasys 3.\npub const APPLICATION_VND_FUJITSU_OASYS3: &str = \"application/vnd.fujitsu.oasys3\";\n/// The `Content-Type` for Fujitsu Oasys.\npub const APPLICATION_VND_FUJITSU_OASYS: &str = \"application/vnd.fujitsu.oasys\";\n/// The `Content-Type` for Microsoft Binder.\npub const APPLICATION_X_MSBINDER: &str = \"application/x-msbinder\";\n/// The `Content-Type` for TGIF.\npub const APPLICATION_X_TGIF: &str = \"application/x-tgif\";\n/// The `Content-Type` for ODA.\npub const APPLICATION_ODA: &str = \"application/oda\";\n/// The `Content-Type` for OpenDocument Database.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_DATABASE: &str =\n    \"application/vnd.oasis.opendocument.database\";\n/// The `Content-Type` for OpenDocument Chart.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_CHART: &str =\n    \"application/vnd.oasis.opendocument.chart\";\n/// The `Content-Type` for OpenDocument Formula.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA: &str =\n    \"application/vnd.oasis.opendocument.formula\";\n/// The `Content-Type` for OpenDocument Formula Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_FORMULA_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.formula-template\";\n/// The `Content-Type` for OpenDocument Graphics.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS: &str =\n    \"application/vnd.oasis.opendocument.graphics\";\n/// The `Content-Type` for OpenDocument Image.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_IMAGE: &str =\n    \"application/vnd.oasis.opendocument.image\";\n/// The `Content-Type` for OpenDocument Text Master.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_MASTER: &str =\n    \"application/vnd.oasis.opendocument.text-master\";\n/// The `Content-Type` for OpenDocument Presentation.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION: &str =\n    \"application/vnd.oasis.opendocument.presentation\";\n/// The `Content-Type` for OpenDocument Spreadsheet.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET: &str =\n    \"application/vnd.oasis.opendocument.spreadsheet\";\n/// The `Content-Type` for OpenDocument Text.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT: &str = \"application/vnd.oasis.opendocument.text\";\n/// The `Content-Type` for Ogg audio.\npub const AUDIO_OGG: &str = \"audio/ogg\";\n/// The `Content-Type` for Ogg video.\npub const VIDEO_OGG: &str = \"video/ogg\";\n/// The `Content-Type` for Ogg.\npub const APPLICATION_OGG: &str = \"application/ogg\";\n/// The `Content-Type` for OMDOC XML.\npub const APPLICATION_OMDOC_XML: &str = \"application/omdoc+xml\";\n/// The `Content-Type` for OneNote.\npub const APPLICATION_ONENOTE: &str = \"application/onenote\";\n/// The `Content-Type` for OEBPS Package XML.\npub const APPLICATION_OEBPS_PACKAGE_XML: &str = \"application/oebps-package+xml\";\n/// The `Content-Type` for OPML.\npub const TEXT_X_OPML: &str = \"text/x-opml\";\n/// The `Content-Type` for Palm.\npub const APPLICATION_VND_PALM: &str = \"application/vnd.palm\";\n/// The `Content-Type` for Lotus Organizer.\npub const APPLICATION_VND_LOTUS_ORGANIZER: &str = \"application/vnd.lotus-organizer\";\n/// The `Content-Type` for Yamaha OpenScoreFormat.\npub const APPLICATION_VND_YAMAHA_OPENSCOREFORMAT: &str = \"application/vnd.yamaha.openscoreformat\";\n/// The `Content-Type` for Yamaha OpenScoreFormat OSFPVG XML.\npub const APPLICATION_VND_YAMAHA_OPENSCOREFORMAT_OSFPVG_XML: &str =\n    \"application/vnd.yamaha.openscoreformat.osfpvg+xml\";\n/// The `Content-Type` for OpenDocument Chart Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_CHART_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.chart-template\";\n/// The `Content-Type` for OpenType Font.\npub const FONT_OTF: &str = \"font/otf\";\n/// The `Content-Type` for OpenDocument Graphics Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_GRAPHICS_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.graphics-template\";\n/// The `Content-Type` for OpenDocument Text Web.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_WEB: &str =\n    \"application/vnd.oasis.opendocument.text-web\";\n/// The `Content-Type` for OpenDocument Image Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_IMAGE_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.image-template\";\n/// The `Content-Type` for OpenDocument Presentation Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_PRESENTATION_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.presentation-template\";\n/// The `Content-Type` for OpenDocument Spreadsheet Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_SPREADSHEET_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.spreadsheet-template\";\n/// The `Content-Type` for OpenDocument Text Template.\npub const APPLICATION_VND_OASIS_OPENDOCUMENT_TEXT_TEMPLATE: &str =\n    \"application/vnd.oasis.opendocument.text-template\";\n/// The `Content-Type` for OpenXPS.\npub const APPLICATION_OXPS: &str = \"application/oxps\";\n/// The `Content-Type` for OpenOffice Extension.\npub const APPLICATION_VND_OPENOFFICEORG_EXTENSION: &str = \"application/vnd.openofficeorg.extension\";\n/// The `Content-Type` for Pascal source.\npub const TEXT_X_PASCAL: &str = \"text/x-pascal\";\n/// The `Content-Type` for PKCS #10.\npub const APPLICATION_PKCS10: &str = \"application/pkcs10\";\n/// The `Content-Type` for PKCS #12.\npub const APPLICATION_X_PKCS12: &str = \"application/x-pkcs12\";\n/// The `Content-Type` for PKCS #7 Certificates.\npub const APPLICATION_X_PKCS7_CERTIFICATES: &str = \"application/x-pkcs7-certificates\";\n/// The `Content-Type` for PKCS #7 MIME.\npub const APPLICATION_PKCS7_MIME: &str = \"application/pkcs7-mime\";\n/// The `Content-Type` for PKCS #7 Certificate Request/Response.\npub const APPLICATION_X_PKCS7_CERTREQRESP: &str = \"application/x-pkcs7-certreqresp\";\n/// The `Content-Type` for PKCS #7 Signature.\npub const APPLICATION_PKCS7_SIGNATURE: &str = \"application/pkcs7-signature\";\n/// The `Content-Type` for PKCS #8.\npub const APPLICATION_PKCS8: &str = \"application/pkcs8\";\n/// The `Content-Type` for Pawaafile.\npub const APPLICATION_VND_PAWAAFILE: &str = \"application/vnd.pawaafile\";\n/// The `Content-Type` for PowerBuilder 6.\npub const APPLICATION_VND_POWERBUILDER6: &str = \"application/vnd.powerbuilder6\";\n/// The `Content-Type` for Portable Bitmap image.\npub const IMAGE_X_PORTABLE_BITMAP: &str = \"image/x-portable-bitmap\";\n/// The `Content-Type` for PCF font.\npub const APPLICATION_X_FONT_PCF: &str = \"application/x-font-pcf\";\n/// The `Content-Type` for HP PCL.\npub const APPLICATION_VND_HP_PCL: &str = \"application/vnd.hp-pcl\";\n/// The `Content-Type` for HP PCLXL.\npub const APPLICATION_VND_HP_PCLXL: &str = \"application/vnd.hp-pclxl\";\n/// The `Content-Type` for PICT image.\npub const IMAGE_PICT: &str = \"image/pict\";\n/// The `Content-Type` for cURL PCURL.\npub const APPLICATION_VND_CURL_PCURL: &str = \"application/vnd.curl.pcurl\";\n/// The `Content-Type` for PCX image.\npub const IMAGE_X_PCX: &str = \"image/x-pcx\";\n/// The `Content-Type` for PDF.\npub const APPLICATION_PDF: &str = \"application/pdf\";\n/// The `Content-Type` for Font Tdpfr.\npub const APPLICATION_FONT_TDPFR: &str = \"application/font-tdpfr\";\n/// The `Content-Type` for Portable Graymap image.\npub const IMAGE_X_PORTABLE_GRAYMAP: &str = \"image/x-portable-graymap\";\n/// The `Content-Type` for PGN chess notation.\npub const APPLICATION_X_CHESS_PGN: &str = \"application/x-chess-pgn\";\n/// The `Content-Type` for PGP encrypted.\npub const APPLICATION_PGP_ENCRYPTED: &str = \"application/pgp-encrypted\";\n/// The `Content-Type` for PKIXCMP.\npub const APPLICATION_PKIXCMP: &str = \"application/pkixcmp\";\n/// The `Content-Type` for PKIX PKIPath.\npub const APPLICATION_PKIX_PKIPATH: &str = \"application/pkix-pkipath\";\n/// The `Content-Type` for 3GPP PIC BW Large.\npub const APPLICATION_VND_3GPP_PIC_BW_LARGE: &str = \"application/vnd.3gpp.pic-bw-large\";\n/// The `Content-Type` for Mobius PLC.\npub const APPLICATION_VND_MOBIUS_PLC: &str = \"application/vnd.mobius.plc\";\n/// The `Content-Type` for PocketLearn.\npub const APPLICATION_VND_POCKETLEARN: &str = \"application/vnd.pocketlearn\";\n/// The `Content-Type` for SCPLS playlist.\npub const AUDIO_X_SCPLS: &str = \"audio/x-scpls\";\n/// The `Content-Type` for CTC POSML.\npub const APPLICATION_VND_CTC_POSML: &str = \"application/vnd.ctc-posml\";\n/// The `Content-Type` for PNG image.\npub const IMAGE_PNG: &str = \"image/png\";\n/// The `Content-Type` for Portable Anymap image.\npub const IMAGE_X_PORTABLE_ANYMAP: &str = \"image/x-portable-anymap\";\n/// The `Content-Type` for MacPorts Portpkg.\npub const APPLICATION_VND_MACPORTS_PORTPKG: &str = \"application/vnd.macports.portpkg\";\n/// The `Content-Type` for Microsoft PowerPoint.\npub const APPLICATION_VND_MS_POWERPOINT: &str = \"application/vnd.ms-powerpoint\";\n/// The `Content-Type` for Microsoft PowerPoint Template (Macro-Enabled).\npub const APPLICATION_VND_MS_POWERPOINT_TEMPLATE_MACROENABLED_12: &str =\n    \"application/vnd.ms-powerpoint.template.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Presentation Template.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_TEMPLATE: &str =\n    \"application/vnd.openxmlformats-officedocument.presentationml.template\";\n/// The `Content-Type` for Microsoft PowerPoint Add-in (Macro-Enabled).\npub const APPLICATION_VND_MS_POWERPOINT_ADDIN_MACROENABLED_12: &str =\n    \"application/vnd.ms-powerpoint.addin.macroenabled.12\";\n/// The `Content-Type` for CUPS PPD.\npub const APPLICATION_VND_CUPS_PPD: &str = \"application/vnd.cups-ppd\";\n/// The `Content-Type` for Portable Pixmap image.\npub const IMAGE_X_PORTABLE_PIXMAP: &str = \"image/x-portable-pixmap\";\n/// The `Content-Type` for Microsoft PowerPoint Slideshow (Macro-Enabled).\npub const APPLICATION_VND_MS_POWERPOINT_SLIDESHOW_MACROENABLED_12: &str =\n    \"application/vnd.ms-powerpoint.slideshow.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Presentation Slideshow.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDESHOW: &str =\n    \"application/vnd.openxmlformats-officedocument.presentationml.slideshow\";\n/// The `Content-Type` for Microsoft PowerPoint Presentation (Macro-Enabled).\npub const APPLICATION_VND_MS_POWERPOINT_PRESENTATION_MACROENABLED_12: &str =\n    \"application/vnd.ms-powerpoint.presentation.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Presentation.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_PRESENTATION: &str =\n    \"application/vnd.openxmlformats-officedocument.presentationml.presentation\";\n/// The `Content-Type` for Lotus Freelance.\npub const APPLICATION_VND_LOTUS_FREELANCE: &str = \"application/vnd.lotus-freelance\";\n/// The `Content-Type` for PICS rules.\npub const APPLICATION_PICS_RULES: &str = \"application/pics-rules\";\n/// The `Content-Type` for 3GPP PIC BW Small.\npub const APPLICATION_VND_3GPP_PIC_BW_SMALL: &str = \"application/vnd.3gpp.pic-bw-small\";\n/// The `Content-Type` for Adobe Photoshop.\npub const IMAGE_VND_ADOBE_PHOTOSHOP: &str = \"image/vnd.adobe.photoshop\";\n/// The `Content-Type` for Linux PSF font.\npub const APPLICATION_X_FONT_LINUX_PSF: &str = \"application/x-font-linux-psf\";\n/// The `Content-Type` for PSKC XML.\npub const APPLICATION_PSKC_XML: &str = \"application/pskc+xml\";\n/// The `Content-Type` for PVI PTID1.\npub const APPLICATION_VND_PVI_PTID1: &str = \"application/vnd.pvi.ptid1\";\n/// The `Content-Type` for Microsoft Publisher.\npub const APPLICATION_X_MSPUBLISHER: &str = \"application/x-mspublisher\";\n/// The `Content-Type` for 3GPP PIC BW Var.\npub const APPLICATION_VND_3GPP_PIC_BW_VAR: &str = \"application/vnd.3gpp.pic-bw-var\";\n/// The `Content-Type` for 3M Post-It Notes.\npub const APPLICATION_VND_3M_POST_IT_NOTES: &str = \"application/vnd.3m.post-it-notes\";\n/// The `Content-Type` for Microsoft PlayReady Media PYA.\npub const AUDIO_VND_MS_PLAYREADY_MEDIA_PYA: &str = \"audio/vnd.ms-playready.media.pya\";\n/// The `Content-Type` for Microsoft PlayReady Media PYV.\npub const VIDEO_VND_MS_PLAYREADY_MEDIA_PYV: &str = \"video/vnd.ms-playready.media.pyv\";\n/// The `Content-Type` for Epson QuickAnime.\npub const APPLICATION_VND_EPSON_QUICKANIME: &str = \"application/vnd.epson.quickanime\";\n/// The `Content-Type` for Intuit QBO.\npub const APPLICATION_VND_INTU_QBO: &str = \"application/vnd.intu.qbo\";\n/// The `Content-Type` for Intuit QFX.\npub const APPLICATION_VND_INTU_QFX: &str = \"application/vnd.intu.qfx\";\n/// The `Content-Type` for PubliShare Delta Tree.\npub const APPLICATION_VND_PUBLISHARE_DELTA_TREE: &str = \"application/vnd.publishare-delta-tree\";\n/// The `Content-Type` for QuickTime image.\npub const IMAGE_X_QUICKTIME: &str = \"image/x-quicktime\";\n/// The `Content-Type` for QuarkXPress.\npub const APPLICATION_VND_QUARK_QUARKXPRESS: &str = \"application/vnd.quark.quarkxpress\";\n/// The `Content-Type` for RealAudio.\npub const AUDIO_X_PN_REALAUDIO: &str = \"audio/x-pn-realaudio\";\n/// The `Content-Type` for RAR compressed archive.\npub const APPLICATION_X_RAR_COMPRESSED: &str = \"application/x-rar-compressed\";\n/// The `Content-Type` for CMU Raster image.\npub const IMAGE_X_CMU_RASTER: &str = \"image/x-cmu-raster\";\n/// The `Content-Type` for iPunplugged RCProfile.\npub const APPLICATION_VND_IPUNPLUGGED_RCPROFILE: &str = \"application/vnd.ipunplugged.rcprofile\";\n/// The `Content-Type` for RDF XML.\npub const APPLICATION_RDF_XML: &str = \"application/rdf+xml\";\n/// The `Content-Type` for Data-Vision RDZ.\npub const APPLICATION_VND_DATA_VISION_RDZ: &str = \"application/vnd.data-vision.rdz\";\n/// The `Content-Type` for BusinessObjects.\npub const APPLICATION_VND_BUSINESSOBJECTS: &str = \"application/vnd.businessobjects\";\n/// The `Content-Type` for DTBResource XML.\npub const APPLICATION_X_DTBRESOURCE_XML: &str = \"application/x-dtbresource+xml\";\n/// The `Content-Type` for RGB image.\npub const IMAGE_X_RGB: &str = \"image/x-rgb\";\n/// The `Content-Type` for RegInfo XML.\npub const APPLICATION_REGINFO_XML: &str = \"application/reginfo+xml\";\n/// The `Content-Type` for RIP audio.\npub const AUDIO_VND_RIP: &str = \"audio/vnd.rip\";\n/// The `Content-Type` for Research Info Systems.\npub const APPLICATION_X_RESEARCH_INFO_SYSTEMS: &str = \"application/x-research-info-systems\";\n/// The `Content-Type` for Resource Lists XML.\npub const APPLICATION_RESOURCE_LISTS_XML: &str = \"application/resource-lists+xml\";\n/// The `Content-Type` for Fujixerox EDMICS RLC.\npub const IMAGE_VND_FUJIXEROX_EDMICS_RLC: &str = \"image/vnd.fujixerox.edmics-rlc\";\n/// The `Content-Type` for Resource Lists Diff XML.\npub const APPLICATION_RESOURCE_LISTS_DIFF_XML: &str = \"application/resource-lists-diff+xml\";\n/// The `Content-Type` for RealMedia.\npub const APPLICATION_VND_RN_REALMEDIA: &str = \"application/vnd.rn-realmedia\";\n/// The `Content-Type` for RealAudio Plugin.\npub const AUDIO_X_PN_REALAUDIO_PLUGIN: &str = \"audio/x-pn-realaudio-plugin\";\n/// The `Content-Type` for JCP J2ME Midlet RMS.\npub const APPLICATION_VND_JCP_JAVAME_MIDLET_RMS: &str = \"application/vnd.jcp.javame.midlet-rms\";\n/// The `Content-Type` for RealMedia VBR.\npub const APPLICATION_VND_RN_REALMEDIA_VBR: &str = \"application/vnd.rn-realmedia-vbr\";\n/// The `Content-Type` for RELAX NG Compact Syntax.\npub const APPLICATION_RELAX_NG_COMPACT_SYNTAX: &str = \"application/relax-ng-compact-syntax\";\n/// The `Content-Type` for RPKI ROA.\npub const APPLICATION_RPKI_ROA: &str = \"application/rpki-roa\";\n/// The `Content-Type` for Cloanto RP9.\npub const APPLICATION_VND_CLOANTO_RP9: &str = \"application/vnd.cloanto.rp9\";\n/// The `Content-Type` for Nokia Radio Presets.\npub const APPLICATION_VND_NOKIA_RADIO_PRESETS: &str = \"application/vnd.nokia.radio-presets\";\n/// The `Content-Type` for Nokia Radio Preset.\npub const APPLICATION_VND_NOKIA_RADIO_PRESET: &str = \"application/vnd.nokia.radio-preset\";\n/// The `Content-Type` for SPARQL Query.\npub const APPLICATION_SPARQL_QUERY: &str = \"application/sparql-query\";\n/// The `Content-Type` for RLS Services XML.\npub const APPLICATION_RLS_SERVICES_XML: &str = \"application/rls-services+xml\";\n/// The `Content-Type` for RSD XML.\npub const APPLICATION_RSD_XML: &str = \"application/rsd+xml\";\n/// The `Content-Type` for RSS XML.\npub const APPLICATION_RSS_XML: &str = \"application/rss+xml\";\n/// The `Content-Type` for RTF.\npub const APPLICATION_RTF: &str = \"application/rtf\";\n/// The `Content-Type` for Rich Text.\npub const TEXT_RICHTEXT: &str = \"text/richtext\";\n/// The `Content-Type` for S3M audio.\npub const AUDIO_S3M: &str = \"audio/s3m\";\n/// The `Content-Type` for Yamaha SMAF Audio.\npub const APPLICATION_VND_YAMAHA_SMAF_AUDIO: &str = \"application/vnd.yamaha.smaf-audio\";\n/// The `Content-Type` for SBML XML.\npub const APPLICATION_SBML_XML: &str = \"application/sbml+xml\";\n/// The `Content-Type` for IBM Secure Container.\npub const APPLICATION_VND_IBM_SECURE_CONTAINER: &str = \"application/vnd.ibm.secure-container\";\n/// The `Content-Type` for Microsoft Schedule.\npub const APPLICATION_X_MSSCHEDULE: &str = \"application/x-msschedule\";\n/// The `Content-Type` for Lotus ScreenCam.\npub const APPLICATION_VND_LOTUS_SCREENCAM: &str = \"application/vnd.lotus-screencam\";\n/// The `Content-Type` for SCVP CV Request.\npub const APPLICATION_SCVP_CV_REQUEST: &str = \"application/scvp-cv-request\";\n/// The `Content-Type` for SCVP CV Response.\npub const APPLICATION_SCVP_CV_RESPONSE: &str = \"application/scvp-cv-response\";\n/// The `Content-Type` for cURL SCURL.\npub const TEXT_VND_CURL_SCURL: &str = \"text/vnd.curl.scurl\";\n/// The `Content-Type` for StarDivision Draw.\npub const APPLICATION_VND_STARDIVISION_DRAW: &str = \"application/vnd.stardivision.draw\";\n/// The `Content-Type` for StarDivision Calc.\npub const APPLICATION_VND_STARDIVISION_CALC: &str = \"application/vnd.stardivision.calc\";\n/// The `Content-Type` for StarDivision Impress.\npub const APPLICATION_VND_STARDIVISION_IMPRESS: &str = \"application/vnd.stardivision.impress\";\n/// The `Content-Type` for Solent SDKM XML.\npub const APPLICATION_VND_SOLENT_SDKM_XML: &str = \"application/vnd.solent.sdkm+xml\";\n/// The `Content-Type` for SDP.\npub const APPLICATION_SDP: &str = \"application/sdp\";\n/// The `Content-Type` for StarDivision Writer.\npub const APPLICATION_VND_STARDIVISION_WRITER: &str = \"application/vnd.stardivision.writer\";\n/// The `Content-Type` for SeeMail.\npub const APPLICATION_VND_SEEMAIL: &str = \"application/vnd.seemail\";\n/// The `Content-Type` for SEMA.\npub const APPLICATION_VND_SEMA: &str = \"application/vnd.sema\";\n/// The `Content-Type` for SEMD.\npub const APPLICATION_VND_SEMD: &str = \"application/vnd.semd\";\n/// The `Content-Type` for SEMF.\npub const APPLICATION_VND_SEMF: &str = \"application/vnd.semf\";\n/// The `Content-Type` for Java Serialized Object.\npub const APPLICATION_JAVA_SERIALIZED_OBJECT: &str = \"application/java-serialized-object\";\n/// The `Content-Type` for Set Payment Initiation.\npub const APPLICATION_SET_PAYMENT_INITIATION: &str = \"application/set-payment-initiation\";\n/// The `Content-Type` for Set Registration Initiation.\npub const APPLICATION_SET_REGISTRATION_INITIATION: &str = \"application/set-registration-initiation\";\n/// The `Content-Type` for Hydrostatix SOF-data.\npub const APPLICATION_VND_HYDROSTATIX_SOF_DATA: &str = \"application/vnd.hydrostatix.sof-data\";\n/// The `Content-Type` for Spotfire SFS.\npub const APPLICATION_VND_SPOTFIRE_SFS: &str = \"application/vnd.spotfire.sfs\";\n/// The `Content-Type` for SFV.\npub const TEXT_X_SFV: &str = \"text/x-sfv\";\n/// The `Content-Type` for SGI image.\npub const IMAGE_SGI: &str = \"image/sgi\";\n/// The `Content-Type` for StarDivision Writer Global.\npub const APPLICATION_VND_STARDIVISION_WRITER_GLOBAL: &str =\n    \"application/vnd.stardivision.writer-global\";\n/// The `Content-Type` for SGML.\npub const TEXT_SGML: &str = \"text/sgml\";\n/// The `Content-Type` for Shell script.\npub const APPLICATION_X_SH: &str = \"application/x-sh\";\n/// The `Content-Type` for Shar archive.\npub const APPLICATION_X_SHAR: &str = \"application/x-shar\";\n/// The `Content-Type` for SHF XML.\npub const APPLICATION_SHF_XML: &str = \"application/shf+xml\";\n/// The `Content-Type` for MrSID image.\npub const IMAGE_X_MRSID_IMAGE: &str = \"image/x-mrsid-image\";\n/// The `Content-Type` for Silk audio.\npub const AUDIO_SILK: &str = \"audio/silk\";\n/// The `Content-Type` for Symbian Install.\npub const APPLICATION_VND_SYMBIAN_INSTALL: &str = \"application/vnd.symbian.install\";\n/// The `Content-Type` for StuffIt archive.\npub const APPLICATION_X_STUFFIT: &str = \"application/x-stuffit\";\n/// The `Content-Type` for StuffItX archive.\npub const APPLICATION_X_STUFFITX: &str = \"application/x-stuffitx\";\n/// The `Content-Type` for Koan.\npub const APPLICATION_VND_KOAN: &str = \"application/vnd.koan\";\n/// The `Content-Type` for Microsoft PowerPoint Slide (Macro-Enabled).\npub const APPLICATION_VND_MS_POWERPOINT_SLIDE_MACROENABLED_12: &str =\n    \"application/vnd.ms-powerpoint.slide.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Presentation Slide.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_PRESENTATIONML_SLIDE: &str =\n    \"application/vnd.openxmlformats-officedocument.presentationml.slide\";\n/// The `Content-Type` for Epson SALT.\npub const APPLICATION_VND_EPSON_SALT: &str = \"application/vnd.epson.salt\";\n/// The `Content-Type` for StepMania Stepchart.\npub const APPLICATION_VND_STEPMANIA_STEPCHART: &str = \"application/vnd.stepmania.stepchart\";\n/// The `Content-Type` for StarDivision Math.\npub const APPLICATION_VND_STARDIVISION_MATH: &str = \"application/vnd.stardivision.math\";\n/// The `Content-Type` for SMIL XML.\npub const APPLICATION_SMIL_XML: &str = \"application/smil+xml\";\n/// The `Content-Type` for SMV video.\npub const VIDEO_X_SMV: &str = \"video/x-smv\";\n/// The `Content-Type` for StepMania Package.\npub const APPLICATION_VND_STEPMANIA_PACKAGE: &str = \"application/vnd.stepmania.package\";\n/// The `Content-Type` for SNF font.\npub const APPLICATION_X_FONT_SNF: &str = \"application/x-font-snf\";\n/// The `Content-Type` for Yamaha SMAF Phrase.\npub const APPLICATION_VND_YAMAHA_SMAF_PHRASE: &str = \"application/vnd.yamaha.smaf-phrase\";\n/// The `Content-Type` for FutureSplash.\npub const APPLICATION_X_FUTURESPLASH: &str = \"application/x-futuresplash\";\n/// The `Content-Type` for In3D Spot.\npub const TEXT_VND_IN3D_SPOT: &str = \"text/vnd.in3d.spot\";\n/// The `Content-Type` for SCVP VP Response.\npub const APPLICATION_SCVP_VP_RESPONSE: &str = \"application/scvp-vp-response\";\n/// The `Content-Type` for SCVP VP Request.\npub const APPLICATION_SCVP_VP_REQUEST: &str = \"application/scvp-vp-request\";\n/// The `Content-Type` for SQL.\npub const APPLICATION_X_SQL: &str = \"application/x-sql\";\n/// The `Content-Type` for WAIS source.\npub const APPLICATION_X_WAIS_SOURCE: &str = \"application/x-wais-source\";\n/// The `Content-Type` for SubRip subtitle.\npub const APPLICATION_X_SUBRIP: &str = \"application/x-subrip\";\n/// The `Content-Type` for SRU XML.\npub const APPLICATION_SRU_XML: &str = \"application/sru+xml\";\n/// The `Content-Type` for SPARQL Results XML.\npub const APPLICATION_SPARQL_RESULTS_XML: &str = \"application/sparql-results+xml\";\n/// The `Content-Type` for SSDL XML.\npub const APPLICATION_SSDL_XML: &str = \"application/ssdl+xml\";\n/// The `Content-Type` for Kodak Descriptor.\npub const APPLICATION_VND_KODAK_DESCRIPTOR: &str = \"application/vnd.kodak-descriptor\";\n/// The `Content-Type` for Epson SSF.\npub const APPLICATION_VND_EPSON_SSF: &str = \"application/vnd.epson.ssf\";\n/// The `Content-Type` for SSML XML.\npub const APPLICATION_SSML_XML: &str = \"application/ssml+xml\";\n/// The `Content-Type` for SailingTracker Track.\npub const APPLICATION_VND_SAILINGTRACKER_TRACK: &str = \"application/vnd.sailingtracker.track\";\n/// The `Content-Type` for Sun XML Calc Template.\npub const APPLICATION_VND_SUN_XML_CALC_TEMPLATE: &str = \"application/vnd.sun.xml.calc.template\";\n/// The `Content-Type` for Sun XML Draw Template.\npub const APPLICATION_VND_SUN_XML_DRAW_TEMPLATE: &str = \"application/vnd.sun.xml.draw.template\";\n/// The `Content-Type` for WT STF.\npub const APPLICATION_VND_WT_STF: &str = \"application/vnd.wt.stf\";\n/// The `Content-Type` for Sun XML Impress Template.\npub const APPLICATION_VND_SUN_XML_IMPRESS_TEMPLATE: &str =\n    \"application/vnd.sun.xml.impress.template\";\n/// The `Content-Type` for HyperStudio.\npub const APPLICATION_HYPERSTUDIO: &str = \"application/hyperstudio\";\n/// The `Content-Type` for Microsoft PKI STL.\npub const APPLICATION_VND_MS_PKI_STL: &str = \"application/vnd.ms-pki.stl\";\n/// The `Content-Type` for PG Format.\npub const APPLICATION_VND_PG_FORMAT: &str = \"application/vnd.pg.format\";\n/// The `Content-Type` for Sun XML Writer Template.\npub const APPLICATION_VND_SUN_XML_WRITER_TEMPLATE: &str = \"application/vnd.sun.xml.writer.template\";\n/// The `Content-Type` for DVB Subtitle.\npub const TEXT_VND_DVB_SUBTITLE: &str = \"text/vnd.dvb.subtitle\";\n/// The `Content-Type` for SUS Calendar.\npub const APPLICATION_VND_SUS_CALENDAR: &str = \"application/vnd.sus-calendar\";\n/// The `Content-Type` for SV4CPIO archive.\npub const APPLICATION_X_SV4CPIO: &str = \"application/x-sv4cpio\";\n/// The `Content-Type` for SV4CRC archive.\npub const APPLICATION_X_SV4CRC: &str = \"application/x-sv4crc\";\n/// The `Content-Type` for DVB Service.\npub const APPLICATION_VND_DVB_SERVICE: &str = \"application/vnd.dvb.service\";\n/// The `Content-Type` for SVD.\npub const APPLICATION_VND_SVD: &str = \"application/vnd.svd\";\n/// The `Content-Type` for SVG image.\npub const IMAGE_SVG_XML: &str = \"image/svg+xml\";\n/// The `Content-Type` for Shockwave Flash.\npub const APPLICATION_X_SHOCKWAVE_FLASH: &str = \"application/x-shockwave-flash\";\n/// The `Content-Type` for Arista Networks SWI.\npub const APPLICATION_VND_ARISTANETWORKS_SWI: &str = \"application/vnd.aristanetworks.swi\";\n/// The `Content-Type` for Sun XML Calc.\npub const APPLICATION_VND_SUN_XML_CALC: &str = \"application/vnd.sun.xml.calc\";\n/// The `Content-Type` for Sun XML Draw.\npub const APPLICATION_VND_SUN_XML_DRAW: &str = \"application/vnd.sun.xml.draw\";\n/// The `Content-Type` for Sun XML Writer Global.\npub const APPLICATION_VND_SUN_XML_WRITER_GLOBAL: &str = \"application/vnd.sun.xml.writer.global\";\n/// The `Content-Type` for Sun XML Impress.\npub const APPLICATION_VND_SUN_XML_IMPRESS: &str = \"application/vnd.sun.xml.impress\";\n/// The `Content-Type` for Sun XML Math.\npub const APPLICATION_VND_SUN_XML_MATH: &str = \"application/vnd.sun.xml.math\";\n/// The `Content-Type` for Sun XML Writer.\npub const APPLICATION_VND_SUN_XML_WRITER: &str = \"application/vnd.sun.xml.writer\";\n/// The `Content-Type` for T3VM image.\npub const APPLICATION_X_T3VM_IMAGE: &str = \"application/x-t3vm-image\";\n/// The `Content-Type` for MyNFC.\npub const APPLICATION_VND_MYNFC: &str = \"application/vnd.mynfc\";\n/// The `Content-Type` for Tao Intent Module Archive.\npub const APPLICATION_VND_TAO_INTENT_MODULE_ARCHIVE: &str =\n    \"application/vnd.tao.intent-module-archive\";\n/// The `Content-Type` for TAR archive.\npub const APPLICATION_X_TAR: &str = \"application/x-tar\";\n/// The `Content-Type` for 3GPP2 TCAP.\npub const APPLICATION_VND_3GPP2_TCAP: &str = \"application/vnd.3gpp2.tcap\";\n/// The `Content-Type` for Tcl script.\npub const APPLICATION_X_TCL: &str = \"application/x-tcl\";\n/// The `Content-Type` for SMART Teacher.\npub const APPLICATION_VND_SMART_TEACHER: &str = \"application/vnd.smart.teacher\";\n/// The `Content-tType` for TEI XML.\npub const APPLICATION_TEI_XML: &str = \"application/tei+xml\";\n/// The `Content-Type` for TeX.\npub const APPLICATION_X_TEX: &str = \"application/x-tex\";\n/// The `Content-Type` for Texinfo.\npub const APPLICATION_X_TEXINFO: &str = \"application/x-texinfo\";\n/// The `Content-Type` for Thraud XML.\npub const APPLICATION_THRAUD_XML: &str = \"application/thraud+xml\";\n/// The `Content-Type` for TeX TFM.\npub const APPLICATION_X_TEX_TFM: &str = \"application/x-tex-tfm\";\n/// The `Content-Type` for TGA image.\npub const IMAGE_X_TGA: &str = \"image/x-tga\";\n/// The `Content-Type` for Microsoft Office Theme.\npub const APPLICATION_VND_MS_OFFICETHEME: &str = \"application/vnd.ms-officetheme\";\n/// The `Content-Type` for TIFF image.\npub const IMAGE_TIFF: &str = \"image/tiff\";\n/// The `Content-Type` for T-Mobile LiveTV.\npub const APPLICATION_VND_TMOBILE_LIVETV: &str = \"application/vnd.tmobile-livetv\";\n/// The `Content-Type` for BitTorrent.\npub const APPLICATION_X_BITTORRENT: &str = \"application/x-bittorrent\";\n/// The `Content-Type` for Groove Tool Template.\npub const APPLICATION_VND_GROOVE_TOOL_TEMPLATE: &str = \"application/vnd.groove-tool-template\";\n/// The `Content-Type` for TRID TPT.\npub const APPLICATION_VND_TRID_TPT: &str = \"application/vnd.trid.tpt\";\n/// The `Content-Type` for TrueApp.\npub const APPLICATION_VND_TRUEAPP: &str = \"application/vnd.trueapp\";\n/// The `Content-Type` for Microsoft Terminal.\npub const APPLICATION_X_MSTERMINAL: &str = \"application/x-msterminal\";\n/// The `Content-Type` for Timestamped Data.\npub const APPLICATION_TIMESTAMPED_DATA: &str = \"application/timestamped-data\";\n/// The `Content-Type` for Tab-Separated Values.\npub const TEXT_TAB_SEPARATED_VALUES: &str = \"text/tab-separated-values\";\n/// The `Content-Type` for Font Collection.\npub const FONT_COLLECTION: &str = \"font/collection\";\n/// The `Content-Type` for TrueType Font.\npub const FONT_TTF: &str = \"font/ttf\";\n/// The `Content-Type` for Turtle.\npub const TEXT_TURTLE: &str = \"text/turtle\";\n/// The `Content-Type` for SimTech MindMapper.\npub const APPLICATION_VND_SIMTECH_MINDMAPPER: &str = \"application/vnd.simtech-mindmapper\";\n/// The `Content-Type` for Genomatix Tuxedo.\npub const APPLICATION_VND_GENOMATIX_TUXEDO: &str = \"application/vnd.genomatix.tuxedo\";\n/// The `Content-Type` for Mobius TXF.\npub const APPLICATION_VND_MOBIUS_TXF: &str = \"application/vnd.mobius.txf\";\n/// The `Content-Type` for UFDL.\npub const APPLICATION_VND_UFDL: &str = \"application/vnd.ufdl\";\n/// The `Content-Type` for Glulx game.\npub const APPLICATION_X_GLULX: &str = \"application/x-glulx\";\n/// The `Content-Type` for UMAJIN.\npub const APPLICATION_VND_UMAJIN: &str = \"application/vnd.umajin\";\n/// The `Content-Type` for Unity.\npub const APPLICATION_VND_UNITY: &str = \"application/vnd.unity\";\n/// The `Content-Type` for UOML XML.\npub const APPLICATION_VND_UOML_XML: &str = \"application/vnd.uoml+xml\";\n/// The `Content-Type` for URI List.\npub const TEXT_URI_LIST: &str = \"text/uri-list\";\n/// The `Content-Type` for USTAR archive.\npub const APPLICATION_X_USTAR: &str = \"application/x-ustar\";\n/// The `Content-Type` for UIQ Theme.\npub const APPLICATION_VND_UIQ_THEME: &str = \"application/vnd.uiq.theme\";\n/// The `Content-Type` for UUEncode.\npub const TEXT_X_UUENCODE: &str = \"text/x-uuencode\";\n/// The `Content-Type` for DECE audio.\npub const AUDIO_VND_DECE_AUDIO: &str = \"audio/vnd.dece.audio\";\n/// The `Content-Type` for DECE data.\npub const APPLICATION_VND_DECE_DATA: &str = \"application/vnd.dece.data\";\n/// The `Content-Type` for DECE graphic.\npub const IMAGE_VND_DECE_GRAPHIC: &str = \"image/vnd.dece.graphic\";\n/// The `Content-Type` for DECE HD video.\npub const VIDEO_VND_DECE_HD: &str = \"video/vnd.dece.hd\";\n/// The `Content-Type` for DECE mobile video.\npub const VIDEO_VND_DECE_MOBILE: &str = \"video/vnd.dece.mobile\";\n/// The `Content-Type` for DECE PD video.\npub const VIDEO_VND_DECE_PD: &str = \"video/vnd.dece.pd\";\n/// The `Content-Type` for DECE SD video.\npub const VIDEO_VND_DECE_SD: &str = \"video/vnd.dece.sd\";\n/// The `Content-Type` for DECE TTML XML.\npub const APPLICATION_VND_DECE_TTML_XML: &str = \"application/vnd.dece.ttml+xml\";\n/// The `Content-Type` for UVVU MP4 video.\npub const VIDEO_VND_UVVU_MP4: &str = \"video/vnd.uvvu.mp4\";\n/// The `Content-Type` for DECE video.\npub const VIDEO_VND_DECE_VIDEO: &str = \"video/vnd.dece.video\";\n/// The `Content-Type` for DECE unspecified.\npub const APPLICATION_VND_DECE_UNSPECIFIED: &str = \"application/vnd.dece.unspecified\";\n/// The `Content-Type` for DECE ZIP.\npub const APPLICATION_VND_DECE_ZIP: &str = \"application/vnd.dece.zip\";\n/// The `Content-Type` for vCard.\npub const TEXT_VCARD: &str = \"text/vcard\";\n/// The `Content-Type` for CDLink.\npub const APPLICATION_X_CDLINK: &str = \"application/x-cdlink\";\n/// The `Content-Type` for vCard.\npub const TEXT_X_VCARD: &str = \"text/x-vcard\";\n/// The `Content-Type` for Groove vCard.\npub const APPLICATION_VND_GROOVE_VCARD: &str = \"application/vnd.groove-vcard\";\n/// The `Content-Type` for vCalendar.\npub const TEXT_X_VCALENDAR: &str = \"text/x-vcalendar\";\n/// The `Content-Type` for VCX.\npub const APPLICATION_VND_VCX: &str = \"application/vnd.vcx\";\n/// The `Content-Type` for Visionary.\npub const APPLICATION_VND_VISIONARY: &str = \"application/vnd.visionary\";\n/// The `Content-Type` for Vivo video.\npub const VIDEO_VND_VIVO: &str = \"video/vnd.vivo\";\n/// The `Content-Type` for VOB video.\npub const VIDEO_X_MS_VOB: &str = \"video/x-ms-vob\";\n/// The `Content-Type` for VRML model.\npub const MODEL_VRML: &str = \"model/vrml\";\n/// The `Content-Type` for Microsoft Visio.\npub const APPLICATION_VND_VISIO: &str = \"application/vnd.visio\";\n/// The `Content-Iype` for VSF.\npub const APPLICATION_VND_VSF: &str = \"application/vnd.vsf\";\n/// The `Content-Type` for VTU model.\npub const MODEL_VND_VTU: &str = \"model/vnd.vtu\";\n/// The `Content-Type` for VoiceXML.\npub const APPLICATION_VOICEXML_XML: &str = \"application/voicexml+xml\";\n/// The `Content-Type` for Doom WAD.\npub const APPLICATION_X_DOOM: &str = \"application/x-doom\";\n/// The `Content-Type` for WAV audio.\npub const AUDIO_X_WAV: &str = \"audio/x-wav\";\n/// The `Content-Type` for WAX audio.\npub const AUDIO_X_MS_WAX: &str = \"audio/x-ms-wax\";\n/// The `Content-Type` for WAP WBMP image.\npub const IMAGE_VND_WAP_WBMP: &str = \"image/vnd.wap.wbmp\";\n/// The `Content-Type` for Critical Tools WBS XML.\npub const APPLICATION_VND_CRITICALTOOLS_WBS_XML: &str = \"application/vnd.criticaltools.wbs+xml\";\n/// The `Content-Type` for WAP WBXML.\npub const APPLICATION_VND_WAP_WBXML: &str = \"application/vnd.wap.wbxml\";\n/// The `Content-Type` for Microsoft Works.\npub const APPLICATION_VND_MS_WORKS: &str = \"application/vnd.ms-works\";\n/// The `Content-Type` for Microsoft Photo.\npub const IMAGE_VND_MS_PHOTO: &str = \"image/vnd.ms-photo\";\n/// The `Content-Type` for WebM audio.\npub const AUDIO_WEBM: &str = \"audio/webm\";\n/// The `Content-Type` for WebM video.\npub const VIDEO_WEBM: &str = \"video/webm\";\n/// The `Content-Type` for WebP image.\npub const IMAGE_WEBP: &str = \"image/webp\";\n/// The `Content-Type` for PMI Widget.\npub const APPLICATION_VND_PMI_WIDGET: &str = \"application/vnd.pmi.widget\";\n/// The `Content-Type` for Widget.\npub const APPLICATION_WIDGET: &str = \"application/widget\";\n/// The `Content-Type` for WM video.\npub const VIDEO_X_MS_WM: &str = \"video/x-ms-wm\";\n/// The `Content-Type` for WMA audio.\npub const AUDIO_X_MS_WMA: &str = \"audio/x-ms-wma\";\n/// The `Content-Type` for WMD.\npub const APPLICATION_X_MS_WMD: &str = \"application/x-ms-wmd\";\n/// The `Content-Type` for WAP WML.\npub const TEXT_VND_WAP_WML: &str = \"text/vnd.wap.wml\";\n/// The `Content-Type` for WAP WMLC.\npub const APPLICATION_VND_WAP_WMLC: &str = \"application/vnd.wap.wmlc\";\n/// The `Content-Type` for WAP WMLScript.\npub const TEXT_VND_WAP_WMLSCRIPT: &str = \"text/vnd.wap.wmlscript\";\n/// The `Content-Type` for WAP WMLScriptC.\npub const APPLICATION_VND_WAP_WMLSCRIPTC: &str = \"application/vnd.wap.wmlscriptc\";\n/// The `Content-Type` for WMV video.\npub const VIDEO_X_MS_WMV: &str = \"video/x-ms-wmv\";\n/// The `Content-Type` for WMX video.\npub const VIDEO_X_MS_WMX: &str = \"video/x-ms-wmx\";\n/// The `Content-Type` for WOFF font.\npub const FONT_WOFF: &str = \"font/woff\";\n/// The `Content-Type` for WOFF2 font.\npub const FONT_WOFF2: &str = \"font/woff2\";\n/// The `Content-Type` for WordPerfect.\npub const APPLICATION_VND_WORDPERFECT: &str = \"application/vnd.wordperfect\";\n/// The `Content-Type` for Microsoft WPL.\npub const APPLICATION_VND_MS_WPL: &str = \"application/vnd.ms-wpl\";\n/// The `Content-Type` for WQD.\npub const APPLICATION_VND_WQD: &str = \"application/vnd.wqd\";\n/// The `Content-Type` for Microsoft Write.\npub const APPLICATION_X_MSWRITE: &str = \"application/x-mswrite\";\n/// The `Content-Type` for WSDL XML.\npub const APPLICATION_WSDL_XML: &str = \"application/wsdl+xml\";\n/// The `Content-Type` for WSPolicy XML.\npub const APPLICATION_WSPOLICY_XML: &str = \"application/wspolicy+xml\";\n/// The `Content-Type` for WebTurbo.\npub const APPLICATION_VND_WEBTURBO: &str = \"application/vnd.webturbo\";\n/// The `Content-Type` for WVX video.\npub const VIDEO_X_MS_WVX: &str = \"video/x-ms-wvx\";\n/// The `Content-Type` for X3D XML.\npub const MODEL_X3D_XML: &str = \"model/x3d+xml\";\n/// The `Content-Type` for X3D Binary.\npub const MODEL_X3D_BINARY: &str = \"model/x3d+binary\";\n/// The `Content-Type` for X3D VRML.\npub const MODEL_X3D_VRML: &str = \"model/x3d+vrml\";\n/// The `Content-Type` for XAML XML.\npub const APPLICATION_XAML_XML: &str = \"application/xaml+xml\";\n/// The `Content-Type` for Silverlight App.\npub const APPLICATION_X_SILVERLIGHT_APP: &str = \"application/x-silverlight-app\";\n/// The `Content-Type` for Xara.\npub const APPLICATION_VND_XARA: &str = \"application/vnd.xara\";\n/// The `Content-Type` for Microsoft XBAP.\npub const APPLICATION_X_MS_XBAP: &str = \"application/x-ms-xbap\";\n/// The `Content-Type` for Fujixerox DocuWorks Binder.\npub const APPLICATION_VND_FUJIXEROX_DOCUWORKS_BINDER: &str =\n    \"application/vnd.fujixerox.docuworks.binder\";\n/// The `Content-Type` for XBM image.\npub const IMAGE_X_XBITMAP: &str = \"image/x-xbitmap\";\n/// The `Content-Type` for XCAP Diff XML.\npub const APPLICATION_XCAP_DIFF_XML: &str = \"application/xcap-diff+xml\";\n/// The `Content-Type` for SyncML DM XML.\npub const APPLICATION_VND_SYNCML_DM_XML: &str = \"application/vnd.syncml.dm+xml\";\n/// The `Content-Type` for Adobe XDP XML.\npub const APPLICATION_VND_ADOBE_XDP_XML: &str = \"application/vnd.adobe.xdp+xml\";\n/// The `Content-Type` for DSSC XML.\npub const APPLICATION_DSSC_XML: &str = \"application/dssc+xml\";\n/// The `Content-Type` for Fujixerox DocuWorks.\npub const APPLICATION_VND_FUJIXEROX_DOCUWORKS: &str = \"application/vnd.fujixerox.docuworks\";\n/// The `Content-Type` for XENC XML.\npub const APPLICATION_XENC_XML: &str = \"application/xenc+xml\";\n/// The `Content-Type` for Patch Ops Error XML.\npub const APPLICATION_PATCH_OPS_ERROR_XML: &str = \"application/patch-ops-error+xml\";\n/// The `Content-Type` for Adobe XFDF.\npub const APPLICATION_VND_ADOBE_XFDF: &str = \"application/vnd.adobe.xfdf\";\n/// The `Content-Type` for XFDL.\npub const APPLICATION_VND_XFDL: &str = \"application/vnd.xfdl\";\n/// The `Content-Type` for XHTML XML.\npub const APPLICATION_XHTML_XML: &str = \"application/xhtml+xml\";\n/// The `Content-Type` for XIFF image.\npub const IMAGE_VND_XIFF: &str = \"image/vnd.xiff\";\n/// The `Content-Type` for Microsoft Excel.\npub const APPLICATION_VND_MS_EXCEL: &str = \"application/vnd.ms-excel\";\n/// The `Content-Type` for Microsoft Excel Add-in (Macro-Enabled).\npub const APPLICATION_VND_MS_EXCEL_ADDIN_MACROENABLED_12: &str =\n    \"application/vnd.ms-excel.addin.macroenabled.12\";\n/// The `Content-Type` for XLIFF XML.\npub const APPLICATION_X_XLIFF_XML: &str = \"application/x-xliff+xml\";\n/// The `Content-Type` for Microsoft Excel Sheet (Binary, Macro-Enabled).\npub const APPLICATION_VND_MS_EXCEL_SHEET_BINARY_MACROENABLED_12: &str =\n    \"application/vnd.ms-excel.sheet.binary.macroenabled.12\";\n/// The `Content-Type` for Microsoft Excel Sheet (Macro-Enabled).\npub const APPLICATION_VND_MS_EXCEL_SHEET_MACROENABLED_12: &str =\n    \"application/vnd.ms-excel.sheet.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Spreadsheet.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_SHEET: &str =\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\";\n/// The `Content-Type` for Microsoft Excel Template (Macro-Enabled).\npub const APPLICATION_VND_MS_EXCEL_TEMPLATE_MACROENABLED_12: &str =\n    \"application/vnd.ms-excel.template.macroenabled.12\";\n/// The `Content-Type` for Office Open XML Spreadsheet Template.\npub const APPLICATION_VND_OPENXMLFORMATS_OFFICEDOCUMENT_SPREADSHEETML_TEMPLATE: &str =\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.template\";\n/// The `Content-Type` for XM audio.\npub const AUDIO_XM: &str = \"audio/xm\";\n/// The `Content-Type` for XML.\npub const APPLICATION_XML: &str = \"application/xml\";\n/// The `Content-Type` for OLPC Sugar.\npub const APPLICATION_VND_OLPC_SUGAR: &str = \"application/vnd.olpc-sugar\";\n/// The `Content-Type` for XOP XML.\npub const APPLICATION_XOP_XML: &str = \"application/xop+xml\";\n/// The `Content-Type` for XPInstall.\npub const APPLICATION_X_XPINSTALL: &str = \"application/x-xpinstall\";\n/// The `Content-Type` for XProc XML.\npub const APPLICATION_XPROC_XML: &str = \"application/xproc+xml\";\n/// The `Content-Type` for XPM image.\npub const IMAGE_X_XPIXMAP: &str = \"image/x-xpixmap\";\n/// The `Content-Type` for IS-XPR.\npub const APPLICATION_VND_IS_XPR: &str = \"application/vnd.is-xpr\";\n/// The `Content-Type` for Microsoft XPS Document.\npub const APPLICATION_VND_MS_XPSDOCUMENT: &str = \"application/vnd.ms-xpsdocument\";\n/// The `Content-Type` for Intercon FormNet.\npub const APPLICATION_VND_INTERCON_FORMNET: &str = \"application/vnd.intercon.formnet\";\n/// The `Content-Type` for XSLT XML.\npub const APPLICATION_XSLT_XML: &str = \"application/xslt+xml\";\n/// The `Content-Type` for SyncML XML.\npub const APPLICATION_VND_SYNCML_XML: &str = \"application/vnd.syncml+xml\";\n/// The `Content-Type` for XSPF XML.\npub const APPLICATION_XSPF_XML: &str = \"application/xspf+xml\";\n/// The `Content-Type` for Mozilla XUL XML.\npub const APPLICATION_VND_MOZILLA_XUL_XML: &str = \"application/vnd.mozilla.xul+xml\";\n/// The `Content-Type` for XWD image.\npub const IMAGE_X_XWINDOWDUMP: &str = \"image/x-xwindowdump\";\n/// The `Content-Type` for XYZ chemical.\npub const CHEMICAL_X_XYZ: &str = \"chemical/x-xyz\";\n/// The `Content-Type` for XZ archive.\npub const APPLICATION_X_XZ: &str = \"application/x-xz\";\n/// The `Content-Type` for YANG.\npub const APPLICATION_YANG: &str = \"application/yang\";\n/// The `Content-Type` for YIN XML.\npub const APPLICATION_YIN_XML: &str = \"application/yin+xml\";\n/// The `Content-Type` for compress archive.\npub const APPLICATION_X_COMPRESS: &str = \"application/x-compress\";\n/// The `Content-Type` for Z-machine.\npub const APPLICATION_X_ZMACHINE: &str = \"application/x-zmachine\";\n/// The `Content-Type` for Zzazz Deck XML.\npub const APPLICATION_VND_ZZAZZ_DECK_XML: &str = \"application/vnd.zzazz.deck+xml\";\n/// The `Content-Type` for ZIP archive.\npub const APPLICATION_ZIP: &str = \"application/zip\";\n/// The `Content-Type` for ZUL.\npub const APPLICATION_VND_ZUL: &str = \"application/vnd.zul\";\n/// The `Content-Type` for Handheld Entertainment XML.\npub const APPLICATION_VND_HANDHELD_ENTERTAINMENT_XML: &str =\n    \"application/vnd.handheld-entertainment+xml\";\n/// The `Content-Type` for multipart/x-mixed-replace.\npub const MULTIPART_X_MIXED_REPLACE: &str = \"multipart/x-mixed-replace\";\n/// The `Content-Type` for newline-delimited JSON.\npub const APPLICATION_X_NDJSON: &str = \"application/x-ndjson\";", "file_size": 89658, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Builder pattern for constructing `HttpRequest` instances.\n///\n/// The `RequestBuilder` struct facilitates the creation of `HttpRequest` objects\n/// through a series of method calls. It allows for flexible and clear configuration of\n/// an HTTP request's components such as method, URL, headers, and body.\n///\n/// # Fields\n/// - `http_request`: A temporary `HttpRequest` instance used to accumulate changes during\n///   the construction process. It holds the current state of the builder.\n/// - `builder`: A finalized `HttpRequest` instance that holds the result after the\n///   builder process has been completed. It is returned when the builder is finalized.\n///\n/// This builder simplifies the creation of `HttpRequest` objects, ensuring thread-safety\n/// and immutability of shared references, while providing a fluent API for constructing\n/// HTTP requests with various configurations.\n#[derive(Debug, Clone)]\npub struct RequestBuilder {\n    pub(crate) http_request: HttpRequest,\n    pub(crate) builder: HttpRequest,\n}", "file_size": 1041, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\protocol\\const.rs", "language": "rust", "content": "/// Represents the uppercase \"HTTP\" protocol string.\npub const HTTP_UPPERCASE: &str = \"HTTP\";\n\n/// Represents the uppercase \"HTTPS\" protocol string.\npub const HTTPS_UPPERCASE: &str = \"HTTPS\";\n\n/// Represents the lowercase \"http\" protocol string.\npub const HTTP_LOWERCASE: &str = \"http\";\n\n/// Represents the lowercase \"https\" protocol string.\npub const HTTPS_LOWERCASE: &str = \"https\";\n\n/// Represents the \"websocket\" protocol string.\npub const WEBSOCKET: &str = \"websocket\";\n\n/// Represents the \"ws\" protocol string, commonly used for WebSockets.\npub const WS: &str = \"ws\";\n\n/// Represents the \"wss\" protocol string, commonly used for secure WebSockets.\npub const WSS: &str = \"wss\";\n\n/// Represents the \"ftp\" protocol string.\npub const FTP: &str = \"ftp\";\n\n/// Represents the \"ftps\" protocol string, commonly used for secure FTP.\npub const FTPS: &str = \"ftps\";\n\n/// Represents the \"sftp\" protocol string, commonly used for SSH File Transfer Protocol.\npub const SFTP: &str = \"sftp\";\n\n/// Represents the \"file\" protocol string, used for local file access.\npub const FILE: &str = \"file\";\n\n/// Represents the \"mailto\" protocol string, used for email addresses.\npub const MAILTO: &str = \"mailto\";\n\n/// Represents the \"data\" protocol string, used for embedding small files inline.\npub const DATA: &str = \"data\";\n\n/// Represents the \"tel\" protocol string, used for telephone numbers.\npub const TEL: &str = \"tel\";\n\n/// Represents the \"sms\" protocol string, used for SMS messages.\npub const SMS: &str = \"sms\";\n\n/// Represents the \"gopher\" protocol string.\npub const GOPHER: &str = \"gopher\";\n\n/// Represents the \"ldap\" protocol string, used for Lightweight Directory Access Protocol.\npub const LDAP: &str = \"ldap\";\n\n/// Represents the \"ldaps\" protocol string, used for secure LDAP.\npub const LDAPS: &str = \"ldaps\";\n\n/// Represents an unknown or unspecified HTTP version string.\npub const UNKNOWN_HTTP_VERSION: &str = \"\";", "file_size": 1909, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\method\\const.rs", "language": "rust", "content": "/// HTTP GET method.\npub const GET: &str = \"GET\";\n/// HTTP POST method.\npub const POST: &str = \"POST\";\n/// HTTP PUT method.\npub const PUT: &str = \"PUT\";\n/// HTTP DELETE method.\npub const DELETE: &str = \"DELETE\";\n/// HTTP PATCH method.\npub const PATCH: &str = \"PATCH\";\n/// HTTP HEAD method.\npub const HEAD: &str = \"HEAD\";\n/// HTTP OPTIONS method.\npub const OPTIONS: &str = \"OPTIONS\";\n/// HTTP CONNECT method.\npub const CONNECT: &str = \"CONNECT\";\n/// HTTP TRACE method.\npub const TRACE: &str = \"TRACE\";\n/// HTTP GET and POST methods.\npub const GET_POST: &str = \"GET, POST\";\n/// HTTP GET and PUT methods.\npub const GET_PUT: &str = \"GET, PUT\";\n/// HTTP GET and DELETE methods.\npub const GET_DELETE: &str = \"GET, DELETE\";\n/// HTTP GET and PATCH methods.\npub const GET_PATCH: &str = \"GET, PATCH\";\n/// HTTP GET and HEAD methods.\npub const GET_HEAD: &str = \"GET, HEAD\";\n/// HTTP GET and OPTIONS methods.\npub const GET_OPTIONS: &str = \"GET, OPTIONS\";\n/// HTTP GET and CONNECT methods.\npub const GET_CONNECT: &str = \"GET, CONNECT\";\n/// HTTP GET and TRACE methods.\npub const GET_TRACE: &str = \"GET, TRACE\";\n/// HTTP POST and PUT methods.\npub const POST_PUT: &str = \"POST, PUT\";\n/// HTTP POST and DELETE methods.\npub const POST_DELETE: &str = \"POST, DELETE\";\n/// HTTP POST and PATCH methods.\npub const POST_PATCH: &str = \"POST, PATCH\";\n/// HTTP POST and HEAD methods.\npub const POST_HEAD: &str = \"POST, HEAD\";\n/// HTTP POST and OPTIONS methods.\npub const POST_OPTIONS: &str = \"POST, OPTIONS\";\n/// HTTP POST and CONNECT methods.\npub const POST_CONNECT: &str = \"POST, CONNECT\";\n/// HTTP POST and TRACE methods.\npub const POST_TRACE: &str = \"POST, TRACE\";\n/// HTTP PUT and DELETE methods.\npub const PUT_DELETE: &str = \"PUT, DELETE\";\n/// HTTP PUT and PATCH methods.\npub const PUT_PATCH: &str = \"PUT, PATCH\";\n/// HTTP PUT and HEAD methods.\npub const PUT_HEAD: &str = \"PUT, HEAD\";\n/// HTTP PUT and OPTIONS methods.\npub const PUT_OPTIONS: &str = \"PUT, OPTIONS\";\n/// HTTP PUT and CONNECT methods.\npub const PUT_CONNECT: &str = \"PUT, CONNECT\";\n/// HTTP PUT and TRACE methods.\npub const PUT_TRACE: &str = \"PUT, TRACE\";\n/// HTTP DELETE and PATCH methods.\npub const DELETE_PATCH: &str = \"DELETE, PATCH\";\n/// HTTP DELETE and HEAD methods.\npub const DELETE_HEAD: &str = \"DELETE, HEAD\";\n/// HTTP DELETE and OPTIONS methods.\npub const DELETE_OPTIONS: &str = \"DELETE, OPTIONS\";\n/// HTTP DELETE and CONNECT methods.\npub const DELETE_CONNECT: &str = \"DELETE, CONNECT\";\n/// HTTP DELETE and TRACE methods.\npub const DELETE_TRACE: &str = \"DELETE, TRACE\";\n/// HTTP PATCH and HEAD methods.\npub const PATCH_HEAD: &str = \"PATCH, HEAD\";\n/// HTTP PATCH and OPTIONS methods.\npub const PATCH_OPTIONS: &str = \"PATCH, OPTIONS\";\n/// HTTP PATCH and CONNECT methods.\npub const PATCH_CONNECT: &str = \"PATCH, CONNECT\";\n/// HTTP PATCH and TRACE methods.\npub const PATCH_TRACE: &str = \"PATCH, TRACE\";\n/// HTTP HEAD and OPTIONS methods.\npub const HEAD_OPTIONS: &str = \"HEAD, OPTIONS\";\n/// HTTP HEAD and CONNECT methods.\npub const HEAD_CONNECT: &str = \"HEAD, CONNECT\";\n/// HTTP HEAD and TRACE methods.\npub const HEAD_TRACE: &str = \"HEAD, TRACE\";\n/// HTTP OPTIONS and CONNECT methods.\npub const OPTIONS_CONNECT: &str = \"OPTIONS, CONNECT\";\n/// HTTP OPTIONS and TRACE methods.\npub const OPTIONS_TRACE: &str = \"OPTIONS, TRACE\";\n/// HTTP CONNECT and TRACE methods.\npub const CONNECT_TRACE: &str = \"CONNECT, TRACE\";\n/// HTTP GET, POST, and PUT methods.\npub const GET_POST_PUT: &str = \"GET, POST, PUT\";\n/// HTTP GET, POST, and DELETE methods.\npub const GET_POST_DELETE: &str = \"GET, POST, DELETE\";\n/// HTTP GET, POST, and PATCH methods.\npub const GET_POST_PATCH: &str = \"GET, POST, PATCH\";\n/// HTTP GET, POST, and HEAD methods.\npub const GET_POST_HEAD: &str = \"GET, POST, HEAD\";\n/// HTTP GET, POST, and OPTIONS methods.\npub const GET_POST_OPTIONS: &str = \"GET, POST, OPTIONS\";\n/// HTTP GET, POST, and CONNECT methods.\npub const GET_POST_CONNECT: &str = \"GET, POST, CONNECT\";\n/// HTTP GET, POST, and TRACE methods.\npub const GET_POST_TRACE: &str = \"GET, POST, TRACE\";\n/// HTTP GET, PUT, and DELETE methods.\npub const GET_PUT_DELETE: &str = \"GET, PUT, DELETE\";\n/// HTTP GET, PUT, and PATCH methods.\npub const GET_PUT_PATCH: &str = \"GET, PUT, PATCH\";\n/// HTTP GET, PUT, and HEAD methods.\npub const GET_PUT_HEAD: &str = \"GET, PUT, HEAD\";\n/// HTTP GET, PUT, and OPTIONS methods.\npub const GET_PUT_OPTIONS: &str = \"GET, PUT, OPTIONS\";\n/// HTTP GET, PUT, and CONNECT methods.\npub const GET_PUT_CONNECT: &str = \"GET, PUT, CONNECT\";\n/// HTTP GET, PUT, and TRACE methods.\npub const GET_PUT_TRACE: &str = \"GET, PUT, TRACE\";\n/// HTTP GET, DELETE, and PATCH methods.\npub const GET_DELETE_PATCH: &str = \"GET, DELETE, PATCH\";\n/// HTTP GET, DELETE, and HEAD methods.\npub const GET_DELETE_HEAD: &str = \"GET, DELETE, HEAD\";\n/// HTTP GET, DELETE, and OPTIONS methods.\npub const GET_DELETE_OPTIONS: &str = \"GET, DELETE, OPTIONS\";\n/// HTTP GET, DELETE, and CONNECT methods.\npub const GET_DELETE_CONNECT: &str = \"GET, DELETE, CONNECT\";\n/// HTTP GET, DELETE, and TRACE methods.\npub const GET_DELETE_TRACE: &str = \"GET, DELETE, TRACE\";\n/// HTTP PATCH, and HEAD methods.\npub const GET_PATCH_HEAD: &str = \"GET, PATCH, HEAD\";\n/// HTTP GET, PATCH, and OPTIONS methods.\npub const GET_PATCH_OPTIONS: &str = \"GET, PATCH, OPTIONS\";\n/// HTTP GET, PATCH, and CONNECT methods.\npub const GET_PATCH_CONNECT: &str = \"GET, PATCH, CONNECT\";\n/// HTTP GET, PATCH, and TRACE methods.\npub const GET_PATCH_TRACE: &str = \"GET, PATCH, TRACE\";\n/// HTTP GET, HEAD, and OPTIONS methods.\npub const GET_HEAD_OPTIONS: &str = \"GET, HEAD, OPTIONS\";\n/// HTTP GET, HEAD, and CONNECT methods.\npub const GET_HEAD_CONNECT: &str = \"GET, HEAD, CONNECT\";\n/// HTTP HEAD and TRACE methods.\npub const GET_HEAD_TRACE: &str = \"GET, HEAD, TRACE\";\n/// HTTP GET, OPTIONS, and CONNECT methods.\npub const GET_OPTIONS_CONNECT: &str = \"GET, OPTIONS, CONNECT\";\n/// HTTP GET, OPTIONS, and TRACE methods.\npub const GET_OPTIONS_TRACE: &str = \"GET, OPTIONS, TRACE\";\n/// HTTP GET, CONNECT, and TRACE methods.\npub const GET_CONNECT_TRACE: &str = \"GET, CONNECT, TRACE\";\n/// HTTP POST, PUT, and DELETE methods.\npub const POST_PUT_DELETE: &str = \"POST, PUT, DELETE\";\n/// HTTP POST, PUT, and PATCH methods.\npub const POST_PUT_PATCH: &str = \"POST, PUT, PATCH\";\n/// HTTP POST, PUT, and HEAD methods.\npub const POST_PUT_HEAD: &str = \"POST, PUT, HEAD\";\n/// HTTP POST, PUT, and OPTIONS methods.\npub const POST_PUT_OPTIONS: &str = \"POST, PUT, OPTIONS\";\n/// HTTP POST, PUT, and CONNECT methods.\npub const POST_PUT_CONNECT: &str = \"POST, PUT, CONNECT\";\n/// HTTP POST, PUT, and TRACE methods.\npub const POST_PUT_TRACE: &str = \"POST, PUT, TRACE\";\n/// HTTP POST, DELETE, and PATCH methods.\npub const POST_DELETE_PATCH: &str = \"POST, DELETE, PATCH\";\n/// HTTP POST, DELETE, and HEAD methods.\npub const POST_DELETE_HEAD: &str = \"POST, DELETE, HEAD\";\n/// HTTP POST, DELETE, and OPTIONS methods.\npub const POST_DELETE_OPTIONS: &str = \"POST, DELETE, OPTIONS\";\n/// HTTP POST, DELETE, and CONNECT methods.\npub const POST_DELETE_CONNECT: &str = \"POST, DELETE, CONNECT\";\n/// HTTP POST, DELETE, and TRACE methods.\npub const POST_DELETE_TRACE: &str = \"POST, DELETE, TRACE\";\n/// HTTP POST, PATCH, and HEAD methods.\npub const POST_PATCH_HEAD: &str = \"POST, PATCH, HEAD\";\n/// HTTP POST, PATCH, and OPTIONS methods.\npub const POST_PATCH_OPTIONS: &str = \"POST, PATCH, OPTIONS\";\n/// HTTP POST, PATCH, and CONNECT methods.\npub const POST_PATCH_CONNECT: &str = \"POST, PATCH, CONNECT\";\n/// HTTP POST, PATCH, and TRACE methods.\npub const POST_PATCH_TRACE: &str = \"POST, PATCH, TRACE\";\n/// HTTP POST, HEAD, and OPTIONS methods.\npub const POST_HEAD_OPTIONS: &str = \"POST, HEAD, OPTIONS\";\n/// HTTP POST, HEAD, and CONNECT methods.\npub const POST_HEAD_CONNECT: &str = \"POST, HEAD, CONNECT\";\n/// HTTP POST, HEAD, and TRACE methods.\npub const POST_HEAD_TRACE: &str = \"POST, HEAD, TRACE\";\n/// HTTP POST, OPTIONS, and CONNECT methods.\npub const POST_OPTIONS_CONNECT: &str = \"POST, OPTIONS, CONNECT\";\n/// HTTP POST, OPTIONS, and TRACE methods.\npub const POST_OPTIONS_TRACE: &str = \"POST, OPTIONS, TRACE\";\n/// HTTP POST, CONNECT, and TRACE methods.\npub const POST_CONNECT_TRACE: &str = \"POST, CONNECT, TRACE\";\n/// HTTP PUT, DELETE, and PATCH methods.\npub const PUT_DELETE_PATCH: &str = \"PUT, DELETE, PATCH\";\n/// HTTP PUT, DELETE, and HEAD methods.\npub const PUT_DELETE_HEAD: &str = \"PUT, DELETE, HEAD\";\n/// HTTP PUT, DELETE, and OPTIONS methods.\npub const PUT_DELETE_OPTIONS: &str = \"PUT, DELETE, OPTIONS\";\n/// HTTP PUT, DELETE, and CONNECT methods.\npub const PUT_DELETE_CONNECT: &str = \"PUT, DELETE, CONNECT\";\n/// HTTP PUT, DELETE, and TRACE methods.\npub const PUT_DELETE_TRACE: &str = \"PUT, DELETE, TRACE\";\n/// HTTP PUT, PATCH, and HEAD methods.\npub const PUT_PATCH_HEAD: &str = \"PUT, PATCH, HEAD\";\n/// HTTP PUT, PATCH, and OPTIONS methods.\npub const PUT_PATCH_OPTIONS: &str = \"PUT, PATCH, OPTIONS\";\n/// HTTP PUT, PATCH, and CONNECT methods.\npub const PUT_PATCH_CONNECT: &str = \"PUT, PATCH, CONNECT\";\n/// HTTP PUT, PATCH, and TRACE methods.\npub const PUT_PATCH_TRACE: &str = \"PUT, PATCH, TRACE\";\n/// HTTP PUT, HEAD, and OPTIONS methods.\npub const PUT_HEAD_OPTIONS: &str = \"PUT, HEAD, OPTIONS\";\n/// HTTP PUT, HEAD, and CONNECT methods.\npub const PUT_HEAD_CONNECT: &str = \"PUT, HEAD, CONNECT\";\n/// HTTP PUT, HEAD, and TRACE methods.\npub const PUT_HEAD_TRACE: &str = \"PUT, HEAD, TRACE\";\n/// HTTP PUT, OPTIONS, and CONNECT methods.\npub const PUT_OPTIONS_CONNECT: &str = \"PUT, OPTIONS, CONNECT\";\n/// HTTP PUT, OPTIONS, and TRACE methods.\npub const PUT_OPTIONS_TRACE: &str = \"PUT, OPTIONS, TRACE\";\n/// HTTP PUT, CONNECT, and TRACE methods.\npub const PUT_CONNECT_TRACE: &str = \"PUT, CONNECT, TRACE\";\n/// HTTP DELETE, PATCH, and HEAD methods.\npub const DELETE_PATCH_HEAD: &str = \"DELETE, PATCH, HEAD\";\n/// HTTP DELETE, PATCH, and OPTIONS methods.\npub const DELETE_PATCH_OPTIONS: &str = \"DELETE, PATCH, OPTIONS\";\n/// HTTP DELETE, PATCH, and CONNECT methods.\npub const DELETE_PATCH_CONNECT: &str = \"DELETE, PATCH, CONNECT\";\n/// HTTP DELETE, PATCH, and TRACE methods.\npub const DELETE_PATCH_TRACE: &str = \"DELETE, PATCH, TRACE\";\n/// HTTP DELETE, HEAD, and OPTIONS methods.\npub const DELETE_HEAD_OPTIONS: &str = \"DELETE, HEAD, OPTIONS\";\n/// HTTP DELETE, HEAD, and CONNECT methods.\npub const DELETE_HEAD_CONNECT: &str = \"DELETE, HEAD, CONNECT\";\n/// HTTP DELETE, HEAD, and TRACE methods.\npub const DELETE_HEAD_TRACE: &str = \"DELETE, HEAD, TRACE\";\n/// HTTP DELETE, OPTIONS, and CONNECT methods.\npub const DELETE_OPTIONS_CONNECT: &str = \"DELETE, OPTIONS, CONNECT\";\n/// HTTP DELETE, OPTIONS, and TRACE methods.\npub const DELETE_OPTIONS_TRACE: &str = \"DELETE, OPTIONS, TRACE\";\n/// HTTP DELETE, CONNECT, and TRACE methods.\npub const DELETE_CONNECT_TRACE: &str = \"DELETE, CONNECT, TRACE\";\n/// HTTP PATCH, HEAD, and OPTIONS methods.\npub const PATCH_HEAD_OPTIONS: &str = \"PATCH, HEAD, OPTIONS\";\n/// HTTP PATCH, HEAD, and CONNECT methods.\npub const PATCH_HEAD_CONNECT: &str = \"PATCH, HEAD, CONNECT\";\n/// HTTP PATCH, HEAD, and TRACE methods.\npub const PATCH_HEAD_TRACE: &str = \"PATCH, HEAD, TRACE\";\n/// HTTP PATCH, OPTIONS, and CONNECT methods.\npub const PATCH_OPTIONS_CONNECT: &str = \"PATCH, OPTIONS, CONNECT\";\n/// HTTP PATCH, OPTIONS, and TRACE methods.\npub const PATCH_OPTIONS_TRACE: &str = \"PATCH, OPTIONS, TRACE\";\n/// HTTP PATCH, CONNECT, and TRACE methods.\npub const PATCH_CONNECT_TRACE: &str = \"PATCH, CONNECT, TRACE\";\n/// HTTP HEAD, OPTIONS, and CONNECT methods.\npub const HEAD_OPTIONS_CONNECT: &str = \"HEAD, OPTIONS, CONNECT\";\n/// HTTP HEAD, OPTIONS, and TRACE methods.\npub const HEAD_OPTIONS_TRACE: &str = \"HEAD, OPTIONS, TRACE\";\n/// HTTP HEAD, CONNECT, and TRACE methods.\npub const HEAD_CONNECT_TRACE: &str = \"HEAD, CONNECT, TRACE\";\n/// HTTP OPTIONS, CONNECT, and TRACE methods.\npub const OPTIONS_CONNECT_TRACE: &str = \"OPTIONS, CONNECT, TRACE\";\n/// HTTP GET, POST, PUT, and DELETE methods.\npub const GET_POST_PUT_DELETE: &str = \"GET, POST, PUT, DELETE\";\n/// HTTP GET, POST, PUT, and PATCH methods.\npub const GET_POST_PUT_PATCH: &str = \"GET, POST, PUT, PATCH\";\n/// HTTP GET, POST, PUT, and HEAD methods.\npub const GET_POST_PUT_HEAD: &str = \"GET, POST, PUT, HEAD\";\n/// HTTP GET, POST, PUT, and OPTIONS methods.\npub const GET_POST_PUT_OPTIONS: &str = \"GET, POST, PUT, OPTIONS\";\n/// HTTP GET, POST, PUT, and CONNECT methods.\npub const GET_POST_PUT_CONNECT: &str = \"GET, POST, PUT, CONNECT\";\n/// HTTP GET, POST, PUT, and TRACE methods.\npub const GET_POST_PUT_TRACE: &str = \"GET, POST, PUT, TRACE\";\n/// HTTP GET, POST, DELETE, and PATCH methods.\npub const GET_POST_DELETE_PATCH: &str = \"GET, POST, DELETE, PATCH\";\n/// HTTP GET, POST, DELETE, and HEAD methods.\npub const GET_POST_DELETE_HEAD: &str = \"GET, POST, DELETE, HEAD\";\n/// HTTP GET, POST, DELETE, and OPTIONS methods.\npub const GET_POST_DELETE_OPTIONS: &str = \"GET, POST, DELETE, OPTIONS\";\n/// HTTP GET, POST, DELETE, and CONNECT methods.\npub const GET_POST_DELETE_CONNECT: &str = \"GET, POST, DELETE, CONNECT\";\n/// HTTP GET, POST, DELETE, and TRACE methods.\npub const GET_POST_DELETE_TRACE: &str = \"GET, POST, DELETE, TRACE\";\n/// HTTP GET, POST, PATCH, and HEAD methods.\npub const GET_POST_PATCH_HEAD: &str = \"GET, POST, PATCH, HEAD\";\n/// HTTP GET, POST, PATCH, and OPTIONS methods.\npub const GET_POST_PATCH_OPTIONS: &str = \"GET, POST, PATCH, OPTIONS\";\n/// HTTP GET, POST, PATCH, and CONNECT methods.\npub const GET_POST_PATCH_CONNECT: &str = \"GET, POST, PATCH, CONNECT\";\n/// HTTP GET, POST, PATCH, and TRACE methods.\npub const GET_POST_PATCH_TRACE: &str = \"GET, POST, PATCH, TRACE\";\n/// HTTP GET, POST, HEAD, and OPTIONS methods.\npub const GET_POST_HEAD_OPTIONS: &str = \"GET, POST, HEAD, OPTIONS\";\n/// HTTP GET, POST, HEAD, and CONNECT methods.\npub const GET_POST_HEAD_CONNECT: &str = \"GET, POST, HEAD, CONNECT\";\n/// HTTP GET, POST, HEAD, and TRACE methods.\npub const GET_POST_HEAD_TRACE: &str = \"GET, POST, HEAD, TRACE\";\n/// HTTP GET, POST, OPTIONS, and CONNECT methods.\npub const GET_POST_OPTIONS_CONNECT: &str = \"GET, POST, OPTIONS, CONNECT\";\n/// HTTP GET, POST, OPTIONS, and TRACE methods.\npub const GET_POST_OPTIONS_TRACE: &str = \"GET, POST, OPTIONS, TRACE\";\n/// HTTP GET, POST, CONNECT, and TRACE methods.\npub const GET_POST_CONNECT_TRACE: &str = \"GET, POST, CONNECT, TRACE\";\n/// HTTP GET, PUT, DELETE, and PATCH methods.\npub const GET_PUT_DELETE_PATCH: &str = \"GET, PUT, DELETE, PATCH\";\n/// HTTP GET, PUT, DELETE, and HEAD methods.\npub const GET_PUT_DELETE_HEAD: &str = \"GET, PUT, DELETE, HEAD\";\n/// HTTP GET, PUT, DELETE, and OPTIONS methods.\npub const GET_PUT_DELETE_OPTIONS: &str = \"GET, PUT, DELETE, OPTIONS\";\n/// HTTP GET, PUT, DELETE, and CONNECT methods.\npub const GET_PUT_DELETE_CONNECT: &str = \"GET, PUT, DELETE, CONNECT\";\n/// HTTP GET, PUT, DELETE, and TRACE methods.\npub const GET_PUT_DELETE_TRACE: &str = \"GET, PUT, DELETE, TRACE\";\n/// HTTP GET, PUT, PATCH, and HEAD methods.\npub const GET_PUT_PATCH_HEAD: &str = \"GET, PUT, PATCH, HEAD\";\n/// HTTP GET, PUT, PATCH, and OPTIONS methods.\npub const GET_PUT_PATCH_OPTIONS: &str = \"GET, PUT, PATCH, OPTIONS\";\n/// HTTP GET, PUT, PATCH, and CONNECT methods.\npub const GET_PUT_PATCH_CONNECT: &str = \"GET, PUT, PATCH, CONNECT\";\n/// HTTP GET, PUT, PATCH, and TRACE methods.\npub const GET_PUT_PATCH_TRACE: &str = \"GET, PUT, PATCH, TRACE\";\n/// HTTP GET, PUT, HEAD, and OPTIONS methods.\npub const GET_PUT_HEAD_OPTIONS: &str = \"GET, PUT, HEAD, OPTIONS\";\n/// HTTP GET, PUT, HEAD, and CONNECT methods.\npub const GET_PUT_HEAD_CONNECT: &str = \"GET, PUT, HEAD, CONNECT\";\n/// HTTP GET, PUT, HEAD, and TRACE methods.\npub const GET_PUT_HEAD_TRACE: &str = \"GET, PUT, HEAD, TRACE\";\n/// HTTP GET, PUT, OPTIONS, and CONNECT methods.\npub const GET_PUT_OPTIONS_CONNECT: &str = \"GET, PUT, OPTIONS, CONNECT\";\n/// HTTP GET, PUT, OPTIONS, and TRACE methods.\npub const GET_PUT_OPTIONS_TRACE: &str = \"GET, PUT, OPTIONS, TRACE\";\n/// HTTP GET, PUT, CONNECT, and TRACE methods.\npub const GET_PUT_CONNECT_TRACE: &str = \"GET, PUT, CONNECT, TRACE\";\n/// HTTP GET, DELETE, PATCH, and HEAD methods.\npub const GET_DELETE_PATCH_HEAD: &str = \"GET, DELETE, PATCH, HEAD\";\n/// HTTP GET, DELETE, PATCH, and OPTIONS methods.\npub const GET_DELETE_PATCH_OPTIONS: &str = \"GET, DELETE, PATCH, OPTIONS\";\n/// HTTP GET, DELETE, PATCH, and CONNECT methods.\npub const GET_DELETE_PATCH_CONNECT: &str = \"GET, DELETE, PATCH, CONNECT\";\n/// HTTP GET, DELETE, PATCH, and TRACE methods.\npub const GET_DELETE_PATCH_TRACE: &str = \"GET, DELETE, PATCH, TRACE\";\n/// HTTP GET, DELETE, HEAD, and OPTIONS methods.\npub const GET_DELETE_HEAD_OPTIONS: &str = \"GET, DELETE, HEAD, OPTIONS\";\n/// HTTP GET, DELETE, HEAD, and CONNECT methods.\npub const GET_DELETE_HEAD_CONNECT: &str = \"GET, DELETE, HEAD, CONNECT\";\n/// HTTP GET, DELETE, HEAD, and TRACE methods.\npub const GET_DELETE_HEAD_TRACE: &str = \"GET, DELETE, HEAD, TRACE\";\n/// HTTP GET, DELETE, OPTIONS, and CONNECT methods.\npub const GET_DELETE_OPTIONS_CONNECT: &str = \"GET, DELETE, OPTIONS, CONNECT\";\n/// HTTP GET, DELETE, OPTIONS, and TRACE methods.\npub const GET_DELETE_OPTIONS_TRACE: &str = \"GET, DELETE, OPTIONS, TRACE\";\n/// HTTP GET, DELETE, CONNECT, and TRACE methods.\npub const GET_DELETE_CONNECT_TRACE: &str = \"GET, DELETE, CONNECT, TRACE\";\n/// HTTP GET, PATCH, HEAD, and OPTIONS methods.\npub const GET_PATCH_HEAD_OPTIONS: &str = \"GET, PATCH, HEAD, OPTIONS\";\n/// HTTP GET, PATCH, HEAD, and CONNECT methods.\npub const GET_PATCH_HEAD_CONNECT: &str = \"GET, PATCH, HEAD, CONNECT\";\n/// HTTP GET, PATCH, HEAD, and TRACE methods.\npub const GET_PATCH_HEAD_TRACE: &str = \"GET, PATCH, HEAD, TRACE\";\n/// HTTP GET, PATCH, OPTIONS, and CONNECT methods.\npub const GET_PATCH_OPTIONS_CONNECT: &str = \"GET, PATCH, OPTIONS, CONNECT\";\n/// HTTP GET, PATCH, OPTIONS, and TRACE methods.\npub const GET_PATCH_OPTIONS_TRACE: &str = \"GET, PATCH, OPTIONS, TRACE\";\n/// HTTP GET, PATCH, CONNECT, and TRACE methods.\npub const GET_PATCH_CONNECT_TRACE: &str = \"GET, PATCH, CONNECT, TRACE\";\n/// HTTP GET, HEAD, OPTIONS, and CONNECT methods.\npub const GET_HEAD_OPTIONS_CONNECT: &str = \"GET, HEAD, OPTIONS, CONNECT\";\n/// HTTP GET, HEAD, OPTIONS, and TRACE methods.\npub const GET_HEAD_OPTIONS_TRACE: &str = \"GET, HEAD, OPTIONS, TRACE\";\n/// HTTP GET, HEAD, CONNECT, and TRACE methods.\npub const GET_HEAD_CONNECT_TRACE: &str = \"GET, HEAD, CONNECT, TRACE\";\n/// HTTP GET, OPTIONS, CONNECT, and TRACE methods.\npub const GET_OPTIONS_CONNECT_TRACE: &str = \"GET, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, PUT, DELETE, PATCH, HEAD, and OPTIONS methods.\npub const POST_PUT_DELETE_PATCH_HEAD_OPTIONS: &str = \"POST, PUT, DELETE, PATCH, HEAD, OPTIONS\";\n/// HTTP POST, PUT, DELETE, PATCH, HEAD, and CONNECT methods.\npub const POST_PUT_DELETE_PATCH_HEAD_CONNECT: &str = \"POST, PUT, DELETE, PATCH, HEAD, CONNECT\";\n/// HTTP POST, PUT, DELETE, PATCH, HEAD, and TRACE methods.\npub const POST_PUT_DELETE_PATCH_HEAD_TRACE: &str = \"POST, PUT, DELETE, PATCH, HEAD, TRACE\";\n/// HTTP POST, PUT, DELETE, PATCH, OPTIONS, and CONNECT methods.\npub const POST_PUT_DELETE_PATCH_OPTIONS_CONNECT: &str =\n    \"POST, PUT, DELETE, PATCH, OPTIONS, CONNECT\";\n/// HTTP POST, PUT, DELETE, PATCH, OPTIONS, and TRACE methods.\npub const POST_PUT_DELETE_PATCH_OPTIONS_TRACE: &str = \"POST, PUT, DELETE, PATCH, OPTIONS, TRACE\";\n/// HTTP POST, PUT, DELETE, PATCH, CONNECT, and TRACE methods.\npub const POST_PUT_DELETE_PATCH_CONNECT_TRACE: &str = \"POST, PUT, DELETE, PATCH, CONNECT, TRACE\";\n/// HTTP POST, PUT, DELETE, HEAD, OPTIONS, and CONNECT methods.\npub const POST_PUT_DELETE_HEAD_OPTIONS_CONNECT: &str = \"POST, PUT, DELETE, HEAD, OPTIONS, CONNECT\";\n/// HTTP POST, PUT, DELETE, HEAD, OPTIONS, and TRACE methods.\npub const POST_PUT_DELETE_HEAD_OPTIONS_TRACE: &str = \"POST, PUT, DELETE, HEAD, OPTIONS, TRACE\";\n/// HTTP POST, PUT, DELETE, HEAD, CONNECT, and TRACE methods.\npub const POST_PUT_DELETE_HEAD_CONNECT_TRACE: &str = \"POST, PUT, DELETE, HEAD, CONNECT, TRACE\";\n/// HTTP POST, PUT, DELETE, OPTIONS, CONNECT, and TRACE methods.\npub const POST_PUT_DELETE_OPTIONS_CONNECT_TRACE: &str =\n    \"POST, PUT, DELETE, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, PUT, PATCH, HEAD, OPTIONS, and CONNECT methods.\npub const POST_PUT_PATCH_HEAD_OPTIONS_CONNECT: &str = \"POST, PUT, PATCH, HEAD, OPTIONS, CONNECT\";\n/// HTTP POST, PUT, PATCH, HEAD, OPTIONS, and TRACE methods.\npub const POST_PUT_PATCH_HEAD_OPTIONS_TRACE: &str = \"POST, PUT, PATCH, HEAD, OPTIONS, TRACE\";\n/// HTTP POST, PUT, PATCH, HEAD, CONNECT, and TRACE methods.\npub const POST_PUT_PATCH_HEAD_CONNECT_TRACE: &str = \"POST, PUT, PATCH, HEAD, CONNECT, TRACE\";\n/// HTTP POST, PUT, PATCH, OPTIONS, CONNECT, and TRACE methods.\npub const POST_PUT_PATCH_OPTIONS_CONNECT_TRACE: &str = \"POST, PUT, PATCH, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, PUT, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const POST_PUT_HEAD_OPTIONS_CONNECT_TRACE: &str = \"POST, PUT, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, DELETE, PATCH, HEAD, OPTIONS, and CONNECT methods.\npub const POST_DELETE_PATCH_HEAD_OPTIONS_CONNECT: &str =\n    \"POST, DELETE, PATCH, HEAD, OPTIONS, CONNECT\";\n/// HTTP POST, DELETE, PATCH, HEAD, OPTIONS, and TRACE methods.\npub const POST_DELETE_PATCH_HEAD_OPTIONS_TRACE: &str = \"POST, DELETE, PATCH, HEAD, OPTIONS, TRACE\";\n/// HTTP POST, DELETE, PATCH, HEAD, CONNECT, and TRACE methods.\npub const POST_DELETE_PATCH_HEAD_CONNECT_TRACE: &str = \"POST, DELETE, PATCH, HEAD, CONNECT, TRACE\";\n/// HTTP POST, DELETE, PATCH, OPTIONS, CONNECT, and TRACE methods.\npub const POST_DELETE_PATCH_OPTIONS_CONNECT_TRACE: &str =\n    \"POST, DELETE, PATCH, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, DELETE, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const POST_DELETE_HEAD_OPTIONS_CONNECT_TRACE: &str =\n    \"POST, DELETE, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP POST, PATCH, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const POST_PATCH_HEAD_OPTIONS_CONNECT_TRACE: &str =\n    \"POST, PATCH, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP PUT, DELETE, PATCH, HEAD, OPTIONS, and CONNECT methods.\npub const PUT_DELETE_PATCH_HEAD_OPTIONS_CONNECT: &str =\n    \"PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT\";\n/// HTTP PUT, DELETE, PATCH, HEAD, OPTIONS, and TRACE methods.\npub const PUT_DELETE_PATCH_HEAD_OPTIONS_TRACE: &str = \"PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE\";\n/// HTTP PUT, DELETE, PATCH, HEAD, CONNECT, and TRACE methods.\npub const PUT_DELETE_PATCH_HEAD_CONNECT_TRACE: &str = \"PUT, DELETE, PATCH, HEAD, CONNECT, TRACE\";\n/// HTTP PUT, DELETE, PATCH, OPTIONS, CONNECT, and TRACE methods.\npub const PUT_DELETE_PATCH_OPTIONS_CONNECT_TRACE: &str =\n    \"PUT, DELETE, PATCH, OPTIONS, CONNECT, TRACE\";\n/// HTTP PUT, DELETE, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const PUT_DELETE_HEAD_OPTIONS_CONNECT_TRACE: &str =\n    \"PUT, DELETE, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP PUT, PATCH, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const PUT_PATCH_HEAD_OPTIONS_CONNECT_TRACE: &str = \"PUT, PATCH, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP DELETE, PATCH, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const DELETE_PATCH_HEAD_OPTIONS_CONNECT_TRACE: &str =\n    \"DELETE, PATCH, HEAD, OPTIONS, CONNECT, TRACE\";\n/// HTTP GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT, and TRACE methods.\npub const GET_POST_PUT_DELETE_PATCH_HEAD_OPTIONS_CONNECT_TRACE: &str =\n    \"GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, CONNECT, TRACE\";\n/// All HTTP methods combined.\npub const ALL_METHODS: &str = GET_POST_PUT_DELETE_PATCH_HEAD_OPTIONS_CONNECT_TRACE;", "file_size": 23196, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\http_status\\const.rs", "language": "rust", "content": "/// HTTP status code 100: Continue.\npub const CONTINUE: &str = \"Continue\";\n/// HTTP status code 101: Switching Protocols.\npub const SWITCHING_PROTOCOLS: &str = \"Switching Protocols\";\n/// HTTP status code 102: Processing.\npub const PROCESSING: &str = \"Processing\";\n/// HTTP status code 103: Early Hints.\npub const EARLY_HINTS: &str = \"Early Hints\";\n/// HTTP status code 200: OK.\npub const OK: &str = \"OK\";\n/// HTTP status code 201: Created.\npub const CREATED: &str = \"Created\";\n/// HTTP status code 202: Accepted.\npub const ACCEPTED: &str = \"Accepted\";\n/// HTTP status code 203: Non-Authoritative Information.\npub const NON_AUTHORITATIVE_INFORMATION: &str = \"Non-Authoritative Information\";\n/// HTTP status code 204: No Content.\npub const NO_CONTENT: &str = \"No Content\";\n/// HTTP status code 205: Reset Content.\npub const RESET_CONTENT: &str = \"Reset Content\";\n/// HTTP status code 206: Partial Content.\npub const PARTIAL_CONTENT: &str = \"Partial Content\";\n/// HTTP status code 207: Multi-Status.\npub const MULTI_STATUS: &str = \"Multi-Status\";\n/// HTTP status code 208: Already Reported.\npub const ALREADY_REPORTED: &str = \"Already Reported\";\n/// HTTP status code 226: IM Used.\npub const IM_USED: &str = \"IM Used\";\n/// HTTP status code 300: Multiple Choices.\npub const MULTIPLE_CHOICES: &str = \"Multiple Choices\";\n/// HTTP status code 301: Moved Permanently.\npub const MOVED_PERMANENTLY: &str = \"Moved Permanently\";\n/// HTTP status code 302: Found.\npub const FOUND: &str = \"Found\";\n/// HTTP status code 303: See Other.\npub const SEE_OTHER: &str = \"See Other\";\n/// HTTP status code 304: Not Modified.\npub const NOT_MODIFIED: &str = \"Not Modified\";\n/// HTTP status code 305: Use Proxy.\npub const USE_PROXY: &str = \"Use Proxy\";\n/// HTTP status code 307: Temporary Redirect.\npub const TEMPORARY_REDIRECT: &str = \"Temporary Redirect\";\n/// HTTP status code 308: Permanent Redirect.\npub const PERMANENT_REDIRECT: &str = \"Permanent Redirect\";\n/// HTTP status code 400: Bad Request.\npub const BAD_REQUEST: &str = \"Bad Request\";\n/// HTTP status code 401: Unauthorized.\npub const UNAUTHORIZED: &str = \"Unauthorized\";\n/// HTTP status code 402: Payment Required.\npub const PAYMENT_REQUIRED: &str = \"Payment Required\";\n/// HTTP status code 403: Forbidden.\npub const FORBIDDEN: &str = \"Forbidden\";\n/// HTTP status code 404: Not Found.\npub const NOT_FOUND: &str = \"Not Found\";\n/// HTTP status code 405: Method Not Allowed.\npub const METHOD_NOT_ALLOWED: &str = \"Method Not Allowed\";\n/// HTTP status code 406: Not Acceptable.\npub const NOT_ACCEPTABLE: &str = \"Not Acceptable\";\n/// HTTP status code 407: Proxy Authentication Required.\npub const PROXY_AUTHENTICATION_REQUIRED: &str = \"Proxy Authentication Required\";\n/// HTTP status code 408: Request Timeout.\npub const REQUEST_TIMEOUT: &str = \"Request Timeout\";\n/// HTTP status code 409: Conflict.\npub const CONFLICT: &str = \"Conflict\";\n/// HTTP status code 410: Gone.\npub const GONE: &str = \"Gone\";\n/// HTTP status code 411: Length Required.\npub const LENGTH_REQUIRED: &str = \"Length Required\";\n/// HTTP status code 412: Precondition Failed.\npub const PRECONDITION_FAILED: &str = \"Precondition Failed\";\n/// HTTP status code 413: Payload Too Large.\npub const PAYLOAD_TOO_LARGE: &str = \"Payload Too Large\";\n/// HTTP status code 414: URI Too Long.\npub const URI_TOO_LONG: &str = \"URI Too Long\";\n/// HTTP status code 415: Unsupported Media Type.\npub const UNSUPPORTED_MEDIA_TYPE: &str = \"Unsupported Media Type\";\n/// HTTP status code 416: Range Not Satisfiable.\npub const RANGE_NOT_SATISFIABLE: &str = \"Range Not Satisfiable\";\n/// HTTP status code 417: Expectation Failed.\npub const EXPECTATION_FAILED: &str = \"Expectation Failed\";\n/// HTTP status code 418: I'm a teapot.\npub const IM_A_TEAPOT: &str = \"I'm a teapot\";\n/// HTTP status code 421: Misdirected Request.\npub const MISDIRECTED_REQUEST: &str = \"Misdirected Request\";\n/// HTTP status code 422: Unprocessable Entity.\npub const UNPROCESSABLE_ENTITY: &str = \"Unprocessable Entity\";\n/// HTTP status code 423: Locked.\npub const LOCKED: &str = \"Locked\";\n/// HTTP status code 424: Failed Dependency.\npub const FAILED_DEPENDENCY: &str = \"Failed Dependency\";\n/// HTTP status code 425: Too Early.\npub const TOO_EARLY: &str = \"Too Early\";\n/// HTTP status code 426: Upgrade Required.\npub const UPGRADE_REQUIRED: &str = \"Upgrade Required\";\n/// HTTP status code 428: Precondition Required.\npub const PRECONDITION_REQUIRED: &str = \"Precondition Required\";\n/// HTTP status code 429: Too Many Requests.\npub const TOO_MANY_REQUESTS: &str = \"Too Many Requests\";\n/// HTTP status code 431: Request Header Fields Too Large.\npub const REQUEST_HEADER_FIELDS_TOO_LARGE: &str = \"Request Header Fields Too Large\";\n/// HTTP status code 451: Unavailable For Legal Reasons.\npub const UNAVAILABLE_FOR_LEGAL_REASONS: &str = \"Unavailable For Legal Reasons\";\n/// HTTP status code 500: Internal Server Error.\npub const INTERNAL_SERVER_ERROR: &str = \"Internal Server Error\";\n/// HTTP status code 501: Not Implemented.\npub const NOT_IMPLEMENTED: &str = \"Not Implemented\";\n/// HTTP status code 502: Bad Gateway.\npub const BAD_GATEWAY: &str = \"Bad Gateway\";\n/// HTTP status code 503: Service Unavailable.\npub const SERVICE_UNAVAILABLE: &str = \"Service Unavailable\";\n/// HTTP status code 504: Gateway Timeout.\npub const GATEWAY_TIMEOUT: &str = \"Gateway Timeout\";\n/// HTTP status code 505: HTTP Version Not Supported.\npub const HTTP_VERSION_NOT_SUPPORTED: &str = \"HTTP Version Not Supported\";\n/// HTTP status code 506: Variant Also Negotiates.\npub const VARIANT_ALSO_NEGOTIATES: &str = \"Variant Also Negotiates\";\n/// HTTP status code 507: Insufficient Storage.\npub const INSUFFICIENT_STORAGE: &str = \"Insufficient Storage\";\n/// HTTP status code 508: Loop Detected.\npub const LOOP_DETECTED: &str = \"Loop Detected\";\n/// HTTP status code 510: Not Extended.\npub const NOT_EXTENDED: &str = \"Not Extended\";\n/// HTTP status code 511: Network Authentication Required.\npub const NETWORK_AUTHENTICATION_REQUIRED: &str = \"Network Authentication Required\";\n/// HTTP status code for unknown status.\npub const UNKNOWN: &str = \"Unknown\";", "file_size": 6067, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\header_value\\const.rs", "language": "rust", "content": "/// Basic authentication scheme.\npub const BASIC: &str = \"Basic\";\n\n/// Indicates no-cache.\npub const NO_CACHE: &str = \"no-cache\";\n\n/// Indicates keep-alive connection.\npub const KEEP_ALIVE: &str = \"keep-alive\";\n\n/// Indicates chunked transfer encoding.\npub const CHUNKED: &str = \"chunked\";\n\n/// Deny page from being framed.\npub const DENY: &str = \"DENY\";\n\n/// Prevent MIME sniffing.\npub const NOSNIFF: &str = \"nosniff\";\n\n/// Indicates an XMLHttpRequest (AJAX).\npub const XMLHTTPREQUEST: &str = \"XMLHttpRequest\";\n\n/// Gzip compression.\npub const GZIP: &str = \"gzip\";\n\n/// Deflate compression.\npub const DEFLATE: &str = \"deflate\";\n\n/// Brotli compression.\npub const BROTLI: &str = \"br\";\n\n/// No encoding (identity).\npub const IDENTITY: &str = \"identity\";\n\n/// Accept any content type.\npub const ACCEPT_ANY: &str = \"*/*\";\n\n/// Wildcard any.\npub const WILDCARD_ANY: &str = \"*\";\n\n/// Prefer English language.\npub const ENGLISH: &str = \"en\";\n\n/// Bearer token authentication.\npub const BEARER: &str = \"Bearer\";\n\n/// Private caching.\npub const PRIVATE: &str = \"private\";\n\n/// Public caching.\npub const PUBLIC: &str = \"public\";\n\n/// Close the connection.\npub const CLOSE: &str = \"close\";\n\n/// Allow framing only by same origin.\npub const SAMEORIGIN: &str = \"SAMEORIGIN\";\n\n/// Charset\npub const CHARSET: &str = \"charset\";\n\n/// Charset Equal\npub const CHARSET_EQUAL: &str = \"charset=\";\n\n/// UTF-8\npub const UTF8: &str = \"utf-8\";\n\n/// ASCII\npub const ASCII: &str = \"us-ascii\";\n\n/// ISO-8859-1 (Latin-1)\npub const ISO_8859_1: &str = \"iso-8859-1\";\n\n/// ISO-8859-2 (Latin-2, Central European)\npub const ISO_8859_2: &str = \"iso-8859-2\";\n\n/// ISO-8859-3 (Latin-3, South European)\npub const ISO_8859_3: &str = \"iso-8859-3\";\n\n/// ISO-8859-4 (Latin-4, North European)\npub const ISO_8859_4: &str = \"iso-8859-4\";\n\n/// ISO-8859-5 (Cyrillic)\npub const ISO_8859_5: &str = \"iso-8859-5\";\n\n/// ISO-8859-6 (Arabic)\npub const ISO_8859_6: &str = \"iso-8859-6\";\n\n/// ISO-8859-7 (Greek)\npub const ISO_8859_7: &str = \"iso-8859-7\";\n\n/// ISO-8859-8 (Hebrew)\npub const ISO_8859_8: &str = \"iso-8859-8\";\n\n/// ISO-8859-9 (Latin-5, Turkish)\npub const ISO_8859_9: &str = \"iso-8859-9\";\n\n/// ISO-8859-10 (Latin-6, Nordic)\npub const ISO_8859_10: &str = \"iso-8859-10\";\n\n/// ISO-8859-11 (Thai)\npub const ISO_8859_11: &str = \"iso-8859-11\";\n\n/// ISO-8859-13 (Latin-7, Baltic Rim)\npub const ISO_8859_13: &str = \"iso-8859-13\";\n\n/// ISO-8859-14 (Latin-8, Celtic)\npub const ISO_8859_14: &str = \"iso-8859-14\";\n\n/// ISO-8859-15 (Latin-9, Western European with € symbol)\npub const ISO_8859_15: &str = \"iso-8859-15\";\n\n/// ISO-8859-16 (Latin-10, South-Eastern European)\npub const ISO_8859_16: &str = \"iso-8859-16\";\n\n/// Windows-1250 (Central European)\npub const WINDOWS_1250: &str = \"windows-1250\";\n\n/// Windows-1251 (Cyrillic)\npub const WINDOWS_1251: &str = \"windows-1251\";\n\n/// Windows-1252 (Western European)\npub const WINDOWS_1252: &str = \"windows-1252\";\n\n/// Windows-1253 (Greek)\npub const WINDOWS_1253: &str = \"windows-1253\";\n\n/// Windows-1254 (Turkish)\npub const WINDOWS_1254: &str = \"windows-1254\";\n\n/// Windows-1255 (Hebrew)\npub const WINDOWS_1255: &str = \"windows-1255\";\n\n/// Windows-1256 (Arabic)\npub const WINDOWS_1256: &str = \"windows-1256\";\n\n/// Windows-1257 (Baltic)\npub const WINDOWS_1257: &str = \"windows-1257\";\n\n/// Windows-1258 (Vietnamese)\npub const WINDOWS_1258: &str = \"windows-1258\";\n\n/// KOI8-R (Russian)\npub const KOI8_R: &str = \"koi8-r\";\n\n/// KOI8-U (Ukrainian)\npub const KOI8_U: &str = \"koi8-u\";\n\n/// Shift JIS (Japanese)\npub const SHIFT_JIS: &str = \"shift_jis\";\n\n/// EUC-JP (Japanese)\npub const EUC_JP: &str = \"euc-jp\";\n\n/// EUC-KR (Korean)\npub const EUC_KR: &str = \"euc-kr\";\n\n/// GB2312 (Simplified Chinese)\npub const GB2312: &str = \"gb2312\";\n\n/// Big5 (Traditional Chinese)\npub const BIG5: &str = \"big5\";\n\n/// UTF-16 (16-bit Unicode)\npub const UTF16: &str = \"utf-16\";\n\n/// UTF-16LE (UTF-16 Little Endian)\npub const UTF16LE: &str = \"utf-16le\";\n\n/// UTF-16BE (UTF-16 Big Endian)\npub const UTF16BE: &str = \"utf-16be\";\n\n/// UTF-32 (32-bit Unicode)\npub const UTF32: &str = \"utf-32\";\n\n/// UTF-32LE (UTF-32 Little Endian)\npub const UTF32LE: &str = \"utf-32le\";\n\n/// UTF-32BE (UTF-32 Big Endian)\npub const UTF32BE: &str = \"utf-32be\";\n\n/// Charset utf8\npub const CHARSET_UTF_8: &str = \"charset=utf-8\";\n\n/// Charset iso-8859-1\npub const CHARSET_ISO_8859_1: &str = \"charset=iso-8859-1\";\n\n/// Charset windows-1252\npub const CHARSET_WINDOWS_1252: &str = \"charset=windows-1252\";\n\n/// Charset shift_jis\npub const CHARSET_SHIFT_JIS: &str = \"charset=shift_jis\";\n\n/// Charset gb2312\npub const CHARSET_GB2312: &str = \"charset=gb2312\";\n\n/// Charset big5\npub const CHARSET_BIG5: &str = \"charset=big5\";\n\n/// Charset utf-16\npub const CHARSET_UTF_16: &str = \"charset=utf-16\";\n\n/// Charset utf-32\npub const CHARSET_UTF_32: &str = \"charset=utf-32\";\n\n/// Charset macintosh\npub const CHARSET_MACINTOSH: &str = \"charset=macintosh\";\n\n/// Charset euc-kr\npub const CHARSET_EUC_KR: &str = \"charset=euc-kr\";\n\n/// Charset us-ascii\npub const CHARSET_ASCII: &str = \"charset=us-ascii\";\n\n/// Charset iso-8859-2\npub const CHARSET_ISO_8859_2: &str = \"charset=iso-8859-2\";\n\n/// Charset iso-8859-3\npub const CHARSET_ISO_8859_3: &str = \"charset=iso-8859-3\";\n\n/// Charset iso-8859-4\npub const CHARSET_ISO_8859_4: &str = \"charset=iso-8859-4\";\n\n/// Charset iso-8859-5\npub const CHARSET_ISO_8859_5: &str = \"charset=iso-8859-5\";\n\n/// Charset iso-8859-6\npub const CHARSET_ISO_8859_6: &str = \"charset=iso-8859-6\";\n\n/// Charset iso-8859-7\npub const CHARSET_ISO_8859_7: &str = \"charset=iso-8859-7\";\n\n/// Charset iso-8859-8\npub const CHARSET_ISO_8859_8: &str = \"charset=iso-8859-8\";\n\n/// Charset iso-8859-9\npub const CHARSET_ISO_8859_9: &str = \"charset=iso-8859-9\";\n\n/// Charset iso-8859-10\npub const CHARSET_ISO_8859_10: &str = \"charset=iso-8859-10\";\n\n/// Charset iso-8859-11\npub const CHARSET_ISO_8859_11: &str = \"charset=iso-8859-11\";\n\n/// Charset iso-8859-13\npub const CHARSET_ISO_8859_13: &str = \"charset=iso-8859-13\";\n\n/// Charset iso-8859-14\npub const CHARSET_ISO_8859_14: &str = \"charset=iso-8859-14\";\n\n/// Charset iso-8859-15\npub const CHARSET_ISO_8859_15: &str = \"charset=iso-8859-15\";\n\n/// Charset iso-8859-16\npub const CHARSET_ISO_8859_16: &str = \"charset=iso-8859-16\";\n\n/// Charset windows-1250\npub const CHARSET_WINDOWS_1250: &str = \"charset=windows-1250\";\n\n/// Charset windows-1251\npub const CHARSET_WINDOWS_1251: &str = \"charset=windows-1251\";\n\n/// Charset windows-1253\npub const CHARSET_WINDOWS_1253: &str = \"charset=windows-1253\";\n\n/// Charset windows-1254\npub const CHARSET_WINDOWS_1254: &str = \"charset=windows-1254\";\n\n/// Charset windows-1255\npub const CHARSET_WINDOWS_1255: &str = \"charset=windows-1255\";\n\n/// Charset windows-1256\npub const CHARSET_WINDOWS_1256: &str = \"charset=windows-1256\";\n\n/// Charset windows-1257\npub const CHARSET_WINDOWS_1257: &str = \"charset=windows-1257\";\n\n/// Charset windows-1258\npub const CHARSET_WINDOWS_1258: &str = \"charset=windows-1258\";\n\n/// Charset koi8-r\npub const CHARSET_KOI8_R: &str = \"charset=koi8-r\";\n\n/// Charset koi8-u\npub const CHARSET_KOI8_U: &str = \"charset=koi8-u\";\n\n/// Charset euc-jp\npub const CHARSET_EUC_JP: &str = \"charset=euc-jp\";\n\n/// Charset utf-16le\npub const CHARSET_UTF_16LE: &str = \"charset=utf-16le\";\n\n/// Charset utf-16be\npub const CHARSET_UTF_16BE: &str = \"charset=utf-16be\";\n\n/// Charset utf-32le\npub const CHARSET_UTF_32LE: &str = \"charset=utf-32le\";\n\n/// Charset utf-32be\npub const CHARSET_UTF_32BE: &str = \"charset=utf-32be\";\n\n/// H2C\npub const H2C_LOWERCASE: &str = \"h2c\";\n\n/// H2C\npub const H2C_UPPERCASE: &str = \"H2C\";\n\n// TLS\npub const TLS_LOWERCASE: &str = \"tls\";\n\n/// TLS\npub const TLS_UPPERCASE: &str = \"TLS\";\n\n/// TLS/1.0\npub const TLS_1_0: &str = \"TLS/1.0\";\n\n/// TLS/1.1\npub const TLS_1_1: &str = \"TLS/1.1\";\n\n/// TLS/1.2\npub const TLS_1_2: &str = \"TLS/1.2\";\n\n/// TLS/1.3\npub const TLS_1_3: &str = \"TLS/1.3\";\n\n/// Bytes\npub const BYTES: &str = \"bytes\";\n\n/// Cache control directive: max-age\npub const MAX_AGE: &str = \"max-age\";\n\n/// Cache control directive: must-revalidate\npub const MUST_REVALIDATE: &str = \"must-revalidate\";\n\n/// Cache control directive: no-store\npub const NO_STORE: &str = \"no-store\";\n\n/// Cache control directive: no-transform\npub const NO_TRANSFORM: &str = \"no-transform\";\n\n/// Cache control directive: proxy-revalidate\npub const PROXY_REVALIDATE: &str = \"proxy-revalidate\";\n\n/// Cache control directive: s-maxage\npub const S_MAXAGE: &str = \"s-maxage\";\n\n/// Cache control directive: immutable\npub const IMMUTABLE: &str = \"immutable\";\n\n/// Cache control directive: stale-while-revalidate\npub const STALE_WHILE_REVALIDATE: &str = \"stale-while-revalidate\";\n\n/// Cache control directive: stale-if-error\npub const STALE_IF_ERROR: &str = \"stale-if-error\";\n\n/// Content disposition: inline\npub const INLINE: &str = \"inline\";\n\n/// Content disposition: attachment\npub const ATTACHMENT: &str = \"attachment\";\n\n/// Content disposition: form-data\npub const FORM_DATA: &str = \"form-data\";\n\n/// X-Frame-Options: ALLOWALL\npub const ALLOWALL: &str = \"ALLOWALL\";\n\n/// X-Content-Type-Options: nosniff (already exists as NOSNIFF)\n\n/// Referrer Policy: no-referrer\npub const NO_REFERRER: &str = \"no-referrer\";\n\n/// Referrer Policy: no-referrer-when-downgrade\npub const NO_REFERRER_WHEN_DOWNGRADE: &str = \"no-referrer-when-downgrade\";\n\n/// Referrer Policy: origin\npub const ORIGIN_ONLY: &str = \"origin\";\n\n/// Referrer Policy: origin-when-cross-origin\npub const ORIGIN_WHEN_CROSS_ORIGIN: &str = \"origin-when-cross-origin\";\n\n/// Referrer Policy: same-origin\npub const SAME_ORIGIN: &str = \"same-origin\";\n\n/// Referrer Policy: strict-origin\npub const STRICT_ORIGIN: &str = \"strict-origin\";\n\n/// Referrer Policy: strict-origin-when-cross-origin\npub const STRICT_ORIGIN_WHEN_CROSS_ORIGIN: &str = \"strict-origin-when-cross-origin\";\n\n/// Referrer Policy: unsafe-url\npub const UNSAFE_URL: &str = \"unsafe-url\";\n\n/// Cross-Origin-Embedder-Policy: require-corp\npub const REQUIRE_CORP: &str = \"require-corp\";\n\n/// Cross-Origin-Embedder-Policy: credentialless\npub const CREDENTIALLESS: &str = \"credentialless\";\n\n/// Cross-Origin-Opener-Policy: same-origin\npub const SAME_ORIGIN_COOP: &str = \"same-origin\";\n\n/// Cross-Origin-Opener-Policy: same-origin-allow-popups\npub const SAME_ORIGIN_ALLOW_POPUPS: &str = \"same-origin-allow-popups\";\n\n/// Cross-Origin-Opener-Policy: unsafe-none\npub const UNSAFE_NONE: &str = \"unsafe-none\";\n\n/// Cross-Origin-Resource-Policy: same-site\npub const SAME_SITE: &str = \"same-site\";\n\n/// Cross-Origin-Resource-Policy: cross-origin\npub const CROSS_ORIGIN: &str = \"cross-origin\";\n\n/// X-XSS-Protection: 1; mode=block\npub const XSS_PROTECTION_BLOCK: &str = \"1; mode=block\";\n\n/// X-XSS-Protection: 0\npub const XSS_PROTECTION_DISABLED: &str = \"0\";\n\n/// X-DNS-Prefetch-Control: on\npub const DNS_PREFETCH_ON: &str = \"on\";\n\n/// X-DNS-Prefetch-Control: off\npub const DNS_PREFETCH_OFF: &str = \"off\";\n\n/// X-Download-Options: noopen\npub const NOOPEN: &str = \"noopen\";\n\n/// X-Permitted-Cross-Domain-Policies: none\npub const NONE: &str = \"none\";\n\n/// X-Permitted-Cross-Domain-Policies: master-only\npub const MASTER_ONLY: &str = \"master-only\";\n\n/// X-Permitted-Cross-Domain-Policies: by-content-type\npub const BY_CONTENT_TYPE: &str = \"by-content-type\";\n\n/// X-Permitted-Cross-Domain-Policies: all\npub const ALL: &str = \"all\";\n\n/// X-Robots-Tag: noindex\npub const NOINDEX: &str = \"noindex\";\n\n/// X-Robots-Tag: nofollow\npub const NOFOLLOW: &str = \"nofollow\";\n\n/// X-Robots-Tag: noarchive\npub const NOARCHIVE: &str = \"noarchive\";\n\n/// X-Robots-Tag: nosnippet\npub const NOSNIPPET: &str = \"nosnippet\";\n\n/// X-Robots-Tag: noimageindex\npub const NOIMAGEINDEX: &str = \"noimageindex\";\n\n/// X-UA-Compatible: IE=edge\npub const IE_EDGE: &str = \"IE=edge\";\n\n/// Expect: 100-continue\npub const CONTINUE_EXPECT: &str = \"100-continue\";\n\n/// Transfer-Encoding: compress\npub const COMPRESS: &str = \"compress\";\n\n/// Accept-Ranges: none\npub const NONE_RANGES: &str = \"none\";\n\n/// Vary: accept-encoding\npub const VARY_ACCEPT_ENCODING: &str = \"accept-encoding\";\n\n/// Vary: user-agent\npub const VARY_USER_AGENT: &str = \"user-agent\";\n\n/// Vary: origin\npub const VARY_ORIGIN: &str = \"origin\";\n\n/// domain\npub const COOKIE_DOMAIN: &str = \"Domain\";\n\n/// domain lowercase\npub const COOKIE_DOMAIN_LOWERCASE: &str = \"domain\";\n\n/// path\npub const COOKIE_PATH: &str = \"Path\";\n\n/// path lowercase\npub const COOKIE_PATH_LOWERCASE: &str = \"path\";\n\n/// secure\npub const COOKIE_SECURE: &str = \"Secure\";\n\n/// secure lowercase\npub const COOKIE_SECURE_LOWERCASE: &str = \"secure\";\n\n/// HttpOnly\npub const COOKIE_HTTP_ONLY: &str = \"HttpOnly\";\n\n/// httponly lowercase\npub const COOKIE_HTTP_ONLY_LOWERCASE: &str = \"httponly\";\n\n/// SameSite\npub const COOKIE_SAME_SITE: &str = \"SameSite\";\n\n/// samesite lowercase\npub const COOKIE_SAME_SITE_LOWERCASE: &str = \"samesite\";\n\n/// max-age\npub const COOKIE_MAX_AGE: &str = \"Max-Age\";\n\n/// max-age lowercase\npub const COOKIE_MAX_AGE_LOWERCASE: &str = \"max-age\";\n\n/// expires\npub const COOKIE_EXPIRES: &str = \"Expires\";\n\n/// expires lowercase\npub const COOKIE_EXPIRES_LOWERCASE: &str = \"expires\";\n\n/// priority\npub const COOKIE_PRIORITY: &str = \"Priority\";\n\n/// priority lowercase\npub const COOKIE_PRIORITY_LOWERCASE: &str = \"priority\";\n\n/// preload\npub const COOKIE_PRELOAD: &str = \"Preload\";\n\n/// preload lowercase\npub const COOKIE_PRELOAD_LOWERCASE: &str = \"preload\";\n\n/// SameSite value: Strict\npub const COOKIE_SAME_SITE_STRICT: &str = \"Strict\";\n\n/// SameSite value: Lax\npub const COOKIE_SAME_SITE_LAX: &str = \"Lax\";\n\n/// SameSite value: None\npub const COOKIE_SAME_SITE_NONE: &str = \"None\";\n\n/// SameSite value: strict lowercase\npub const COOKIE_SAME_SITE_STRICT_LOWERCASE: &str = \"strict\";\n\n/// SameSite value: lax lowercase\npub const COOKIE_SAME_SITE_LAX_LOWERCASE: &str = \"lax\";\n\n/// SameSite value: none lowercase\npub const COOKIE_SAME_SITE_NONE_LOWERCASE: &str = \"none\";\n\n/// Priority value: Low\npub const COOKIE_PRIORITY_LOW: &str = \"Low\";\n\n/// Priority value: Medium\npub const COOKIE_PRIORITY_MEDIUM: &str = \"Medium\";\n\n/// Priority value: High\npub const COOKIE_PRIORITY_HIGH: &str = \"High\";\n\n/// Priority value: low lowercase\npub const COOKIE_PRIORITY_LOW_LOWERCASE: &str = \"low\";\n\n/// Priority value: medium lowercase\npub const COOKIE_PRIORITY_MEDIUM_LOWERCASE: &str = \"medium\";\n\n/// Priority value: high lowercase\npub const COOKIE_PRIORITY_HIGH_LOWERCASE: &str = \"high\";\n\n/// Cookie attribute with value: SameSite=Strict\npub const COOKIE_SAME_SITE_STRICT_ATTR: &str = \"SameSite=Strict\";\n\n/// Cookie attribute with value: SameSite=Lax\npub const COOKIE_SAME_SITE_LAX_ATTR: &str = \"SameSite=Lax\";\n\n/// Cookie attribute with value: SameSite=None\npub const COOKIE_SAME_SITE_NONE_ATTR: &str = \"SameSite=None\";\n\n/// Cookie attribute with value: samesite=strict lowercase\npub const COOKIE_SAME_SITE_STRICT_ATTR_LOWERCASE: &str = \"samesite=strict\";\n\n/// Cookie attribute with value: samesite=lax lowercase\npub const COOKIE_SAME_SITE_LAX_ATTR_LOWERCASE: &str = \"samesite=lax\";\n\n/// Cookie attribute with value: samesite=none lowercase\npub const COOKIE_SAME_SITE_NONE_ATTR_LOWERCASE: &str = \"samesite=none\";\n\n/// Cookie attribute with value: Priority=Low\npub const COOKIE_PRIORITY_LOW_ATTR: &str = \"Priority=Low\";\n\n/// Cookie attribute with value: Priority=Medium\npub const COOKIE_PRIORITY_MEDIUM_ATTR: &str = \"Priority=Medium\";\n\n/// Cookie attribute with value: Priority=High\npub const COOKIE_PRIORITY_HIGH_ATTR: &str = \"Priority=High\";\n\n/// Cookie attribute with value: priority=low lowercase\npub const COOKIE_PRIORITY_LOW_ATTR_LOWERCASE: &str = \"priority=low\";\n\n/// Cookie attribute with value: priority=medium lowercase\npub const COOKIE_PRIORITY_MEDIUM_ATTR_LOWERCASE: &str = \"priority=medium\";\n\n/// Cookie attribute with value: priority=high lowercase\npub const COOKIE_PRIORITY_HIGH_ATTR_LOWERCASE: &str = \"priority=high\";\n\n/// Cookie separator\npub const COOKIE_SEPARATOR: &str = \"; \";\n\n/// Cookie name-value separator\npub const COOKIE_NAME_VALUE_SEPARATOR: &str = \"=\";\n\n/// Cookie attribute prefix: Domain=\npub const COOKIE_DOMAIN_PREFIX: &str = \"Domain=\";\n\n/// Cookie attribute prefix: domain= lowercase\npub const COOKIE_DOMAIN_PREFIX_LOWERCASE: &str = \"domain=\";\n\n/// Cookie attribute prefix: Path=\npub const COOKIE_PATH_PREFIX: &str = \"Path=\";\n\n/// Cookie attribute prefix: path= lowercase\npub const COOKIE_PATH_PREFIX_LOWERCASE: &str = \"path=\";\n\n/// Cookie attribute prefix: Max-Age=\npub const COOKIE_MAX_AGE_PREFIX: &str = \"Max-Age=\";\n\n/// Cookie attribute prefix: max-age= lowercase\npub const COOKIE_MAX_AGE_PREFIX_LOWERCASE: &str = \"max-age=\";\n\n/// Cookie attribute prefix: Expires=\npub const COOKIE_EXPIRES_PREFIX: &str = \"Expires=\";\n\n/// Cookie attribute prefix: expires= lowercase\npub const COOKIE_EXPIRES_PREFIX_LOWERCASE: &str = \"expires=\";\n\n/// Cookie attribute prefix: SameSite=\npub const COOKIE_SAME_SITE_PREFIX: &str = \"SameSite=\";\n\n/// Cookie attribute prefix: samesite= lowercase\npub const COOKIE_SAME_SITE_PREFIX_LOWERCASE: &str = \"samesite=\";\n\n/// Cookie attribute prefix: Priority=\npub const COOKIE_PRIORITY_PREFIX: &str = \"Priority=\";\n\n/// Cookie attribute prefix: priority= lowercase\npub const COOKIE_PRIORITY_PREFIX_LOWERCASE: &str = \"priority=\";\n\n/// Cookie common max-age values: 0 (delete immediately)\npub const COOKIE_MAX_AGE_DELETE: &str = \"0\";\n\n/// Cookie common max-age values: session (no max-age)\npub const COOKIE_MAX_AGE_SESSION: &str = \"\";\n\n/// Cookie common max-age values: 1 hour\npub const COOKIE_MAX_AGE_1_HOUR: &str = \"3600\";\n\n/// Cookie common max-age values: 1 day\npub const COOKIE_MAX_AGE_1_DAY: &str = \"86400\";\n\n/// Cookie common max-age values: 1 week\npub const COOKIE_MAX_AGE_1_WEEK: &str = \"604800\";\n\n/// Cookie common max-age values: 1 month (30 days)\npub const COOKIE_MAX_AGE_1_MONTH: &str = \"2592000\";\n\n/// Cookie common max-age values: 1 year\npub const COOKIE_MAX_AGE_1_YEAR: &str = \"31536000\";\n\n/// Cookie common path values: root path\npub const COOKIE_PATH_ROOT: &str = \"/\";\n\n/// Cookie common domain values: localhost\npub const COOKIE_DOMAIN_LOCALHOST: &str = \"localhost\";\n\n/// Cookie __Secure- prefix\npub const COOKIE_SECURE_PREFIX: &str = \"__Secure-\";\n\n/// Cookie __Host- prefix\npub const COOKIE_HOST_PREFIX: &str = \"__Host-\";\n\n/// Cookie complete attribute strings with common values\n/// Complete secure cookie attributes\npub const COOKIE_SECURE_HTTP_ONLY: &str = \"Secure; HttpOnly\";\n\n/// Complete secure cookie attributes lowercase\npub const COOKIE_SECURE_HTTP_ONLY_LOWERCASE: &str = \"secure; httponly\";\n\n/// Complete secure cookie with SameSite=Strict\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_STRICT: &str = \"Secure; HttpOnly; SameSite=Strict\";\n\n/// Complete secure cookie with SameSite=Strict lowercase\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_STRICT_LOWERCASE: &str =\n    \"secure; httponly; samesite=strict\";\n\n/// Complete secure cookie with SameSite=Lax\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_LAX: &str = \"Secure; HttpOnly; SameSite=Lax\";\n\n/// Complete secure cookie with SameSite=Lax lowercase\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_LAX_LOWERCASE: &str = \"secure; httponly; samesite=lax\";\n\n/// Complete secure cookie with SameSite=None\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_NONE: &str = \"Secure; HttpOnly; SameSite=None\";\n\n/// Complete secure cookie with SameSite=None lowercase\npub const COOKIE_SECURE_HTTP_ONLY_SAME_SITE_NONE_LOWERCASE: &str =\n    \"secure; httponly; samesite=none\";\n\n/// Cookie with root path\npub const COOKIE_PATH_ROOT_ATTR: &str = \"Path=/\";\n\n/// Cookie with root path lowercase\npub const COOKIE_PATH_ROOT_ATTR_LOWERCASE: &str = \"path=/\";\n\n/// Cookie deletion attributes (Max-Age=0; Expires=Thu, 01 Jan 1970 00:00:00 GMT)\npub const COOKIE_DELETE_ATTRS: &str = \"Max-Age=0; Expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\n/// Cookie deletion attributes lowercase\npub const COOKIE_DELETE_ATTRS_LOWERCASE: &str = \"max-age=0; expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n\n/// Common expires date for deletion\npub const COOKIE_EXPIRES_EPOCH: &str = \"Thu, 01 Jan 1970 00:00:00 GMT\";\n\n/// Cookie attribute: Expires\npub const COOKIE_EXPIRES_ATTRIBUTE: &str = \"; Expires=\";\n\n/// Cookie attribute: expires lowercase\npub const COOKIE_EXPIRES_ATTRIBUTE_LOWERCASE: &str = \"; expires=\";\n\n/// Cookie attribute: Max-Age\npub const COOKIE_MAX_AGE_ATTRIBUTE: &str = \"; Max-Age=\";\n\n/// Cookie attribute: max-age lowercase\npub const COOKIE_MAX_AGE_ATTRIBUTE_LOWERCASE: &str = \"; max-age=\";\n\n/// Cookie attribute: Domain\npub const COOKIE_DOMAIN_ATTRIBUTE: &str = \"; Domain=\";\n\n/// Cookie attribute: domain lowercase\npub const COOKIE_DOMAIN_ATTRIBUTE_LOWERCASE: &str = \"; domain=\";\n\n/// Cookie attribute: Path\npub const COOKIE_PATH_ATTRIBUTE: &str = \"; Path=\";\n\n/// Cookie attribute: path lowercase\npub const COOKIE_PATH_ATTRIBUTE_LOWERCASE: &str = \"; path=\";\n\n/// Cookie attribute: Secure\npub const COOKIE_SECURE_ATTRIBUTE: &str = \"; Secure\";\n\n/// Cookie attribute: secure lowercase\npub const COOKIE_SECURE_ATTRIBUTE_LOWERCASE: &str = \"; secure\";\n\n/// Cookie attribute: HttpOnly\npub const COOKIE_HTTP_ONLY_ATTRIBUTE: &str = \"; HttpOnly\";\n\n/// Cookie attribute: httponly lowercase\npub const COOKIE_HTTP_ONLY_ATTRIBUTE_LOWERCASE: &str = \"; httponly\";\n\n/// Cookie attribute: SameSite\npub const COOKIE_SAME_SITE_ATTRIBUTE: &str = \"; SameSite=\";\n\n/// Cookie attribute: samesite lowercase\npub const COOKIE_SAME_SITE_ATTRIBUTE_LOWERCASE: &str = \"; samesite=\";", "file_size": 21238, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\session\\const.rs", "language": "rust", "content": "/// The default name for the session cookie.\npub const SESSION_COOKIE_NAME: &str = \"session_id\";\n\n/// The default length of the session ID.\npub const SESSION_ID_LENGTH: usize = 32;\n\n/// The default session timeout duration in seconds (30 minutes).\npub const SESSION_TIMEOUT_SECONDS: u64 = 1800;\n\n/// The default session timeout duration in milliseconds (30 minutes).\npub const SESSION_TIMEOUT_MILLISECONDS: u64 = 1800000;\n\n/// A string constant representing \"session\".\npub const SESSION: &str = \"session\";\n\n/// The session data key used to store the user's ID.\npub const SESSION_USER_ID_KEY: &str = \"user_id\";\n\n/// The session data key used to store the username.\npub const SESSION_USERNAME_KEY: &str = \"username\";\n\n/// The session data key used to store the user's role.\npub const SESSION_USER_ROLE_KEY: &str = \"user_role\";\n\n/// The session data key used to store the login timestamp.\npub const SESSION_LOGIN_TIME_KEY: &str = \"login_time\";\n\n/// The session data key used to store the last access timestamp.\npub const SESSION_LAST_ACCESS_TIME_KEY: &str = \"last_access_time\";\n\n/// The session data key used to store the client's IP address.\npub const SESSION_IP_ADDRESS_KEY: &str = \"ip_address\";\n\n/// The session data key used to store the client's user agent string.\npub const SESSION_USER_AGENT_KEY: &str = \"user_agent\";\n\n/// The session data key used to store the CSRF token.\npub const SESSION_CSRF_TOKEN_KEY: &str = \"csrf_token\";\n\n/// The session data key used to store the user's language preference.\npub const SESSION_LANGUAGE_KEY: &str = \"language\";\n\n/// The session data key used to store the user's timezone.\npub const SESSION_TIMEZONE_KEY: &str = \"timezone\";\n\n/// The string representing an active session state.\npub const SESSION_STATE_ACTIVE: &str = \"active\";\n\n/// The string representing an expired session state.\npub const SESSION_STATE_EXPIRED: &str = \"expired\";\n\n/// The string representing an invalid session state.\npub const SESSION_STATE_INVALID: &str = \"invalid\";\n\n/// The string representing a destroyed session state.\npub const SESSION_STATE_DESTROYED: &str = \"destroyed\";\n\n/// The default interval in seconds for cleaning up expired sessions (5 minutes).\npub const SESSION_CLEANUP_INTERVAL_SECONDS: u64 = 300;\n\n/// The maximum number of concurrent sessions allowed per user.\npub const MAX_SESSIONS_PER_USER: usize = 5;\n\n/// The character set used for generating session IDs.\npub const SESSION_ID_CHARSET: &str =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n\n/// The byte representation of the session ID character set.\npub const SESSION_ID_CHARSET_BYTES: &[u8] = SESSION_ID_CHARSET.as_bytes();\n\n/// The threshold in seconds after which a session should be regenerated (15 minutes).\npub const SESSION_REGENERATION_THRESHOLD_SECONDS: u64 = 900;\n\n/// The prefix used for session flash message keys.\npub const SESSION_FLASH_MESSAGE_PREFIX: &str = \"flash:\";\n\n/// The type for a successful flash message.\npub const SESSION_FLASH_SUCCESS: &str = \"success\";\n/// The type for an error flash message.\npub const SESSION_FLASH_ERROR: &str = \"error\";\n/// The type for a warning flash message.\npub const SESSION_FLASH_WARNING: &str = \"warning\";\n/// The type for an informational flash message.\npub const SESSION_FLASH_INFO: &str = \"info\";\n\n/// The name of the \"remember me\" cookie.\npub const SESSION_REMEMBER_ME_COOKIE_NAME: &str = \"remember_me\";\n\n/// The length of the \"remember me\" token.\npub const SESSION_REMEMBER_ME_TOKEN_LENGTH: usize = 64;\n\n/// The timeout duration in seconds for the \"remember me\" token (30 days).\npub const SESSION_REMEMBER_ME_TIMEOUT_SECONDS: u64 = 2592000;\n\n/// The separator used between components of a session fingerprint.\npub const SESSION_FINGERPRINT_SEPARATOR: &str = \"|\";\n\n/// The timeout in milliseconds for acquiring a session lock.\npub const SESSION_LOCK_TIMEOUT_MILLISECONDS: u64 = 5000;\n\n/// The maximum number of concurrent accesses allowed for a single session.\npub const SESSION_CONCURRENT_ACCESS_LIMIT: usize = 10;", "file_size": 3991, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\brotli\\mod.rs", "language": "rust", "content": "pub(crate) mod decode;\npub(crate) mod encode;", "file_size": 45, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-request\\src\\request\\request\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Result type for HTTP requests, containing either a response or error.\npub type RequestResult = Result<BoxResponseTrait, RequestError>;\n\n/// Boxed trait object for asynchronous HTTP requests.\npub type BoxAsyncRequestTrait = Box<dyn AsyncRequestTrait<RequestResult = RequestResult>>;\n\n/// Boxed trait object for synchronous HTTP requests.\npub type BoxRequestTrait = Box<dyn RequestTrait<RequestResult = RequestResult>>;\n\n/// Boxed trait object for asynchronous read/write streams.\npub(crate) type BoxAsyncReadWrite = Box<dyn AsyncReadWrite>;\n\n/// Boxed trait object for synchronous read/write streams.\npub(crate) type BoxReadWrite = Box<dyn ReadWrite>;", "file_size": 669, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\cfg.rs", "language": "rust", "content": "#[test]\nfn test() {\n    use crate::*;\n    use std::borrow::Cow;\n\n    let headers: HashMap<_, _, BuildHasherDefault<XxHash3_64>> =\n        HashMap::with_hasher(BuildHasherDefault::default());\n    let data: Vec<u8> = vec![];\n    let body: Cow<'_, Vec<u8>> = Compress::from(&headers).decode(&data, 1_024_000);\n    assert_eq!(*body, data);\n\n    let _ = Compress::Gzip.encode(&[], 1_024_000);\n    let _ = Compress::Deflate.encode(&[], 1_024_000);\n    let _ = Compress::Br.encode(&[], 1_024_000);\n\n    let _ = Compress::Gzip.decode(&[], 1_024_000);\n    let _ = Compress::Deflate.decode(&[], 1_024_000);\n    let _ = Compress::Br.decode(&[], 1_024_000);\n}", "file_size": 647, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\gzip\\encode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Compresses the given data using Gzip compression.\n///\n/// This function takes a byte slice of data and compresses it using the `GzEncoder` from the `flate2` crate.\n/// The compression is done in a buffered manner to optimize performance. If compression is successful,\n/// the result is returned as an owned `Vec<u8>`. If an error occurs during compression, an empty `Vec<u8>`\n/// is returned.\n///\n/// # Arguments\n///\n/// - `data` - A reference to a byte slice (`&[u8]`) containing the data to be compressed.\n/// - `buffer_size` - The buffer size to use for the buffered writer. A larger buffer size can improve\n///   performance for larger datasets.\n///\n/// # Returns\n///\n/// - `Cow<Vec<u8>>` - The compressed data as a `Cow<Vec<u8>>`. If compression is successful, the\n///   compressed data is returned as an owned `Vec<u8>`. If an error occurs, an empty owned `Vec<u8>`\n///   is returned.\npub fn encode(data: &[u8], buffer_size: usize) -> Cow<Vec<u8>> {\n    let encoder: GzEncoder<Vec<u8>> = GzEncoder::new(Vec::new(), Compression::default());\n    let mut buffered_writer: BufWriter<GzEncoder<Vec<u8>>> =\n        BufWriter::with_capacity(buffer_size, encoder);\n    if let Err(_) = buffered_writer.write_all(data) {\n        return Cow::Owned(Vec::new());\n    }\n    match buffered_writer.into_inner() {\n        Ok(encoder) => Cow::Owned(encoder.finish().unwrap_or_else(|_| Vec::new())),\n        Err(_) => Cow::Owned(Vec::new()),\n    }\n}", "file_size": 1455, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\gzip\\decode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Decompresses the given Gzip-compressed data.\n///\n/// This function takes a byte slice of Gzip-compressed data and decompresses it using the `GzDecoder`\n/// from the `flate2` crate. The decompression is done in a buffered manner to optimize performance.\n/// If decompression is successful, the result is returned as an owned `Vec<u8>`. If an error occurs\n/// during decompression, an empty `Vec<u8>` is returned.\n///\n/// # Arguments\n///\n/// - `data` - A reference to a byte slice (`&[u8]`) containing the Gzip-compressed data.\n/// - `buffer_size` - The buffer size to use for the buffered reader. A larger buffer size can improve\n///   performance for larger datasets.\n///\n/// # Returns\n///\n/// - `Cow<Vec<u8>>` - The decompressed data as a `Cow<Vec<u8>>`. If decompression is successful, the\n///   decompressed data is returned as an owned `Vec<u8>`. If an error occurs, an empty owned `Vec<u8>`\n///   is returned.\npub fn decode(data: &[u8], buffer_size: usize) -> Cow<Vec<u8>> {\n    let decoder: GzDecoder<&[u8]> = GzDecoder::new(data);\n    let mut buffered_reader: BufReader<GzDecoder<&[u8]>> =\n        BufReader::with_capacity(buffer_size, decoder);\n    let mut decompressed_data: Vec<u8> = Vec::new();\n    match buffered_reader.read_to_end(&mut decompressed_data) {\n        Ok(_) => Cow::Owned(decompressed_data),\n        _ => Cow::Owned(Vec::new()),\n    }\n}", "file_size": 1381, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\compress\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides the default value for the `Compress` enum, which is `Unknown`.\nimpl Default for Compress {\n    fn default() -> Self {\n        Self::Unknown\n    }\n}\n\n/// Enables parsing a string into a `Compress` enum variant.\n///\n/// This implementation allows converting string representations of compression\n/// algorithms (like \"gzip\", \"deflate\", \"br\") into their corresponding `Compress`\n/// enum variants. If the string does not match any known compression types,\n/// it defaults to `Compress::Unknown`.\nimpl FromStr for Compress {\n    type Err = ();\n\n    /// Parses a string into a `Compress` enum variant.\n    ///\n    /// This method converts string representations of compression algorithms\n    /// (case-insensitive) into their corresponding `Compress` enum variants.\n    /// Unknown strings are converted to `Compress::Unknown`.\n    ///\n    /// # Arguments\n    ///\n    /// - `data` - The string to parse, which should be a compression algorithm name.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Self, Self::Err>` - Returns `Ok` with the matching `Compress` variant,\n    ///   or `Ok(Compress::Unknown)` for unknown strings. Never returns `Err`.\n    fn from_str(data: &str) -> Result<Self, Self::Err> {\n        match data.to_lowercase().as_str() {\n            _data if _data == CONTENT_ENCODING_GZIP => Ok(Self::Gzip),\n            _data if _data == CONTENT_ENCODING_DEFLATE => Ok(Self::Deflate),\n            _data if _data == CONTENT_ENCODING_BROTLI => Ok(Self::Br),\n            _ => Ok(Self::Unknown),\n        }\n    }\n}\n\n/// Implements the `Display` trait for the `Compress` enum.\n///\n/// This allows the `Compress` enum variants to be formatted as strings,\n/// typically used for outputting the `Content-Encoding` header value.\nimpl fmt::Display for Compress {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let display_str = match *self {\n            Compress::Gzip => CONTENT_ENCODING_GZIP,\n            Compress::Deflate => CONTENT_ENCODING_DEFLATE,\n            Compress::Br => CONTENT_ENCODING_BROTLI,\n            Compress::Unknown => EMPTY_STR,\n        };\n        write!(f, \"{}\", display_str)\n    }\n}\n\n/// Provides methods for interacting with the `Compress` enum.\nimpl Compress {\n    /// Checks if the current instance is of the `Unknown` type.\n    ///\n    /// This method compares the current instance with the `Unknown` variant of the enum.\n    /// It returns `true` if the instance is of type `Unknown`, otherwise `false`.\n    ///\n    /// # Returns\n    ///\n    /// - `true` if the instance is of type `Unknown`.\n    /// - `false` otherwise.\n    pub fn is_unknown(&self) -> bool {\n        *self == Self::Unknown\n    }\n\n    /// Extracts the compression type from an HTTP header.\n    ///\n    /// This function looks for the `Content-Encoding` header in the provided `Header` and attempts\n    /// to parse it into a `Compress` enum value.\n    ///\n    /// # Arguments\n    ///\n    /// - `header` - The HTTP header from which the compression type is to be extracted.\n    ///\n    /// # Returns\n    ///\n    /// - The `Compress` value corresponding to the `Content-Encoding` header, or `Compress::Unknown`\n    ///   if the header does not match any known compression types.\n    pub fn from(header: &HashMap<String, String, BuildHasherDefault<XxHash3_64>>) -> Self {\n        header\n            .get(CONTENT_ENCODING)\n            .map(|value| value.parse::<Compress>().unwrap_or_default())\n            .unwrap_or_default()\n    }\n\n    /// Decompresses the given data based on the selected compression algorithm.\n    ///\n    /// This method takes a byte slice of compressed data and decompresses it using one of the following\n    /// compression algorithms, depending on the variant of the enum it is called on:\n    /// - `Gzip` - Decompresses using Gzip compression.\n    /// - `Deflate` - Decompresses using Deflate compression.\n    /// - `Br` - Decompresses using Brotli compression.\n    /// - `Unknown` - Returns the input data as-is (no decompression performed).\n    ///\n    /// # Parameters\n    ///\n    /// - `data` - A reference to a byte slice (`&[u8]`) containing the compressed data to be decoded.\n    /// - `buffer_size` - The buffer size to use for the decompression process. A larger buffer size can\n    ///   improve performance for larger datasets.\n    ///\n    /// # Returns\n    ///\n    /// - `Cow<Vec<u8>>` - The decompressed data as a `Cow<Vec<u8>>`. If the compression algorithm\n    ///   is `Unknown`, the original data is returned unchanged, as a borrowed reference. Otherwise,\n    ///   the decompressed data is returned as an owned `Vec<u8>`.\n    pub fn decode<'a>(&self, data: &'a [u8], buffer_size: usize) -> Cow<'a, Vec<u8>> {\n        match self {\n            Self::Gzip => gzip::decode::decode(data, buffer_size),\n            Self::Deflate => deflate::decode::decode(data, buffer_size),\n            Self::Br => brotli::decode::decode(data, buffer_size),\n            Self::Unknown => Cow::Owned(data.to_vec()),\n        }\n    }\n\n    /// Compresses the given data based on the selected compression algorithm.\n    ///\n    /// This method takes a byte slice of data and compresses it using one of the following\n    /// compression algorithms, depending on the variant of the enum it is called on:\n    /// - `Gzip` - Compresses using Gzip compression.\n    /// - `Deflate` - Compresses using Deflate compression.\n    /// - `Br` - Compresses using Brotli compression.\n    /// - `Unknown` - Returns the input data as-is (no compression performed).\n    ///\n    /// # Parameters\n    ///\n    /// - `data` - A reference to a byte slice (`&[u8]`) containing the data to be compressed.\n    /// - `buffer_size` - The buffer size to use for the compression process. A larger buffer size can\n    ///   improve performance for larger datasets.\n    ///\n    /// # Returns\n    ///\n    /// - `Cow<Vec<u8>>` - The compressed data as a `Cow<Vec<u8>>`. If the compression algorithm\n    ///   is `Unknown`, the original data is returned unchanged, as a borrowed reference. Otherwise,\n    ///   the compressed data is returned as an owned `Vec<u8>`.\n    pub fn encode<'a>(&self, data: &'a [u8], buffer_size: usize) -> Cow<'a, Vec<u8>> {\n        match self {\n            Self::Gzip => gzip::encode::encode(data, buffer_size),\n            Self::Deflate => deflate::encode::encode(data, buffer_size),\n            Self::Br => brotli::encode::encode(data),\n            Self::Unknown => Cow::Owned(data.to_vec()),\n        }\n    }\n}", "file_size": 6471, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\deflate\\encode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Compresses the given data using the Deflate compression algorithm.\n///\n/// This function takes a byte slice of data and compresses it using the Deflate compression algorithm.\n/// The data is written to a buffered writer to optimize performance. The compressed data is returned\n/// as a `Cow<Vec<u8>>`. If compression succeeds, the resulting compressed data is returned as an\n/// owned `Vec<u8>`. If any error occurs during the compression process, an empty `Vec<u8>` is returned.\n///\n/// # Arguments\n///\n/// - `data` - A reference to a byte slice (`&[u8]`) containing the data to be compressed.\n/// - `buffer_size` - The buffer size to use for the buffered writer. A larger buffer size can\n///   improve performance for larger datasets.\n///\n/// # Returns\n///\n/// - `Cow<Vec<u8>>` - The compressed data as a `Cow<Vec<u8>>`. If compression is successful, the\n///   compressed data is returned as an owned `Vec<u8>`. If an error occurs, an empty owned `Vec<u8>`\n///   is returned.\npub fn encode(data: &[u8], buffer_size: usize) -> Cow<Vec<u8>> {\n    let encoder: DeflateEncoder<Vec<u8>> = DeflateEncoder::new(Vec::new(), Compression::default());\n    let mut buffered_writer: BufWriter<DeflateEncoder<Vec<u8>>> =\n        BufWriter::with_capacity(buffer_size, encoder);\n    if let Err(_) = buffered_writer.write_all(data) {\n        return Cow::Owned(Vec::new());\n    }\n    match buffered_writer.into_inner() {\n        Ok(encoder) => Cow::Owned(encoder.finish().unwrap_or_else(|_| Vec::new())),\n        Err(_) => Cow::Owned(Vec::new()),\n    }\n}", "file_size": 1557, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\compress\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#impl;\npub(crate) mod r#type;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-constant\\src\\http_version\\const.rs", "language": "rust", "content": "/// HTTP version 0.9.\npub const HTTP_VERSION_0_9: &str = \"HTTP/0.9\";\n/// HTTP version 1.0.\npub const HTTP_VERSION_1_0: &str = \"HTTP/1.0\";\n/// HTTP version 1.1.\npub const HTTP_VERSION_1_1: &str = \"HTTP/1.1\";\n/// HTTP version 2.\npub const HTTP_VERSION_2: &str = \"HTTP/2\";\n/// HTTP version 3.\npub const HTTP_VERSION_3: &str = \"HTTP/3\";", "file_size": 332, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\compress\\const.rs", "language": "rust", "content": "/// The header name for content encoding.\npub const CONTENT_ENCODING: &str = \"content-encoding\";\n/// The content encoding type for gzip.\npub const CONTENT_ENCODING_GZIP: &str = \"gzip\";\n/// The content encoding type for deflate.\npub const CONTENT_ENCODING_DEFLATE: &str = \"deflate\";\n/// The content encoding type for brotli.\npub const CONTENT_ENCODING_BROTLI: &str = \"br\";\n/// An empty string.\npub const EMPTY_STR: &str = \"\";", "file_size": 424, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\lib.rs", "language": "rust", "content": "//! http-compress\n//!\n//! A high-performance async library for HTTP compression/decompression,\n//! supporting Brotli, Deflate, and Gzip algorithms. Provides both compression\n//! and decompression capabilities with optimized memory usage,\n//! ideal for HTTP clients/servers and network programming.\n\npub(crate) mod brotli;\npub(crate) mod cfg;\npub(crate) mod compress;\npub(crate) mod deflate;\npub(crate) mod gzip;\n\npub use compress::r#type::*;\npub use twox_hash::XxHash3_64;\n\npub(crate) use ::brotli::Decompressor;\npub(crate) use compress::r#const::*;\npub(crate) use core::hash::BuildHasherDefault;\npub(crate) use flate2::{\n    Compression,\n    read::{DeflateDecoder, GzDecoder},\n    write::{DeflateEncoder, GzEncoder},\n};\npub(crate) use std::{\n    borrow::Cow,\n    collections::HashMap,\n    fmt,\n    io::{BufReader, BufWriter, Read, prelude::*},\n    str::FromStr,\n};", "file_size": 865, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\compress\\type.rs", "language": "rust", "content": "/// Represents different compression algorithms supported by the library.\n#[derive(Debug, PartialEq, Eq)]\npub enum Compress {\n    /// Gzip compression algorithm.\n    Gzip,\n    /// Deflate compression algorithm.\n    Deflate,\n    /// Brotli compression algorithm.\n    Br,\n    /// Represents an unknown or unsupported compression algorithm.\n    Unknown,\n}", "file_size": 352, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\deflate\\decode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Decompresses Deflate compressed data.\n///\n/// # Arguments\n///\n/// - `&[u8]` - The compressed data to decode.\n/// - `usize` - The buffer size for decompression.\n///\n/// # Returns\n///\n/// - `Cow<Vec<u8>>` - The decompressed data.\npub fn decode(data: &[u8], buffer_size: usize) -> Cow<Vec<u8>> {\n    let decoder: DeflateDecoder<&[u8]> = DeflateDecoder::new(data);\n    let mut buffered_reader: BufReader<DeflateDecoder<&[u8]>> =\n        BufReader::with_capacity(buffer_size, decoder);\n    let mut decompressed_data: Vec<u8> = Vec::new();\n    match buffered_reader.read_to_end(&mut decompressed_data) {\n        Ok(_) => Cow::Owned(decompressed_data),\n        _ => Cow::Owned(Vec::new()),\n    }\n}", "file_size": 709, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\hot_restart\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Result type alias for hot restart operations.\npub type ResultHotRestartError = Result<(), HotRestartError>;", "file_size": 126, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\brotli\\decode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Decompresses the given data using the specified decompressor.\n///\n/// This function takes a byte slice of compressed data and decompresses it using\n/// a decompressor, returning the result as a `Cow<Vec<u8>>`. If decompression is successful,\n/// the decompressed data is returned as an owned `Vec<u8>`. In case of an error, an empty\n/// `Vec<u8>` is returned.\n///\n/// # Parameters\n/// - `data` - A reference to a byte slice (`&[u8]`) containing the compressed data to be decoded.\n/// - `buffer_size` - The buffer size to use for the decompression process. A larger buffer size can\n///   improve performance for larger datasets.\n///\n/// # Returns\n/// - `Cow<Vec<u8>>` - The decompressed data as a `Cow<Vec<u8>>`. If decompression is successful, the\n///   decompressed data is returned as an owned `Vec<u8>`. In case of an error, an empty owned\n///   `Vec<u8>` is returned.\npub fn decode(data: &[u8], buffer_size: usize) -> Cow<Vec<u8>> {\n    let mut decompressor: Decompressor<&[u8]> = Decompressor::new(data, buffer_size);\n    let mut decompressed_data: Vec<u8> = Vec::new();\n    match decompressor.read_to_end(&mut decompressed_data) {\n        Ok(_) => Cow::Owned(decompressed_data),\n        _ => Cow::Owned(Vec::new()),\n    }\n}", "file_size": 1248, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\http-compress\\src\\brotli\\encode\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Compresses the given data using Gzip compression.\n///\n/// This function takes a byte slice of data and compresses it using the Gzip compression algorithm.\n/// If the compression succeeds, the resulting compressed data is returned as a `Cow<Vec<u8>>`.\n/// If any error occurs during the compression process, an empty `Vec<u8>` is returned.\n///\n/// # Parameters\n/// - `data` - A reference to a byte slice (`&[u8]`) containing the data to be compressed.\n///\n/// # Returns\n/// - `Cow<Vec<u8>>` - The compressed data as a `Cow<Vec<u8>>`. The compressed data is returned as an\n///   owned `Vec<u8>`. If compression fails, an empty owned `Vec<u8>` is returned.\npub fn encode(data: &[u8]) -> Cow<Vec<u8>> {\n    let mut encoder: GzEncoder<Vec<u8>> = GzEncoder::new(Vec::new(), Compression::default());\n    if let Err(_) = encoder.write_all(data) {\n        return Cow::Owned(Vec::new());\n    }\n    Cow::Owned(encoder.finish().unwrap_or_else(|_| Vec::new()))\n}", "file_size": 968, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\error\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of Display trait for HotRestartError.\nimpl fmt::Display for HotRestartError {\n    /// Formats the error message for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self` - The HotRestartError instance.\n    /// - `&mut fmt::Formatter` - The formatter to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            HotRestartError::CargoWatchNotInstalled => write!(\n                f,\n                \"Cargo-watch is not installed. Please install it using: cargo install cargo-watch\"\n            ),\n            HotRestartError::CommandSpawnFailed(e) => {\n                write!(f, \"Failed to spawn cargo watch command: {}\", e)\n            }\n            HotRestartError::CommandWaitFailed(e) => {\n                write!(f, \"Failed to wait for cargo watch command: {}\", e)\n            }\n            HotRestartError::Other(e) => write!(f, \"An unexpected error occurred: {}\", e),\n        }\n    }\n}\n\n/// Implementation of From trait for converting Error to HotRestartError.\nimpl From<Error> for HotRestartError {\n    /// Converts a generic Error into HotRestartError.\n    ///\n    /// # Arguments\n    ///\n    /// - `Error` - The source error to convert.\n    ///\n    /// # Returns\n    ///\n    /// - `Self` - The converted error.\n    fn from(err: Error) -> Self {\n        HotRestartError::Other(err.to_string())\n    }\n}", "file_size": 1486, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\hot_restart\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Internal function to handle hot restart process.\n///\n/// # Arguments\n///\n/// - `&[&str]` - Arguments to pass to cargo-watch.\n/// - `bool` - Whether to wait for process completion.\n/// - `F` - The future to run before hot restart.\n///\n/// # Returns\n///\n/// - `ResultHotRestartError` - Result of hot restart operation.\nasync fn run_hot_restart<F>(run_args: &[&str], wait: bool, before_hook: F) -> ResultHotRestartError\nwhere\n    F: Future<Output = ()>,\n{\n    before_hook.await;\n    let check_output: Output = Command::new(\"cargo\")\n        .args(&[\"install\", \"--list\"])\n        .output()\n        .map_err(|e| HotRestartError::Other(e.to_string()))?;\n    let check_output_str: Cow<'_, str> = String::from_utf8_lossy(&check_output.stdout);\n    if !check_output_str.contains(\"cargo-watch\") {\n        eprintln!(\"Cargo-watch is not installed. Attempting to install...\");\n        let install_status: ExitStatus = Command::new(\"cargo\")\n            .args(&[\"install\", \"cargo-watch\"])\n            .stdout(Stdio::inherit())\n            .stderr(Stdio::inherit())\n            .spawn()?\n            .wait()?;\n        if !install_status.success() {\n            return Err(HotRestartError::CargoWatchNotInstalled);\n        }\n        eprintln!(\"Cargo-watch installed successfully.\");\n    }\n    let mut command: Command = Command::new(\"cargo-watch\");\n    command\n        .args(run_args)\n        .stdout(Stdio::inherit())\n        .stderr(Stdio::inherit())\n        .stdin(Stdio::inherit());\n    let mut child: Child = command\n        .spawn()\n        .map_err(|e| HotRestartError::CommandSpawnFailed(e.to_string()))?;\n    if wait {\n        child\n            .wait()\n            .map_err(|e| HotRestartError::CommandWaitFailed(e.to_string()))?;\n    }\n    exit(0);\n}\n\n/// Starts hot restart process without waiting for completion.\n///\n/// # Arguments\n///\n/// - `&[&str]` - Arguments to pass to cargo-watch.\n/// - `F` - The future to run before hot restart.\n///\n/// # Returns\n///\n/// - `ResultHotRestartError` - Result of hot restart operation.\npub async fn hot_restart<F>(run_args: &[&str], before_hook: F) -> ResultHotRestartError\nwhere\n    F: Future<Output = ()>,\n{\n    run_hot_restart(run_args, false, before_hook).await\n}\n\n/// Starts hot restart process and waits for completion.\n///\n/// # Arguments\n///\n/// - `&[&str]` - Arguments to pass to cargo-watch.\n/// - `F` - The future to run before hot restart.\n///\n/// # Returns\n///\n/// - `ResultHotRestartError` - Result of hot restart operation.\npub async fn hot_restart_wait<F>(run_args: &[&str], before_hook: F) -> ResultHotRestartError\nwhere\n    F: Future<Output = ()>,\n{\n    run_hot_restart(run_args, true, before_hook).await\n}", "file_size": 2677, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\error\\enum.rs", "language": "rust", "content": "/// Errors that can occur during hot restart process.\npub enum HotRestartError {\n    /// Indicates cargo-watch is not installed.\n    CargoWatchNotInstalled,\n    /// Failed to spawn command process.\n    CommandSpawnFailed(String),\n    /// Failed to wait for command process completion.\n    CommandWaitFailed(String),\n    /// Other unspecified error with message.\n    Other(String),\n}", "file_size": 382, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\cmd\\git.rs", "language": "rust", "content": "use crate::*;\n\n/// Initializes a new git repository.\npub fn init() {\n    Command::new(\"git\")\n        .arg(\"init\")\n        .status()\n        .expect(\"Failed to execute git init\");\n}\n\n/// Adds a directory to git's safe directory list globally.\n///\n/// # Arguments\n///\n/// - `&str` - The path to add as safe directory.\npub fn config_global_add_safe_directory(path: &str) {\n    Command::new(\"git\")\n        .args([\n            \"config\",\n            \"--global\",\n            \"--add\",\n            \"safe.directory\",\n            &format!(\"'{}'\", path),\n        ])\n        .status()\n        .expect(\"Failed to execute git config --global --add safe.directory './'\");\n}\n\n/// Disables git's advice about ignored files.\npub fn config_advice_add_ignored_file_false() {\n    Command::new(\"git\")\n        .args([\"config\", \"advice.addIgnoredFile\", \"false\"])\n        .status()\n        .expect(\"Failed to execute git config advice.addIgnoredFile false\");\n}\n\n/// Adds a new git remote.\n///\n/// # Arguments\n///\n/// - `&Remote` - The remote configuration to add.\npub fn remote_add(remote: &Remote) {\n    Command::new(\"git\")\n        .arg(\"remote\")\n        .arg(\"add\")\n        .arg(&remote.name)\n        .arg(&remote.url)\n        .status()\n        .expect(\"Failed to add remote\");\n}\n\n/// Stages all changes in the git repository.\npub fn add_all() {\n    Command::new(\"git\")\n        .args([\"add\", \"*\"])\n        .status()\n        .expect(\"Failed to add *\");\n}\n\n/// Commits staged changes with a message.\n///\n/// # Arguments\n///\n/// - `&str` - The commit message.\npub fn commit(msg: &str) {\n    Command::new(\"git\")\n        .args([\"commit\", \"-m\", msg])\n        .status()\n        .expect(&format!(\"Failed to commit -m {}\", msg));\n}\n\n/// Pushes changes to a git remote.\n///\n/// # Arguments\n///\n/// - `&str` - The remote name to push to.\npub fn push(remote: &str) {\n    Command::new(\"git\")\n        .args([\"push\", remote])\n        .status()\n        .expect(\"Failed to push to remote\");\n}\n\n/// Displays git help information.\npub fn help() {\n    let get_package_name: &str = get_package_name();\n    println!(\n        \"{} extension usage: {} acp\\n\",\n        get_package_name, get_package_name\n    );\n    Command::new(\"git\")\n        .arg(\"help\")\n        .status()\n        .expect(\"Failed to run help\");\n}\n\n/// Displays package version information.\npub fn version() {\n    println!(\"{} version: {}\", get_package_name(), get_package_version());\n}\n\n/// Executes arbitrary git command with arguments.\n///\n/// # Arguments\n///\n/// - `&Vec<OsString>` - The command line arguments.\npub fn other(args: &Vec<OsString>) {\n    let status: ExitStatus = Command::new(\"git\")\n        .args(args)\n        .status()\n        .expect(\"Failed to execute git command\");\n    exit(status.code().unwrap_or_default());\n}", "file_size": 2753, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\cmd\\mod.rs", "language": "rust", "content": "pub(crate) mod git;", "file_size": 19, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\lib.rs", "language": "rust", "content": "//! hot-restart\n//!\n//! A Rust library for hot restarting applications without downtime.\n//! Provides seamless process replacement for servers and long-running services,\n//! enabling zero-downtime updates and configuration reloads.\n\npub(crate) mod error;\npub(crate) mod hot_restart;\n\npub use error::r#enum::*;\npub use hot_restart::{r#fn::*, r#type::*};\n\npub(crate) use std::{\n    borrow::Cow,\n    fmt,\n    future::Future,\n    io::Error,\n    process::{Child, Command, ExitStatus, Output, Stdio, exit},\n};", "file_size": 503, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\file\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn test_write() {\n    use crate::*;\n    const FILE_DIR: &str = \"./log\";\n    const NEW_FILE_DIR: &str = \"./new_log\";\n    const NEW_TEST_DIR: &str = \"./test_log\";\n    const FILE_PATH: &str = \"./log/test.txt\";\n    let _ = write_to_file(FILE_PATH, \"test\".as_bytes());\n    let res: Vec<u8> = read_from_file(FILE_PATH).unwrap_or_default();\n    let size: Option<u64> = get_file_size(FILE_PATH);\n    println!(\"read_from_file => {:?}\", String::from_utf8_lossy(&res));\n    println!(\"get_file_size => {:?}\", size);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = copy_dir_files(FILE_DIR, NEW_FILE_DIR);\n    println!(\"copy_dir_files => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = delete_file(FILE_PATH);\n    println!(\"delete_file => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = move_dir(FILE_DIR, NEW_TEST_DIR);\n    println!(\"move_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = delete_dir(NEW_TEST_DIR);\n    println!(\"delete_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = delete_dir(NEW_FILE_DIR);\n    println!(\"delete_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let _ = async_write_to_file(FILE_PATH, \"test\".as_bytes()).await;\n    let res: Vec<u8> = async_read_from_file(FILE_PATH).await.unwrap_or_default();\n    let size: Option<u64> = async_get_file_size(FILE_PATH).await;\n    println!(\"read_from_file => {:?}\", String::from_utf8_lossy(&res));\n    println!(\"get_file_size => {:?}\", size);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = async_copy_dir_files(FILE_DIR, NEW_FILE_DIR).await;\n    println!(\"copy_dir_files => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = async_delete_file(FILE_PATH).await;\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    println!(\"delete_file => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = async_move_dir(FILE_DIR, NEW_TEST_DIR).await;\n    println!(\"move_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = async_delete_dir(NEW_TEST_DIR).await;\n    println!(\"delete_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n    let res: Result<(), std::io::Error> = async_delete_dir(NEW_FILE_DIR).await;\n    println!(\"delete_dir => {:?}\", res);\n    let _ = std::thread::sleep(std::time::Duration::from_secs(2));\n}", "file_size": 2926, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\config\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Configuration type mapping paths to remote configurations.\npub type Config = HashMap<String, Vec<Remote>>;\n\n/// Remote repository configuration.\n#[derive(Serialize, Deserialize, Debug)]\npub struct Remote {\n    /// Remote name.\n    pub name: String,\n    /// Remote URL.\n    pub url: String,\n}", "file_size": 310, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\hot-restart\\src\\hot_restart\\mod.rs", "language": "rust", "content": "pub(crate) mod r#fn;\npub(crate) mod r#type;", "file_size": 43, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\main.rs", "language": "rust", "content": "//! gtl\n//!\n//! gtl is a Git-based tool designed to simplify the management\n//! of multiple remote repositories. It extends Git's functionality\n//! by providing one-click initialization and pushing to multiple\n//! remote repositories, making it especially useful for developers\n//! who need to maintain multiple remote repositories simultaneously.\n\npub(crate) mod cmd;\npub(crate) mod config;\npub(crate) use crate::{cmd::git, config::r#type::*};\npub(crate) use chrono::Local;\npub(crate) use config::{r#const::*, func::*};\npub(crate) use serde::Deserialize;\npub(crate) use serde::Serialize;\npub(crate) use std::{\n    collections::HashMap,\n    env,\n    ffi::OsString,\n    fs,\n    io::{self, Write},\n    path::{Path, PathBuf},\n    process::{Command, ExitStatus, exit},\n};\n\n/// Package name constant.\npub(crate) const PACKAGE_NAME: &str = \"gtl\";\n/// Package version constant.\npub(crate) const PACKAGE_VERSION: &str = \"0.1.6\";\n\n#[derive(Deserialize)]\nstruct CargoToml {\n    package: Package,\n}\n\n#[derive(Deserialize)]\nstruct Package {\n    version: String,\n}\n\n/// Gets the package name.\n///\n/// # Returns\n///\n/// - `&'static str` - The package name.\npub(crate) fn get_package_name() -> &'static str {\n    PACKAGE_NAME\n}\n\n/// Gets the package version.\n///\n/// # Returns\n///\n/// - `&'static str` - The package version.\npub(crate) fn get_package_version() -> &'static str {\n    PACKAGE_VERSION\n}\n\n/// Main entry point of the application.\n///\n/// # Arguments\n///\n/// - `Vec<OsString>` - Command line arguments.\nfn main() {\n    let args: Vec<_> = env::args_os().skip(1).collect();\n    if args.is_empty() {\n        eprintln!(\"Usage: {} help\", get_package_name());\n        exit(1);\n    }\n    let config: Config = read_config(CONFIG_PATH);\n    let args_first: OsString = args[0].clone();\n    if args_first == OsString::from(\"init\") {\n        init_repository(&config);\n    } else if args_first == OsString::from(\"push\") {\n        push_to_all_remotes(&config);\n    } else if args_first == OsString::from(\"acp\") {\n        add_commit_push_to_all_remotes(&config);\n    } else if args_first == OsString::from(\"pacp\") {\n        publish_package();\n        add_commit_auto_push(&config);\n    } else if args_first == OsString::from(\"help\") {\n        git::help();\n    } else if args_first == OsString::from(\"-v\")\n        || args_first == OsString::from(\"version\")\n        || args_first == OsString::from(\"--version\")\n    {\n        git::version();\n    } else {\n        git::other(&args);\n    }\n}\n\n/// Publishes the crate to crates.io with retries.\nfn publish_package() {\n    const MAX_RETRIES: u32 = 6;\n    const RETRY_DELAY_SECS: u64 = 2;\n\n    for attempt in 1..=MAX_RETRIES {\n        let status = Command::new(\"cargo\")\n            .args([\"publish\", \"--allow-dirty\"])\n            .status();\n\n        match status {\n            Ok(exit_status) if exit_status.success() => {\n                println!(\"Successfully published package.\");\n                return;\n            }\n            Ok(exit_status) => {\n                eprintln!(\n                    \"Attempt {} failed with status: {}. Retrying in {} seconds...\",\n                    attempt, exit_status, RETRY_DELAY_SECS\n                );\n            }\n            Err(e) => {\n                eprintln!(\n                    \"Attempt {} failed with error: {}. Retrying in {} seconds...\",\n                    attempt, e, RETRY_DELAY_SECS\n                );\n            }\n        }\n\n        if attempt < MAX_RETRIES {\n            std::thread::sleep(std::time::Duration::from_secs(RETRY_DELAY_SECS));\n        }\n    }\n\n    panic!(\"Failed to publish package after {} attempts.\", MAX_RETRIES);\n}\n\n/// Initializes a git repository with configuration.\n///\n/// # Arguments\n///\n/// - `&Config` - The configuration to use.\nfn init_repository(config: &Config) {\n    git::init();\n    git::config_global_add_safe_directory(\"./\");\n    git::config_advice_add_ignored_file_false();\n    let current_dir: PathBuf = std::env::current_dir().unwrap();\n    let current_path: &str = current_dir.to_str().unwrap();\n    if let Some(remotes) = config.get(current_path) {\n        for remote in remotes {\n            git::remote_add(remote);\n        }\n    }\n}\n\n/// Pushes to all configured git remotes.\n///\n/// # Arguments\n///\n/// - `&Config` - The configuration containing remotes.\nfn push_to_all_remotes(config: &Config) {\n    let current_dir: PathBuf = std::env::current_dir().unwrap();\n    let current_path: &str = current_dir.to_str().unwrap();\n    if let Some(remotes) = config.get(current_path) {\n        for remote in remotes {\n            git::push(&remote.name);\n        }\n    }\n}\n\n/// Generates a commit message automatically based on Cargo.toml version or timestamp.\n///\n/// # Returns\n///\n/// - `String` - The generated commit message.\nfn generate_auto_commit_message() -> String {\n    match fs::read_to_string(\"Cargo.toml\") {\n        Ok(content) => {\n            if let Ok(cargo_toml) = toml::from_str::<CargoToml>(&content) {\n                format!(\"feat: v{}\", cargo_toml.package.version)\n            } else {\n                let now = Local::now();\n                format!(\"feat: {}\", now.format(\"%Y-%m-%d %H:%M:%S\"))\n            }\n        }\n        Err(_) => {\n            let now = Local::now();\n            format!(\"feat: {}\", now.format(\"%Y-%m-%d %H:%M:%S\"))\n        }\n    }\n}\n\n/// Adds, commits with an auto-generated message, and pushes to all remotes.\n///\n/// # Arguments\n///\n/// - `&Config` - The configuration containing remotes.\nfn add_commit_auto_push(config: &Config) {\n    git::add_all();\n    let commit_msg = generate_auto_commit_message();\n    git::commit(&commit_msg);\n    push_to_all_remotes(config);\n}\n\n/// Adds, commits and pushes to all configured git remotes.\n///\n/// # Arguments\n///\n/// - `&Config` - The configuration containing remotes.\nfn add_commit_push_to_all_remotes(config: &Config) {\n    let current_dir: PathBuf = std::env::current_dir().unwrap();\n    let current_path: &str = current_dir.to_str().unwrap();\n    io::stdout().flush().unwrap();\n    let mut commit_msg_input: String = String::new();\n    io::stdin().read_line(&mut commit_msg_input).unwrap();\n    let commit_msg_trimmed: &str = commit_msg_input.trim();\n    let commit_msg = if commit_msg_trimmed.is_empty() {\n        generate_auto_commit_message()\n    } else {\n        commit_msg_trimmed.to_string()\n    };\n    git::add_all();\n    git::commit(&commit_msg);\n    if let Some(remotes) = config.get(current_path) {\n        for remote in remotes {\n            git::push(&remote.name);\n        }\n    }\n}", "file_size": 6507, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\file\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub use r#struct::*;", "file_size": 89, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\move\\mod.rs", "language": "rust", "content": "pub(crate) mod r#async;\npub(crate) mod sync;\n\npub use r#async::*;\npub use sync::*;", "file_size": 82, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\config\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#func;\npub(crate) mod r#type;", "file_size": 69, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\write\\sync\\fn.rs", "language": "rust", "content": "use std::fs::{OpenOptions, create_dir_all};\nuse std::io::{Error, Write};\n\n/// Writes content to a file.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n/// - `&[u8]` - The content to write.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if successful, Err with error details otherwise.\npub fn write_to_file(file_path: &str, content: &[u8]) -> Result<(), Error> {\n    if let Some(parent_dir) = std::path::Path::new(file_path).parent() {\n        create_dir_all(parent_dir)?;\n    }\n    OpenOptions::new()\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(file_path)\n        .and_then(|mut file| file.write_all(content))\n}\n\n/// Appends content to a file.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n/// - `&[u8]` - The content to append.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if successful, Err with error details otherwise.\npub fn append_to_file(file_path: &str, content: &[u8]) -> Result<(), Error> {\n    if let Some(parent_dir) = std::path::Path::new(file_path).parent() {\n        create_dir_all(parent_dir)?;\n    }\n    OpenOptions::new()\n        .write(true)\n        .create(true)\n        .append(true)\n        .open(file_path)\n        .and_then(|mut file| file.write_all(content))\n}", "file_size": 1283, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\future-fn\\src\\cfg.rs", "language": "rust", "content": "#[cfg(test)]\n#[tokio::test]\nasync fn test() {\n    use crate::*;\n    use std::time::Duration;\n    use tokio::time::sleep;\n\n    let string: String = String::from(\"test\");\n    let number: i32 = 1;\n    let future_fn = future_fn!(string, number, {\n        let tmp_string: String = String::from(\"test\");\n        assert_eq!(string, tmp_string);\n        assert_eq!(number, 1);\n    });\n    future_fn().await;\n\n    let future_fn = future_fn!(string, number, |data| {\n        let tmp_string: String = String::from(\"test\");\n        sleep(Duration::from_millis(360)).await;\n        assert_eq!(string, tmp_string);\n        assert_eq!(data, 1);\n        assert_eq!(number, 1);\n    });\n    future_fn(1).await;\n\n    let future_fn = future_fn!(string, number, |data: i32| {\n        let tmp_string: String = String::from(\"test\");\n        sleep(Duration::from_millis(360)).await;\n        assert_eq!(string, tmp_string);\n        assert_eq!(data, 1);\n        assert_eq!(number, 1);\n        sleep(Duration::from_millis(360)).await;\n    });\n    future_fn(1).await;\n\n    let future_fn = future_fn!(string, number, |data: i32| {\n        let tmp_string: String = String::from(\"test\");\n        sleep(Duration::from_millis(360)).await;\n        assert_eq!(string, tmp_string);\n        assert_eq!(data, 1);\n        assert_eq!(number, 1);\n    });\n    future_fn(1).await;\n}", "file_size": 1339, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\future-fn\\src\\macro.rs", "language": "rust", "content": "/// Generates an asynchronous closure that clones specified external variables and executes the given closure body asynchronously.\n///\n/// This macro supports two forms:\n/// 1. An async closure with no parameters.\n/// 2. An async closure with specified parameters.\n#[macro_export]\nmacro_rules! future_fn {\n    ($($var:ident),*, { $($closure_body:tt)* }) => {\n        || {\n            #[allow(unused_parens)]\n            let ($($var),*) = ($($var.clone()),*);\n            async move {\n                $($closure_body)*\n            }\n        }\n    };\n\n    ($($var:ident),*, |$( $closure_param:ident $(: $closure_param_ty:ty)? ),*| { $($closure_body:tt)* }) => {\n        {\n            #[allow(unused_parens)]\n            let ($($var),*) = ($($var.clone()),*);\n            move |$( $closure_param $(: $closure_param_ty)? ),*| {\n                let ($($var),*) = ($($var.clone()),*);\n                async move {\n                    $($closure_body)*\n                }\n            }\n        }\n    };\n}", "file_size": 996, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\file\\struct.rs", "language": "rust", "content": "/// A wrapper struct for file data in string format.\n///\n/// Provides convenient access to file contents as a string.\n#[derive(Debug, Clone)]\npub struct FileDataString(\n    /// The actual string content of the file.\n    pub(crate) String,\n);", "file_size": 241, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\lib.rs", "language": "rust", "content": "//! file-operation\n//!\n//! A Rust library providing comprehensive utilities for file operations with both sync/async support.\n//! Includes operations for copy, delete, move, read and write files. Simplifies file handling\n//! in Rust projects with safe and efficient methods for file manipulation and metadata querying.\n\npub(crate) mod copy;\npub(crate) mod delete;\npub(crate) mod file;\npub(crate) mod r#move;\npub(crate) mod read;\npub(crate) mod write;\n\npub use copy::*;\npub use delete::*;\npub use file::*;\npub use r#move::*;\npub use read::*;\npub use write::*;", "file_size": 558, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\write\\async\\fn.rs", "language": "rust", "content": "use tokio::fs::{OpenOptions, create_dir_all};\nuse tokio::io::{AsyncWriteExt, Error};\n\n/// Writes content to a file asynchronously.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n/// - `&[u8]` - The content to write.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if successful, Err with error details otherwise.\npub async fn async_write_to_file(file_path: &str, content: &[u8]) -> Result<(), Error> {\n    if let Some(parent_dir) = std::path::Path::new(file_path).parent() {\n        create_dir_all(parent_dir).await?;\n    }\n    let mut file = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .truncate(true)\n        .open(file_path)\n        .await?;\n    file.write_all(content).await?;\n    Ok(())\n}\n\n/// Appends content to a file asynchronously.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n/// - `&[u8]` - The content to append.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if successful, Err with error details otherwise.\npub async fn async_append_to_file(file_path: &str, content: &[u8]) -> Result<(), Error> {\n    if let Some(parent_dir) = std::path::Path::new(file_path).parent() {\n        create_dir_all(parent_dir).await?;\n    }\n    let mut file = OpenOptions::new()\n        .write(true)\n        .create(true)\n        .append(true)\n        .open(file_path)\n        .await?;\n    file.write_all(content).await?;\n    Ok(())\n}", "file_size": 1411, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\future-fn\\src\\lib.rs", "language": "rust", "content": "//! future-fn\n//!\n//! A Rust library providing macros to simplify the creation of\n//! asynchronous closures with external state captured by move.\n//! Useful for structuring asynchronous code with ease and clarity.\n\npub(crate) mod cfg;\npub(crate) mod r#macro;\n\n#[allow(unused_imports)]\npub use r#macro::*;", "file_size": 304, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\config\\func.rs", "language": "rust", "content": "use crate::*;\n\n/// Reads configuration from a file, creates default if not exists.\n///\n/// # Arguments\n///\n/// - `P: AsRef<Path>` - The path to the configuration file.\n///\n/// # Returns\n///\n/// - `Config` - The parsed configuration.\npub fn read_config<P: AsRef<Path>>(path: P) -> Config {\n    let path_ref: &Path = path.as_ref();\n    if !path_ref.exists() {\n        if let Some(parent) = path_ref.parent() {\n            fs::create_dir_all(parent).expect(\"Unable to create directories\");\n        }\n        let empty_config: Config = HashMap::new();\n        let data: String =\n            serde_json::to_string(&empty_config).expect(\"Unable to serialize empty config\");\n        fs::write(&path, data).expect(\"Unable to write empty config file\");\n    }\n    let data: String = fs::read_to_string(path).expect(\"Unable to read config file\");\n    serde_json::from_str(&data).expect(\"Unable to parse config file\")\n}", "file_size": 907, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\read\\async\\fn.rs", "language": "rust", "content": "use std::path::Path;\nuse tokio::fs::*;\nuse tokio::io::AsyncReadExt;\n\n/// Reads the content of a file and converts it to the specified type.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file to read.\n///\n/// # Returns\n///\n/// - `Result<T, Box<dyn std::error::Error + Send + Sync>>` - The converted file content or an error.\npub async fn async_read_from_file<T>(file_path: &str) -> Result<T, Box<dyn std::error::Error>>\nwhere\n    T: From<Vec<u8>>,\n{\n    let path: &Path = Path::new(file_path);\n    let mut file: File = File::open(path).await?;\n    let mut content: Vec<u8> = Vec::new();\n    file.read_to_end(&mut content).await?;\n    Ok(T::from(content))\n}\n\n/// Gets the size of a file in bytes.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n///\n/// # Returns\n///\n/// - `Option<u64>` - The file size in bytes if successful, None otherwise.\npub async fn async_get_file_size(file_path: &str) -> Option<u64> {\n    metadata(file_path)\n        .await\n        .and_then(|metadata| Ok(Some(metadata.len())))\n        .unwrap_or(None)\n}", "file_size": 1050, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\file\\impl.rs", "language": "rust", "content": "use super::r#struct::FileDataString;\nuse std::fmt;\n\n/// Provides conversion implementation from byte vector to FileDataString.\nimpl From<Vec<u8>> for FileDataString {\n    /// Converts a byte vector to FileDataString.\n    ///\n    /// # Arguments\n    ///\n    /// - `Vec<u8>` - The byte vector to convert.\n    ///\n    /// # Returns\n    ///\n    /// - `FileDataString` - The converted string wrapper.\n    fn from(bytes: Vec<u8>) -> Self {\n        FileDataString(String::from_utf8(bytes).unwrap_or_else(|_| String::new()))\n    }\n}\n\n/// Provides Display trait implementation for FileDataString.\nimpl fmt::Display for FileDataString {\n    /// Formats the FileDataString for display.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter<'_>` - The formatter to write to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - The result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}", "file_size": 978, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\gtl\\src\\config\\const.rs", "language": "rust", "content": "/// Path to the configuration file.\npub const CONFIG_PATH: &str = \"/home/.git_helper/config.json\";", "file_size": 98, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\move\\async\\fn.rs", "language": "rust", "content": "use std::ffi::OsString;\nuse std::future::Future;\nuse std::path::{Path, PathBuf};\nuse std::pin::Pin;\nuse tokio::fs::{ReadDir, create_dir_all, read_dir, remove_dir, remove_dir_all, rename};\nuse tokio::io::Error;\n\n/// Moves a file from the source path to the destination path asynchronously.\n///\n/// # Arguments\n///\n/// - `&str` - The source file path.\n/// - `&str` - The destination file path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was moved successfully, Err with error details otherwise.\npub async fn async_move_file(src: &str, dest: &str) -> Result<(), Error> {\n    rename(src, dest).await?;\n    Ok(())\n}\n\n/// Moves a directory and all its contents to another location asynchronously.\n///\n/// # Arguments\n///\n/// - `&str` - The source directory path.\n/// - `&str` - The destination directory path.\n///\n/// # Returns\n///\n/// - `Pin<Box<dyn Future<Output = Result<(), std::io::Error>> + 'a>>` - A pinned boxed future that resolves to the move operation result.\npub fn async_move_dir<'a>(\n    src_dir: &'a str,\n    dest_dir: &'a str,\n) -> Pin<Box<dyn Future<Output = Result<(), Error>> + 'a>> {\n    Box::pin(async move {\n        let src_path: &Path = Path::new(src_dir);\n        let dest_path: &Path = Path::new(dest_dir);\n        if dest_path.exists() {\n            remove_dir_all(dest_path).await?;\n        }\n        create_dir_all(dest_path).await?;\n        let mut entries: ReadDir = read_dir(src_path).await?;\n        while let Some(entry) = entries.next_entry().await? {\n            let file_name: OsString = entry.file_name();\n            let src_file_path: PathBuf = entry.path();\n            let mut dest_file_path: PathBuf = PathBuf::from(dest_path);\n            dest_file_path.push(file_name);\n            if src_file_path.is_dir() {\n                async_move_dir(\n                    src_file_path.to_str().unwrap(),\n                    dest_file_path.to_str().unwrap(),\n                )\n                .await?;\n            } else if src_file_path.is_file() {\n                rename(&src_file_path, &dest_file_path).await?;\n            }\n        }\n        remove_dir(src_path).await?;\n        Ok(())\n    })\n}", "file_size": 2157, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\copy\\async\\fn.rs", "language": "rust", "content": "use crate::{delete_dir, delete_file};\nuse std::{\n    ffi::OsString,\n    io::Error,\n    path::{Path, PathBuf},\n};\nuse tokio::{\n    fs::{ReadDir, copy, create_dir_all, read_dir},\n    spawn,\n    task::JoinHandle,\n};\n\n/// Asynchronously copies a file from the source path to the destination path.\n///\n/// # Arguments\n///\n/// - `&str` - The source file path.\n/// - `&str` - The destination file path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was copied successfully, Err with error details otherwise.\npub async fn async_copy_file(src: &str, dest: &str) -> Result<(), Error> {\n    copy(src, dest).await?;\n    Ok(())\n}\n\n/// Asynchronously copies all files from the source directory to the destination directory.\n///\n/// # Arguments\n///\n/// - `&str` - The source directory path.\n/// - `&str` - The destination directory path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if all files were copied successfully, Err with error details otherwise.\npub async fn async_copy_dir_files(src_dir: &str, dest_dir: &str) -> Result<(), Error> {\n    let src_path: &Path = Path::new(src_dir);\n    let dest_path: &Path = Path::new(dest_dir);\n    if dest_path.exists() {\n        if let Some(dest_path_str) = dest_path.to_str() {\n            if dest_path.is_file() {\n                delete_file(dest_path_str)?;\n            }\n            if dest_path.is_dir() {\n                delete_dir(dest_path_str)?;\n            }\n        }\n    }\n    create_dir_all(dest_path).await?;\n    let mut tasks: Vec<JoinHandle<Result<(), Error>>> = Vec::new();\n    let mut read_dir: ReadDir = read_dir(src_path).await?;\n    while let Some(entry) = read_dir.next_entry().await? {\n        let file_name: OsString = entry.file_name();\n        let src_file_path: PathBuf = entry.path();\n        let mut dest_file_path: PathBuf = PathBuf::from(dest_path);\n        dest_file_path.push(file_name);\n        if src_file_path.is_dir() {\n            let src_file_path_str: String = src_file_path.to_str().unwrap().to_string();\n            let dest_file_path_str: String = dest_file_path.to_str().unwrap().to_string();\n            tasks.push(spawn(async move {\n                async_copy_file(&src_file_path_str, &dest_file_path_str).await\n            }));\n        } else if src_file_path.is_file() {\n            let src_file_path_str: String = src_file_path.to_str().unwrap().to_string();\n            let dest_file_path_str: String = dest_file_path.to_str().unwrap().to_string();\n            tasks.push(spawn(async move {\n                async_copy_file(&src_file_path_str, &dest_file_path_str).await\n            }));\n        }\n    }\n    for task in tasks {\n        task.await??;\n    }\n    Ok(())\n}", "file_size": 2692, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\delete\\sync\\fn.rs", "language": "rust", "content": "use std::{io::Error, path::Path};\n\n/// Deletes a file at the given path.\n///\n/// # Arguments\n///\n/// - `&str` - The file path to delete.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was deleted successfully, Err with error details otherwise.\npub fn delete_file(path: &str) -> Result<(), Error> {\n    std::fs::remove_file(path)\n}\n\n/// Deletes a directory and all its contents.\n///\n/// # Arguments\n///\n/// - `&str` - The directory path to delete.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the directory was deleted successfully, Err with error details otherwise.\npub fn delete_dir(path: &str) -> Result<(), Error> {\n    let dir_path: &Path = Path::new(path);\n    std::fs::remove_dir_all(dir_path)?;\n    Ok(())\n}", "file_size": 761, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\copy\\sync\\fn.rs", "language": "rust", "content": "use crate::*;\nuse std::{\n    ffi::OsString,\n    fs::{DirEntry, copy, create_dir_all, read_dir},\n    io::Error,\n    path::{Path, PathBuf},\n};\n\n/// Copies a file from the source path to the destination path.\n///\n/// # Arguments\n///\n/// - `&str` - The source file path.\n/// - `&str` - The destination file path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was copied successfully, Err with error details otherwise.\npub fn copy_file(src: &str, dest: &str) -> Result<(), Error> {\n    copy(src, dest)?;\n    Ok(())\n}\n\n/// Copies all files from the source directory to the destination directory.\n///\n/// # Arguments\n///\n/// - `&str` - The source directory path.\n/// - `&str` - The destination directory path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if all files were copied successfully, Err with error details otherwise.\npub fn copy_dir_files(src_dir: &str, dest_dir: &str) -> Result<(), Error> {\n    let src_path: &Path = Path::new(src_dir);\n    let dest_path: &Path = Path::new(dest_dir);\n    if dest_path.exists() {\n        if let Some(dest_path_str) = dest_path.to_str() {\n            if dest_path.is_file() {\n                delete_file(dest_path_str)?;\n            }\n            if dest_path.is_dir() {\n                delete_dir(dest_path_str)?;\n            }\n        }\n    }\n    create_dir_all(dest_path)?;\n    for entry in read_dir(src_path)? {\n        let entry: DirEntry = entry?;\n        let file_name: OsString = entry.file_name();\n        let src_file_path: PathBuf = entry.path();\n        let mut dest_file_path: PathBuf = PathBuf::from(dest_path);\n        dest_file_path.push(file_name);\n        if src_file_path.is_dir() {\n            copy_dir_files(\n                src_file_path.to_str().unwrap(),\n                dest_file_path.to_str().unwrap(),\n            )?;\n        } else if src_file_path.is_file() {\n            copy(&src_file_path, &dest_file_path)?;\n        }\n    }\n    Ok(())\n}", "file_size": 1952, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_compare_version() {\n    use crate::*;\n    let version1: &str = \"1.2.3-alpha\";\n    let version2: &str = \"1.2.3-alpha\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Equal);\n    let version1: &str = \"1.2.3\";\n    let version2: &str = \"1.2.3-alpha\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Less);\n    let version1: &str = \"1.2.2\";\n    let version2: &str = \"1.2.3-alpha\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Less);\n    let version1: &str = \"1.2.4\";\n    let version2: &str = \"1.2.3-alpha\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Greater);\n    let version1: &str = \"1.2.4\";\n    let version2: &str = \"1.2.3\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Greater);\n    let version1: &str = \"1.2.4\";\n    let version2: &str = \"1.2.5\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Less);\n    let version1: &str = \"1.2.4\";\n    let version2: &str = \"1.2.4\";\n    let result: Result<VersionComparison, VersionError> =\n        CompareVersion::compare_version(version1, version2);\n    assert_eq!(result.unwrap(), VersionComparison::Equal);\n}\n\n#[test]\nfn test_matches_version_range() {\n    use crate::*;\n    let version: &str = \"1.2.3-alpha\";\n    let range1: &str = \"^1.2.0\";\n    let range2: &str = \"~1.2.3\";\n    let result: bool = match CompareVersion::matches_version_range(version, range1) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, true);\n    let result: bool = match CompareVersion::matches_version_range(version, range2) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, true);\n\n    let version: &str = \"1.2.5-alpha\";\n    let range1: &str = \"^1.2.0\";\n    let range2: &str = \"~1.2.3\";\n    let result: bool = match CompareVersion::matches_version_range(version, range1) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, true);\n    let result: bool = match CompareVersion::matches_version_range(version, range2) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, true);\n\n    let version: &str = \"1.3.0\";\n    let range1: &str = \"^1.2.0\";\n    let range2: &str = \"~1.2.3\";\n    let result: bool = match CompareVersion::matches_version_range(version, range1) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, true);\n    let result: bool = match CompareVersion::matches_version_range(version, range2) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, false);\n\n    let version: &str = \"2.0.0\";\n    let range1: &str = \"^1.2.0\";\n    let range2: &str = \"~1.2.3\";\n    let result: bool = match CompareVersion::matches_version_range(version, range1) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, false);\n    let result: bool = match CompareVersion::matches_version_range(version, range2) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, false);\n\n    let version: &str = \"1.0.0\";\n    let range1: &str = \"^1.2.0\";\n    let range2: &str = \"~1.2.3\";\n    let result: bool = match CompareVersion::matches_version_range(version, range1) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, false);\n    let result: bool = match CompareVersion::matches_version_range(version, range2) {\n        Ok(matches) => matches,\n        Err(_) => false,\n    };\n    assert_eq!(result, false);\n}", "file_size": 4187, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\read\\sync\\fn.rs", "language": "rust", "content": "use std::fs::*;\nuse std::io::Read;\nuse std::path::Path;\n\n/// Reads the content of a file and converts it to the specified type.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file to read.\n///\n/// # Returns\n///\n/// - `Result<T, Box<dyn std::error::Error + Send + Sync>>` - The converted file content or an error.\npub fn read_from_file<T>(file_path: &str) -> Result<T, Box<dyn std::error::Error>>\nwhere\n    T: From<Vec<u8>>,\n{\n    let path: &Path = Path::new(file_path);\n    let mut file: File = File::open(path)?;\n    let mut content: Vec<u8> = Vec::new();\n    file.read_to_end(&mut content)?;\n    Ok(T::from(content))\n}\n\n/// Gets the size of a file in bytes.\n///\n/// # Arguments\n///\n/// - `&str` - The path to the file.\n///\n/// # Returns\n///\n/// - `Option<u64>` - The file size in bytes if successful, None otherwise.\npub fn get_file_size(file_path: &str) -> Option<u64> {\n    metadata(file_path)\n        .and_then(|metadata| Ok(Some(metadata.len())))\n        .unwrap_or(None)\n}", "file_size": 987, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl ColorContrast {\n    /// Calculates the relative luminance of a color.\n    ///\n    /// # Arguments\n    ///\n    /// - `u8` - Red component (0-255)\n    /// - `u8` - Green component (0-255)\n    /// - `u8` - Blue component (0-255)\n    ///\n    /// # Returns\n    ///\n    /// - `f64` - Relative luminance value (0.0-1.0)\n    pub fn calculate_luminance(r: u8, g: u8, b: u8) -> f64 {\n        let r_norm: f64 = r as f64 / 255.0;\n        let g_norm: f64 = g as f64 / 255.0;\n        let b_norm: f64 = b as f64 / 255.0;\n        let r_linear: f64 = if r_norm <= 0.03928 {\n            r_norm / 12.92\n        } else {\n            ((r_norm + 0.055) / 1.055).powf(2.4)\n        };\n        let g_linear: f64 = if g_norm <= 0.03928 {\n            g_norm / 12.92\n        } else {\n            ((g_norm + 0.055) / 1.055).powf(2.4)\n        };\n        let b_linear: f64 = if b_norm <= 0.03928 {\n            b_norm / 12.92\n        } else {\n            ((b_norm + 0.055) / 1.055).powf(2.4)\n        };\n        0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear\n    }\n\n    /// Calculates the contrast ratio between two colors.\n    ///\n    /// # Arguments\n    ///\n    /// - `(u8, u8, u8)` - First color RGB values\n    /// - `(u8, u8, u8)` - Second color RGB values\n    ///\n    /// # Returns\n    ///\n    /// - `f64` - Contrast ratio (1.0-21.0)\n    pub fn calculate_contrast_ratio(color1: (u8, u8, u8), color2: (u8, u8, u8)) -> f64 {\n        let lum1: f64 = Self::calculate_luminance(color1.0, color1.1, color1.2);\n        let lum2: f64 = Self::calculate_luminance(color2.0, color2.1, color2.2);\n        let lighter: f64 = lum1.max(lum2);\n        let darker: f64 = lum1.min(lum2);\n        (lighter + 0.05) / (darker + 0.05)\n    }\n\n    /// Extracts RGB values from ColorType.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ColorType` - Color to extract RGB from\n    ///\n    /// # Returns\n    ///\n    /// - `(u8, u8, u8)` - RGB values\n    pub fn extract_rgb_from_color_type(color: &ColorType) -> (u8, u8, u8) {\n        match color {\n            ColorType::Rgb(r, g, b) => (*r, *g, *b),\n            ColorType::Color256(hex) => {\n                let r: u8 = ((hex >> 16) & 0xFF) as u8;\n                let g: u8 = ((hex >> 8) & 0xFF) as u8;\n                let b: u8 = (hex & 0xFF) as u8;\n                (r, g, b)\n            }\n            ColorType::Use(color) => {\n                use super::r#type::Color;\n                match color {\n                    Color::Default => (128, 128, 128),\n                    Color::Black => (0, 0, 0),\n                    Color::Red => (255, 0, 0),\n                    Color::Green => (0, 255, 0),\n                    Color::Yellow => (255, 255, 0),\n                    Color::Blue => (0, 0, 255),\n                    Color::Magenta => (255, 0, 255),\n                    Color::Cyan => (0, 255, 255),\n                    Color::White => (255, 255, 255),\n                }\n            }\n        }\n    }\n\n    /// Checks if two colors have sufficient contrast for readability.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ColorType` - Text color\n    /// - `&ColorType` - Background color\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Whether contrast is sufficient (ratio >= 4.5)\n    pub fn has_sufficient_contrast(text_color: &ColorType, bg_color: &ColorType) -> bool {\n        let text_rgb: (u8, u8, u8) = Self::extract_rgb_from_color_type(text_color);\n        let bg_rgb: (u8, u8, u8) = Self::extract_rgb_from_color_type(bg_color);\n        let ratio: f64 = Self::calculate_contrast_ratio(text_rgb, bg_rgb);\n        ratio >= 4.5\n    }\n\n    /// Automatically adjusts text color to ensure sufficient contrast with background.\n    ///\n    /// # Arguments\n    ///\n    /// - `&ColorType` - Original text color\n    /// - `&ColorType` - Background color\n    ///\n    /// # Returns\n    ///\n    /// - `ColorType` - Adjusted text color with sufficient contrast\n    pub fn ensure_sufficient_contrast(text_color: &ColorType, bg_color: &ColorType) -> ColorType {\n        if Self::has_sufficient_contrast(text_color, bg_color) {\n            return text_color.clone();\n        }\n        let text_rgb: (u8, u8, u8) = Self::extract_rgb_from_color_type(text_color);\n        let bg_rgb: (u8, u8, u8) = Self::extract_rgb_from_color_type(bg_color);\n        let bg_luminance: f64 = Self::calculate_luminance(bg_rgb.0, bg_rgb.1, bg_rgb.2);\n        if bg_luminance > 0.5 {\n            Self::darken_color_for_contrast(text_rgb, bg_rgb)\n        } else {\n            Self::lighten_color_for_contrast(text_rgb, bg_rgb)\n        }\n    }\n\n    /// Darkens a color while preserving its hue for better contrast against light backgrounds.\n    ///\n    /// # Arguments\n    ///\n    /// - `(u8, u8, u8)` - Original text color RGB\n    /// - `(u8, u8, u8)` - Background color RGB\n    ///\n    /// # Returns\n    ///\n    /// - `ColorType` - Darkened color with sufficient contrast\n    fn darken_color_for_contrast(text_rgb: (u8, u8, u8), bg_rgb: (u8, u8, u8)) -> ColorType {\n        let (r, g, b): (u8, u8, u8) = text_rgb;\n        let max_component: u8 = r.max(g).max(b);\n        if max_component == 0 {\n            return ColorType::Rgb(0, 0, 0);\n        }\n        let scale_factor: f64 = 0.3;\n        let new_r: u8 = ((r as f64 * scale_factor) as u8).min(80);\n        let new_g: u8 = ((g as f64 * scale_factor) as u8).min(80);\n        let new_b: u8 = ((b as f64 * scale_factor) as u8).min(80);\n        let result_color: ColorType = ColorType::Rgb(new_r, new_g, new_b);\n        if Self::calculate_contrast_ratio((new_r, new_g, new_b), bg_rgb) >= 4.5 {\n            result_color\n        } else {\n            ColorType::Rgb(0, 0, 0)\n        }\n    }\n\n    /// Lightens a color while preserving its hue for better contrast against dark backgrounds.\n    ///\n    /// # Arguments\n    ///\n    /// - `(u8, u8, u8)` - Original text color RGB\n    /// - `(u8, u8, u8)` - Background color RGB\n    ///\n    /// # Returns\n    ///\n    /// - `ColorType` - Lightened color with sufficient contrast\n    fn lighten_color_for_contrast(text_rgb: (u8, u8, u8), bg_rgb: (u8, u8, u8)) -> ColorType {\n        let (r, g, b): (u8, u8, u8) = text_rgb;\n        let scale_factor: f64 = 2.5;\n        let new_r: u8 = ((r as f64 * scale_factor) as u8).min(255).max(200);\n        let new_g: u8 = ((g as f64 * scale_factor) as u8).min(255).max(200);\n        let new_b: u8 = ((b as f64 * scale_factor) as u8).min(255).max(200);\n        let result_color: ColorType = ColorType::Rgb(new_r, new_g, new_b);\n        if Self::calculate_contrast_ratio((new_r, new_g, new_b), bg_rgb) >= 4.5 {\n            result_color\n        } else {\n            ColorType::Rgb(255, 255, 255)\n        }\n    }\n}", "file_size": 6640, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\blod.rs", "language": "rust", "content": "/// ANSI escape code for bold text formatting.\npub const BLOD: &str = \"\\x1b[1m\";\n\n/// ANSI escape code to reset bold text formatting.\npub const UNBLOD: &str = \"\\x1b[22m\";", "file_size": 170, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\compare_version\\enum.rs", "language": "rust", "content": "/// Result of comparing two versions.\n///\n/// Indicates whether the first version is greater than, less than, or equal to the second version.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum VersionComparison {\n    /// Indicates that the first version is greater than the second version.\n    Greater,\n    /// Indicates that the first version is less than the second version.\n    Less,\n    /// Indicates that the two versions are equal.\n    Equal,\n}", "file_size": 464, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\compare_version\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod error;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub use r#enum::*;\npub use error::*;\npub use r#struct::*;", "file_size": 151, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\compare_version\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Version {\n    /// Parses a version from a string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - A string slice that holds the version in the format 'x.y.z'.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<Self, VersionError>` - A `Result` indicating the parsed `Version` struct on success, or a `VersionError` on failure.\n    pub(crate) fn parse(version: &str) -> Result<Self, VersionError> {\n        let mut parts: Vec<&str> = version.split('.').collect();\n        let (patch_part, pre_release) = if let Some(patch_with_prerelease) = parts.pop() {\n            let mut patch_parts = patch_with_prerelease.splitn(2, '-');\n            (\n                patch_parts.next().unwrap_or(\"\"),\n                patch_parts.next().map(|s| s.to_string()),\n            )\n        } else {\n            return Err(VersionError::ParseError(\n                \"Version format error, should be in the form 'x.y.z'.\".to_string(),\n            ));\n        };\n        let major: u32 = parts\n            .get(0)\n            .unwrap_or(&\"0\")\n            .parse::<u32>()\n            .map_err(|_| VersionError::MajorVersionError)?;\n        let minor: u32 = parts\n            .get(1)\n            .unwrap_or(&\"0\")\n            .parse::<u32>()\n            .map_err(|_| VersionError::MinorVersionError)?;\n        let patch: u32 = patch_part\n            .parse::<u32>()\n            .map_err(|_| VersionError::PatchVersionError)?;\n        Ok(Self {\n            major,\n            minor,\n            patch,\n            pre_release,\n        })\n    }\n}\n\nimpl CompareVersion {\n    /// Compares two version strings and returns a `VersionComparison` enum.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The first version string to compare.\n    /// - `&str` - The second version string to compare.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<VersionComparison, VersionError>` - A `Result` indicating the comparison result on success, or a `VersionError` on failure.\n    pub fn compare_version(\n        version1: &str,\n        version2: &str,\n    ) -> Result<VersionComparison, VersionError> {\n        let v1: Version = Version::parse(version1)?;\n        let v2: Version = Version::parse(version2)?;\n        match v1.cmp(&v2) {\n            std::cmp::Ordering::Greater => Ok(VersionComparison::Greater),\n            std::cmp::Ordering::Less => Ok(VersionComparison::Less),\n            std::cmp::Ordering::Equal => Ok(VersionComparison::Equal),\n        }\n    }\n\n    /// Checks whether a version matches a specified range, supporting `^` and `~` ranges.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The version string to check.\n    /// - `&str` - The version range string to match against.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<bool, VersionError>` - A `Result` indicating whether the version matches the range on success, or a `VersionError` on failure.\n    pub fn matches_version_range(version: &str, range: &str) -> Result<bool, VersionError> {\n        let target_version: Version = Version::parse(version)?;\n        if let Some(stripped_range) = range.strip_prefix('^') {\n            let base_version = Version::parse(stripped_range)?;\n            // `^` indicates major version compatibility\n            Ok(target_version.major == base_version.major\n                && (target_version.minor > base_version.minor\n                    || (target_version.minor == base_version.minor\n                        && target_version >= base_version)))\n        } else if let Some(stripped_range) = range.strip_prefix('~') {\n            let base_version: Version = Version::parse(stripped_range)?;\n            // `~` indicates minor version compatibility\n            Ok(target_version.major == base_version.major\n                && target_version.minor == base_version.minor\n                && target_version >= base_version)\n        } else {\n            Err(VersionError::InvalidRangeFormat)\n        }\n    }\n}", "file_size": 3927, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\lib.rs", "language": "rust", "content": "//! compare_version\n//!\n//! A Rust library for comparing semantic versioning\n//! strings and checking version compatibility.\n\npub(crate) mod cfg;\npub(crate) mod compare_version;\n\npub use compare_version::*;\n\npub(crate) use std::fmt;", "file_size": 232, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\delete\\async\\fn.rs", "language": "rust", "content": "use std::path::Path;\nuse tokio::fs::{remove_dir_all, remove_file};\nuse tokio::io::Error;\n\n/// Asynchronously deletes a file at the given path.\n///\n/// # Arguments\n///\n/// - `&str` - The file path to delete.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was deleted successfully, Err with error details otherwise.\npub async fn async_delete_file(path: &str) -> Result<(), Error> {\n    remove_file(path).await\n}\n\n/// Asynchronously deletes a directory and all its contents.\n///\n/// # Arguments\n///\n/// - `&str` - The directory path to delete.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the directory was deleted successfully, Err with error details otherwise.\npub async fn async_delete_dir(path: &str) -> Result<(), Error> {\n    let dir_path: &Path = Path::new(path);\n    remove_dir_all(dir_path).await?;\n    Ok(())\n}", "file_size": 864, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\file-operation\\src\\move\\sync\\fn.rs", "language": "rust", "content": "use std::ffi::OsString;\nuse std::path::Path;\nuse std::path::PathBuf;\n\n/// Moves a file from the source path to the destination path.\n///\n/// # Arguments\n///\n/// - `&str` - The source file path.\n/// - `&str` - The destination file path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the file was moved successfully, Err with error details otherwise.\npub fn move_file(src: &str, dest: &str) -> Result<(), std::io::Error> {\n    std::fs::rename(src, dest)?;\n    Ok(())\n}\n\n/// Moves a directory and all its contents to another location.\n///\n/// # Arguments\n///\n/// - `&str` - The source directory path.\n/// - `&str` - The destination directory path.\n///\n/// # Returns\n///\n/// - `Result<(), std::io::Error>` - Ok if the directory was moved successfully, Err with error details otherwise.\npub fn move_dir(src_dir: &str, dest_dir: &str) -> Result<(), std::io::Error> {\n    let src_path: &Path = Path::new(src_dir);\n    let dest_path: &Path = Path::new(dest_dir);\n    if dest_path.exists() {\n        std::fs::remove_dir_all(dest_path)?;\n    }\n    std::fs::create_dir_all(dest_path)?;\n    for entry in std::fs::read_dir(src_path)? {\n        let entry: std::fs::DirEntry = entry?;\n        let file_name: OsString = entry.file_name();\n        let src_file_path: PathBuf = entry.path();\n        let mut dest_file_path: PathBuf = PathBuf::from(dest_path);\n        dest_file_path.push(file_name);\n        if src_file_path.is_dir() {\n            move_dir(\n                src_file_path.to_str().unwrap(),\n                dest_file_path.to_str().unwrap(),\n            )?;\n        } else if src_file_path.is_file() {\n            std::fs::rename(&src_file_path, &dest_file_path)?;\n        }\n    }\n    std::fs::remove_dir(src_path)?;\n    Ok(())\n}", "file_size": 1745, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\compare_version\\struct.rs", "language": "rust", "content": "/// Represents a semantic version with major, minor, patch, and pre-release components.\n///\n/// Follows semantic versioning specification (SemVer).\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub(crate) struct Version {\n    /// Major version number.\n    pub(crate) major: u32,\n    /// Minor version number.\n    pub(crate) minor: u32,\n    /// Patch version number.\n    pub(crate) patch: u32,\n    /// Optional pre-release identifier.\n    pub(crate) pre_release: Option<String>,\n}\n\n/// Utility for comparing version strings.\n///\n/// Provides methods for version comparison and range matching.\n#[derive(Clone)]\npub struct CompareVersion;", "file_size": 645, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\macro\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_proc_macro_output_struct() {\n    use crate::*;\n    output_macro!(Output {\n        text: \"test_proc_macro\",\n        color: ColorType::default(),\n        bg_color: ColorType::Use(Color::Yellow),\n        endl: true,\n        ..Default::default()\n    });\n}\n\n#[test]\nfn test_proc_macro_output_builder() {\n    use crate::*;\n    output_macro!(\n        OutputBuilder::new()\n            .text(\"test_output_builder\")\n            .color(ColorType::Use(Color::Cyan))\n            .blod(true)\n            .endl(true)\n            .build()\n    );\n}\n\n#[test]\nfn test_proc_macro_multiple() {\n    use crate::*;\n    output_macro!(\n        Output {\n            text: \"test_proc_macro\",\n            color: ColorType::default(),\n            bg_color: ColorType::Use(Color::Yellow),\n            endl: true,\n            ..Default::default()\n        },\n        OutputBuilder::new()\n            .text(\"test_output_builder1\")\n            .color(ColorType::Color256(0xffffff))\n            .blod(true)\n            .endl(true)\n            .build(),\n        OutputBuilder::new()\n            .text(\"test_output_builder2\")\n            .color(ColorType::Color256(0xffffff))\n            .blod(true)\n            .endl(true)\n            .build()\n    );\n}\n\n#[test]\nfn test_print_type() {\n    use crate::*;\n    let msg: &str = \"1\\n2\\n3\\r\\n4\";\n    println_success!(msg);\n    println!(\"==========\");\n    println_warning!(msg);\n    println!(\"==========\");\n    println_error!(msg);\n    println!(\"==========\");\n    let msg: &str = \"1234\";\n    println_success!(msg, msg);\n    println!(\"==========\");\n    println_warning!(msg, msg);\n    println!(\"==========\");\n    println_error!(msg, msg);\n    println!(\"==========\");\n}", "file_size": 1688, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\fn.rs", "language": "rust", "content": "/// Generates an ANSI escape sequence for foreground colors in 256 colors.\n///\n/// # Arguments\n///\n/// - `u32` - RGB color code in hexadecimal format (0x000000 to 0xFFFFFF)\n///\n/// # Returns\n///\n/// - `String` - ANSI escape sequence for the foreground color\npub fn color256_fg_color(code: u32) -> String {\n    if code > 0xFFFFFF {\n        return String::new();\n    }\n    let r: u32 = (code >> 16) & 0xFF;\n    let g: u32 = (code >> 8) & 0xFF;\n    let b: u32 = code & 0xFF;\n    let color_index: u32 = rgb_to_256_color_index(r as u8, g as u8, b as u8);\n    format!(\"\\x1b[38;5;{}m\", color_index)\n}\n\n/// Generates an ANSI escape sequence for background colors in 256 colors.\n///\n/// # Arguments\n///\n/// - `u32` - RGB color code in hexadecimal format (0x000000 to 0xFFFFFF)\n///\n/// # Returns\n///\n/// - `String` - ANSI escape sequence for the background color\npub fn color256_bg_color(code: u32) -> String {\n    if code > 0xFFFFFF {\n        return String::new();\n    }\n    let r: u32 = (code >> 16) & 0xFF;\n    let g: u32 = (code >> 8) & 0xFF;\n    let b: u32 = code & 0xFF;\n    let color_index: u32 = rgb_to_256_color_index(r as u8, g as u8, b as u8);\n    format!(\"\\x1b[48;5;{}m\", color_index)\n}\n\n/// Generates an ANSI escape sequence for true color foreground colors.\n///\n/// # Arguments\n///\n/// - `u8` - Red component (0-255)\n/// - `u8` - Green component (0-255)\n/// - `u8` - Blue component (0-255)\n///\n/// # Returns\n///\n/// - `String` - ANSI escape sequence for the true color foreground\npub fn rgb_fg_color(r: u8, g: u8, b: u8) -> String {\n    format!(\"\\x1b[38;2;{};{};{}m\", r, g, b)\n}\n\n/// Generates an ANSI escape sequence for true color background colors.\n///\n/// # Arguments\n///\n/// - `u8` - Red component (0-255)\n/// - `u8` - Green component (0-255)\n/// - `u8` - Blue component (0-255)\n///\n/// # Returns\n///\n/// - `String` - ANSI escape sequence for the true color background\npub fn rgb_bg_color(r: u8, g: u8, b: u8) -> String {\n    format!(\"\\x1b[48;2;{};{};{}m\", r, g, b)\n}\n\n/// Converts RGB values to 256-color palette index with high precision.\n///\n/// # Arguments\n///\n/// - `u8` - Red component (0-255)\n/// - `u8` - Green component (0-255)\n/// - `u8` - Blue component (0-255)\n///\n/// # Returns\n///\n/// - `u32` - 256-color palette index (16-231 for RGB colors, 0-15 for standard colors, 232-255 for grayscale)\nfn rgb_to_256_color_index(r: u8, g: u8, b: u8) -> u32 {\n    if r == g && g == b {\n        if r < 8 {\n            return 16;\n        } else if r > 248 {\n            return 231;\n        } else {\n            return 232 + ((r as u32 - 8) * 24 / 248);\n        }\n    }\n    let r_index: u32 = if r < 48 {\n        0\n    } else if r < 115 {\n        1\n    } else {\n        (r as u32 - 35) / 40\n    };\n    let g_index: u32 = if g < 48 {\n        0\n    } else if g < 115 {\n        1\n    } else {\n        (g as u32 - 35) / 40\n    };\n    let b_index: u32 = if b < 48 {\n        0\n    } else if b < 115 {\n        1\n    } else {\n        (b as u32 - 35) / 40\n    };\n    16 + 36 * r_index + 6 * g_index + b_index\n}", "file_size": 3009, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\compare-version\\src\\compare_version\\error.rs", "language": "rust", "content": "use crate::*;\n\n/// Errors that can occur during version parsing and comparison.\n#[derive(Debug, PartialEq, Eq, PartialOrd, Ord, Clone)]\npub enum VersionError {\n    /// An error occurred during parsing, with a specific message.\n    ParseError(String),\n    /// The format of the version range is invalid.\n    InvalidRangeFormat,\n    /// An error occurred while parsing the major version component.\n    MajorVersionError,\n    /// An error occurred while parsing the minor version component.\n    MinorVersionError,\n    /// An error occurred while parsing the patch version component.\n    PatchVersionError,\n}\n\n/// Implements the `Display` trait for `VersionError` to provide user-friendly error messages.\nimpl fmt::Display for VersionError {\n    /// Formats the `VersionError` into a human-readable string.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter` - Formatter to write the output to.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        match self {\n            VersionError::ParseError(msg) => write!(f, \"Parse error: {}\", msg),\n            VersionError::InvalidRangeFormat => {\n                write!(f, \"Unsupported range format, only '^' or '~' are supported\")\n            }\n            VersionError::MajorVersionError => write!(f, \"Major version parsing error\"),\n            VersionError::MinorVersionError => write!(f, \"Minor version parsing error\"),\n            VersionError::PatchVersionError => write!(f, \"Patch version parsing error\"),\n        }\n    }\n}", "file_size": 1596, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\struct.rs", "language": "rust", "content": "/// Provides utilities for calculating and ensuring color contrast ratios.\n///\n/// Used to determine if text colors meet WCAG accessibility standards\n/// when displayed on specific background colors.\n#[derive(Clone)]\npub struct ColorContrast;", "file_size": 242, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\mod.rs", "language": "rust", "content": "pub(crate) mod blod;\npub(crate) mod cfg;\npub(crate) mod r#const;\npub(crate) mod r#fn;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\npub(crate) mod r#type;", "file_size": 156, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_color() {\n    use crate::*;\n    use color::r#const::DEFAULT;\n    let color: Color = Color::Default;\n    let color_str: &String = &color.to_string();\n    assert_eq!(color_str, DEFAULT);\n}\n\n#[test]\nfn test_color_get_str() {\n    use crate::*;\n    let color_str: &str = &Color::Default.get_str(DisplayType::Text);\n    let res_color_str: &String = &Color::Default.to_string();\n    assert_eq!(color_str, res_color_str);\n}\n\n#[test]\nfn test_bg_color() {\n    use crate::*;\n    use color::r#const::DEFAULT;\n    let bg_color: Color = Color::Default;\n    let bg_color_str: &String = &bg_color.to_string();\n    assert_eq!(bg_color_str, DEFAULT);\n}\n\n#[test]\nfn test_bg_color_get_str() {\n    use crate::*;\n    let bg_color_str: &str = &Color::Default.get_str(DisplayType::Background);\n    let ans_bg_color_str: &String = &Color::Default.to_string();\n    assert_eq!(bg_color_str, ans_bg_color_str);\n}\n\n#[test]\nfn test_color256_fg_color() {\n    use crate::*;\n    use color::r#fn::color256_fg_color;\n    let color_str: String = color256_fg_color(0x3f3f3f);\n    let ans_color_str: String = format!(\"\\x1b[38;5;{}m\", 237);\n    assert_eq!(color_str, ans_color_str);\n}\n\n#[test]\nfn test_color256_bg_color() {\n    use crate::*;\n    use color::r#fn::color256_bg_color;\n    let color_str: String = color256_bg_color(0x000000);\n    let ans_color_str: String = format!(\"\\x1b[48;5;{}m\", 16);\n    assert_eq!(color_str, ans_color_str);\n}\n\n#[test]\nfn test_rgb_fg_color() {\n    use crate::*;\n    use color::r#fn::rgb_fg_color;\n    let color_str: String = rgb_fg_color(255, 255, 255);\n    let ans_color_str: String = format!(\"\\x1b[38;2;{};{};{}m\", 255, 255, 255);\n    assert_eq!(color_str, ans_color_str);\n}\n\n#[test]\nfn test_rgb_bg_color() {\n    use crate::*;\n    use color::r#fn::rgb_bg_color;\n    let color_str: String = rgb_bg_color(0, 0, 0);\n    let ans_color_str: String = format!(\"\\x1b[48;2;{};{};{}m\", 0, 0, 0);\n    assert_eq!(color_str, ans_color_str);\n}", "file_size": 1943, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents different types of colors that can be used for text formatting.\n#[derive(Debug, Clone, PartialEq)]\npub enum ColorType {\n    /// RGB color with red, green and blue components.\n    Rgb(u8, u8, u8),\n    /// 256-color palette color.\n    Color256(u32),\n    /// Predefined built-in colors.\n    Use(Color),\n}\n\n/// Specifies whether color applies to text or background.\n#[derive(Debug, Clone, PartialEq)]\npub(crate) enum DisplayType {\n    /// Color applies to text.\n    Text,\n    /// Color applies to background.\n    Background,\n}\n\n/// Predefined color constants for easy text formatting.\n#[derive(Debug, Clone, PartialEq)]\npub enum Color {\n    /// Default terminal color.\n    Default,\n    /// Black color.\n    Black,\n    /// Red color.\n    Red,\n    /// Green color.\n    Green,\n    /// Yellow color.\n    Yellow,\n    /// Blue color.\n    Blue,\n    /// Magenta color.\n    Magenta,\n    /// Cyan color.\n    Cyan,\n    /// White color.\n    White,\n}\n\n/// Trait for converting colors to their ANSI escape sequences.\npub(crate) trait ColorDisplay {\n    /// Gets the ANSI escape sequence for the color.\n    ///\n    /// # Arguments\n    ///\n    /// - `&Self` - Reference to self\n    /// - `DisplayType` - Whether to apply to text or background\n    ///\n    /// # Returns\n    ///\n    /// - `String` - The ANSI escape sequence string\n    fn get_str(&self, display_type: DisplayType) -> String;\n}\n\nimpl Default for Color {\n    fn default() -> Self {\n        Color::Default\n    }\n}\n\nimpl ColorDisplay for Color {\n    fn get_str(&self, display_type: DisplayType) -> String {\n        let str: &str = match display_type {\n            DisplayType::Text => match self {\n                Color::Red => RED,\n                Color::Green => GREEN,\n                Color::Blue => BLUE,\n                Color::Yellow => YELLOW,\n                Color::Black => BLACK,\n                Color::White => WHITE,\n                Color::Default => DEFAULT,\n                Color::Magenta => MAGENTA,\n                Color::Cyan => CYAN,\n            },\n            DisplayType::Background => match self {\n                Color::Red => BG_RED,\n                Color::Green => BG_GREEN,\n                Color::Blue => BG_BLUE,\n                Color::Yellow => BG_YELLOW,\n                Color::Black => BG_BLACK,\n                Color::White => BG_WHITE,\n                Color::Default => DEFAULT,\n                Color::Magenta => BG_MAGENTA,\n                Color::Cyan => BG_CYAN,\n            },\n        };\n        str.to_string()\n    }\n}\n\nimpl Display for Color {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.get_str(DisplayType::Text))\n    }\n}\n\nimpl Display for ColorType {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"{}\", self.get_str(DisplayType::Text))\n    }\n}\n\nimpl ColorDisplay for ColorType {\n    fn get_str(&self, display_type: DisplayType) -> String {\n        match self {\n            ColorType::Color256(fg) => match display_type {\n                DisplayType::Text => color256_fg_color(*fg),\n                DisplayType::Background => color256_bg_color(*fg),\n            },\n            ColorType::Rgb(r, g, b) => match display_type {\n                DisplayType::Text => rgb_fg_color(*r, *g, *b),\n                DisplayType::Background => rgb_bg_color(*r, *g, *b),\n            },\n            ColorType::Use(color) => color.get_str(display_type.clone()),\n        }\n    }\n}\n\nimpl Default for ColorType {\n    fn default() -> Self {\n        ColorType::Use(Color::Default)\n    }\n}", "file_size": 3550, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output\\fn.rs", "language": "rust", "content": "use crate::*;\n\n/// Executes the output operation with the given formatting.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\n///\n/// # Arguments\n///\n/// - `Output` - The output configuration\npub fn output(output: Output) {\n    // Text\n    let text: &str = output.text;\n    let color: ColorType = output.color.clone();\n    let bg_color: ColorType = output.bg_color.clone();\n    let blod: bool = output.blod.clone();\n    // endl\n    let endl: bool = output.endl;\n    let mut task_list: Task<'_> = Task::default();\n    // Add text\n    task_list.add(Text {\n        text,\n        color,\n        bg_color,\n        blod,\n        endl,\n    });\n    // run\n    task_list.run_all();\n}", "file_size": 694, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\macro\\macro.rs", "language": "rust", "content": "/// Macro for outputting colored text to the terminal.\n///\n/// # Arguments\n///\n/// - `Output` or `OutputBuilder` - One or more output instances to execute\n#[macro_export]\nmacro_rules! output_macro {\n    ($($output:expr),*) => {\n        $(\n            $output.output();\n        )*\n    };\n}\n\n/// Internal macro for handling common message printing logic.\n///\n/// # Arguments\n///\n/// - `ColorType` - Text color\n/// - `ColorType` - Background color\n/// - `&str` - One or more message strings to print\n///\n/// Used by the success/warning/error printing macros to avoid code duplication.\n#[macro_export]\nmacro_rules! __print_message_common {\n    ($color:expr, $bg_color:expr, $($data:expr),*) => {{\n        use crate::*;\n        let binding: String = format!(\"[{}]\", time());\n        let mut time_output_builder: OutputBuilder<'_> = OutputBuilder::new();\n        let time_output: Output<'_> = time_output_builder\n            .text(&binding)\n            .blod(true)\n            .color($color)\n            .bg_color($bg_color)\n            .build();\n        let mut text_output_builder: OutputBuilder<'_> = OutputBuilder::new();\n        let mut text: String = String::new();\n        $(\n            text.push_str(&$data.to_string());\n        )*\n        let mut lines_iter = text.lines().peekable();\n        while let Some(line) = lines_iter.next() {\n            let mut output_list_builder = OutputListBuilder::new();\n            output_list_builder.add(time_output.clone());\n            let text_output: Output<'_> = text_output_builder\n                .text(&line)\n                .blod(true)\n                .endl(true)\n                .build();\n            output_list_builder.add(text_output);\n            output_list_builder.run();\n        }\n    }};\n}\n\n/// Prints a success message with green background and white text.\n#[macro_export]\nmacro_rules! println_success {\n    ($($data:expr),*) => {\n        crate::__print_message_common!(ColorType::Use(Color::White), ColorType::Use(Color::Green), $($data),*);\n    };\n}\n\n/// Prints a warning message with yellow background and white text.\n#[macro_export]\nmacro_rules! println_warning {\n    ($($data:expr),*) => {\n        crate::__print_message_common!(ColorType::Use(Color::White), ColorType::Use(Color::Yellow), $($data),*);\n    };\n}\n\n/// Prints an error message with red background and white text.\n#[macro_export]\nmacro_rules! println_error {\n    ($($data:expr),*) => {\n        crate::__print_message_common!(ColorType::Use(Color::White), ColorType::Use(Color::Red), $($data),*);\n    };\n}", "file_size": 2531, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\lib.rs", "language": "rust", "content": "//! color-output\n//!\n//! An atomic output library based on Rust that supports output\n//! functionalities through functions, builders, and other methods.\n//! It allows customization of text and background colors.\n\nmod color;\nmod r#macro;\nmod output;\nmod output_builder;\nmod output_list;\nmod output_list_builder;\nmod task;\nmod text;\n\npub use color::r#type::*;\npub use hyperlane_time::*;\npub use output::{r#fn::*, r#struct::Output};\npub use output_builder::r#struct::OutputBuilder;\npub use output_list::r#struct::OutputList;\npub use output_list_builder::r#struct::OutputListBuilder;\n\npub(crate) use color::{r#const::*, r#fn::*, r#struct::*};\npub(crate) use output_list::r#fn::output_list;\npub(crate) use std::borrow::Cow;\npub(crate) use std::{\n    fmt::{self, Display},\n    io::Write,\n};\npub(crate) use task::r#struct::*;\npub(crate) use text::r#struct::Text;", "file_size": 855, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\color\\const.rs", "language": "rust", "content": "/// Default color (no formatting).\npub const DEFAULT: &str = \"\";\n\n/// Reset all formatting to default.\npub const RESET: &str = \"\\x1b[0m\";\n\n/// ANSI escape code for black text.\npub const BLACK: &str = \"\\x1b[30m\";\n\n/// ANSI escape code for red text.\npub const RED: &str = \"\\x1b[31m\";\n\n/// ANSI escape code for green text.\npub const GREEN: &str = \"\\x1b[32m\";\n\n/// ANSI escape code for yellow text.\npub const YELLOW: &str = \"\\x1b[33m\";\n\n/// ANSI escape code for blue text.\npub const BLUE: &str = \"\\x1b[34m\";\n\n/// ANSI escape code for magenta text.\npub const MAGENTA: &str = \"\\x1b[35m\";\n\n/// ANSI escape code for cyan text.\npub const CYAN: &str = \"\\x1b[36m\";\n\n/// ANSI escape code for white text.\npub const WHITE: &str = \"\\x1b[37m\";\n\n/// ANSI escape code for black background.\npub const BG_BLACK: &str = \"\\x1b[40m\";\n\n/// ANSI escape code for red background.\npub const BG_RED: &str = \"\\x1b[41m\";\n\n/// ANSI escape code for green background.\npub const BG_GREEN: &str = \"\\x1b[42m\";\n\n/// ANSI escape code for yellow background.\npub const BG_YELLOW: &str = \"\\x1b[43m\";\n\n/// ANSI escape code for blue background.\npub const BG_BLUE: &str = \"\\x1b[44m\";\n\n/// ANSI escape code for magenta background.\npub const BG_MAGENTA: &str = \"\\x1b[45m\";\n\n/// ANSI escape code for cyan background.\npub const BG_CYAN: &str = \"\\x1b[46m\";\n\n/// ANSI escape code for white background.\npub const BG_WHITE: &str = \"\\x1b[47m\";", "file_size": 1389, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Output with empty configuration.\nimpl<'a> Default for Output<'a> {\n    fn default() -> Self {\n        Output {\n            text: \"\",\n            color: ColorType::default(),\n            bg_color: ColorType::default(),\n            blod: false,\n            endl: false,\n        }\n    }\n}\n\nimpl<'a> Output<'a> {\n    /// Executes the output operation with current configuration.\n    ///\n    /// # Returns\n    ///\n    /// - `()` - No return value\n    pub fn output(self) {\n        output(self);\n    }\n}", "file_size": 543, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_output_struct_function() {\n    use crate::*;\n    output(Output {\n        text: \"test_output_struct\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Color256(0x000000),\n        endl: true,\n        ..Default::default()\n    });\n}\n\n#[test]\nfn test_output_struct_output_method() {\n    use crate::*;\n    Output {\n        text: \"test_output_struct_output\",\n        color: ColorType::Use(Color::Default),\n        bg_color: ColorType::Use(Color::Blue),\n        endl: true,\n        ..Default::default()\n    }\n    .output();\n}", "file_size": 560, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_builder\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_output_builder_new_from() {\n    use crate::*;\n    output(\n        OutputBuilder::new()\n            .text(\"test_output_builder\")\n            .color(ColorType::Color256(0xffffff))\n            .bg_color(ColorType::Color256(0xffffff))\n            .blod(true)\n            .endl(true)\n            .build(),\n    );\n    output(\n        OutputBuilder::new_from(Output::default())\n            .text(\"test_output_builder\")\n            .color(ColorType::Color256(0xffffff))\n            .bg_color(ColorType::Color256(0xffffff))\n            .blod(true)\n            .endl(true)\n            .build(),\n    );\n}\n\n#[test]\nfn test_output_builder() {\n    use crate::*;\n    OutputBuilder::new()\n        .text(\"test_output_builder_output\")\n        .bg_color(ColorType::Color256(0xffffff))\n        .color(ColorType::Color256(0xffffff))\n        .blod(true)\n        .endl(true)\n        .build()\n        .output();\n}", "file_size": 905, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Builder pattern for constructing Output configurations.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\npub struct OutputBuilder<'a> {\n    /// The Output configuration being built.\n    pub output: Output<'a>,\n}", "file_size": 251, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#fn;\npub(crate) mod r#impl;\npub(crate) mod r#struct;", "file_size": 88, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list_builder\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Builder pattern for constructing OutputList configurations.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\n#[derive(Debug, Clone)]\npub struct OutputListBuilder<'a> {\n    /// Collection of Output configurations being built.\n    pub output_list: Vec<Output<'a>>,\n}", "file_size": 304, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\clonelicious\\src\\lib.rs", "language": "rust", "content": "//! clonelicious\n//!\n//! A Rust macro library that simplifies cloning and closure execution.\n//! The `clone!` macro automatically clones variables and immediately executes\n//! the closure with the cloned values, streamlining common patterns in Rust programming.\n\npub(crate) mod cfg;\npub(crate) mod r#macro;", "file_size": 306, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Implementation of OutputBuilder methods.\nimpl<'a> OutputBuilder<'a> {\n    /// Creates a new OutputBuilder instance.\n    ///\n    /// # Returns\n    ///\n    /// - `OutputBuilder<'a>` - The new builder instance.\n    pub fn new() -> Self {\n        Self {\n            output: Output::default(),\n        }\n    }\n\n    /// Creates a new OutputBuilder from existing Output.\n    ///\n    /// # Arguments\n    ///\n    /// - `Output` - The output configuration to initialize from\n    ///\n    /// # Returns\n    ///\n    /// - `OutputBuilder` - The new builder instance\n    pub fn new_from(output: Output<'a>) -> Self {\n        Self { output }\n    }\n\n    /// Sets the output text.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The text content to display\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining\n    pub fn text(&mut self, text: &'a str) -> &mut Self {\n        self.output.text = text;\n        self\n    }\n\n    /// Sets the text color.\n    ///\n    /// # Arguments\n    ///\n    /// - `ColorType` - The color to apply to text\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining\n    pub fn color(&mut self, color: ColorType) -> &mut Self {\n        self.output.color = color;\n        self\n    }\n\n    /// Sets the background color.\n    ///\n    /// # Arguments\n    ///\n    /// - `ColorType` - The background color type.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for chaining.\n    pub fn bg_color(&mut self, bg_color: ColorType) -> &mut Self {\n        self.output.bg_color = bg_color;\n        self\n    }\n\n    /// Sets bold text style.\n    ///\n    /// # Arguments\n    ///\n    /// - `bool` - Whether to use bold style.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for chaining.\n    pub fn blod(&mut self, blod: bool) -> &mut Self {\n        self.output.blod = blod;\n        self\n    }\n\n    /// Sets whether to add newline at end.\n    ///\n    /// # Arguments\n    ///\n    /// - `bool` - Whether to add newline.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for chaining.\n    pub fn endl(&mut self, endl: bool) -> &mut Self {\n        self.output.endl = endl;\n        self\n    }\n\n    /// Builds the final Output.\n    ///\n    /// # Returns\n    ///\n    /// - `Output<'a>` - The constructed output.\n    pub fn build(&self) -> Output {\n        self.output.clone()\n    }\n\n    /// Outputs the current state.\n    ///\n    /// # Returns\n    ///\n    /// - `()` - No return value.\n    pub fn output(&self) {\n        output(self.output.clone());\n    }\n}", "file_size": 2599, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\text\\impl.rs", "language": "rust", "content": "use super::r#struct::*;\nuse crate::color::{blod::*, r#const::*};\nuse crate::*;\nuse std::borrow::Cow;\n\n/// Default implementation for Text with empty content and default styling.\nimpl<'a> Default for Text<'a> {\n    fn default() -> Self {\n        Text {\n            text: \"\",\n            color: ColorType::default(),\n            bg_color: ColorType::default(),\n            blod: false,\n            endl: false,\n        }\n    }\n}\n\nimpl<'a> Text<'a> {\n    /// Creates a new Text instance from existing configuration.\n    ///\n    /// # Arguments\n    ///\n    /// - `Text` - Source text configuration to clone\n    ///\n    /// # Returns\n    ///\n    /// - `Text` - New instance with cloned configuration\n    pub(crate) fn new_from(text: &Text<'a>) -> Self {\n        Self { ..text.clone() }\n    }\n\n    /// Gets the display string as a `Cow` (clone on write).\n    ///\n    /// This method generates a formatted string that represents the text with\n    /// the appropriate color and background color. If the text is bold, it applies\n    /// bold formatting to the text color.\n    ///\n    /// # Returns\n    /// - `Cow<'a, str>`: An owned copy of the formatted string.\n    pub(crate) fn get_display_str_cow(&self) -> Cow<'a, str> {\n        let text: &str = self.text;\n        let blod: bool = self.blod.clone();\n\n        let adjusted_color: ColorType = if matches!(self.color, ColorType::Use(Color::Default)) {\n            ColorContrast::ensure_sufficient_contrast(&self.color, &self.bg_color)\n        } else {\n            self.color.clone()\n        };\n        let color: &String = &adjusted_color.to_string();\n        let bg_color: &String = &self.bg_color.get_str(DisplayType::Background);\n        let mut colored_text: String = if blod {\n            format!(\"{}{}{}{}{}{}\", bg_color, color, BLOD, text, UNBLOD, RESET)\n        } else {\n            format!(\"{}{}{}{}\", bg_color, color, text, RESET)\n        };\n        if self.endl {\n            colored_text.push_str(\"\\n\");\n        }\n        Cow::Owned(colored_text)\n    }\n}", "file_size": 2010, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_builder\\mod.rs", "language": "rust", "content": "pub(crate) mod cfg;\npub(crate) mod r#impl;\npub(crate) mod r#struct;", "file_size": 67, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\task\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Default implementation for Task with empty text list.\nimpl<'a> Default for Task<'a> {\n    fn default() -> Self {\n        Self { text_list: vec![] }\n    }\n}\n\n/// Implementation of task operations.\nimpl<'a> Task<'a> {\n    /// Adds a text configuration to the task list.\n    ///\n    /// # Arguments\n    ///\n    /// - `Text` - The text configuration to add\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The task for method chaining\n    pub(crate) fn add(&mut self, new_text: Text<'a>) -> &mut Self {\n        self.text_list.push(new_text);\n        self\n    }\n\n    /// Clears all text configurations from the task list.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The cleared task for method chaining\n    pub(crate) fn clear(&mut self) -> &mut Self {\n        self.text_list.clear();\n        self\n    }\n\n    /// Runs all tasks in the list.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut Self` - The mutable task instance.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The task instance after execution.\n    pub(crate) fn run_all(&mut self) -> &mut Self {\n        let copy_task_list: Vec<Text<'a>> = self.text_list.clone();\n        self.clear();\n        let mut output_str: String = String::new();\n        for text in copy_task_list {\n            let colored_time: &Cow<'_, str> = &Text::new_from(&text).get_display_str_cow();\n            output_str.push_str(colored_time);\n        }\n        print!(\"{}\", output_str);\n        std::io::stdout().flush().unwrap();\n        self\n    }\n}", "file_size": 1536, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\clonelicious\\src\\macro.rs", "language": "rust", "content": "/// A helper macro to clone variables into closures or async blocks easily.\n///\n/// This macro supports several usage patterns:\n///\n/// - Clone variables into an `async move` block.\n/// - Clone variables into a regular block.\n/// - Clone variables into an `async move` closure with or without explicit `move`.\n/// - Clone variables into a regular closure with or without explicit `move`.\n#[macro_export]\nmacro_rules! clone {\n    ( $( $var:ident ),* => async move $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        async move $body\n    }};\n\n    ( $( $var:ident ),* => $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        $body\n    }};\n\n    ( $( $var:ident ),* => move |$( $arg:ident $(: $ty:ty)? ),*| async move $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        move |$( $arg $(: $ty)? ),*| {\n            $( let $var = $var.clone(); )*\n            async move $body\n        }\n    }};\n\n    ( $( $var:ident ),* => |$( $arg:ident $(: $ty:ty)? ),*| async move $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        move |$( $arg $(: $ty)? ),*| {\n            $( let $var = $var.clone(); )*\n            async move $body\n        }\n    }};\n\n    ( $( $var:ident ),* => move |$( $arg:ident $(: $ty:ty)? ),*| $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        move |$( $arg $(: $ty)? ),*| {\n            $( let $var = $var.clone(); )*\n            $body\n        }\n    }};\n\n    ( $( $var:ident ),* => |$( $arg:ident $(: $ty:ty)? ),*| $body:block ) => {{\n        $( let $var = $var.clone(); )*\n        move |$( $arg $(: $ty)? ),*| {\n            $( let $var = $var.clone(); )*\n            $body\n        }\n    }};\n}", "file_size": 1671, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\text\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_text() {\n    use super::r#struct::Text;\n    use crate::*;\n    let text_default: Text<'_> = Text::default();\n    let text_default_str: &String = &text_default.get_display_str_cow().into_owned();\n    let text: Text<'_> = Text {\n        text: \"\",\n        color: ColorType::default(),\n        bg_color: ColorType::default(),\n        blod: false,\n        endl: false,\n    };\n    let text_str: &String = &text.get_display_str_cow().into_owned();\n    assert_eq!(text_default_str, text_str);\n}", "file_size": 501, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a colored text output with formatting options.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\n#[derive(Debug, Clone)]\npub struct Output<'a> {\n    /// The text content to output.\n    pub text: &'a str,\n    /// The text color.\n    pub color: ColorType,\n    /// The background color.\n    pub bg_color: ColorType,\n    /// Whether the text should be bold.\n    pub blod: bool,\n    /// Whether to add a newline after the text.\n    pub endl: bool,\n}", "file_size": 494, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list\\impl.rs", "language": "rust", "content": "use super::r#fn::output_list;\nuse crate::*;\nuse std::ops::Deref;\nuse std::slice::Iter;\nuse std::vec;\n\nimpl<'a> Default for OutputList<'a> {\n    /// Provides a default implementation for OutputList.\n    ///\n    /// # Returns\n    ///\n    /// - `OutputList` - New instance containing a single default Output\n    fn default() -> Self {\n        OutputList(vec![Output::<'a>::default()])\n    }\n}\n\nimpl<'a> Deref for OutputList<'a> {\n    type Target = Vec<Output<'a>>;\n\n    /// Dereferences OutputList to its internal Vec of Outputs.\n    ///\n    /// # Returns\n    ///\n    /// - `&Vec<Output>` - Reference to the internal vector of outputs\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nimpl<'a> IntoIterator for &'a OutputList<'a> {\n    type Item = &'a Output<'a>;\n    type IntoIter = Iter<'a, Output<'a>>;\n\n    /// Returns an iterator over the elements of the internal Vec.\n    ///\n    /// # Returns\n    ///\n    /// - `Iter<Output>` - Iterator over references to Output elements\n    fn into_iter(self) -> Self::IntoIter {\n        self.0.iter()\n    }\n}\n\nimpl<'a> OutputList<'a> {\n    /// Provides an iterator over the elements in the internal `Vec<Output<'a>>`.\n    ///\n    /// # Returns\n    /// - `Iter<'_, Output<'a>>`: An iterator over references to `Output` elements.\n    pub fn iter(&self) -> std::slice::Iter<'_, Output<'a>> {\n        self.0.iter()\n    }\n\n    /// Outputs the content of each `Output` in the list.\n    ///\n    /// This method clones the `OutputList` and iterates through its elements, calling the `output` method on each cloned `Output`.\n    ///\n    /// # Returns\n    /// - `()` : Nothing is returned.\n    pub fn output(self) {\n        let output_list_clone: OutputList<'a> = self.clone();\n        output_list(&output_list_clone.to_vec());\n    }\n}", "file_size": 1779, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\cfg.rs", "language": "rust", "content": "#[tokio::test]\nasync fn handle() {\n    use crate::*;\n\n    let chunk_strategy: ChunkStrategy<'_> = ChunkStrategy::new(\n        0,\n        \"./uploads\",\n        \"abcdefg\",\n        \"test.txt\",\n        1,\n        |file_id: &str, chunk_index: usize| format!(\"{file_id}.{chunk_index}\"),\n    )\n    .unwrap();\n    chunk_strategy.save_chunk(b\"test\", 0).await.unwrap();\n    chunk_strategy.merge_chunks().await.unwrap();\n}", "file_size": 410, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list_builder\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl<'a> OutputListBuilder<'a> {\n    /// Creates a new empty OutputListBuilder.\n    ///\n    /// # Returns\n    ///\n    /// - `OutputListBuilder` - New instance with empty output list\n    pub fn new() -> Self {\n        Self {\n            output_list: vec![],\n        }\n    }\n\n    /// Creates a new OutputListBuilder from existing outputs.\n    ///\n    /// # Arguments\n    ///\n    /// - `Vec<Output>` - Collection of outputs to initialize with\n    ///\n    /// # Returns\n    ///\n    /// - `OutputListBuilder` - New instance containing the specified outputs\n    pub fn new_from(output_list: Vec<Output<'a>>) -> Self {\n        Self { output_list }\n    }\n\n    /// Adds an output to the list.\n    ///\n    /// # Arguments\n    ///\n    /// - `Output` - The output configuration to add\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Self` - The builder for method chaining\n    pub fn add(&mut self, output: Output<'a>) -> &mut Self {\n        self.output_list.push(output);\n        self\n    }\n\n    /// Removes an output item from the list at the specified index.\n    ///\n    /// # Parameters\n    /// - `&mut self`: A mutable reference to the current instance of `OutputListBuilder`.\n    /// - `idx`: The index of the output item to be removed.\n    ///\n    /// # Returns\n    /// - `&mut Self`: A mutable reference to the current instance, allowing for method chaining.\n    ///\n    /// If the index is out of bounds, the list remains unchanged.\n    pub fn remove(&mut self, idx: usize) -> &mut Self {\n        if idx >= self.output_list.len() {\n            return self;\n        }\n        self.output_list.remove(idx);\n        self\n    }\n\n    /// Clears all output items from the output list.\n    ///\n    /// # Parameters\n    /// - `&mut self`: A mutable reference to the current instance of `OutputListBuilder`.\n    pub fn clear(&mut self) {\n        self.output_list.clear();\n    }\n\n    /// Runs all output items in the list, executing their output logic.\n    ///\n    /// # Parameters\n    /// - `&mut self`: A mutable reference to the current instance of `OutputListBuilder`.\n    ///\n    /// # Returns\n    /// - `&mut Self`: A mutable reference to the current instance, allowing for method chaining.\n    ///\n    /// The method clones the current output list, clears the original list, and executes\n    /// the output for each cloned item.\n    pub fn run(&mut self) -> &mut Self {\n        let output_list_clone: Vec<Output<'a>> = self.output_list.clone();\n        self.clear();\n        output_list(&output_list_clone.to_vec());\n        self\n    }\n\n    /// Queries the output item at the specified index.\n    ///\n    /// # Parameters\n    /// - `&self`: An immutable reference to the current instance of `OutputListBuilder`.\n    /// - `idx`: The index of the output item to query.\n    ///\n    /// # Returns\n    /// - `Output`: The output item at the specified index, or a default output if the index is out of bounds.\n    pub fn query_idx(&self, idx: usize) -> Output {\n        if idx >= self.output_list.len() {\n            return Output::default();\n        }\n        self.output_list[idx].clone()\n    }\n\n    /// Runs the output item at the specified index.\n    ///\n    /// # Parameters\n    /// - `&mut self`: A mutable reference to the current instance of `OutputListBuilder`.\n    /// - `idx`: The index of the output item to run.\n    ///\n    /// # Returns\n    /// - `&mut Self`: A mutable reference to the current instance, allowing for method chaining.\n    ///\n    /// If the index is out of bounds, the list remains unchanged.\n    pub fn run_idx(&mut self, idx: usize) -> &mut Self {\n        if idx >= self.output_list.len() {\n            return self;\n        }\n        let output: Output<'_> = self.query_idx(idx);\n        output.output();\n        self\n    }\n}", "file_size": 3764, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\task\\cfg.rs", "language": "rust", "content": "#[test]\n\nfn test_task() {\n    use crate::*;\n    use task::r#struct::Task;\n    use text::r#struct::Text;\n    let mut task: Task<'_> = Task::default();\n    task.add(Text::default()).add(Text {\n        text: \"1\",\n        ..Text::default()\n    });\n    task.run_all();\n    println!(\"{:?}\", task);\n}", "file_size": 293, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\clonelicious\\src\\cfg.rs", "language": "rust", "content": "#[cfg(test)]\n#[tokio::test]\nasync fn test_clone() {\n    use crate::*;\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res: String = clone!(s1, s2 => {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}\", s1, s2)\n    });\n    assert_eq!(res, format!(\"{} {}\", s1, s2));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res: String = clone!(s1, s2 => async move {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}\", s1, s2)\n    })\n    .await;\n    assert_eq!(res, format!(\"{} {}\", s1, s2));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => |data| {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 =>  |data| async move {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\").await, String::from(\"Hello World!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => |data: &str| {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => |data: String| async move {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\".to_owned()).await, format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => move |data| {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => move |data| async move {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\").await, format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => move |data: &str| {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\"), format!(\"{} {}{}\", s1, s2, \"!\"));\n\n    let s1: String = String::from(\"Hello\");\n    let s2: String = String::from(\"World\");\n    let res = clone!(s1, s2 => move |data: String| async move {\n        assert_eq!(s1, String::from(\"Hello\"));\n        assert_eq!(s2, String::from(\"World\"));\n        format!(\"{} {}{}\", s1, s2, data)\n    });\n    assert_eq!(res(\"!\".to_owned()).await, format!(\"{} {}{}\", s1, s2, \"!\"));\n}", "file_size": 3501, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\task\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Represents a collection of text tasks to be executed sequentially.\n#[derive(Debug, Clone, PartialEq)]\npub(crate) struct Task<'a> {\n    /// Collection of text configurations to process\n    pub(crate) text_list: Vec<Text<'a>>,\n}", "file_size": 245, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list\\fn.rs", "language": "rust", "content": "use crate::text::r#struct::Text;\nuse crate::*;\nuse task::r#struct::Task;\n\n/// Executes a sequence of output operations.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\n///\n/// # Arguments\n///\n/// - `Vec<Output>` - Collection of output configurations to execute\n///\n/// # Returns\n///\n/// - `()` - No return value\npub fn output_list(output_list: &Vec<Output>) {\n    let mut task_list: Task<'_> = Task::default();\n    for output in output_list {\n        // Text\n        let text: &str = output.text;\n        let color: ColorType = output.color.clone();\n        let bg_color: ColorType = output.bg_color.clone();\n        let blod: bool = output.blod.clone();\n        // endl\n        let endl: bool = output.endl;\n        // Add text\n        task_list.add(Text {\n            text,\n            color,\n            bg_color,\n            blod,\n            endl,\n        });\n    }\n    // run\n    task_list.run_all();\n}", "file_size": 930, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list\\struct.rs", "language": "rust", "content": "use crate::Output;\n\n/// Represents a list of Output configurations for sequential execution.\n///\n/// [Official Documentation](https://docs.ltpp.vip/COLOR-OUTPUT/)\n#[derive(Debug, Clone)]\npub struct OutputList<'a>(\n    /// Collection of Output configurations to execute in sequence\n    pub Vec<Output<'a>>,\n);", "file_size": 308, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\lib.rs", "language": "rust", "content": "//! chunkify\n//!\n//! A simple and efficient chunking library for Rust.\n\npub(crate) mod cfg;\npub(crate) mod chunk;\n\npub(crate) use chunk::lazy::*;\npub(crate) use dashmap::{DashMap, mapref::one::RefMut};\npub(crate) use file_operation::*;\npub(crate) use once_cell::sync::Lazy;\npub(crate) use std::{\n    fmt,\n    fs::{self, File, OpenOptions},\n    hash::BuildHasherDefault,\n    io::{BufWriter, Write},\n    path::Path,\n    sync::Arc,\n};\npub(crate) use tokio::sync::{RwLock, RwLockWriteGuard};\npub(crate) use twox_hash::XxHash3_64;\n\npub use chunk::{r#const::*, error::*, r#struct::*, r#trait::*, r#type::*};", "file_size": 601, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\error.rs", "language": "rust", "content": "use crate::*;\n\n/// Errors that can occur during chunking operations.\n///\n/// Represents various failure scenarios when processing file chunks.\n#[derive(Debug)]\npub enum ChunkStrategyError {\n    /// Missing file ID header in request.\n    MissingFileId,\n    /// Invalid chunk index value.\n    InvalidChunkIndex,\n    /// Missing chunk index header in request.\n    MissingChunkIndex,\n    /// Invalid total chunks value.\n    InvalidTotalChunks,\n    /// Missing total chunks header in request.\n    MissingTotalChunks,\n    /// Missing file name header in request.\n    MissingFileName,\n    /// Received empty chunk data.\n    EmptyChunkData,\n    /// Chunk index exceeds total chunks.\n    IndexOutOfBounds(usize, usize),\n    /// Failed to merge chunks.\n    Merge,\n    /// Failed to create directory.\n    CreateDirectory(String),\n    /// Failed to create chunk file.\n    CreateChunkFile(String),\n    /// Failed to write chunk data.\n    WriteChunk(String),\n    /// Failed to create output file.\n    CreateOutputFile(String),\n    /// Failed to read chunk file.\n    ReadChunk(String),\n    /// Failed to write to output file.\n    WriteOutput(String),\n}\n\n/// Provides display formatting for chunk strategy errors.\nimpl fmt::Display for ChunkStrategyError {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        let message = match self {\n            ChunkStrategyError::MissingFileId => \"Missing X-File-Id header\",\n            ChunkStrategyError::InvalidChunkIndex => \"Invalid X-Chunk-Index header\",\n            ChunkStrategyError::MissingChunkIndex => \"Missing X-Chunk-Index header\",\n            ChunkStrategyError::InvalidTotalChunks => \"Invalid X-Total-Chunks header\",\n            ChunkStrategyError::MissingTotalChunks => \"Missing X-Total-Chunks header\",\n            ChunkStrategyError::MissingFileName => \"Missing X-File-Name header\",\n            ChunkStrategyError::EmptyChunkData => \"Empty chunk data\",\n            ChunkStrategyError::CreateDirectory(msg) => {\n                &format!(\"Failed to create directory: {}\", msg)\n            }\n            ChunkStrategyError::CreateChunkFile(msg) => {\n                &format!(\"Failed to create chunk file: {}\", msg)\n            }\n            ChunkStrategyError::WriteChunk(msg) => &format!(\"Failed to write chunk: {}\", msg),\n            ChunkStrategyError::CreateOutputFile(msg) => {\n                &format!(\"Failed to create output file: {}\", msg)\n            }\n            ChunkStrategyError::ReadChunk(msg) => &format!(\"Failed to read chunk: {}\", msg),\n            ChunkStrategyError::WriteOutput(msg) => {\n                &format!(\"Failed to write to output file: {}\", msg)\n            }\n            ChunkStrategyError::Merge => &format!(\"Failed to complete the file merge operation\"),\n            ChunkStrategyError::IndexOutOfBounds(chunk_index, total_chunks) => &format!(\n                \"Index {} out of bounds(total: {})\",\n                chunk_index, total_chunks\n            ),\n        };\n        write!(f, \"{}\", message)\n    }\n}\n\n/// Marks ChunkStrategyError as a standard error type.\nimpl std::error::Error for ChunkStrategyError {}\n\n/// Converts ChunkStrategyError to a byte vector.\n///\n/// Used for error responses in HTTP handlers.\nimpl From<ChunkStrategyError> for Vec<u8> {\n    fn from(error: ChunkStrategyError) -> Self {\n        error.to_string().into_bytes()\n    }\n}", "file_size": 3342, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\text\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Configurable text display with color, background and style options.\n///\n/// Used for building formatted console output with various display attributes.\n#[derive(Debug, Clone, PartialEq)]\npub(crate) struct Text<'a> {\n    /// The actual text content.\n    pub(crate) text: &'a str,\n    /// The color of the text.\n    pub(crate) color: ColorType,\n    /// The background color of the text.\n    pub(crate) bg_color: ColorType,\n    /// Whether the text should be bold.\n    pub(crate) blod: bool,\n    /// Whether to add newline after the text\n    pub(crate) endl: bool,\n}", "file_size": 582, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\const.rs", "language": "rust", "content": "/// HTTP header name for file ID in chunking operations.\npub const CHUNKIFY_FILE_ID_HEADER: &str = \"x-file-id\";\n\n/// HTTP header name for chunk index in chunking operations.\npub const CHUNKIFY_CHUNK_INDEX_HEADER: &str = \"x-chunk-index\";\n\n/// HTTP header name for total chunks count in chunking operations.\npub const CHUNKIFY_TOTAL_CHUNKS_HEADER: &str = \"x-total-chunks\";\n\n/// HTTP header name for original file name in chunking operations.\npub const CHUNKIFY_FILE_NAME_HEADER: &str = \"x-file-name\";", "file_size": 498, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Blanket implementation for chunk naming functions.\nimpl<'a, F> ChunkNaming<'a> for F where F: Fn(&'a str, usize) -> String + Send + Sync {}\n\n/// Implementation of chunk strategy methods.\nimpl<'a> ChunkStrategy<'a> {\n    /// Creates a new chunk strategy instance.\n    ///\n    /// # Arguments\n    ///\n    /// - `usize` - Starting chunk index (0-based)\n    /// - `&str` - Directory path for chunk storage\n    /// - `&str` - Unique file identifier\n    /// - `&str` - Original filename\n    /// - `usize` - Total chunks count\n    /// - `F` - Function implementing ChunkNaming trait\n    ///\n    /// # Returns\n    ///\n    /// - `NewChunkStrategyResult` - Result containing strategy or error\n    pub fn new<F>(\n        start_chunk_index: usize,\n        upload_dir: &'a str,\n        file_id: &'a str,\n        file_name: &'a str,\n        total_chunks: usize,\n        file_name_func: F,\n    ) -> NewChunkStrategyResult<'a>\n    where\n        F: ChunkNaming<'a> + 'static,\n    {\n        if start_chunk_index >= total_chunks {\n            return Err(ChunkStrategyError::IndexOutOfBounds(\n                start_chunk_index,\n                total_chunks,\n            ));\n        }\n        Ok(Self {\n            upload_dir,\n            start_chunk_index,\n            file_id,\n            file_name,\n            total_chunks,\n            file_name_func: Box::new(file_name_func),\n        })\n    }\n\n    /// Gets the JSON path for a chunk file.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - File identifier\n    /// - `usize` - Chunk index (0-based)\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Generated path in JSON format\n    fn get_chunk_json_path(&self, file_id: &'a str, chunk_index: usize) -> String {\n        (self.file_name_func)(file_id, chunk_index)\n    }\n\n    /// Gets the full path for a chunk file.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - File identifier\n    /// - `usize` - Chunk index (0-based)\n    ///\n    /// # Returns\n    ///\n    /// - `String` - Absolute path to chunk file\n    fn get_chunk_path(&self, file_id: &'a str, chunk_index: usize) -> String {\n        Path::new(&self.upload_dir)\n            .join(self.get_chunk_json_path(file_id, chunk_index))\n            .to_string_lossy()\n            .into_owned()\n    }\n\n    /// Saves a chunk to the specified path.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Path to save chunk.\n    /// - `&[u8]` - Chunk data.\n    ///\n    /// # Returns\n    ///\n    /// - `ChunkStrategyResult` - Result of save operation.\n    async fn save_chunk(&self, chunk_path: &str, chunk_data: &[u8]) -> ChunkStrategyResult {\n        async_write_to_file(chunk_path, chunk_data)\n            .await\n            .map_err(|e| {\n                ChunkStrategyError::WriteChunk(format!(\n                    \"Failed to write chunk to {}: {}\",\n                    chunk_path, e\n                ))\n            })?;\n        Ok(())\n    }\n}\n\n/// Implementation of handle strategy for chunk operations.\nimpl<'a> HandleStrategy<'a> for ChunkStrategy<'a> {\n    /// Saves a chunk with index validation.\n    ///\n    /// # Arguments\n    ///\n    /// - `&'a [u8]` - Chunk data.\n    /// - `usize` - Chunk index.\n    ///\n    /// # Returns\n    ///\n    /// - `ChunkStrategyResult` - Result of save operation.\n    async fn save_chunk(&self, chunk_data: &'a [u8], chunk_index: usize) -> ChunkStrategyResult {\n        if !Path::new(&self.upload_dir).exists() {\n            fs::create_dir_all(&self.upload_dir)\n                .map_err(|e| ChunkStrategyError::CreateDirectory(e.to_string()))?;\n        }\n        let chunk_path: String = self.get_chunk_path(self.file_id, chunk_index);\n        self.save_chunk(&chunk_path, &chunk_data).await?;\n        let chunks_status: RefMut<'_, String, RwLock<Vec<bool>>> = UPLOADING_FILES\n            .entry(self.file_id.to_owned())\n            .or_insert_with(|| RwLock::new(vec![false; self.total_chunks]));\n        let mut chunks_status: RwLockWriteGuard<'_, Vec<bool>> = chunks_status.write().await;\n        if chunks_status.len() != self.total_chunks {\n            *chunks_status = vec![false; self.total_chunks];\n        }\n        if chunk_index >= chunks_status.len() {\n            return Err(ChunkStrategyError::IndexOutOfBounds(\n                chunk_index,\n                self.total_chunks,\n            ));\n        }\n        chunks_status[chunk_index] = true;\n        Ok(())\n    }\n\n    /// Merges all chunks into the final file.\n    ///\n    /// # Returns\n    ///\n    /// - `ChunkStrategyResult` - Result of merge operation.\n    async fn merge_chunks(&self) -> ChunkStrategyResult {\n        let chunks_status: RefMut<'_, String, RwLock<Vec<bool>>> = UPLOADING_FILES\n            .entry(self.file_id.to_owned())\n            .or_insert_with(|| RwLock::new(vec![false; self.total_chunks]));\n        let mut chunks_status: RwLockWriteGuard<'_, Vec<bool>> = chunks_status.write().await;\n        let all_chunks_uploaded: bool = chunks_status.iter().all(|&status| status);\n        if !all_chunks_uploaded {\n            return Err(ChunkStrategyError::Merge);\n        }\n        chunks_status.clear();\n        drop(chunks_status);\n        let final_path: String = Path::new(&self.upload_dir)\n            .join(self.file_name)\n            .to_string_lossy()\n            .into_owned();\n        let output_file: File = OpenOptions::new()\n            .create(true)\n            .write(true)\n            .open(&final_path)\n            .map_err(|e| ChunkStrategyError::CreateOutputFile(e.to_string()))?;\n        let mut writer: BufWriter<File> = BufWriter::new(output_file);\n        for i in self.start_chunk_index..self.total_chunks {\n            let chunk_path: String = self.get_chunk_path(self.file_id, i);\n            let chunk_data: Vec<u8> = async_read_from_file(&chunk_path).await.map_err(|e| {\n                ChunkStrategyError::ReadChunk(format!(\n                    \"Failed to read chunk from {}: {}\",\n                    chunk_path, e\n                ))\n            })?;\n            writer\n                .write_all(&chunk_data)\n                .map_err(|e| ChunkStrategyError::WriteOutput(e.to_string()))?;\n            let _ = fs::remove_file(&chunk_path);\n        }\n        Ok(())\n    }\n}", "file_size": 6187, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\lazy.rs", "language": "rust", "content": "use crate::*;\n\n/// Global map tracking upload status of file chunks.\n///\n/// Uses DashMap for concurrent access and RwLock for tracking chunk status.\npub static UPLOADING_FILES: Lazy<\n    Arc<DashMap<String, RwLock<Vec<bool>>, BuildHasherDefault<XxHash3_64>>>,\n> = Lazy::new(|| Arc::new(DashMap::with_hasher(BuildHasherDefault::default())));", "file_size": 341, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_output_list_struct() {\n    use crate::*;\n    OutputList(vec![\n        Output {\n            text: \"test_output_list_struct_1\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Color256(0x000000),\n            endl: false,\n            ..Default::default()\n        },\n        Output {\n            text: \"test_output_struct_output_2\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Use(Color::Blue),\n            endl: true,\n            ..Default::default()\n        },\n    ])\n    .output();\n}", "file_size": 574, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\color-output\\src\\output_list_builder\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_new_output_list_builder() {\n    use crate::*;\n    OutputListBuilder::new()\n        .add(\n            OutputBuilder::new()\n                .text(\"text\")\n                .bg_color(ColorType::Use(Color::Blue))\n                .endl(false)\n                .build(),\n        )\n        .add(Output {\n            text: \"test_new_output_list_builder_1\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Color256(0x3f3f3f),\n            endl: false,\n            ..Default::default()\n        })\n        .add(Output {\n            text: \"test_new_output_list_builder_2\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Use(Color::Cyan),\n            endl: true,\n            ..Default::default()\n        })\n        .run();\n}\n\n#[test]\nfn test_new_from_output_list_builder() {\n    use crate::*;\n    OutputListBuilder::new_from(vec![Output::default()])\n        .add(\n            OutputBuilder::new()\n                .text(\"text\")\n                .bg_color(ColorType::Use(Color::Blue))\n                .endl(false)\n                .build(),\n        )\n        .add(Output {\n            text: \"test_new_from_output_list_builder_1\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Color256(0x3f3f3f),\n            endl: false,\n            ..Default::default()\n        })\n        .add(Output {\n            text: \"test_new_from_output_list_builder_2\",\n            color: ColorType::Use(Color::Default),\n            bg_color: ColorType::Use(Color::Cyan),\n            endl: true,\n            ..Default::default()\n        })\n        .run();\n}", "file_size": 1637, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\chinese_id_card\\const.rs", "language": "rust", "content": "/// Weight values used for Chinese ID card number validation.\npub(crate) const WEIGHTS: [i32; 17] = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2];\n/// Check code characters used for Chinese ID card validation.\npub(crate) const CHECK_CODES: [char; 11] = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2'];", "file_size": 317, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\cfg.rs", "language": "rust", "content": "#[test]\nfn test_is_valid_id_number() {\n    use crate::*;\n\n    let valid: bool = ChineseIdCard::is_valid_id_number(\"110101202311012176\");\n    assert_eq!(valid, true);\n    let un_valid: bool = ChineseIdCard::is_invalid_id_number(\"110101202311012171\");\n    assert_eq!(un_valid, true);\n}", "file_size": 283, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\chinese_id_card\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides validation methods for Chinese ID card numbers.\nimpl ChineseIdCard {\n    /// Validates whether a given string represents a valid Chinese ID card number.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Type implementing ToString trait.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Validation result.\n    pub fn is_valid_id_number<T: ToString>(id_number: T) -> bool {\n        let id_number_string: String = id_number.to_string();\n        if id_number_string.len() != 18 || !id_number_string[..17].chars().all(|c| c.is_digit(10)) {\n            return false;\n        }\n        let last_char: char = id_number_string.chars().last().unwrap();\n        if !(last_char.is_digit(10) || last_char == 'X') {\n            return false;\n        }\n        let sum: i32 = id_number_string[..17]\n            .chars()\n            .zip(WEIGHTS.iter())\n            .map(|(c, &w)| c.to_digit(10).unwrap() as i32 * w)\n            .sum();\n        let check_code: char = CHECK_CODES[(sum % 11) as usize];\n        check_code == last_char\n    }\n\n    /// Checks whether a given string represents an invalid Chinese ID card number.\n    ///\n    /// # Arguments\n    ///\n    /// - `T` - Type implementing ToString trait.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Validation result.\n    pub fn is_invalid_id_number<T: ToString>(id_number: T) -> bool {\n        !Self::is_valid_id_number(id_number)\n    }\n}", "file_size": 1422, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\struct.rs", "language": "rust", "content": "use crate::*;\n\n/// Configuration for chunking operations.\n///\n/// Contains all necessary parameters for performing chunked file operations.\npub struct ChunkStrategy<'a> {\n    /// The starting index for chunking operations.\n    pub(crate) start_chunk_index: usize,\n    /// Directory where chunks will be uploaded.\n    pub(crate) upload_dir: &'a str,\n    /// Function for generating chunk file names.\n    pub(crate) file_name_func: Box<dyn ChunkNaming<'a>>,\n    /// Unique identifier for the file being chunked.\n    pub(crate) file_id: &'a str,\n    /// Original name of the file being chunked.\n    pub(crate) file_name: &'a str,\n    /// Total number of chunks to create.\n    pub(crate) total_chunks: usize,\n}", "file_size": 706, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\trait.rs", "language": "rust", "content": "use crate::*;\n\n/// Trait for generating chunk file names.\n///\n/// Implementations should provide a function that generates unique names for chunk files.\npub trait ChunkNaming<'a>: Fn(&'a str, usize) -> String + Send + Sync {}\n\n/// Trait for handling chunk operations.\n///\n/// Defines the interface for saving and merging file chunks.\npub trait HandleStrategy<'a>: Send + Sync {\n    /// Saves a chunk of data.\n    ///\n    /// # Arguments\n    ///\n    /// - `&'a [u8]` - The chunk data to save.\n    /// - `usize` - The chunk index.\n    ///\n    /// # Returns\n    ///\n    /// - `impl Future<Output = ChunkStrategyResult>` - Future of the save operation.\n    fn save_chunk(\n        &self,\n        chunk_data: &'a [u8],\n        chunk_index: usize,\n    ) -> impl Future<Output = ChunkStrategyResult> + Send;\n\n    /// Merges all chunks into the final file.\n    ///\n    /// # Returns\n    ///\n    /// - `impl Future<Output = ChunkStrategyResult>` - Future of the merge operation.\n    fn merge_chunks(&self) -> impl Future<Output = ChunkStrategyResult> + Send;\n}", "file_size": 1050, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\type.rs", "language": "rust", "content": "use crate::*;\n\n/// Result type for creating new chunk strategies.\npub type NewChunkStrategyResult<'a> = Result<ChunkStrategy<'a>, ChunkStrategyError>;\n\n/// Result type for chunk strategy operations.\npub type ChunkStrategyResult = Result<(), ChunkStrategyError>;", "file_size": 261, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\chunkify\\src\\chunk\\mod.rs", "language": "rust", "content": "pub mod r#const;\npub mod error;\npub mod r#impl;\npub mod lazy;\npub mod r#struct;\npub mod r#trait;\npub mod r#type;", "file_size": 112, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\mod.rs", "language": "rust", "content": "#[cfg(test)]\nmod cfg;\n\npub(crate) mod r#const;\npub(crate) mod error;\npub(crate) mod r#impl;\npub(crate) mod r#struct;", "file_size": 116, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\encode\\struct.rs", "language": "rust", "content": "/// Handles the decoding operations for the application.\n///\n/// This struct provides methods to decode strings using a specified character set.\npub struct Decode {}", "file_size": 165, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\encode\\mod.rs", "language": "rust", "content": "#[cfg(test)]\npub(crate) mod cfg;\npub(crate) mod r#impl;\npub(crate) mod r#struct;", "file_size": 80, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\chinese_id_card\\struct.rs", "language": "rust", "content": "/// Represents a Chinese ID card number and provides validation functionality.\n///\n/// This structure encapsulates the logic for validating Chinese ID card numbers\n/// according to the official standards.\npub struct ChineseIdCard;", "file_size": 230, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\const.rs", "language": "rust", "content": "/// Standard length for character sets used in encoding/decoding.\n///\n/// Represents the required number of unique characters (64) for base64-like encoding.\npub const CHARSET_LEN: usize = 64;", "file_size": 191, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\lib.rs", "language": "rust", "content": "//! bin-encode-decode\n//!\n//! A high-performance binary encode and decode library\n//! that supports customizable character sets beyond Base64.\n\npub(crate) mod common;\npub(crate) mod decode;\npub(crate) mod encode;\n\npub use common::{error::*, r#struct::*};\npub use decode::r#struct::*;\npub use encode::r#struct::*;\n\npub(crate) use common::r#const::*;\npub(crate) use std::{collections::HashSet, fmt};", "file_size": 397, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\chinese_id_card\\mod.rs", "language": "rust", "content": "pub(crate) mod r#const;\npub(crate) mod r#impl;\npub(crate) mod r#struct;\n\npub(crate) use r#const::*;\npub use r#struct::*;", "file_size": 120, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\decode\\impl.rs", "language": "rust", "content": "use crate::*;\n\nimpl Decode {\n    /// Decodes an encoded string using specified character set.\n    ///\n    /// Processes 4-character groups to reconstruct original bytes by mapping each\n    /// character to its position in the charset.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The character set used for decoding.\n    /// - `&str` - The string to decode.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<String, DecodeError>` - Result of decoding operation.\n    pub fn execute(charset: &str, decode_str: &str) -> Result<String, DecodeError> {\n        if !Charset::judge_charset_safe(charset) {\n            return Err(DecodeError::CharsetError);\n        }\n        let mut buffer: Vec<u8> = Vec::new();\n        let mut decoded: Vec<u8> = Vec::new();\n        for ch in decode_str.chars() {\n            if let Some(idx) = charset.chars().position(|c| c == ch) {\n                buffer.push(idx as u8);\n            }\n            if buffer.len() == 4 {\n                let combined: usize = ((buffer[0] as usize) << 18)\n                    | ((buffer[1] as usize) << 12)\n                    | ((buffer[2] as usize) << 6)\n                    | (buffer[3] as usize);\n                decoded.push((combined >> 16) as u8);\n                decoded.push((combined >> 8) as u8);\n                decoded.push(combined as u8);\n                buffer.clear();\n            }\n        }\n        let decode_res: String =\n            String::from_utf8(decoded.into_iter().filter(|&x| x != 0).collect())\n                .unwrap_or_default();\n        Ok(decode_res)\n    }\n}", "file_size": 1566, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\error\\mod.rs", "language": "rust", "content": "pub(crate) mod r#enum;\npub(crate) mod r#impl;\n\npub use r#enum::*;\n\npub(super) use crate::*;", "file_size": 91, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\struct.rs", "language": "rust", "content": "/// Handles string encoding and decoding operations.\n///\n/// Uses a custom character set for the encoding/decoding process.\n///\n/// The character set should contain unique characters and ideally have 64 characters\n/// for base64-like encoding.\n#[derive(Debug, Clone)]\npub struct Charset<'a>(\n    /// Reference to the character set used for encoding/decoding.\n    pub &'a str,\n);", "file_size": 378, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\china_identification_card\\src\\lib.rs", "language": "rust", "content": "//! china_identification_card\n//!\n//! A Rust library for validating Chinese identification card numbers based on official rules and checksums.\n\nmod cfg;\n\npub(crate) mod chinese_id_card;\n\npub use chinese_id_card::*;", "file_size": 214, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\decode\\struct.rs", "language": "rust", "content": "/// Handles the encoding operations for the application.\n///\n/// This struct provides methods to encode strings using a specified character set.\npub struct Encode {}", "file_size": 165, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\error\\enum.rs", "language": "rust", "content": "/// Represents errors that can occur during encoding.\n///\n/// These errors are related to character set validation and encoding process.\n#[derive(Debug, Clone)]\npub enum EncodeError {\n    /// Indicates invalid character set configuration.\n    CharsetError,\n}\n\n/// Represents errors that can occur during decoding.\n///\n/// These errors are related to character set validation and decoding process.\n#[derive(Debug, Clone)]\npub enum DecodeError {\n    /// Indicates invalid character set configuration.\n    CharsetError,\n}", "file_size": 518, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\cfg.rs", "language": "rust", "content": "use crate::*;\n\n#[test]\nfn test_crypt_decode() {\n    let mut en_decode: Charset<'_> = Charset::new();\n    let test_str: &str = \"test\";\n    let mut charset: String = String::new();\n    for i in 0..26 {\n        let ch: char = ('a' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..26 {\n        let ch: char = ('A' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..10 {\n        let ch: char = ('0' as u8 + i) as char;\n        charset.push(ch);\n    }\n    charset.push_str(\"_=\");\n    en_decode.charset(&charset);\n    let encode: Result<String, EncodeError> = en_decode.encode(test_str);\n    let decode: Result<String, DecodeError> = en_decode.decode(&encode.clone().unwrap());\n    assert_eq!(decode.unwrap(), test_str);\n}", "file_size": 751, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\encode\\cfg.rs", "language": "rust", "content": "use crate::*;\n\n#[test]\nfn test_decode() {\n    let mut charset: String = String::new();\n    for i in 0..26 {\n        let ch: char = ('a' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..26 {\n        let ch: char = ('A' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..10 {\n        let ch: char = ('0' as u8 + i) as char;\n        charset.push(ch);\n    }\n    charset.push_str(\"_=\");\n    let encode_res: Result<String, EncodeError> = Encode::execute(&charset, \"test\");\n    assert_eq!(encode_res.unwrap(), \"aab0aabLaabZaab0\");\n}", "file_size": 561, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\decode\\cfg.rs", "language": "rust", "content": "use crate::*;\n\n#[test]\nfn test_decode() {\n    let mut charset: String = String::new();\n    for i in 0..26 {\n        let ch: char = ('a' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..26 {\n        let ch: char = ('A' as u8 + i) as char;\n        charset.push(ch);\n    }\n    for i in 0..10 {\n        let ch: char = ('0' as u8 + i) as char;\n        charset.push(ch);\n    }\n    charset.push_str(\"_=\");\n    let encode_res: Result<String, DecodeError> = Decode::execute(&charset, \"aab0aabLaabZaab0\");\n    assert_eq!(encode_res.unwrap(), \"test\");\n}", "file_size": 561, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\error\\impl.rs", "language": "rust", "content": "use super::*;\n\n/// Provides display formatting for EncodeError.\n///\n/// Implements human-readable error messages for encoding failures.\nimpl fmt::Display for EncodeError {\n    /// Formats the EncodeError for display purposes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter<'_>` - The formatter to use.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            EncodeError::CharsetError => write!(\n                f,\n                \"EncodeError: Charset is invalid. Please ensure the charset contains exactly {} unique characters.\",\n                CHARSET_LEN\n            ),\n        }\n    }\n}\n\n/// Provides display formatting for DecodeError.\n///\n/// Implements human-readable error messages for decoding failures.\nimpl fmt::Display for DecodeError {\n    /// Formats the DecodeError for display purposes.\n    ///\n    /// # Arguments\n    ///\n    /// - `&mut fmt::Formatter<'_>` - The formatter to use.\n    ///\n    /// # Returns\n    ///\n    /// - `fmt::Result` - Result of the formatting operation.\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            DecodeError::CharsetError => write!(\n                f,\n                \"DecodeError: Charset is invalid. Please ensure the charset contains exactly {} unique characters.\",\n                CHARSET_LEN\n            ),\n        }\n    }\n}", "file_size": 1481, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\common\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides default implementation for Charset.\n///\n/// Creates a new Charset instance with empty string as default charset.\n///\n/// # Returns\n///\n/// - `Charset<'a>` - New instance with empty charset.\nimpl<'a> Default for Charset<'a> {\n    fn default() -> Self {\n        Charset(\"\")\n    }\n}\n\nimpl<'a> Charset<'a> {\n    /// Creates a new Charset instance with default charset.\n    ///\n    /// # Returns\n    ///\n    /// - `Charset<'a>` - New instance with empty charset.\n    pub fn new() -> Self {\n        Charset::default()\n    }\n\n    /// Validates if charset meets safety requirements.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - Checks if the charset contains exactly CHARSET_LEN unique characters.\n    ///\n    /// # Returns\n    ///\n    /// - `bool` - Validation result.\n    pub(crate) fn judge_charset_safe(charset: &str) -> bool {\n        let mut hash_set: HashSet<char> = HashSet::new();\n        for tmp_char in charset.chars() {\n            hash_set.insert(tmp_char);\n        }\n        if hash_set.len() != CHARSET_LEN {\n            return false;\n        }\n        true\n    }\n\n    /// Sets the character set for encoding/decoding operations.\n    ///\n    /// # Arguments\n    ///\n    /// - `&'b str` - The character set to use.\n    ///\n    /// # Returns\n    ///\n    /// - `&mut Charset<'a>` - Self reference for method chaining.\n    pub fn charset<'b>(&mut self, charset: &'b str) -> &mut Self\n    where\n        'b: 'a,\n    {\n        if self.0 != Charset::default().0 {\n            return self;\n        }\n        self.0 = charset;\n        self\n    }\n\n    /// Encodes input string using current charset.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The string to encode.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<String, EncodeError>` - Encoding result.\n    pub fn encode(&self, encode_str: &str) -> Result<String, EncodeError> {\n        Encode::execute(self.0, encode_str)\n    }\n\n    /// Decodes input string using current charset.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The string to decode.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<String, DecodeError>` - Decoding result.\n    pub fn decode(&self, decode_str: &str) -> Result<String, DecodeError> {\n        Decode::execute(self.0, decode_str)\n    }\n}", "file_size": 2280, "extension": ".rs"}
{"file_path": "training_sources\\crates-dev\\bin-encode-decode\\src\\encode\\impl.rs", "language": "rust", "content": "use crate::*;\n\n/// Provides encoding functionality.\nimpl Encode {\n    /// Encodes input string using specified character set.\n    ///\n    /// Processes 3-byte chunks to produce 4-character encoded segments.\n    ///\n    /// # Arguments\n    ///\n    /// - `&str` - The character set used for encoding.\n    /// - `&str` - String to encode.\n    ///\n    /// # Returns\n    ///\n    /// - `Result<String, EncodeError>` - Encoded string or error.\n    pub fn execute(charset: &str, encode_str: &str) -> Result<String, EncodeError> {\n        if !Charset::judge_charset_safe(charset) {\n            return Err(EncodeError::CharsetError);\n        }\n        let mut result: String = String::new();\n        let mut buffer: Vec<u8> = Vec::new();\n        for &byte in encode_str.as_bytes() {\n            buffer.extend_from_slice(&[0, 0, byte]);\n        }\n        for chunk in buffer.chunks(3) {\n            let combined: usize =\n                ((chunk[0] as usize) << 16) | ((chunk[1] as usize) << 8) | (chunk[2] as usize);\n            for i in (0..4).rev() {\n                let idx: usize = (combined >> (i * 6)) & 0b111111;\n                result.push(charset.chars().nth(idx).unwrap_or_default());\n            }\n        }\n        Ok(result)\n    }\n}", "file_size": 1234, "extension": ".rs"}
